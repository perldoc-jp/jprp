=head1 名前 (NAME)

Apache::SSI - Perl での Server Side Includes の実行

=head1 概要 (SYNOPSIS)

httpd.conf 内:

    <Files *.phtml>  # または何らか
    SetHandler perl-script
    PerlHandler Apache::SSI
    </Files>

あなたは Apache::SSI サブクラスに独自拡張を期待できます。もしそうであれば、
PERL_METHOD_HANDLERS=1 とあわせて mod_perl をコンパイルしてください (そうすれば
オブジェクト指向継承が利用できます)。そして、モジュールをこのように作って下さい:

    package MySSI;
    use Apache::SSI ();
    @ISA = qw(Apache::SSI);

    #埋め込みシンタックス:
    #<!--#something param=value -->
    sub ssi_something {
       my($self, $attr) = @_;
       my $cmd = $attr->{param};
       ...
       return $a_string;   
    }
 
 そして httpd.conf 内は:
 
    <Files *.phtml>
     SetHandler perl-script
     PerlHandler MySSI
    </Files>

=head1 説明 (DESCRIPTION)

Apache::SSI は、HTML サーバ解析処理のための mod_include の機能を実行します。
これは Apache の mod_perl 以下で動作します。

私の思いでは、あなたがこのモジュールを使いたいかも知れない二つの主な理由があります:
あなたは独自のカスタム SSI 命令を実行するためのサブクラスが使える。そして/または、
他の mod_perl ハンドラの出力を解析、または SSI 出力を他のハンドラへ
送ることができる (そうする場合 Apache::Filter を利用して下さい)。

各 SSI 命令は Apache::SSI の、接頭辞 "ssi_" のメソッドによって処理される。
例えば、<!--#printenv--> は ssi_printenv メソッドによって処理される。
SSI タグ内の属性=値のペアは解析され、ハッシュリファレンスで
メソッドに渡される

'Echo' 命令は、ssi_echo メソッドによって処理され、その代表が、
接頭辞 "echo_" のメソッドを調べる。例えば、<!--#echo
var=DOCUMENT_NAME--> は echo_DOCUMENT_NAME メソッドに処理される。

あなたは Apache::SSI から継承し 'ssi_*' と 'echo_*' メソッドを
オーバーライドするか、新規のものを書くことで、振る舞いをカスタマイズできます。

=head2 SSI 命令 (SSI Directives)

このモジュールは mod_include と同じ命令をサポートします。少なくとも、
それが目標です。=) 以下に一覧されながら、文書化されていないメソッドについては、
http://www.apache.org/ で mod_include のオンラインドキュメントを見て下さい。

=over 4

=item * config

=item * echo

=item * exec

=item * fsize

=item * flastmod

=item * include

=item * printenv

=item * set

=item * perl

Perl 関数を呼び出す方法は二つ、そして引数を与える二つの方法があります。
関数はどちらも無名サブルーチンリファレンスによって、
またはどこかで定義された関数名で指定されることができます。

 <!--#perl sub="sub { localtime() }"-->
 <!--#perl sub="time::now"-->

もし sub 引数が、正規表現 /^\s*sub[^\w:]/ にマッチすると、
サブルーチンリファレンスとみなされます。さもなくば、関数名とみなされます。
後者の場合、名前に "::" が含まれていない場合に、"main::" 文字列が
関数名の先頭に付加されます (これは関数が main パッケージか、あなたの指定する
パッケージ内にあることを強制します)。これは、あなたのコードを
main パッケージに置くための非常に悪い考えなので、私は気乗りしないで
この特徴を是認しているだけだという事に注意してください。

大抵、無名サブルーチンを使う事は遅くさせます。なぜなら、
それぞれは eval() されなければならず、キャッシュされないからである。
最善の結果のためには、親プロセス内に必要なコードをプリロードして、
そして名前でそれを呼び出してください。

もしあなたが "&Package::SubPack::handler" のようなサブルーチンを呼び出しているなら
"handler" 部分は省略可能で、このように作れます:

 <!--#perl sub="Package::Subpack"-->

もしあなたが関数に引数のリストを与えたいなら、"arg" か "args" パラメータの
どちらかを使います:

 <!--#perl sub="sub {$_[0] * 7}" arg=7-->
 <!--#perl sub=holy::matrimony arg=Hi arg=Lois-->
 <!--#perl sub=holy::matrimony args=Hi,Lois-->

"args" パラメータは簡単なカンマ分割をします。一般に
"args" パラメータを介してカンマを引数に埋め込む方法がない事
を意味します。これには "arg" パラメータを使って下さい。

もしあなたがキーと値のペアを与えたく、キーが 'sub', 'arg', 'args', または
'pass_request' (以下参照) でないのなら、あなたのルーチンはキーと値の
B<両者> を渡されるでしょう。これはキーと値のペアをあなたの関数へ、
ハッシュを渡させます:

 <!--#perl sub=holy::matrimony groom=Hi bride=Lois-->
 これは &holy::matrimony('groom', 'Hi', 'bride', 'Lois'); を呼びます。

バージョン 1.95 の時点で、私達は現在の Apache リクエストオブジェクト ($r) を
第一引数として関数に渡します。この動作を止めるには、'pass_request=no' の、
キーと値のペアを渡すか、あなたのサーバ設定ファイルに
'PerlSetVar SSIPerlPass_Request no' を置いてください。

Perl SSI 呼び出しに関しての詳細情報は、C<http://perl.apache.org/src/mod_perl.html>
をご覧下さい。

=item * if

=item * elif

=item * else

=item * endif

これらの四つの命令は C<mod_include> と同じように使われます。一点の
重要な違い: ブール式は、Perl の eval() を使用して評価されます。これは、
等価比較に C<=> に代わり C<==> か C<eq> を使用する事を意味します。また、条件式に
プリロードされた Perl サブルーチンを使用することが出来る事も意味します:

 <!--#if expr="&Movies::is_by_Coen_Brothers($MOVIE)"-->
  This movie is by the Coen Brothers.
 <!--#else-->
  This movie is not by the Coen Brothers.
 <!--#endif-->

もっとも、それはとても複雑な Perl の処理はできない。なぜならそれは手動で
(C<mod_include> のように $var または ${var} 形式の) 変数を探し、そして
$object->method または $hash{'key'} のような表記は間違えさせられるだろうからです。
Apache の変数がまだ埋められている間に、Perl 独自の表記を許可する方法について
どんな提案でも歓迎します。

=back

=head1 ハンドラのチェーン化 (CHAINING HANDLERS)

スタックされたハンドラのチェーン内にこのモジュールを存在させるために、
二つのかなり簡単な方法があります。第一に C<Apache::Filter> を使い、そしてあなたの
httpd.conf はこのような何かに見えるでしょう:

 PerlModule Apache::Filter
 PerlModule Apache::SSI
 PerlModule My::BeforeSSI
 PerlModule My::AfterSSI
 <Files ~ "\.ssi$">
  SetHandler perl-script
  PerlSetVar Filter On
  PerlHandler My::BeforeSSI Apache::SSI My::AfterSSI
 </Files>

C<"PerlSetVar Filter On"> ディレクティブは三つのスタックされたハンドラに
それらをフィルタリングモードにすべきだと命じます。これは必須です。

第二に C<Apache::OutputChain> を使い、そしてあなたの httpd.conf は
このような何かに見えるでしょう:

 PerlModule Apache::OutputChain
 PerlModule Apache::SSIChain
 PerlModule My::BeforeSSI
 PerlModule My::AfterSSI
 <Files ~ "\.ssi$">
  SetHandler perl-script
  PerlHandler Apache::OutputChain My::AfterSSI Apache::SSIChain My::BeforeSSI
 </Files>

このハンドラの順番は、二つの異なるメソッドで反転する事に注意してください。
一つの理由は、私が書いた C<Apache::Filter> は、順番をより直感的にさせます。
もう一つの理由は、C<Apache::SSI> それ自身が C<Apache::Filter> を使う
スタックハンドラで使われる事が出来る事です。それゆえに、C<Apache::OutputChain>
と一緒に使われるには、C<Apache::SSIChain> に包まれる必要があります。

より明確な情報は C<Apache::OutputChain> と C<Apache::Filter> のドキュメントを
ご覧下さい。そして、警告 (CAVEATS) の中の注記も見てください。
 

=head1 警告 (CAVEATS)

* Apache::Filter を介してハンドラのチェーン化した時、もし <!--#include ...-->
または <!--#exec cgi=...--> を使う場合、Apache::SSI はチェーン内の最後のフィルタ
でなければなりません。これは Apache::SSI がファイルのインクルードのために、
$r->lookup_uri(...)->run を使い、これは Perl の STDOUT よりむしろ C の stdout へ
出力を送るからです。従い Apache::Filter はそれの捕捉やフィルタが出来ません。

もし Apache::SSI はチェーン内の最後のフィルタか、あなたが <!--#fsize-->,
<!--#flastmod--> 等の簡単な SSI 命令を貼り付けるのなら問題ないだろう。

* 現在は、<!--#echo var=whatever--> が変数を探す手法は、最初に
$r->subprocess_env を試み、そして %ENV を試み、そして五つの追加の環境変数は
mod_include が提供します。この順序は正しいでしょうか？

=head1 行うこと (TO DO)

http://www.apache.org/docs/mod/mod_include.html を再訪し、私が出来ることが
他に何かないかを見ること。

ファイルをインクルードする時に十分に発達したサブリクエストを実行するか、
またはちょうどファイルを開いて出力するか、のどちらかを選択させる
"PerlSetVar ASSI_Subrequests 0|1" オプションを持つことは素敵だろう。

real.t テストのために Apache::test の使い方を知りたい。

=head1 参考資料 (SEE ALSO)

mod_include, mod_perl(3), Apache(3), HTML::Embperl(3), Apache::ePerl(3),
Apache::OutputChain(3)

=head1 作者 (AUTHOR)

Ken Williams ken@forum.swarthmore.edu

基本概念は Doug MacEachern dougm@osf.org によるオリジナルバージョン。
実装は異なる。

=head1 著作権 (COPYRIGHT)

Copyright 1998 Swarthmore College.  All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=head1 翻訳者

谷口公一 E<lt>taniguchi@users.sourceforge.jpE<gt>


