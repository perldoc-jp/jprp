
=encoding euc-jp

=head1 NAME

=begin original

perliol - C API for Perl's implementation of IO in Layers.

=end original

perliol - IO 層の Perl 実装への C API

(訳注: (TBR)がついている段落は「みんなの自動翻訳＠TexTra」による
機械翻訳です。)

=head1 SYNOPSIS

    /* Defining a layer ... */
    #include <perliol.h>

=head1 DESCRIPTION

=begin original

This document describes the behavior and implementation of the PerlIO
abstraction described in L<perlapio> when C<USE_PERLIO> is defined (and
C<USE_SFIO> is not).

=end original

この文書は、C<USE_PERLIO> が定義されている(そして C<USE_SFIO> が
定義されていない)場合に L<perlapio> で記述されている PerlIO 抽象化の
振る舞いと実装について記述しています。

=head2 History and Background

(歴史と背景)

=begin original

The PerlIO abstraction was introduced in perl5.003_02 but languished as
just an abstraction until perl5.7.0. However during that time a number
of perl extensions switched to using it, so the API is mostly fixed to
maintain (source) compatibility.

=end original

PerlIO抽象化はperl5.003_02で導入されましたが、perl5.7.0までは単なる抽象化として低迷していました。
しかし、その間に多くのperl拡張がそれを使用するように切り替えられたので、APIは(ソース)互換性を維持するためにほとんど固定されています。
(TBR)

=begin original

The aim of the implementation is to provide the PerlIO API in a flexible
and platform neutral manner. It is also a trial of an "Object Oriented
C, with vtables" approach which may be applied to Perl 6.

=end original

この実装の目的は、柔軟でプラットフォームに中立な方法でPerlIO APIを提供することです。
また、Perl 6に適用できる「オブジェクト指向C(vtablesを使用)」アプローチの試行でもあります。
(TBR)

=head2 Basic Structure

(基本構造)

=begin original

PerlIO is a stack of layers.

=end original

PerlIO は層のスタックです。

=begin original

The low levels of the stack work with the low-level operating system
calls (file descriptors in C) getting bytes in and out, the higher
layers of the stack buffer, filter, and otherwise manipulate the I/O,
and return characters (or bytes) to Perl.  Terms I<above> and I<below>
are used to refer to the relative positioning of the stack layers.

=end original

下位レベルのスタックは、下位レベルのオペレーティングシステムコール(Cのファイル記述子)と連動してバイトを入出力し、上位層のスタックバッファー、フィルター、その他の方法で入出力を操作し、文字(またはバイト)をPerlに返します。
I<above>およびI<below>という用語は、スタック層の相対的な位置を示すために使用されます。
(TBR)

=begin original

A layer contains a "vtable", the table of I/O operations (at C level
a table of function pointers), and status flags.  The functions in the
vtable implement operations like "open", "read", and "write".

=end original

層には、"vtable"、I/O操作のテーブル(Cレベルでは関数ポインタのテーブル)、およびステータスフラグが含まれます。
vtable内の関数は、"open"、"read"、"write"などの操作を実装します。
(TBR)

=begin original

When I/O, for example "read", is requested, the request goes from Perl
first down the stack using "read" functions of each layer, then at the
bottom the input is requested from the operating system services, then
the result is returned up the stack, finally being interpreted as Perl
data.

=end original

I/O(たとえば「read」)が要求されると、要求はまずPerlから各層の「read」関数を使用してスタックに送られ、次に一番下でオペレーティングシステムサービスからの入力が要求され、その結果がスタックに戻され、最終的にPerlデータとして解釈されます。
(TBR)

=begin original

The requests do not necessarily go always all the way down to the
operating system: that's where PerlIO buffering comes into play.

=end original

要求は必ずしも常にオペレーティングシステムまで届くわけではありません。
そこでPerlIOバッファリングが機能します。
(TBR)

=begin original

When you do an open() and specify extra PerlIO layers to be deployed,
the layers you specify are "pushed" on top of the already existing
default stack.  One way to see it is that "operating system is
on the left" and "Perl is on the right".

=end original

open()を実行し、デプロイする追加のPerlIO層を指定すると、指定した層は既存のデフォルトスタックの上に「プッシュ」されます。
これを理解する1つの方法は、「オペレーティングシステムが左側にあり」、「Perlが右側にある」ということです。
(TBR)

=begin original

What exact layers are in this default stack depends on a lot of
things: your operating system, Perl version, Perl compile time
configuration, and Perl runtime configuration.  See L<PerlIO>,
L<perlrun/PERLIO>, and L<open> for more information.

=end original

このデフォルトスタックにどの層が含まれるかは、オペレーティングシステム、Perlのバージョン、Perlコンパイル時の設定、Perlランタイムの設定など、さまざまな要素によって異なります。
詳細については、L<PerlIO>、L<perlrun/PERLIO>、およびL<open>を参照してください。
(TBR)

=begin original

binmode() operates similarly to open(): by default the specified
layers are pushed on top of the existing stack.

=end original

binmode()はopen()と同様に動作します。
デフォルトでは、指定された層が既存のスタックの上にプッシュされます。
(TBR)

=begin original

However, note that even as the specified layers are "pushed on top"
for open() and binmode(), this doesn't mean that the effects are
limited to the "top": PerlIO layers can be very 'active' and inspect
and affect layers also deeper in the stack.  As an example there
is a layer called "raw" which repeatedly "pops" layers until
it reaches the first layer that has declared itself capable of
handling binary data.  The "pushed" layers are processed in left-to-right
order.

=end original

ただし、指定された層がopen()とbinmode()で"一番上にプッシュ"されていても、効果が"一番上"に限定されているわけではないことに注意してください:PerlIO層は非常に'アクティブ'であり、スタック内のより深い層も検査して影響を与えることができます。
一例として、"raw"と呼ばれる層があり、バイナリデータを処理できると宣言された最初の層に到達するまで層を繰り返し"ポップ"します。
"プッシュ"された層は左から右の順に処理されます。
(TBR)

=begin original

sysopen() operates (unsurprisingly) at a lower level in the stack than
open().  For example in UNIX or UNIX-like systems sysopen() operates
directly at the level of file descriptors: in the terms of PerlIO
layers, it uses only the "unix" layer, which is a rather thin wrapper
on top of the UNIX file descriptors.

=end original

例えば、UNIXやUNIXに似たシステムでは、sysopen()はファイル記述子のレベルで直接動作します。
PerlIO層に関しては、"unix"層のみを使用します。
"unix"層はUNIXファイル記述子の上の薄いラッパーです。
(TBR)

=head2 Layers vs Disciplines

(層とディシプリン)

=begin original

Initial discussion of the ability to modify IO streams behaviour used
the term "discipline" for the entities which were added. This came (I
believe) from the use of the term in "sfio", which in turn borrowed it
from "line disciplines" on Unix terminals. However, this document (and
the C code) uses the term "layer".

=end original

IOストリームの振る舞いを変更する機能についての最初の議論では、追加されたエンティティに"discipline"という用語が使われていましたが、これは"sfio"という用語が使われていたことに由来すると思います。
この用語はUnix端末の"line discipline"から借用したものです。
ただし、このドキュメント(およびCコード)では"layer"という用語を使用しています。
(TBR)

=begin original

This is, I hope, a natural term given the implementation, and should
avoid connotations that are inherent in earlier uses of "discipline"
for things which are rather different.

=end original

これは、実装された場合の自然な用語であることを願っており、かなり異なるものに対する「規律」の初期の使用に内在する含意を避けるべきである。
(TBR)

=head2 Data Structures

(データ構造体)

=begin original

The basic data structure is a PerlIOl:

=end original

基本データ構造体は PerlIOl です:

	typedef struct _PerlIO PerlIOl;
	typedef struct _PerlIO_funcs PerlIO_funcs;
	typedef PerlIOl *PerlIO;

	struct _PerlIO
	{
	 PerlIOl *	next;       /* Lower layer */
	 PerlIO_funcs *	tab;        /* Functions for this layer */
	 IV		flags;      /* Various flags for state */
	};

=begin original

A C<PerlIOl *> is a pointer to the struct, and the I<application>
level C<PerlIO *> is a pointer to a C<PerlIOl *> - i.e. a pointer
to a pointer to the struct. This allows the application level C<PerlIO *>
to remain constant while the actual C<PerlIOl *> underneath
changes. (Compare perl's C<SV *> which remains constant while its
C<sv_any> field changes as the scalar's type changes.) An IO stream is
then in general represented as a pointer to this linked-list of
"layers".

=end original

C<PerlIOl *>は構造体へのポインタであり、I<アプリケーション>レベルC<PerlIO *>はC<PerlIOl *>へのポインタ、つまり構造体へのポインタへのポインタです。
これにより、実際のC<PerlIOl *>が変化しても、アプリケーションレベルC<PerlIO *>は一定に保たれます(PerlのC<SV *>と比較してください。
PerlのC<SV *>は、スカラの型が変化するにつれてC<sv_any>フィールドが変化します)。
IOストリームは一般に、この「層」のリンクリストへのポインタとして表現されます。
(TBR)

=begin original

It should be noted that because of the double indirection in a C<PerlIO *>,
a C<< &(perlio->next) >> "is" a C<PerlIO *>, and so to some degree
at least one layer can use the "standard" API on the next layer down.

=end original

C<PerlIO *>における二重の間接化のために、C<< &(perlio->next)>>"は"C<PerlIO *>であり、したがって、少なくとも1つの層は、ある程度まで、次の層の"標準"アプリケーションプログラミングインターフェイスを使用することができることに注意してください。
(TBR)

=begin original

A "layer" is composed of two parts:

=end original

一つの「層」は二つの部分から構成されます:

=over 4

=item 1.

=begin original

The functions and attributes of the "layer class".

=end original

「層クラス」の関数と属性。

=item 2.

=begin original

The per-instance data for a particular handle.

=end original

特定のハンドルのためのインスタンス単位のデータ。

=back

=head2 Functions and Attributes

(関数と属性)

=begin original

The functions and attributes are accessed via the "tab" (for table)
member of C<PerlIOl>. The functions (methods of the layer "class") are
fixed, and are defined by the C<PerlIO_funcs> type. They are broadly the
same as the public C<PerlIO_xxxxx> functions:

=end original

関数と属性にアクセスするには、C<PerlIOl>の"tab"(テーブル用)メンバを使用します。
関数(層"class"のメソッド)は固定されており、C<PerlIO_funcs>型で定義されます。
これらは、パブリックC<PerlIO_xxxxx>関数とほぼ同じです。
(TBR)

  struct _PerlIO_funcs
  {
   Size_t		fsize;
   char *		name;
   Size_t		size;
   IV		kind;
   IV		(*Pushed)(pTHX_ PerlIO *f,const char *mode,SV *arg, PerlIO_funcs *tab);
   IV		(*Popped)(pTHX_ PerlIO *f);
   PerlIO *	(*Open)(pTHX_ PerlIO_funcs *tab,
  			PerlIO_list_t *layers, IV n,
  			const char *mode,
  			int fd, int imode, int perm,
  			PerlIO *old,
  			int narg, SV **args);
   IV		(*Binmode)(pTHX_ PerlIO *f);
   SV *		(*Getarg)(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
   IV		(*Fileno)(pTHX_ PerlIO *f);
   PerlIO *     (*Dup)(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
   /* Unix-like functions - cf sfio line disciplines */
   SSize_t	(*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
   SSize_t	(*Unread)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
   SSize_t	(*Write)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
   IV		(*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
   Off_t	(*Tell)(pTHX_ PerlIO *f);
   IV		(*Close)(pTHX_ PerlIO *f);
   /* Stdio-like buffered IO functions */
   IV		(*Flush)(pTHX_ PerlIO *f);
   IV		(*Fill)(pTHX_ PerlIO *f);
   IV		(*Eof)(pTHX_ PerlIO *f);
   IV		(*Error)(pTHX_ PerlIO *f);
   void		(*Clearerr)(pTHX_ PerlIO *f);
   void		(*Setlinebuf)(pTHX_ PerlIO *f);
   /* Perl's snooping functions */
   STDCHAR *	(*Get_base)(pTHX_ PerlIO *f);
   Size_t	(*Get_bufsiz)(pTHX_ PerlIO *f);
   STDCHAR *	(*Get_ptr)(pTHX_ PerlIO *f);
   SSize_t	(*Get_cnt)(pTHX_ PerlIO *f);
   void		(*Set_ptrcnt)(pTHX_ PerlIO *f,STDCHAR *ptr,SSize_t cnt);
  };

=begin original

The first few members of the struct give a function table size for
compatibility check "name" for the layer, the  size to C<malloc> for the per-instance data,
and some flags which are attributes of the class as whole (such as whether it is a buffering
layer), then follow the functions which fall into four basic groups:

=end original

構造体の最初の数メンバは、層の互換性チェック"name"のための関数テーブルサイズ、インスタンス単位のデータのためのC<malloc>へのサイズ、クラス全体の属性であるいくつかのフラグ(バッファ層かどうかなど)を与え、次の4つの基本グループに分類される関数に従います。
(TBR)

=over 4

=item 1.

=begin original

Opening and setup functions

=end original

オープンと設定のための関数

=item 2.

=begin original

Basic IO operations

=end original

基本 IO 操作

=item 3.

=begin original

Stdio class buffering options.

=end original

Stdio クラスバッファリングオプション。

=item 4.

=begin original

Functions to support Perl's traditional "fast" access to the buffer.

=end original

Perl の伝統的なバッファへの「高速」アクセスに対応する関数。

=back

=begin original

A layer does not have to implement all the functions, but the whole
table has to be present. Unimplemented slots can be NULL (which will
result in an error when called) or can be filled in with stubs to
"inherit" behaviour from a "base class". This "inheritance" is fixed
for all instances of the layer, but as the layer chooses which stubs
to populate the table, limited "multiple inheritance" is possible.

=end original

層はすべての関数を実装する必要はありませんが、テーブル全体が存在する必要があります。
実装されていないスロットはNULL(エラーコール時が発生します)、または"ベースクラス"から動作を"継承"するためのスタブで埋めることができます。
この"継承"は層のすべてのインスタンスに対して固定されていますが、層がテーブルに格納するスタブを選択するため、"多重継承"は制限されます。
(TBR)

=head2 Per-instance Data

(インスタンス単位のデータ)

=begin original

The per-instance data are held in memory beyond the basic PerlIOl
struct, by making a PerlIOl the first member of the layer's struct
thus:

=end original

インスタンス単位のデータは、PerlIOlを層構造体の最初のメンバにすることによって、基本的なPerlIOl構造体以外のメモリに保持される。
(TBR)

	typedef struct
	{
	 struct _PerlIO base;       /* Base "class" info */
	 STDCHAR *	buf;        /* Start of buffer */
	 STDCHAR *	end;        /* End of valid part of buffer */
	 STDCHAR *	ptr;        /* Current position in buffer */
	 Off_t		posn;       /* Offset of buf into the file */
	 Size_t		bufsiz;     /* Real size of buffer */
	 IV		oneword;    /* Emergency buffer */
	} PerlIOBuf;

=begin original

In this way (as for perl's scalars) a pointer to a PerlIOBuf can be
treated as a pointer to a PerlIOl.

=end original

このようにして(perlのスカラと同様に)PerlIOBufへのポインタをPerlIOlへのポインタとして扱うことができます。
(TBR)

=head2 Layers in action.

(実行中の層)

                table           perlio          unix
            |           |
            +-----------+    +----------+    +--------+
   PerlIO ->|           |--->|  next    |--->|  NULL  |
            +-----------+    +----------+    +--------+
            |           |    |  buffer  |    |   fd   |
            +-----------+    |          |    +--------+
            |           |    +----------+

=begin original

The above attempts to show how the layer scheme works in a simple case.
The application's C<PerlIO *> points to an entry in the table(s)
representing open (allocated) handles. For example the first three slots
in the table correspond to C<stdin>,C<stdout> and C<stderr>. The table
in turn points to the current "top" layer for the handle - in this case
an instance of the generic buffering layer "perlio". That layer in turn
points to the next layer down - in this case the low-level "unix" layer.

=end original

上記では、単純なケースで層スキームがどのように機能するかを示します。
アプリケーションのC<PerlIO *>は、オープン(割り当てられた)ハンドルを表すテーブルのエントリを指します。
たとえば、テーブルの最初の3つのスロットは、C<stdin>、C<stdout>、C<stderr>に対応します。
テーブルは次にハンドルの現在の"最上位"層(この場合は汎用バッファ層"perlio"のインスタンス)を指します。
この層は次に下の層(この場合は低レベル"unix"層)を指します。
(TBR)

=begin original

The above is roughly equivalent to a "stdio" buffered stream, but with
much more flexibility:

=end original

上記は"stdio"バッファストリームとほぼ同じですが、より柔軟性があります:
(TBR)

=over 4

=item *

=begin original

If Unix level C<read>/C<write>/C<lseek> is not appropriate for (say)
sockets then the "unix" layer can be replaced (at open time or even
dynamically) with a "socket" layer.

=end original

もしUnixレベルのC<read>/C<write>/C<lseek>が(例えば)ソケットに適切でないなら、"unix"層は(オープン時あるいは動的に)"socket"層に置き換えることができます。
(TBR)

=item *

=begin original

Different handles can have different buffering schemes. The "top"
layer could be the "mmap" layer if reading disk files was quicker
using C<mmap> than C<read>. An "unbuffered" stream can be implemented
simply by not having a buffer layer.

=end original

異なるハンドルは異なるバッファリングスキームを持つことができます。
ディスクファイルの読み込みがC<read>よりC<mmap>を使用した方が速い場合、"top"層は"mmap"層になる可能性があります。
"unbuffered"ストリームは単にバッファ層を持たないことで実装できます。
(TBR)

=item *

=begin original

Extra layers can be inserted to process the data as it flows through.
This was the driving need for including the scheme in perl 5.7.0+ - we
needed a mechanism to allow data to be translated between perl's
internal encoding (conceptually at least Unicode as UTF-8), and the
"native" format used by the system. This is provided by the
":encoding(xxxx)" layer which typically sits above the buffering layer.

=end original

データが流れるときにデータを処理するために、追加の層を挿入することができます。
これは、perl 5.7.0+にスキームを含めるための原動力となった要求でした-perlの内部エンコーディング(概念的には少なくともUTF-8としてのUnicode)とシステムで使用される"ネイティブ"フォーマットとの間でデータを変換できるメカニズムが必要でした。
これは、一般的にバッファ層の上に位置する":encoding(xxxx)"層によって提供されます。
(TBR)

=item *

=begin original

A layer can be added that does "\n" to CRLF translation. This layer
can be used on any platform, not just those that normally do such
things.

=end original

"\n"をCRLF変換に行う層を追加できます。
この層は、通常そのようなことを行うプラットフォームだけでなく、あらゆるプラットフォームで使用できます。
(TBR)

=back

=head2 Per-instance flag bits

(インスタンス単位のフラグビット)

=begin original

The generic flag bits are a hybrid of C<O_XXXXX> style flags deduced
from the mode string passed to C<PerlIO_open()>, and state bits for
typical buffer layers.

=end original

一般的なフラグビットは、C<PerlIO_open()>に渡されたモード文字列から推定されたC<O_XXXXX>スタイルフラグと、典型的なバッファ層の状態ビットとのハイブリッドである。
(TBR)

=over 4

=item PERLIO_F_EOF

=begin original

End of file.

=end original

ファイルの末尾。

=item PERLIO_F_CANWRITE

=begin original

Writes are permitted, i.e. opened as "w" or "r+" or "a", etc.

=end original

書き込みが許可されている; つまり "w", "r+", "a" などとして開かれている。

=item  PERLIO_F_CANREAD

=begin original

Reads are permitted i.e. opened "r" or "w+" (or even "a+" - ick).

=end original

読み込みが許可されている; "r", "w+" (または "a+" 的) として開かれている。

=item PERLIO_F_ERROR

=begin original

An error has occurred (for C<PerlIO_error()>).

=end original

(C<PerlIO_error()> のための) エラーが発生した。

=item PERLIO_F_TRUNCATE

=begin original

Truncate file suggested by open mode.

=end original

オープンモードで提案されたファイルを切り詰める。

=item PERLIO_F_APPEND

=begin original

All writes should be appends.

=end original

全ての書き込みは追記される。

=item PERLIO_F_CRLF

=begin original

Layer is performing Win32-like "\n" mapped to CR,LF for output and CR,LF
mapped to "\n" for input. Normally the provided "crlf" layer is the only
layer that need bother about this. C<PerlIO_binmode()> will mess with this
flag rather than add/remove layers if the C<PERLIO_K_CANCRLF> bit is set
for the layers class.

=end original

層はWin 32のような"\n"を実行しています。
"\n"は出力用にCR,LFにマップされ、CR,LFは入力用に"\n"にマップされます。
通常、"crlf"層が提供されていますが、これを気にする必要がある層はこれだけです。
C<PerlIO_K_CANCRLF>ビットが層クラスに設定されている場合、C<PERLIO_binmode()>は層を追加/削除するのではなく、このフラグを扱います。
(TBR)

=item PERLIO_F_UTF8

=begin original

Data written to this layer should be UTF-8 encoded; data provided
by this layer should be considered UTF-8 encoded. Can be set on any layer
by ":utf8" dummy layer. Also set on ":encoding" layer.

=end original

この層に書き込まれるデータはUTF-8エンコードされている必要があります。
この層によって提供されるデータはUTF-8エンコードされているとみなされます。
":utf8"ダミー層によって任意の層に設定できます。
":encoding"層にも設定できます。
(TBR)

=item PERLIO_F_UNBUF

=begin original

Layer is unbuffered - i.e. write to next layer down should occur for
each write to this layer.

=end original

層はバッファされていません。
つまり、次の層への書き込みは、この層への書き込みごとに行われます。
(TBR)

=item PERLIO_F_WRBUF

=begin original

The buffer for this layer currently holds data written to it but not sent
to next layer.

=end original

現在、この層のバッファには、書き込まれたデータが保持されますが、次の層には送信されません。
(TBR)

=item PERLIO_F_RDBUF

=begin original

The buffer for this layer currently holds unconsumed data read from
layer below.

=end original

現在、この層のバッファには、下の層から読み込まれた未使用データが保持されています。
(TBR)

=item PERLIO_F_LINEBUF

=begin original

Layer is line buffered. Write data should be passed to next layer down
whenever a "\n" is seen. Any data beyond the "\n" should then be
processed.

=end original

層はラインバッファされています。
"\n"が検出された場合、書き込みデータは次の画層に渡される必要があります。
"\n"を超えるデータは処理されます。
(TBR)

=item PERLIO_F_TEMP

=begin original

File has been C<unlink()>ed, or should be deleted on C<close()>.

=end original

ファイルが C<unlink()> されている、または C<close()> で削除されるべき。

=item PERLIO_F_OPEN

=begin original

Handle is open.

=end original

ハンドルが開いている。

=item PERLIO_F_FASTGETS

=begin original

This instance of this layer supports the "fast C<gets>" interface.
Normally set based on C<PERLIO_K_FASTGETS> for the class and by the
existence of the function(s) in the table. However a class that
normally provides that interface may need to avoid it on a
particular instance. The "pending" layer needs to do this when
it is pushed above a layer which does not support the interface.
(Perl's C<sv_gets()> does not expect the streams fast C<gets> behaviour
to change during one "get".)

=end original

この層のこのインスタンスは"fast C<gets>"インタフェースをサポートします。
通常は、クラスのC<PERLIO_K_FASTGETS>とテーブル内の関数の存在に基づいて設定されます。
しかし、通常そのインタフェースを提供するクラスは、特定のインスタンスでそのインタフェースを回避する必要があるかもしれません。
"pending"層は、そのインタフェースをサポートしない層の上にプッシュされたときに、これを行う必要があります。
(PerlのC<sv_gets()>は、"get"の間にストリームの高速なC<gets>動作が変化することを期待していません。
)
(TBR)

=back

=head2 Methods in Detail

(メソッドの詳細)

=over 4

=item fsize

	Size_t fsize;

=begin original

Size of the function table. This is compared against the value PerlIO
code "knows" as a compatibility check. Future versions I<may> be able
to tolerate layers compiled against an old version of the headers.

=end original

ファンクションテーブルのサイズ。
これは互換性チェックとしてPerlIOコードが「知っている」値と比較されます。
将来のバージョンでは、古いバージョンのヘッダに対してコンパイルされた層を許容できるようになる可能性があります。
(TBR)

=item name

	char * name;

=begin original

The name of the layer whose open() method Perl should invoke on
open().  For example if the layer is called APR, you will call:

=end original

Perlがopen()で呼び出すopen()メソッドを持つ層の名前。
たとえば、層がAPRという場合は、次のようにコールします。
(TBR)

  open $fh, ">:APR", ...

=begin original

and Perl knows that it has to invoke the PerlIOAPR_open() method
implemented by the APR layer.

=end original

そしてPerlは、APR層によって実装されたPerlIOAPR_open()メソッドを呼び出さなければならないことを知っています。
(TBR)

=item size

	Size_t size;

=begin original

The size of the per-instance data structure, e.g.:

=end original

インスタンス単位のデータ構造体のサイズ; つまり:

  sizeof(PerlIOAPR)

=begin original

If this field is zero then C<PerlIO_pushed> does not malloc anything
and assumes layer's Pushed function will do any required layer stack
manipulation - used to avoid malloc/free overhead for dummy layers.
If the field is non-zero it must be at least the size of C<PerlIOl>,
C<PerlIO_pushed> will allocate memory for the layer's data structures
and link new layer onto the stream's stack. (If the layer's Pushed
method returns an error indication the layer is popped again.)

=end original

このフィールドが0の場合、C<PerlIO_pushed>は何もmallocせず、layerのPushed関数が必要な層スタック操作を行うと仮定します。
これはmalloc/freeオーバーヘッドをダミー層に対して回避するために使用されます。
フィールドが0以外の場合、少なくともC<PerlIOl>のサイズである必要があります。
C<PerlIO_pushed>は層のデータ構造にメモリを割り当て、新しい層をストリームのスタックにリンクします(層のPushedメソッドがエラー表示を返す場合、層は再度ポップされます)。
(TBR)

=item kind

	IV kind;

=over 4

=item * PERLIO_K_BUFFERED

=begin original

The layer is buffered.

=end original

層がバッファリングされている。

=item * PERLIO_K_RAW

=begin original

The layer is acceptable to have in a binmode(FH) stack - i.e. it does not
(or will configure itself not to) transform bytes passing through it.

=end original

層は、バイナリモード(FH)スタックを持つことが許容されます。
つまり、層を通過するバイトを変換しません(または、変換しないように自身を設定しません)。
(TBR)

=item * PERLIO_K_CANCRLF

=begin original

Layer can translate between "\n" and CRLF line ends.

=end original

層は "\n" と CRLF 行末を変換できる。

=item * PERLIO_K_FASTGETS

=begin original

Layer allows buffer snooping.

=end original

層はバッファを覗くことを許可している。

=item * PERLIO_K_MULTIARG

=begin original

Used when the layer's open() accepts more arguments than usual. The
extra arguments should come not before the C<MODE> argument. When this
flag is used it's up to the layer to validate the args.

=end original

層のopen()が通常より多くの引数を受け入れる場合に使用されます。
余分な引数は、C<MODE>引数の前に指定しないでください。
このフラグを使用する場合は、層がargsを検証します。
(TBR)

=back

=item Pushed

	IV	(*Pushed)(pTHX_ PerlIO *f,const char *mode, SV *arg);

=begin original

The only absolutely mandatory method. Called when the layer is pushed
onto the stack.  The C<mode> argument may be NULL if this occurs
post-open. The C<arg> will be non-C<NULL> if an argument string was
passed. In most cases this should call C<PerlIOBase_pushed()> to
convert C<mode> into the appropriate C<PERLIO_F_XXXXX> flags in
addition to any actions the layer itself takes.  If a layer is not
expecting an argument it need neither save the one passed to it, nor
provide C<Getarg()> (it could perhaps C<Perl_warn> that the argument
was un-expected).

=end original

唯一絶対に必要なメソッドです。
層がスタックにプッシュされるときに呼び出されます。
C<mode>引数は、オープン後に発生する場合はNULLになる可能性があります。
引数文字列が渡された場合、C<arg>は非C<NULL>になります。
ほとんどの場合、これはC<PerlIOBase_pushed()>を呼び出し、層自身が行うアクションに加えて、C<mode>を適切なC<PERLIO_F_XXXXX>フラグに変換する必要があります。
層が引数を予期していない場合は、渡された引数を保存する必要も、C<Getarg()>を指定する必要もありません(引数が予期されていなかった場合は、C<Perl_warn>である可能性があります)。
(TBR)

=begin original

Returns 0 on success. On failure returns -1 and should set errno.

=end original

成功時は 0 を返します。
失敗時には -1 を返して errno が設定されます。

=item Popped

	IV	(*Popped)(pTHX_ PerlIO *f);

=begin original

Called when the layer is popped from the stack. A layer will normally
be popped after C<Close()> is called. But a layer can be popped
without being closed if the program is dynamically managing layers on
the stream. In such cases C<Popped()> should free any resources
(buffers, translation tables, ...) not held directly in the layer's
struct.  It should also C<Unread()> any unconsumed data that has been
read and buffered from the layer below back to that layer, so that it
can be re-provided to what ever is now above.

=end original

層がスタックからポップされるときに呼び出されます。
層は通常、C<Close()>が呼び出された後にポップされます。
しかし、プログラムがストリーム上の層を動的に管理している場合、層は閉じずにポップされる可能性があります。
そのような場合、C<Pop()>は、層の構造体に直接保持されていないリソース(バッファ、変換テーブルなど)を解放する必要があります。
また、下の層から読み込まれてバッファされた未使用のデータをC<Unread()>に戻して、現在上にあるものに再度提供できるようにします。
(TBR)

=begin original

Returns 0 on success and failure.  If C<Popped()> returns I<true> then
I<perlio.c> assumes that either the layer has popped itself, or the
layer is super special and needs to be retained for other reasons.
In most cases it should return I<false>.

=end original

成功および失敗時に0を戻します。
C<perlio()>がI<true>を戻した場合、I<Pop.c>は、層が自身でポップしたか、層が超特殊で他の理由で保持する必要があると想定します。
ほとんどの場合、I<false>を戻します。
(TBR)

=item Open

	PerlIO *	(*Open)(...);

=begin original

The C<Open()> method has lots of arguments because it combines the
functions of perl's C<open>, C<PerlIO_open>, perl's C<sysopen>,
C<PerlIO_fdopen> and C<PerlIO_reopen>.  The full prototype is as
follows:

=end original

C<Open()>メソッドは、perlのC<open>、C<PerlIO_open>、perlのC<sysopen>、C<PerlIO_fdopen>、C<PerlIO_reopen>の関数を組み合わせているため、多くの引数を持っています。
完全なプロトタイプは次のとおりです。
(TBR)

 PerlIO *	(*Open)(pTHX_ PerlIO_funcs *tab,
			PerlIO_list_t *layers, IV n,
			const char *mode,
			int fd, int imode, int perm,
			PerlIO *old,
			int narg, SV **args);

=begin original

Open should (perhaps indirectly) call C<PerlIO_allocate()> to allocate
a slot in the table and associate it with the layers information for
the opened file, by calling C<PerlIO_push>.  The I<layers> is an
array of all the layers destined for the C<PerlIO *>, and any
arguments passed to them, I<n> is the index into that array of the
layer being called. The macro C<PerlIOArg> will return a (possibly
C<NULL>) SV * for the argument passed to the layer.

=end original

Openは(おそらく間接的に)C<PerlIO_allocate()>を呼び出してテーブル内のスロットを割り当て、C<PerlIO_push>を呼び出して開いたファイルの層情報に関連付ける必要があります。
I<layers>はC<PerlIO *>宛てのすべての層の配列であり、それらに渡された引数I<n>は呼び出された層のその配列へのインデックスです。
マクロC<PerlIOArg>は層に渡された引数に対して(おそらくC<NULL>)SV*を返します。
(TBR)

=begin original

The I<mode> string is an "C<fopen()>-like" string which would match
the regular expression C</^[I#]?[rwa]\+?[bt]?$/>.

=end original

I<mode>文字列は、正規表現C</^[I#]?[rwa]\+?[bt]?$/>に一致する"C<fopen()>様"文字列です。
(TBR)

=begin original

The C<'I'> prefix is used during creation of C<stdin>..C<stderr> via
special C<PerlIO_fdopen> calls; the C<'#'> prefix means that this is
C<sysopen> and that I<imode> and I<perm> should be passed to
C<PerlLIO_open3>; C<'r'> means B<r>ead, C<'w'> means B<w>rite and
C<'a'> means B<a>ppend. The C<'+'> suffix means that both reading and
writing/appending are permitted.  The C<'b'> suffix means file should
be binary, and C<'t'> means it is text. (Almost all layers should do
the IO in binary mode, and ignore the b/t bits. The C<:crlf> layer
should be pushed to handle the distinction.)

=end original

C<'I'>接頭辞は、特殊なC<PerlIO_fdopen>呼び出しによるC<stdin>.C<stderr>の作成時に使用されます。
C<'#'>接頭辞はこれがC<sysopen>であり、I<imode>とI<perm>がC<PerlLIO_open3>に渡されることを意味します。
C<'r'>はB<r>ead、C<'w'>はB<w>rite、C<'a'>はB<a>ppendを意味します。
C<'+'>接尾辞は読み取りと書き込み/追加の両方が許可されることを意味します。
C<'b'>接尾辞はファイルがバイナリであることを意味し、C<'t'>はテキストであることを意味します(ほとんどすべての層はバイナリモードでIOを行い、b/tビットは無視します。
C<:crlf>層はこの区別を処理するようにプッシュされるべきです)。
(TBR)

=begin original

If I<old> is not C<NULL> then this is a C<PerlIO_reopen>. Perl itself
does not use this (yet?) and semantics are a little vague.

=end original

もしI<old>がC<NULL>でなければ、これはC<PerlIO_reopen>です。
Perl自体は(まだ?)これを使っておらず、セマンティクスも少し曖昧です。
(TBR)

=begin original

If I<fd> not negative then it is the numeric file descriptor I<fd>,
which will be open in a manner compatible with the supplied mode
string, the call is thus equivalent to C<PerlIO_fdopen>. In this case
I<nargs> will be zero.

=end original

I<fd>が負でない場合、これは数値ファイルディスクリプタI<fd>であり、指定されたモード文字列と互換性のある方法でオープンされる。
したがって、この呼び出しはC<PerlIO_fdopen>と等価である。
この場合、I<nargs>は0になる。
(TBR)

=begin original

If I<nargs> is greater than zero then it gives the number of arguments
passed to C<open>, otherwise it will be 1 if for example
C<PerlIO_open> was called.  In simple cases SvPV_nolen(*args) is the
pathname to open.

=end original

I<nargs>が0より大きい場合は、C<open>に渡された引数の数を返します。
そうでなければ、たとえばC<PerlIO_open>が呼び出された場合は1になります。
単純な場合には、SvPV_nolen(*args)が開くパス名です。
(TBR)

=begin original

Having said all that translation-only layers do not need to provide
C<Open()> at all, but rather leave the opening to a lower level layer
and wait to be "pushed".  If a layer does provide C<Open()> it should
normally call the C<Open()> method of next layer down (if any) and
then push itself on top if that succeeds.

=end original

とは言っても、変換のみの層はC<Open()>を提供する必要は全くなく、むしろ下位レベルの層に開口部を残し、"プッシュ"されるのを待つ必要があります。
層がC<Open()>を提供する場合、通常は次の層のC<Open()>メソッドを呼び出し(もしあれば)、成功した場合には自身を一番上にプッシュする必要があります。
(TBR)

=begin original

If C<PerlIO_push> was performed and open has failed, it must
C<PerlIO_pop> itself, since if it's not, the layer won't be removed
and may cause bad problems.

=end original

C<PerlIO_push>が実行され、オープンが失敗した場合、それはC<PerlIO_pop>自身でなければならない。
そうでない場合、層は削除されず、悪い問題を引き起こす可能性があるからである。
(TBR)

=begin original

Returns C<NULL> on failure.

=end original

失敗時には C<NULL> を返します。

=item Binmode

	IV        (*Binmode)(pTHX_ PerlIO *f);

=begin original

Optional. Used when C<:raw> layer is pushed (explicitly or as a result
of binmode(FH)). If not present layer will be popped. If present
should configure layer as binary (or pop itself) and return 0.
If it returns -1 for error C<binmode> will fail with layer
still on the stack.

=end original

オプション。
C<:raw>層がプッシュされたときに使用されます(明示的に、またはbinmode(FH)の結果として)。
層が存在しない場合は、層がポップされます。
層が存在する場合は、層をバイナリ(またはポップ自体)として設定し、0を返す必要があります。
エラーで-1が返された場合、C<binmode>は失敗し、層はまだスタック上にあります。
(TBR)

=item Getarg

	SV *      (*Getarg)(pTHX_ PerlIO *f,
			    CLONE_PARAMS *param, int flags);

=begin original

Optional. If present should return an SV * representing the string
argument passed to the layer when it was
pushed. e.g. ":encoding(ascii)" would return an SvPV with value
"ascii". (I<param> and I<flags> arguments can be ignored in most
cases)

=end original

省略可能です。
存在する場合は、層がプッシュされたときに層に渡された文字列引数を表すSV*が戻されます。
たとえば、":encoding(ascii)"は、値"ascii"のSvPVを戻します。
(I<param>およびI<flags>引数はほとんどの場合無視できます)
(TBR)

=begin original

C<Dup> uses C<Getarg> to retrieve the argument originally passed to
C<Pushed>, so you must implement this function if your layer has an
extra argument to C<Pushed> and will ever be C<Dup>ed.

=end original

C<Dup>はC<Getarg>ををに渡された引数を取得するためにC<Getarg>を使用します。
したがって、層にC<Pushed>への追加引数があり、C<Dup>される場合は、この関数を実装する必要があります。
(TBR)

=item Fileno

	IV        (*Fileno)(pTHX_ PerlIO *f);

=begin original

Returns the Unix/Posix numeric file descriptor for the handle. Normally
C<PerlIOBase_fileno()> (which just asks next layer down) will suffice
for this.

=end original

ハンドルのUnix/Posix数値ファイル記述子を返します。
通常、これにはC<PerlIOBase_fileno()>(単に次の層を要求する)で十分です。
(TBR)

=begin original

Returns -1 on error, which is considered to include the case where the
layer cannot provide such a file descriptor.

=end original

エラー時に-1を返します。
これは、層がそのようなファイル記述子を提供できない場合を含むと考えられます。
(TBR)

=item Dup

	PerlIO * (*Dup)(pTHX_ PerlIO *f, PerlIO *o,
			CLONE_PARAMS *param, int flags);

=begin original

XXX: Needs more docs.

=end original

XXX: もっと文書が必要です。

=begin original

Used as part of the "clone" process when a thread is spawned (in which
case param will be non-NULL) and when a stream is being duplicated via
'&' in the C<open>.

=end original

スレッドが生成されるとき(この場合、paramは非NULLになります)、およびストリームがC<open>の'&'によって複製されるときに、"clone"プロセスの一部として使用されます。
(TBR)

=begin original

Similar to C<Open>, returns PerlIO* on success, C<NULL> on failure.

=end original

C<Open> と同様ですが、正常時には PerlIO* を返し、失敗時には C<NULL> を
返します。

=item Read

	SSize_t	(*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);

=begin original

Basic read operation.

=end original

基本読み込み操作です。

=begin original

Typically will call C<Fill> and manipulate pointers (possibly via the
API).  C<PerlIOBuf_read()> may be suitable for derived classes which
provide "fast gets" methods.

=end original

通常、はC<Fill>を呼び出し、ポインタを操作します(おそらくアプリケーションプログラミングインターフェイス経由で)。
C<PerlIOBuf_read()>は、"fast gets"メソッドを提供する派生クラスに適しています。
(TBR)

=begin original

Returns actual bytes read, or -1 on an error.

=end original

実際に読み込まれたバイト数か、エラー時には -1 を返します。

=item	Unread

	SSize_t	(*Unread)(pTHX_ PerlIO *f,
			  const void *vbuf, Size_t count);

=begin original

A superset of stdio's C<ungetc()>. Should arrange for future reads to
see the bytes in C<vbuf>. If there is no obviously better implementation
then C<PerlIOBase_unread()> provides the function by pushing a "fake"
"pending" layer above the calling layer.

=end original

stdioのC<ungetc()>のスーパーセット。
今後の読み込みでC<vbuf>内のバイトを参照するように手配する必要があります。
明らかに優れた実装がない場合、C<PerlIOBase_unread()>は"fake""pending"層を呼び出し元層の上にプッシュすることで関数を提供します。
(TBR)

=begin original

Returns the number of unread chars.

=end original

まだ読み込んでいない文字の数を返します。

=item Write

	SSize_t	(*Write)(PerlIO *f, const void *vbuf, Size_t count);

=begin original

Basic write operation.

=end original

基本書き込み操作です。

=begin original

Returns bytes written or -1 on an error.

=end original

書き込まれたバイト数か、エラー時には -1 を返します。

=item Seek

	IV	(*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);

=begin original

Position the file pointer. Should normally call its own C<Flush>
method and then the C<Seek> method of next layer down.

=end original

ファイルポインタを配置します。
通常は、独自のC<Flush>メソッドを呼び出し、次の層のC<Seek>メソッドを呼び出します。
(TBR)

=begin original

Returns 0 on success, -1 on failure.

=end original

成功時には 0 を、失敗時には -1 を返します。

=item Tell

	Off_t	(*Tell)(pTHX_ PerlIO *f);

=begin original

Return the file pointer. May be based on layers cached concept of
position to avoid overhead.

=end original

ファイルポインタを返します。
オーバーヘッドを避けるために、層にキャッシュされた位置の概念に基づくことがあります。
(TBR)

=begin original

Returns -1 on failure to get the file pointer.

=end original

ファイルポインタヲ得るのに失敗した場合は -1 を返します。

=item Close

	IV	(*Close)(pTHX_ PerlIO *f);

=begin original

Close the stream. Should normally call C<PerlIOBase_close()> to flush
itself and close layers below, and then deallocate any data structures
(buffers, translation tables, ...) not  held directly in the data
structure.

=end original

ストリームを閉じます。
通常はC<PerlIOBase_close()>を呼び出して自身をフラッシュし、下位の層を閉じます。
次に、データ構造に直接保持されていないデータ構造(バッファ、変換テーブルなど)の割り当てを解除します。
(TBR)

=begin original

Returns 0 on success, -1 on failure.

=end original

成功時には 0 を、失敗時には -1 を返します。

=item Flush

	IV	(*Flush)(pTHX_ PerlIO *f);

=begin original

Should make stream's state consistent with layers below. That is, any
buffered write data should be written, and file position of lower layers
adjusted for data read from below but not actually consumed.
(Should perhaps C<Unread()> such data to the lower layer.)

=end original

ストリームの状態を下位層と一致させる必要があります。
つまり、バッファされた書き込みデータが書き込まれ、下位層のファイル位置は下位層から読み込まれたが実際には消費されないデータに合わせて調整される必要があります(おそらくそのようなデータを下位層にC<Unread()>すべきです)。
(TBR)

=begin original

Returns 0 on success, -1 on failure.

=end original

成功時には 0 を、失敗時には -1 を返します。

=item Fill

	IV	(*Fill)(pTHX_ PerlIO *f);

=begin original

The buffer for this layer should be filled (for read) from layer
below.  When you "subclass" PerlIOBuf layer, you want to use its
I<_read> method and to supply your own fill method, which fills the
PerlIOBuf's buffer.

=end original

この画層のバッファは、下の画層から読み込むために塗りつぶす必要があります。
PerlIOBuf画層を"サブクラス"する場合、I<_read>メソッドを使用し、PerlIOBufのバッファを埋める独自の塗りつぶしメソッドを指定します。
(TBR)

=begin original

Returns 0 on success, -1 on failure.

=end original

成功時には 0 を、失敗時には -1 を返します。

=item Eof

	IV	(*Eof)(pTHX_ PerlIO *f);

=begin original

Return end-of-file indicator. C<PerlIOBase_eof()> is normally sufficient.

=end original

ファイル終端指示子を返します。
普通は C<PerlIOBase_eof()> で十分です。

=begin original

Returns 0 on end-of-file, 1 if not end-of-file, -1 on error.

=end original

ファイル末尾では 0 を、ファイル末尾でなければ 1 を、エラー時には -1 を
返します。

=item Error

	IV	(*Error)(pTHX_ PerlIO *f);

=begin original

Return error indicator. C<PerlIOBase_error()> is normally sufficient.

=end original

エラー指示子を返します。
普通は C<PerlIOBase_error()> で十分です。

=begin original

Returns 1 if there is an error (usually when C<PERLIO_F_ERROR> is set,
0 otherwise.

=end original

エラー (普通は C<PERLIO_F_ERROR> がセットされている) の場合は 1、
さもなければ 0 を返します。

=item  Clearerr

	void	(*Clearerr)(pTHX_ PerlIO *f);

=begin original

Clear end-of-file and error indicators. Should call C<PerlIOBase_clearerr()>
to set the C<PERLIO_F_XXXXX> flags, which may suffice.

=end original

ファイル終了インジケータとエラーインジケータをクリアします。
C<PerlIOBase_clearerr()>を呼び出してC<PERLIO_F_XXXXX>フラグを設定する必要があります。
これで十分です。
(TBR)

=item Setlinebuf

	void	(*Setlinebuf)(pTHX_ PerlIO *f);

=begin original

Mark the stream as line buffered. C<PerlIOBase_setlinebuf()> sets the
PERLIO_F_LINEBUF flag and is normally sufficient.

=end original

C<PerlIOBase_setlinebuf()>はPERLIO_F_LINEBUFフラグをは_F_フラグを設定し、通常はこれで十分です。
(TBR)

=item Get_base

	STDCHAR *	(*Get_base)(pTHX_ PerlIO *f);

=begin original

Allocate (if not already done so) the read buffer for this layer and
return pointer to it. Return NULL on failure.

=end original

この層の読み込みバッファを割り当て(まだ割り当てていない場合)、この層へのポインタを返します。
失敗した場合はNULLを返します。
(TBR)

=item Get_bufsiz

	Size_t	(*Get_bufsiz)(pTHX_ PerlIO *f);

=begin original

Return the number of bytes that last C<Fill()> put in the buffer.

=end original

直前の C<Fill()> がバッファに設定したバイト数を返します。

=item Get_ptr

	STDCHAR *	(*Get_ptr)(pTHX_ PerlIO *f);

=begin original

Return the current read pointer relative to this layer's buffer.

=end original

現在の層のバッファに関連する現在の読み込みポインタを返します。

=item Get_cnt

	SSize_t	(*Get_cnt)(pTHX_ PerlIO *f);

=begin original

Return the number of bytes left to be read in the current buffer.

=end original

現在のバッファで読み込まれるために残っているバイト数を返します。

=item Set_ptrcnt

	void	(*Set_ptrcnt)(pTHX_ PerlIO *f,
			      STDCHAR *ptr, SSize_t cnt);

=begin original

Adjust the read pointer and count of bytes to match C<ptr> and/or C<cnt>.
The application (or layer above) must ensure they are consistent.
(Checking is allowed by the paranoid.)

=end original

C<ptr>および/またはC<cnt>に一致するように、読み出しポインタおよびバイト数を調整する。
アプリケーション(またはその上の層)は、それらが一貫していることを確認する必要があります。
(チェックは被害妄想者によって許可されています)
(TBR)

=back

=head2 Utilities

(ユーティリティ)

=begin original

To ask for the next layer down use PerlIONext(PerlIO *f).

=end original

次の層を調べるには PerlIONext(PerlIO *f) を使います。

=begin original

To check that a PerlIO* is valid use PerlIOValid(PerlIO *f).  (All
this does is really just to check that the pointer is non-NULL and
that the pointer behind that is non-NULL.)

=end original

PerlIO*が有効であることをチェックするには、PerlIOValid(PerlIO*f)を使用します。
(これは単に、ポインタが非NULLであり、その背後にあるポインタが非NULLであることをチェックするだけです)。
(TBR)

=begin original

PerlIOBase(PerlIO *f) returns the "Base" pointer, or in other words,
the C<PerlIOl*> pointer.

=end original

PerlIOBase(PerlIO*f)は"Base"ポインタ、つまりC<PerlIOl*>ポインタを返します。
(TBR)

=begin original

PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a type.

=end original

PerlIOSelf(PerlIO*f,type)PerlIOBaseキャストを型に戻します。
(TBR)

=begin original

Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either
calls the I<callback> from the functions of the layer I<f> (just by
the name of the IO function, like "Read") with the I<args>, or if
there is no such callback, calls the I<base> version of the callback
with the same args, or if the f is invalid, set errno to EBADF and
return I<failure>.

=end original

Perl_PerlIO_or_Base(PerlIO*f,callback,base,failure,args)は、層I<f>の関数から("Read"のようにIO関数の名前だけで)I<args>を使ってI<callback>を呼び出すか、そのようなコールバックがない場合は、同じargsを使ってI<base>バージョンのコールバックを呼び出すか、fが無効な場合はerrnoにEBADFを設定してI<failure>を返します。
(TBR)

=begin original

Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls
the I<callback> of the functions of the layer I<f> with the I<args>,
or if there is no such callback, set errno to EINVAL.  Or if the f is
invalid, set errno to EBADF and return I<failure>.

=end original

Perl_PerlIO_or_fail(PerlIO*f,callback,failure,args)は、I<args>を指定して層I<f>の関数のI<callback>を呼び出すか、そのようなコールバックがない場合はerrnoにEINVALを設定します。
fが無効な場合はerrnoにEBADFを設定してI<failure>を返します。
(TBR)

=begin original

Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls
the I<callback> of the functions of the layer I<f> with the I<args>,
or if there is no such callback, calls the I<base> version of the
callback with the same args, or if the f is invalid, set errno to
EBADF.

=end original

Perl_PerlIO_or_Base_void(PerlIO*f,callback,base,args)は、I<args>を使って層I<f>の関数のI<callback>を呼び出すか、そのようなコールバックがない場合は同じargsを使ってI<base>バージョンのコールバックを呼び出すか、fが無効な場合はerrnoにEBADFを設定します。
(TBR)

=begin original

Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the
I<callback> of the functions of the layer I<f> with the I<args>, or if
there is no such callback, set errno to EINVAL.  Or if the f is
invalid, set errno to EBADF.

=end original

Perl_PerlIO_or_fail_void(PerlIO*f,callback,args)は、層I<f>の関数のI<callback>をI<args>で呼び出すか、そのようなコールバックがない場合はerrnoにEINVALを設定します。
fが無効な場合はerrnoにEBADFを設定します。
(TBR)

=head2 Implementing PerlIO Layers

(PerlIO 層の実装)

=begin original

If you find the implementation document unclear or not sufficient,
look at the existing PerlIO layer implementations, which include:

=end original

実装文書が不明確または十分でない場合は、次のような既存のPerlIO層実装を確認してください。
(TBR)

=over

=item * C implementations

=begin original

The F<perlio.c> and F<perliol.h> in the Perl core implement the
"unix", "perlio", "stdio", "crlf", "utf8", "byte", "raw", "pending"
layers, and also the "mmap" and "win32" layers if applicable.
(The "win32" is currently unfinished and unused, to see what is used
instead in Win32, see L<PerlIO/"Querying the layers of filehandles"> .)

=end original

PerlコアのF<perlio.c>とF<perliol.h>は、"unix","perlio","stdio","crlf","utf8","byte","raw","pending"層と、"mmap"と"Win32"層を実装しています("Win32"は現在未完成で未使用です。
Win32で何が使われているかはL<PerlIO/"Querying the layers of filehandles">を参照してください)。
(TBR)

=begin original

PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl core.

=end original

Perl コアの PerlIO::encoding, PerlIO::scalar, PerlIO::via。

=begin original

PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on CPAN.

=end original

CPAN の PerlIO::gzip と APR::PerlIO (mod_perl 2.0)。

=item * Perl implementations

=begin original

PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::* on CPAN.

=end original

Perl コアの PerlIO::via::QuotedPrint と CPAN の PerlIO::via::*。

=back

=begin original

If you are creating a PerlIO layer, you may want to be lazy, in other
words, implement only the methods that interest you.  The other methods
you can either replace with the "blank" methods

=end original

PerlIO層を作成する場合は、怠惰にする、つまり、目的のメソッドのみを実装する必要があります。
他のメソッドは、「ブランク」メソッドに置き換えることができます。
(TBR)

    PerlIOBase_noop_ok
    PerlIOBase_noop_fail

=begin original

(which do nothing, and return zero and -1, respectively) or for
certain methods you may assume a default behaviour by using a NULL
method.  The Open method looks for help in the 'parent' layer.
The following table summarizes the behaviour:

=end original

(何も実行せず、それぞれ0と-1を返します)、または特定のメソッドでは、NULLメソッドを使用してデフォルトの動作を想定することができます。
Openメソッドは親層でヘルプを検索します。
次の表に動作を要約します:
(TBR)

    method      behaviour with NULL

    Clearerr    PerlIOBase_clearerr
    Close       PerlIOBase_close
    Dup         PerlIOBase_dup
    Eof         PerlIOBase_eof
    Error       PerlIOBase_error
    Fileno      PerlIOBase_fileno
    Fill        FAILURE
    Flush       SUCCESS
    Getarg      SUCCESS
    Get_base    FAILURE
    Get_bufsiz  FAILURE
    Get_cnt     FAILURE
    Get_ptr     FAILURE
    Open        INHERITED
    Popped      SUCCESS
    Pushed      SUCCESS
    Read        PerlIOBase_read
    Seek        FAILURE
    Set_cnt     FAILURE
    Set_ptrcnt  FAILURE
    Setlinebuf  PerlIOBase_setlinebuf
    Tell        FAILURE
    Unread      PerlIOBase_unread
    Write       FAILURE

 FAILURE        Set errno (to EINVAL in UNIXish, to LIB$_INVARG in VMS) and
                return -1 (for numeric return values) or NULL (for pointers)
 INHERITED      Inherited from the layer below
 SUCCESS        Return 0 (for numeric return values) or a pointer 

=head2 Core Layers

(コア層)

=begin original

The file C<perlio.c> provides the following layers:

=end original

ファイル C<perlio.c> は以下の層を提供します:

=over 4

=item "unix"

=begin original

A basic non-buffered layer which calls Unix/POSIX C<read()>, C<write()>,
C<lseek()>, C<close()>. No buffering. Even on platforms that distinguish
between O_TEXT and O_BINARY this layer is always O_BINARY.

=end original

Unix/POSIX C<read()>,C<write()>,C<lseek()>,C<close()>を呼び出す基本的な非バッファ層。
バッファリングなし。
O_TEXTとO_BINARYを区別するプラットフォームでも、この層は常にO_BINARYである。
(TBR)

=item "perlio"

=begin original

A very complete generic buffering layer which provides the whole of
PerlIO API. It is also intended to be used as a "base class" for other
layers. (For example its C<Read()> method is implemented in terms of
the C<Get_cnt()>/C<Get_ptr()>/C<Set_ptrcnt()> methods).

=end original

PerlIO API全体を提供する非常に完全な汎用バッファリング層です。
他の層の"ベースクラス"として使用することも意図されています(例えば、C<Read()>メソッドはC<Get_cnt()>/C<Get_ptr()>/C<Set_ptrcnt()>メソッドとして実装されています)。
(TBR)

=begin original

"perlio" over "unix" provides a complete replacement for stdio as seen
via PerlIO API. This is the default for USE_PERLIO when system's stdio
does not permit perl's "fast gets" access, and which do not
distinguish between C<O_TEXT> and C<O_BINARY>.

=end original

"unix"上の"perlio"は、PerlIOに見られるstdioの完全な置き換えを提供します。
これは、システムのstdioがperlの"fast gets"アクセスを許可せず、C<O_TEXT>とC<O_BINARY>を区別しない場合のUSE_PERLIOのデフォルトです。
(TBR)

=item "stdio"

=begin original

A layer which provides the PerlIO API via the layer scheme, but
implements it by calling system's stdio. This is (currently) the default
if system's stdio provides sufficient access to allow perl's "fast gets"
access and which do not distinguish between C<O_TEXT> and C<O_BINARY>.

=end original

PerlIO APIを層スキーム経由で提供するが、システムのstdioを呼び出すことによって実装する層。
システムのstdioがperlの"fast gets"アクセスを可能にするのに十分なアクセスを提供し、C<O_TEXT>とC<O_BINARY>を区別しない場合、これが(現在)デフォルトです。
(TBR)

=item "crlf"

=begin original

A layer derived using "perlio" as a base class. It provides Win32-like
"\n" to CR,LF translation. Can either be applied above "perlio" or serve
as the buffer layer itself. "crlf" over "unix" is the default if system
distinguishes between C<O_TEXT> and C<O_BINARY> opens. (At some point
"unix" will be replaced by a "native" Win32 IO layer on that platform,
as Win32's read/write layer has various drawbacks.) The "crlf" layer is
a reasonable model for a layer which transforms data in some way.

=end original

基本クラスとして"perlio"を使用して派生した画層。
CR、LF変換にWin32のような"\n"を提供します。
"perlio"の上に適用することも、バッファ層自体として使用することもできます。
"unix"上の"crlf"は、システムがC<O_TEXT>とC<O_BINARY>を区別して開く場合のデフォルトです。
(Win32の読み取り/書き込み層にはさまざまな欠点があるため、ある時点で"unix"はそのプラットフォーム上の"ネイティブ"Win32 IO層に置き換えられます。
"crlf"層は、何らかの方法でデータを変換する層の妥当なモデルです。
(TBR)

=item "mmap"

=begin original

If Configure detects C<mmap()> functions this layer is provided (with
"perlio" as a "base") which does "read" operations by mmap()ing the
file. Performance improvement is marginal on modern systems, so it is
mainly there as a proof of concept. It is likely to be unbundled from
the core at some point. The "mmap" layer is a reasonable model for a
minimalist "derived" layer.

=end original

ConfigureがC<mmap()>関数を検出した場合、この層は("base"として"perlio"とともに)提供されます。
この層はファイルをmmap()で"read"操作を行います。
現在のシステムではパフォーマンスの向上はわずかであるため、主に概念実証として存在します。
ある時点でコアから切り離される可能性があります。
"mmap"層は、ミニマリストの"derived"層の合理的なモデルです。
(TBR)

=item "pending"

=begin original

An "internal" derivative of "perlio" which can be used to provide
Unread() function for layers which have no buffer or cannot be
bothered.  (Basically this layer's C<Fill()> pops itself off the stack
and so resumes reading from layer below.)

=end original

"perlio"から"内部"派生したもので、バッファを持たない層や邪魔にならない層に対してUnread()関数を提供するために使用することができます(基本的にこの層のC<Fill()>はスタックから自身をポップし、下の層から読み取りを再開します)。
(TBR)

=item "raw"

=begin original

A dummy layer which never exists on the layer stack. Instead when
"pushed" it actually pops the stack removing itself, it then calls
Binmode function table entry on all the layers in the stack - normally
this (via PerlIOBase_binmode) removes any layers which do not have
C<PERLIO_K_RAW> bit set. Layers can modify that behaviour by defining
their own Binmode entry.

=end original

層スタック上に存在しないダミー層。
"push"された場合、実際に自身を削除してスタックをポップする代わりに、スタック内のすべての層上でBinmode関数テーブルエントリを呼び出します-通常は(PerlIOBase_binmode経由で)C<PERLIO_K_RAW>ビットが設定されていない層を削除します。
層は独自のBinmodeエントリを定義することで、その動作を変更できます。
(TBR)

=item "utf8"

=begin original

Another dummy layer. When pushed it pops itself and sets the
C<PERLIO_F_UTF8> flag on the layer which was (and now is once more)
the top of the stack.

=end original

別のダミー層。
プッシュされると、自身がポップし、スタックの一番上にあった(今はもう一度)層にC<PERLIO_F_UTF8>フラグをセットする。
(TBR)

=back

=begin original

In addition F<perlio.c> also provides a number of C<PerlIOBase_xxxx()>
functions which are intended to be used in the table slots of classes
which do not need to do anything special for a particular method.

=end original

さらに、F<perlio.c>は、クラスのテーブルスロットで使用することを目的としたC<PerlIOBase_xxxx()>関数を数多く提供しており、これらは特定のメソッドに対して特別なことを行う必要はありません。
(TBR)

=head2 Extension Layers

(エクステンション層)

=begin original

Layers can made available by extension modules. When an unknown layer
is encountered the PerlIO code will perform the equivalent of :

=end original

層は拡張モジュールによって利用可能にすることができる。
未知の層に遭遇した場合、PerlIOコードは以下と同等の処理を行う:
(TBR)

   use PerlIO 'layer';

=begin original

Where I<layer> is the unknown layer. F<PerlIO.pm> will then attempt to:

=end original

I<layer> が不明な層とします。
F<PerlIO.pm> は以下を試します:

   require PerlIO::layer;

=begin original

If after that process the layer is still not defined then the C<open>
will fail.

=end original

そのプロセスの後、層がまだ定義されていない場合、C<open>は失敗します。
(TBR)

=begin original

The following extension layers are bundled with perl:

=end original

以下のエクステンション層は perl に組み込まれています:

=over 4

=item ":encoding"

   use Encoding;

=begin original

makes this layer available, although F<PerlIO.pm> "knows" where to
find it.  It is an example of a layer which takes an argument as it is
called thus:

=end original

はこの層を利用可能にしますが、F<PerlIO.pm>はその場所を「知っている」のです。
これは、引数を取る層の例です。
(TBR)

   open( $fh, "<:encoding(iso-8859-7)", $pathname );

=item ":scalar"

=begin original

Provides support for reading data from and writing data to a scalar.

=end original

スカラに対するデータの読み書き対応を提供します。

   open( $fh, "+<:scalar", \$scalar );

=begin original

When a handle is so opened, then reads get bytes from the string value
of I<$scalar>, and writes change the value. In both cases the position
in I<$scalar> starts as zero but can be altered via C<seek>, and
determined via C<tell>.

=end original

ハンドルがこのようにオープンされると、I<$scalar>の文字列値からgetバイトを読み取り、値を変更する書き込みを行います。
どちらの場合も、I<$scalar>の位置は0から始まりますが、C<seek>で変更でき、C<tell>で決定できます。
(TBR)

=begin original

Please note that this layer is implied when calling open() thus:

=end original

open() を呼び出すときにこの層が暗示されていることにどうか注意してください;
従って:

   open( $fh, "+<", \$scalar );

=item ":via"

=begin original

Provided to allow layers to be implemented as Perl code.  For instance:

=end original

Perl コードとして実装された層を使えるようにします。
例えば:

   use PerlIO::via::StripHTML;
   open( my $fh, "<:via(StripHTML)", "index.html" );

=begin original

See L<PerlIO::via> for details.

=end original

詳しくは L<PerlIO::via> を参照してください。

=back

=head1 TODO

=begin original

Things that need to be done to improve this document.

=end original

この文書を改良するために行われる必要のあることです。

=over

=item *

=begin original

Explain how to make a valid fh without going through open()(i.e. apply
a layer). For example if the file is not opened through perl, but we
want to get back a fh, like it was opened by Perl.

=end original

open()を経由せずに有効なfhを作成する方法(層を適用する)を説明します。
例えば、ファイルがperlで開かれていない場合に、Perlで開かれたようにfhを取得したい場合などです。
(TBR)

=begin original

How PerlIO_apply_layera fits in, where its docs, was it made public?

=end original

PerlIO_apply_layeraは、そのドキュメントのどこにどのように適合し、公開されましたか?
(TBR)

=begin original

Currently the example could be something like this:

=end original

現在の例は、次のようになります。
(TBR)

  PerlIO *foo_to_PerlIO(pTHX_ char *mode, ...)
  {
      char *mode; /* "w", "r", etc */
      const char *layers = ":APR"; /* the layer name */
      PerlIO *f = PerlIO_allocate(aTHX);
      if (!f) {
          return NULL;
      }

      PerlIO_apply_layers(aTHX_ f, mode, layers);

      if (f) {
          PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
          /* fill in the st struct, as in _open() */
          st->file = file;
          PerlIOBase(f)->flags |= PERLIO_F_OPEN;

          return f;
      }
      return NULL;
  }

=item *

=begin original

fix/add the documentation in places marked as XXX.

=end original

XXXとマークされた場所にドキュメントを修正/追加します。
(TBR)

=item *

=begin original

The handling of errors by the layer is not specified. e.g. when $!
should be set explicitly, when the error handling should be just
delegated to the top layer.

=end original

層によるエラー処理は指定されていません。
例えば$!が明示的に設定されている場合や、エラー処理がトップ層に委任されている場合などです。
(TBR)

=begin original

Probably give some hints on using SETERRNO() or pointers to where they
can be found.

=end original

SETERRNO()を使うためのヒントや、それらがどこにあるかを示すポインタを提供するとよいでしょう。
(TBR)

=item *

=begin original

I think it would help to give some concrete examples to make it easier
to understand the API. Of course I agree that the API has to be
concise, but since there is no second document that is more of a
guide, I think that it'd make it easier to start with the doc which is
an API, but has examples in it in places where things are unclear, to
a person who is not a PerlIO guru (yet).

=end original

APIを理解しやすくするために、いくつかの具体的な例を示すことが役立つと思います。
もちろん、APIが簡潔である必要があることには同意しますが、ガイドに近い2番目のドキュメントはないので、PerlIOの第一人者ではない人に対して、APIであるが、物事が明確でない場所での例があるドキュメントから始める方が簡単だと思います。
(TBR)

=back

=cut

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org>
Status: in progress

=end meta

