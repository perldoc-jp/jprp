
=encoding euc-jp

=head1 NAME

=begin original

perldebguts - Guts of Perl debugging 

=end original

perldebguts - Perl デバッグの内部

(訳注: (TBR)がついている段落は「みんなの自動翻訳＠TexTra」による
機械翻訳です。)

=head1 DESCRIPTION

=begin original

This is not the perldebug(1) manpage, which tells you how to use
the debugger.  This manpage describes low-level details concerning
the debugger's internals, which range from difficult to impossible
to understand for anyone who isn't incredibly intimate with Perl's guts.
Caveat lector.

=end original

これは、デバッガの使い方を記した perldebug(1) man ページではありません。
この man ページは、難しいものから Perl の内部にものすごく詳しい人でなければ
理解することができないようなものまで、デバッガの内部に関する低レベルな詳細を
記述しています。
読者に対する注意です。

=head1 Debugger Internals

(デバッガの内部)

=begin original

Perl has special debugging hooks at compile-time and run-time used
to create debugging environments.  These hooks are not to be confused
with the I<perl -Dxxx> command described in L<perlrun>, which is
usable only if a special Perl is built per the instructions in the
F<INSTALL> podpage in the Perl source tree.

=end original

Perlには、デバッグ環境を作成するためにコンパイル時および実行時に使用される特別なデバッグフックがあります。
これらのフックは、L<perlrun>で説明されているI<perl -Dxxx>コマンドと混同しないでください。
I<perl -Dxxx>コマンドは、PerlソースツリーのF<INSTALL>podpageの指示に従って特別なPerlが構築されている場合にのみ使用できます。
(TBR)

=begin original

For example, whenever you call Perl's built-in C<caller> function
from the package C<DB>, the arguments that the corresponding stack
frame was called with are copied to the C<@DB::args> array.  These
mechanisms are enabled by calling Perl with the B<-d> switch.
Specifically, the following additional features are enabled
(cf. L<perlvar/$^P>):

=end original

たとえば、パッケージC<DB>からPerlの組み込みC<caller>関数を呼び出すと、対応するスタックフレームが呼び出された引数がC<@DB::args>配列にコピーされます。
これらのメカニズムは、B<-d>スイッチを使用してPerlを呼び出すことによって有効になります。
特に、次の追加機能が有効になります(L<perlvar/$^P>を参照)。
(TBR)

=over 4

=item *

=begin original

Perl inserts the contents of C<$ENV{PERL5DB}> (or C<BEGIN {require
'perl5db.pl'}> if not present) before the first line of your program.

=end original

Perlは、プログラムの最初の行の前にC<$ENV{PERL5DB}>(存在しない場合はC<BEGIN{require'PERL5DB.pl'}>)の内容を挿入します。
(TBR)

=item *

=begin original

Each array C<@{"_<$filename"}> holds the lines of $filename for a
file compiled by Perl.  The same is also true for C<eval>ed strings
that contain subroutines, or which are currently being executed.
The $filename for C<eval>ed strings looks like C<(eval 34)>.
Code assertions in regexes look like C<(re_eval 19)>.

=end original

各配列C<@{"_<$filename"}>には、Perlでコンパイルされたファイルの$filenameの行が含まれています。
サブルーチンを含むC<eval>で作成された文字列、または現在実行中の文字列についても同様です。
C<eval>で作成された文字列の$filenameはC<(eval 34)>のようになります。
正規表現のコードアサーションはC<(re_eval 19)>のようになります。
(TBR)

=begin original

Values in this array are magical in numeric context: they compare
equal to zero only if the line is not breakable.

=end original

この配列の値は、数値コンテキストでは魔法のようなものです。
行が壊れない場合にのみ0と比較されます。
(TBR)

=item *

=begin original

Each hash C<%{"_<$filename"}> contains breakpoints and actions keyed
by line number.  Individual entries (as opposed to the whole hash)
are settable.  Perl only cares about Boolean true here, although
the values used by F<perl5db.pl> have the form
C<"$break_condition\0$action">.  

=end original

各ハッシュC<%{"_<$filename"}>には、行番号でキー設定されたブレークポイントとアクションが含まれています。
個々のエントリ(ハッシュ全体ではなく)は設定可能です。
F<perl5db.pl>で使用される値はC<"$break_condition\0$action">の形式ですが、PerlではBoolean trueしか考慮されません。
(TBR)

=begin original

The same holds for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for C<eval>ed strings
looks like C<(eval 34)> or  C<(re_eval 19)>.

=end original

サブルーチンを含む評価済み文字列、または現在実行中の文字列についても同様です。
C<eval>で作成された文字列の$filenameは、C<(eval 34)>またはC<(re_eval 19)>のようになります。
(TBR)

=item *

=begin original

Each scalar C<${"_<$filename"}> contains C<"_<$filename">.  This is
also the case for evaluated strings that contain subroutines, or
which are currently being executed.  The $filename for C<eval>ed
strings looks like C<(eval 34)> or C<(re_eval 19)>.

=end original

各スカラーC<${"_<$filename"}>には、C<"_<$filename">が含まれます。
これは、サブルーチンを含む評価済み文字列、または現在実行中の文字列にも当てはまります。
C<eval>で作成された文字列の$filenameは、C<(eval 34)>またはC<(re_eval 19)>のようになります。
(TBR)

=item *

=begin original

After each C<require>d file is compiled, but before it is executed,
C<DB::postponed(*{"_<$filename"})> is called if the subroutine
C<DB::postponed> exists.  Here, the $filename is the expanded name of
the C<require>d file, as found in the values of %INC.

=end original

各C<require>dファイルがコンパイルされた後、実行される前に、サブルーチンC<DB::delayed>が存在する場合は、C<DB::delayed(*{"_<$filename"})>が呼び出されます。
ここで、$filenameは%INCの値にあるC<require>dファイルの拡張名です。
(TBR)

=item *

=begin original

After each subroutine C<subname> is compiled, the existence of
C<$DB::postponed{subname}> is checked.  If this key exists,
C<DB::postponed(subname)> is called if the C<DB::postponed> subroutine
also exists.

=end original

各サブルーチンC<subname>がコンパイルされた後、C<$DB::delayed{subname}>の存在がチェックされます。
このキーが存在する場合、C<DB::delayed>サブルーチンも存在すれば、C<DB::delayed(subname)>が呼び出されます。
(TBR)

=item *

=begin original

A hash C<%DB::sub> is maintained, whose keys are subroutine names
and whose values have the form C<filename:startline-endline>.
C<filename> has the form C<(eval 34)> for subroutines defined inside
C<eval>s, or C<(re_eval 19)> for those within regex code assertions.

=end original

ハッシュC<%DB::sub>が維持されます。
このハッシュのキーはサブルーチン名で、値の形式はC<filename:startline-endline>です。
C<filename>は、C<eval>s内で定義されたサブルーチンの場合はC<(eval 34)>、regexコードアサーション内で定義されたサブルーチンの場合はC<(re_eval 19)>です。
(TBR)

=item *

=begin original

When the execution of your program reaches a point that can hold a
breakpoint, the C<DB::DB()> subroutine is called if any of the variables
C<$DB::trace>, C<$DB::single>, or C<$DB::signal> is true.  These variables
are not C<local>izable.  This feature is disabled when executing
inside C<DB::DB()>, including functions called from it 
unless C<< $^D & (1<<30) >> is true.

=end original

プログラムの実行がブレークポイントを保持できるポイントに達すると、変数C<$DB::trace>、C<$DB::single>、またはC<$DB::signal>のいずれかがtrueの場合にC<DB::DB()>サブルーチンが呼び出されます。
これらの変数はC<local>に対応していません。
この機能は、C<$^D&(1<<30) >>がtrueでない限り、C<DB::DB()>から呼び出された関数も含めて、C<DB::DB()>内部で実行されている場合は無効です。
(TBR)

=item *

=begin original

When execution of the program reaches a subroutine call, a call to
C<&DB::sub>(I<args>) is made instead, with C<$DB::sub> holding the
name of the called subroutine. (This doesn't happen if the subroutine
was compiled in the C<DB> package.)

=end original

プログラムの実行がサブルーチンコールに到達すると、代わりにC<&DB::sub>(I<args>)が呼び出されます。
C<$DB::sub>は呼び出されたサブルーチンの名前を保持します(これは、サブルーチンがC<DB>パッケージでコンパイルされている場合には発生しません)。
(TBR)

=back

=begin original

Note that if C<&DB::sub> needs external data for it to work, no
subroutine call is possible without it. As an example, the standard
debugger's C<&DB::sub> depends on the C<$DB::deep> variable
(it defines how many levels of recursion deep into the debugger you can go
before a mandatory break).  If C<$DB::deep> is not defined, subroutine
calls are not possible, even though C<&DB::sub> exists.

=end original

C<&DB::sub>が動作するために外部データを必要とする場合、C<&DB::sub>がないとサブルーチンコールができないことに注意してください。
例として、標準デバッガのC<&DB::sub>はC<$DB::deep>変数に依存しています(この変数は、デバッガに対して、強制ブレークの前に実行できる再帰レベルを定義します)。
C<$DB::deep>が定義されていない場合、C<&DB::sub>が存在していてもサブルーチンコールはできません。
(TBR)

=head2 Writing Your Own Debugger

(独自のデバッガを書く)

=head3 Environment Variables

(環境変数)

=begin original

The C<PERL5DB> environment variable can be used to define a debugger.
For example, the minimal "working" debugger (it actually doesn't do anything)
consists of one line:

=end original

C<PERL5DB>環境変数を使用して、デバッガを定義することができます。
例えば、最小の「動作」デバッガ(実際には何も実行しません)は、以下の1行で構成されます。
(TBR)

  sub DB::DB {}

=begin original

It can easily be defined like this:

=end original

次のように簡単に定義できます。
(TBR)

  $ PERL5DB="sub DB::DB {}" perl -d your-script

=begin original

Another brief debugger, slightly more useful, can be created
with only the line:

=end original

もう1つの簡単なデバッガは、少し便利ですが、次の行だけで作成できます。
(TBR)

  sub DB::DB {print ++$i; scalar <STDIN>}

=begin original

This debugger prints a number which increments for each statement
encountered and waits for you to hit a newline before continuing
to the next statement.

=end original

このデバッガは、文が検出されるたびに増分する番号を出力し、改行が入力されるのを待ってから次の文に進みます。
(TBR)

=begin original

The following debugger is actually useful:

=end original

次のデバッガが実際に役立ちます。
(TBR)

  {
    package DB;
    sub DB  {}
    sub sub {print ++$i, " $sub\n"; &$sub}
  }

=begin original

It prints the sequence number of each subroutine call and the name of the
called subroutine.  Note that C<&DB::sub> is being compiled into the
package C<DB> through the use of the C<package> directive.

=end original

各サブルーチンコールのシーケンス番号と呼び出されたサブルーチンの名前を出力します。
C<&DB::sub>は、C<package>ディレクティブを使用してパッケージC<DB>にコンパイルされていることに注意してください。
(TBR)

=begin original

When it starts, the debugger reads your rc file (F<./.perldb> or
F<~/.perldb> under Unix), which can set important options.
(A subroutine (C<&afterinit>) can be defined here as well; it is executed
after the debugger completes its own initialization.)

=end original

デバッガが起動すると、rcファイル(UnixではF<./.perldb>またはF<~/.perldb>)が読み取られ、重要なオプションが設定されます(サブルーチン(C<&afterinit>)もここで定義できます。
デバッガが初期化を完了した後に実行されます)。
(TBR)

=begin original

After the rc file is read, the debugger reads the PERLDB_OPTS
environment variable and uses it to set debugger options. The
contents of this variable are treated as if they were the argument
of an C<o ...> debugger command (q.v. in L<perldebug/Options>).

=end original

rcファイルが読み込まれた後、デバッガはPERLDB_OPTS環境変数を読み込み、これを使用してデバッガオプションを設定します。
この変数の内容は、C<o.>デバッガコマンド(L<perldebug/Options>の場合)の引数として処理されます。
(TBR)

=head3 Debugger internal variables

(デバッガの内部変数)

=begin original

In addition to the file and subroutine-related variables mentioned above,
the debugger also maintains various magical internal variables.

=end original

上記のファイルおよびサブルーチン関連の変数に加えて、デバッガはさまざまな魔法の内部変数も保持しています。
(TBR)

=over 4

=item *

=begin original

C<@DB::dbline> is an alias for C<@{"::_<current_file"}>, which
holds the lines of the currently-selected file (compiled by Perl), either
explicitly chosen with the debugger's C<f> command, or implicitly by flow
of execution.

=end original

C<@DB::dbline>はC<@{"::_<current_file"}>の別名であり、現在選択されている(Perlでコンパイルされた)ファイルの行を保持します。
このファイルは、デバッガのC<f>コマンドで明示的に選択された場合も、実行フローによって暗黙的に選択された場合もあります。
(TBR)

=begin original

Values in this array are magical in numeric context: they compare
equal to zero only if the line is not breakable.

=end original

この配列の値は、数値コンテキストでは魔法のようなものです。
行が壊れない場合にのみ0と比較されます。
(TBR)

=item *

=begin original

C<%DB::dbline>, is an alias for C<%{"::_<current_file"}>, which
contains breakpoints and actions keyed by line number in
the currently-selected file, either explicitly chosen with the
debugger's C<f> command, or implicitly by flow of execution.

=end original

C<%DB::dbline>は、C<%{"::_<current_file"}>のエイリアスです。
ブレークポイントとアクションは、現在選択されているファイルの行番号によってキー設定されます。
ブレークポイントとアクションは、デバッガのC<f>コマンドで明示的に選択されるか、実行フローによって暗黙的に選択されます。
(TBR)

=begin original

As previously noted, individual entries (as opposed to the whole hash)
are settable.  Perl only cares about Boolean true here, although
the values used by F<perl5db.pl> have the form
C<"$break_condition\0$action">.

=end original

前述のように、個々のエントリ(ハッシュ全体ではなく)は設定可能です。
F<perl5db.pl>で使用される値はC<"$break_condition\0$action">の形式ですが、ここではPerlはBoolean trueだけを扱います。
(TBR)

=back

=head3 Debugger customization functions

(デバッガカスタマイズ関数)

=begin original

Some functions are provided to simplify customization.

=end original

カスタマイズを簡単にするために、いくつかの機能が用意されています。
(TBR)

=over 4

=item *

=begin original

See L<perldebug/"Configurable Options"> for a description of options parsed by
C<DB::parse_options(string)>.

=end original

C<DB::parse_options(string)>で解析されるオプションについては、L<perldebug/"Configurable Options">を参照してください。
(TBR)

=item *

=begin original

C<DB::dump_trace(skip[,count])> skips the specified number of frames
and returns a list containing information about the calling frames (all
of them, if C<count> is missing).  Each entry is reference to a hash
with keys C<context> (either C<.>, C<$>, or C<@>), C<sub> (subroutine
name, or info about C<eval>), C<args> (C<undef> or a reference to
an array), C<file>, and C<line>.

=end original

C<DB::dump_trace(skip[,count])>は、指定された数のフレームをスキップし、呼び出しフレーム(C<count>がない場合はすべてのフレーム)に関する情報を含むリストを返します。
各エントリは、C<context>(C<.>、C<$>、またはC<@>のいずれか)、C<sub>(サブルーチン名、またはC<eval>に関する情報)、C<args>(C<undef>または配列への参照)、C<file>、およびC<line>というキーを持つハッシュへの参照です。
(TBR)

=item *

=begin original

C<DB::print_trace(FH, skip[, count[, short]])> prints
formatted info about caller frames.  The last two functions may be
convenient as arguments to C<< < >>, C<< << >> commands.

=end original

C<DB::print_trace(FH, skip[, count[, short]])>は、発信者フレームについてフォーマットされた情報を出力します。
最後の2つの関数は、C<<<>>、C<<<<>>コマンドの引数として便利です。
(TBR)

=back

=begin original

Note that any variables and functions that are not documented in
this manpages (or in L<perldebug>) are considered for internal   
use only, and as such are subject to change without notice.

=end original

このマンページ(またはL<perldebug>)に記載されていない変数および関数は、内部使用のみを考慮したものであり、予告なしに変更されることがあります。
(TBR)

=head1 Frame Listing Output Examples

(フレームリスト出力の例)

=begin original

The C<frame> option can be used to control the output of frame 
information.  For example, contrast this expression trace:

=end original

C<frame>オプションを使用して、フレーム情報の出力を制御できます。
たとえば、次の式トレースを対比します。
(TBR)

 $ perl -de 42
 Stack dump during die enabled outside of evals.

 Loading DB routines from perl5db.pl patch level 0.94
 Emacs support available.

 Enter h or `h h' for help.

 main::(-e:1):   0
   DB<1> sub foo { 14 }

   DB<2> sub bar { 3 }

   DB<3> t print foo() * bar()
 main::((eval 172):3):   print foo() + bar();
 main::foo((eval 168):2):
 main::bar((eval 170):2):
 42

=begin original

with this one, once the C<o>ption C<frame=2> has been set:

=end original

C<o>オプションC<frame=2>が設定されると、次のようになります。
(TBR)

   DB<4> o f=2
                frame = '2'
   DB<5> t print foo() * bar()
 3:      foo() * bar()
 entering main::foo
  2:     sub foo { 14 };
 exited main::foo
 entering main::bar
  2:     sub bar { 3 };
 exited main::bar
 42

=begin original

By way of demonstration, we present below a laborious listing
resulting from setting your C<PERLDB_OPTS> environment variable to
the value C<f=n N>, and running I<perl -d -V> from the command line.
Examples use various values of C<n> are shown to give you a feel
for the difference between settings.  Long those it may be, this
is not a complete listing, but only excerpts.

=end original

ここでは、C<PERLDB_OPTS>環境変数をC<f=n N>の値に設定し、コマンドラインからI<perl -d -V>を実行した結果得られた骨の折れるリストについて説明します。
C<n>のさまざまな値を使用した例は、設定の違いを理解するために示されています。
長い間、これは完全なリストではなく、抜粋のみです。
(TBR)

=over 4

=item 1

  entering main::BEGIN
   entering Config::BEGIN
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   Package lib/Config.pm.
   entering Config::TIEHASH
   entering Exporter::import
    entering Exporter::export
  entering Config::myconfig
   entering Config::FETCH
   entering Config::FETCH
   entering Config::FETCH
   entering Config::FETCH

=item 2

  entering main::BEGIN
   entering Config::BEGIN
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   exited Config::BEGIN
   Package lib/Config.pm.
   entering Config::TIEHASH
   exited Config::TIEHASH
   entering Exporter::import
    entering Exporter::export
    exited Exporter::export
   exited Exporter::import
  exited main::BEGIN
  entering Config::myconfig
   entering Config::FETCH
   exited Config::FETCH
   entering Config::FETCH
   exited Config::FETCH
   entering Config::FETCH

=item 3

  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from li
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'osname') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'osvers') from lib/Config.pm:574

=item 4

  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   out $=Config::BEGIN() from lib/Config.pm:0
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   out $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
  out $=main::BEGIN() from /dev/null:0
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   out $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
   in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574

=item 5

  in  $=main::BEGIN() from /dev/null:0
   in  $=Config::BEGIN() from lib/Config.pm:2
    Package lib/Exporter.pm.
    Package lib/Carp.pm.
   out $=Config::BEGIN() from lib/Config.pm:0
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:644
   out $=Config::TIEHASH('Config') from lib/Config.pm:644
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
  out $=main::BEGIN() from /dev/null:0
  in  @=Config::myconfig() from /dev/null:0
   in  $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
   out $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
   in  $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574
   out $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574

=item 6

  in  $=CODE(0x15eca4)() from /dev/null:0
   in  $=CODE(0x182528)() from lib/Config.pm:2
    Package lib/Exporter.pm.
   out $=CODE(0x182528)() from lib/Config.pm:0
   scalar context return from CODE(0x182528): undef
   Package lib/Config.pm.
   in  $=Config::TIEHASH('Config') from lib/Config.pm:628
   out $=Config::TIEHASH('Config') from lib/Config.pm:628
   scalar context return from Config::TIEHASH:   empty hash
   in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
    in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
    out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
    scalar context return from Exporter::export: ''
   out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
   scalar context return from Exporter::import: ''

=back

=begin original

In all cases shown above, the line indentation shows the call tree.
If bit 2 of C<frame> is set, a line is printed on exit from a
subroutine as well.  If bit 4 is set, the arguments are printed
along with the caller info.  If bit 8 is set, the arguments are
printed even if they are tied or references.  If bit 16 is set, the
return value is printed, too.

=end original

上記のすべての場合で、行インデントには呼び出しツリーが表示されます。
C<frame>のビット2が設定されている場合は、サブルーチンの終了時にも行が出力されます。
ビット4が設定されている場合は、引数が呼び出し元の情報とともに出力されます。
ビット8が設定されている場合は、関連付けられていたり参照されている場合でも、引数が出力されます。
ビット16が設定されている場合は、戻り値も出力されます。
(TBR)

=begin original

When a package is compiled, a line like this

=end original

パッケージがコンパイルされると、以下のような行が生成されます。
(TBR)

    Package lib/Carp.pm.

=begin original

is printed with proper indentation.

=end original

は適切なインデントで印刷されます。
(TBR)

=head1 Debugging regular expressions

(正規表現のデバッグ)

=begin original

There are two ways to enable debugging output for regular expressions.

=end original

正規表現のデバッグ出力を有効にするには2つの方法があります。
(TBR)

=begin original

If your perl is compiled with C<-DDEBUGGING>, you may use the
B<-Dr> flag on the command line.

=end original

perlがC<-DDEBUGGING>でコンパイルされている場合は、コマンドラインでB<-Dr>フラグを使用できます。
(TBR)

=begin original

Otherwise, one can C<use re 'debug'>, which has effects at
compile time and run time.  It is not lexically scoped.

=end original

そうでなければ、C<use re 'debug'>を使うことができます。
これはコンパイル時と実行時に効果があります。
これは辞書的にスコープされません。
(TBR)

=head2 Compile-time output

(コンパイル時出力)

=begin original

The debugging output at compile time looks like this:

=end original

コンパイル時のデバッグ出力は次のようになります。
(TBR)

  Compiling REx `[bc]d(ef*g)+h[ij]k$'
  size 45 Got 364 bytes for offset annotations.
  first at 1
  rarest char g at 0
  rarest char d at 0
     1: ANYOF[bc](12)
    12: EXACT <d>(14)
    14: CURLYX[0] {1,32767}(28)
    16:   OPEN1(18)
    18:     EXACT <e>(20)
    20:     STAR(23)
    21:       EXACT <f>(0)
    23:     EXACT <g>(25)
    25:   CLOSE1(27)
    27:   WHILEM[1/1](0)
    28: NOTHING(29)
    29: EXACT <h>(31)
    31: ANYOF[ij](42)
    42: EXACT <k>(44)
    44: EOL(45)
    45: END(0)
  anchored `de' at 1 floating `gh' at 3..2147483647 (checking floating) 
        stclass `ANYOF[bc]' minlen 7 
  Offsets: [45]
  	1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
  	0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
  	11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
  	0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  
  Omitting $` $& $' support.

=begin original

The first line shows the pre-compiled form of the regex.  The second
shows the size of the compiled form (in arbitrary units, usually
4-byte words) and the total number of bytes allocated for the
offset/length table, usually 4+C<size>*8.  The next line shows the
label I<id> of the first node that does a match.

=end original

最初の行は、事前にコンパイルされたregexの形式を示します。
2番目の行は、コンパイルされた形式のサイズ(任意の単位、通常は4バイトワード)と、オフセット/長さテーブルに割り当てられた合計バイト数(通常は4+C<size>*8)を示します。
次の行は、一致した最初のノードのラベルI<id>を示します。
(TBR)

=begin original

The 

=end original

の
(TBR)

  anchored `de' at 1 floating `gh' at 3..2147483647 (checking floating) 
        stclass `ANYOF[bc]' minlen 7 

=begin original

line (split into two lines above) contains optimizer
information.  In the example shown, the optimizer found that the match 
should contain a substring C<de> at offset 1, plus substring C<gh>
at some offset between 3 and infinity.  Moreover, when checking for
these substrings (to abandon impossible matches quickly), Perl will check
for the substring C<gh> before checking for the substring C<de>.  The
optimizer may also use the knowledge that the match starts (at the
C<first> I<id>) with a character class, and no string 
shorter than 7 characters can possibly match.

=end original

line(上の2行に分割)には、オプティマイザ情報が含まれています。
表示された例では、オプティマイザは、一致にはオフセット1の部分文字列C<de>と、3から無限大までのオフセットの部分文字列C<gh>が含まれている必要があることを検出しました。
さらに、これらの部分文字列をチェックする際に(不可能な一致を迅速に破棄するために)、Perlは部分文字列C<de>をチェックする前に部分文字列C<gh>をチェックします。
オプティマイザは、文字クラスとの一致が(C<first>I<id>で)開始され、7文字より短い文字列は一致しない可能性があるという知識も使用できます。
(TBR)

=begin original

The fields of interest which may appear in this line are

=end original

この行に表示される関連フィールドは次のとおりです。
(TBR)

=over 4

=item C<anchored> I<STRING> C<at> I<POS>

=item C<floating> I<STRING> C<at> I<POS1..POS2>

=begin original

See above.

=end original

上記を参照してください。
(TBR)

=item C<matching floating/anchored>

=begin original

Which substring to check first.

=end original

最初にチェックする部分文字列。
(TBR)

=item C<minlen>

=begin original

The minimal length of the match.

=end original

一致の最小長。
(TBR)

=item C<stclass> I<TYPE>

=begin original

Type of first matching node.

=end original

最初に一致したノードのタイプ。
(TBR)

=item C<noscan>

=begin original

Don't scan for the found substrings.

=end original

見つかったサブストリングをスキャンしません。
(TBR)

=item C<isall>

=begin original

Means that the optimizer information is all that the regular
expression contains, and thus one does not need to enter the regex engine at
all.

=end original

オプティマイザ情報が正規表現に含まれるすべてであり、したがってregexエンジンに入る必要がないことを意味します。
(TBR)

=item C<GPOS>

=begin original

Set if the pattern contains C<\G>.

=end original

パターンにC<\G>が含まれている場合に設定します。
(TBR)

=item C<plus> 

=begin original

Set if the pattern starts with a repeated char (as in C<x+y>).

=end original

パターンが繰り返し文字(C<x+y>など)で始まる場合に設定されます。
(TBR)

=item C<implicit>

=begin original

Set if the pattern starts with C<.*>.

=end original

パターンがC<.*>で始まる場合に設定します。
(TBR)

=item C<with eval> 

=begin original

Set if the pattern contain eval-groups, such as C<(?{ code })> and
C<(??{ code })>.

=end original

パターンにC<(?{ code })>やC<(?{ code })>などの評価グループが含まれている場合に設定します。
(TBR)

=item C<anchored(TYPE)>

=begin original

If the pattern may match only at a handful of places, (with C<TYPE>
being C<BOL>, C<MBOL>, or C<GPOS>.  See the table below.

=end original

パターンが(C<TYPE>がC<BOL>、C<MBOL>、またはC<GPOS>である)一握りの場所でしか一致しない場合は、次の表を参照してください。
(TBR)

=back

=begin original

If a substring is known to match at end-of-line only, it may be
followed by C<$>, as in C<floating `k'$>.

=end original

部分文字列が行末でのみ一致することがわかっている場合は、C<floating `k'$>のように、その後にC<$>が続きます。
(TBR)

=begin original

The optimizer-specific information is used to avoid entering (a slow) regex
engine on strings that will not definitely match.  If the C<isall> flag
is set, a call to the regex engine may be avoided even when the optimizer
found an appropriate place for the match.

=end original

オプティマイザ固有の情報は、完全に一致しない文字列にregexエンジンが(遅い)入力されるのを回避するために使用されます。
C<isall>フラグが設定されている場合、オプティマイザが一致する適切な場所を検出した場合でも、regexエンジンの呼び出しを回避できます。
(TBR)

=begin original

Above the optimizer section is the list of I<nodes> of the compiled
form of the regex.  Each line has format 

=end original

オプティマイザセクションの上には、regexのコンパイル形式のI<nodes>のリストがあります。
各行の書式は以下のとおりです。
(TBR)

=begin original

C<   >I<id>: I<TYPE> I<OPTIONAL-INFO> (I<next-id>)

=end original

C<>I<id>:I<タイプ>I<オプション-情報>(I<next-id>)
(TBR)

=head2 Types of nodes

(ノードの型)

=begin original

Here are the possible types, with short descriptions:

=end original

次に、使用可能なタイプと簡単な説明を示します。
(TBR)

    # TYPE arg-description [num-args] [longjump-len] DESCRIPTION

    # Exit points
    END		no	End of program.
    SUCCEED	no	Return from a subroutine, basically.

    # Anchors:
    BOL		no	Match "" at beginning of line.
    MBOL	no	Same, assuming multiline.
    SBOL	no	Same, assuming singleline.
    EOS		no	Match "" at end of string.
    EOL		no	Match "" at end of line.
    MEOL	no	Same, assuming multiline.
    SEOL	no	Same, assuming singleline.
    BOUND	no	Match "" at any word boundary
    BOUNDL	no	Match "" at any word boundary
    NBOUND	no	Match "" at any word non-boundary
    NBOUNDL	no	Match "" at any word non-boundary
    GPOS	no	Matches where last m//g left off.

    # [Special] alternatives
    ANY		no	Match any one character (except newline).
    SANY	no	Match any one character.
    ANYOF	sv	Match character in (or not in) this class.
    ALNUM	no	Match any alphanumeric character
    ALNUML	no	Match any alphanumeric char in locale
    NALNUM	no	Match any non-alphanumeric character
    NALNUML	no	Match any non-alphanumeric char in locale
    SPACE	no	Match any whitespace character
    SPACEL	no	Match any whitespace char in locale
    NSPACE	no	Match any non-whitespace character
    NSPACEL	no	Match any non-whitespace char in locale
    DIGIT	no	Match any numeric character
    NDIGIT	no	Match any non-numeric character

    # BRANCH	The set of branches constituting a single choice are hooked
    #		together with their "next" pointers, since precedence prevents
    #		anything being concatenated to any individual branch.  The
    #		"next" pointer of the last BRANCH in a choice points to the
    #		thing following the whole choice.  This is also where the
    #		final "next" pointer of each individual branch points; each
    #		branch starts with the operand node of a BRANCH node.
    #
    BRANCH	node	Match this alternative, or the next...

    # BACK	Normal "next" pointers all implicitly point forward; BACK
    #		exists to make loop structures possible.
    # not used
    BACK	no	Match "", "next" ptr points backward.

    # Literals
    EXACT	sv	Match this string (preceded by length).
    EXACTF	sv	Match this string, folded (prec. by length).
    EXACTFL	sv	Match this string, folded in locale (w/len).

    # Do nothing
    NOTHING	no	Match empty string.
    # A variant of above which delimits a group, thus stops optimizations
    TAIL	no	Match empty string. Can jump here from outside.

    # STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
    #		BRANCH structures using BACK.  Simple cases (one character
    #		per match) are implemented with STAR and PLUS for speed
    #		and to minimize recursive plunges.
    #
    STAR	node	Match this (simple) thing 0 or more times.
    PLUS	node	Match this (simple) thing 1 or more times.

    CURLY	sv 2	Match this simple thing {n,m} times.
    CURLYN	no 2	Match next-after-this simple thing 
    #			{n,m} times, set parens.
    CURLYM	no 2	Match this medium-complex thing {n,m} times.
    CURLYX	sv 2	Match this complex thing {n,m} times.

    # This terminator creates a loop structure for CURLYX
    WHILEM	no	Do curly processing and see if rest matches.

    # OPEN,CLOSE,GROUPP	...are numbered at compile time.
    OPEN	num 1	Mark this point in input as start of #n.
    CLOSE	num 1	Analogous to OPEN.

    REF		num 1	Match some already matched string
    REFF	num 1	Match already matched string, folded
    REFFL	num 1	Match already matched string, folded in loc.

    # grouping assertions
    IFMATCH	off 1 2	Succeeds if the following matches.
    UNLESSM	off 1 2	Fails if the following matches.
    SUSPEND	off 1 1	"Independent" sub-regex.
    IFTHEN	off 1 1	Switch, should be preceded by switcher .
    GROUPP	num 1	Whether the group matched.

    # Support for long regex
    LONGJMP	off 1 1	Jump far away.
    BRANCHJ	off 1 1	BRANCH with long offset.

    # The heavy worker
    EVAL	evl 1	Execute some Perl code.

    # Modifiers
    MINMOD	no	Next operator is not greedy.
    LOGICAL	no	Next opcode should set the flag only.

    # This is not used yet
    RENUM	off 1 1	Group with independently numbered parens.

    # This is not really a node, but an optimized away piece of a "long" node.
    # To simplify debugging output, we mark it as if it were a node
    OPTIMIZED	off	Placeholder for dump.

=for unprinted-credits
Next section M-J. Dominus (mjd-perl-patch+@plover.com) 20010421

=begin original

Following the optimizer information is a dump of the offset/length
table, here split across several lines:

=end original

オプティマイザ情報の次に示すのは、オフセット/長さテーブルのダンプです。
ここでは、いくつかの行に分割されています。
(TBR)

  Offsets: [45]
  	1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
  	0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
  	11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
  	0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  

=begin original

The first line here indicates that the offset/length table contains 45
entries.  Each entry is a pair of integers, denoted by C<offset[length]>.
Entries are numbered starting with 1, so entry #1 here is C<1[4]> and
entry #12 is C<5[1]>.  C<1[4]> indicates that the node labeled C<1:>
(the C<1: ANYOF[bc]>) begins at character position 1 in the
pre-compiled form of the regex, and has a length of 4 characters.
C<5[1]> in position 12 
indicates that the node labeled C<12:>
(the C<< 12: EXACT <d> >>) begins at character position 5 in the
pre-compiled form of the regex, and has a length of 1 character.
C<12[1]> in position 14 
indicates that the node labeled C<14:>
(the C<< 14: CURLYX[0] {1,32767} >>) begins at character position 12 in the
pre-compiled form of the regex, and has a length of 1 character---that
is, it corresponds to the C<+> symbol in the precompiled regex.

=end original

ここの最初の行は、offset/lengthテーブルに45個のエントリが含まれていることを示しています。
各エントリは、C<offset[length]>で表される整数のペアです。
エントリは1から始まる番号が付けられます。
ここでのエントリ#1はC<1[4]>で、エントリ#12はC<5[1]>です。
C<1[4]>は、C<1:>というラベルの付いたノード(C<1: ANYOF[bc]>)が、事前コンパイルされたregex形式の文字位置1から始まり、4文字の長さを持つことを示します。
12番目のC<5[1]>は、C<12:>というラベルの付いたノード(C<<12:EXACT<d>>>)が、事前コンパイルされたregex形式の文字位置5から始まり、1文字の長さを持つことを示します。
14番目のC<12[1]>は、C<14:>というラベルの付いたノード(C<< 14: CURLYX[0] {1,32767} >>)が、事前コンパイルされたregex形式の文字位置12から始まり、1文字の長さを持つことを示します。
つまり、事前コンパイルされたregexのC<+>記号に対応します。
(TBR)

=begin original

C<0[0]> items indicate that there is no corresponding node.

=end original

C<0[0]>の項目は、対応するノードがないことを示します。
(TBR)

=head2 Run-time output

(実行時出力)

=begin original

First of all, when doing a match, one may get no run-time output even
if debugging is enabled.  This means that the regex engine was never
entered and that all of the job was therefore done by the optimizer.

=end original

まず第1に、マッチングを行う際に、デバッグが有効になっていてもランタイム出力が得られない場合があります。
これは、regexエンジンが入力されておらず、したがってすべてのジョブがオプティマイザによって実行されたことを意味します。
(TBR)

=begin original

If the regex engine was entered, the output may look like this:

=end original

regexエンジンが入力された場合、出力は次のようになります。
(TBR)

  Matching `[bc]d(ef*g)+h[ij]k$' against `abcdefg__gh__'
    Setting an EVAL scope, savestack=3
     2 <ab> <cdefg__gh_>    |  1: ANYOF
     3 <abc> <defg__gh_>    | 11: EXACT <d>
     4 <abcd> <efg__gh_>    | 13: CURLYX {1,32767}
     4 <abcd> <efg__gh_>    | 26:   WHILEM
				0 out of 1..32767  cc=effff31c
     4 <abcd> <efg__gh_>    | 15:     OPEN1
     4 <abcd> <efg__gh_>    | 17:     EXACT <e>
     5 <abcde> <fg__gh_>    | 19:     STAR
			     EXACT <f> can match 1 times out of 32767...
    Setting an EVAL scope, savestack=3
     6 <bcdef> <g__gh__>    | 22:       EXACT <g>
     7 <bcdefg> <__gh__>    | 24:       CLOSE1
     7 <bcdefg> <__gh__>    | 26:       WHILEM
				    1 out of 1..32767  cc=effff31c
    Setting an EVAL scope, savestack=12
     7 <bcdefg> <__gh__>    | 15:         OPEN1
     7 <bcdefg> <__gh__>    | 17:         EXACT <e>
       restoring \1 to 4(4)..7
				    failed, try continuation...
     7 <bcdefg> <__gh__>    | 27:         NOTHING
     7 <bcdefg> <__gh__>    | 28:         EXACT <h>
				    failed...
				failed...

=begin original

The most significant information in the output is about the particular I<node>
of the compiled regex that is currently being tested against the target string.
The format of these lines is

=end original

出力で最も重要な情報は、ターゲット文字列に対して現在テストされている、コンパイルされた正規表現の特定のI<node>に関するものです。
これらの行の書式は以下のとおりです。
(TBR)

=begin original

C<    >I<STRING-OFFSET> <I<PRE-STRING>> <I<POST-STRING>>   |I<ID>:  I<TYPE>

=end original

C<>I<STRING-OFFSET><I<PRE-STRING>><I<POST-STRING>>I<ID>:I<TYPE>
(TBR)

=begin original

The I<TYPE> info is indented with respect to the backtracking level.
Other incidental information appears interspersed within.

=end original

I<TYPE>情報は、バックトラッキングレベルに応じてインデントされます。
その他の付随情報は、その中に点在して表示されます。
(TBR)

=head1 Debugging Perl memory usage

(Perl のメモリ使用のデバッグ)

=begin original

Perl is a profligate wastrel when it comes to memory use.  There
is a saying that to estimate memory usage of Perl, assume a reasonable
algorithm for memory allocation, multiply that estimate by 10, and
while you still may miss the mark, at least you won't be quite so
astonished.  This is not absolutely true, but may provide a good
grasp of what happens.

=end original

Perlはメモリ使用量に関しては非常に厄介な存在です。
Perlのメモリ使用量を見積もるためには、メモリ割り当てのための妥当なアルゴリズムを仮定し、その推定値に10を乗算します。
そして、それでも見当がつかないかもしれませんが、少なくともそれほど驚くことはありません。
これは完全に正しいわけではありませんが、何が起きているのかを十分に把握することができるかもしれません。
(TBR)

=begin original

Assume that an integer cannot take less than 20 bytes of memory, a
float cannot take less than 24 bytes, a string cannot take less
than 32 bytes (all these examples assume 32-bit architectures, the
result are quite a bit worse on 64-bit architectures).  If a variable
is accessed in two of three different ways (which require an integer,
a float, or a string), the memory footprint may increase yet another
20 bytes.  A sloppy malloc(3) implementation can inflate these
numbers dramatically.

=end original

整数は20バイト未満のメモリを取ることができず、浮動小数点は24バイト未満のメモリを取ることができず、文字列は32バイト未満のメモリを取ることができないと仮定します(これらの例はすべて32ビットアーキテクチャを想定していますが、64ビットアーキテクチャでは結果がかなり悪くなります)。
3つの異なる方法(整数、浮動小数点、または文字列を必要とする方法)のうち2つの方法で変数にアクセスする場合、メモリフットプリントはさらに20バイト増加する可能性があります。
不十分なmalloc(3)の実装は、これらの数値を劇的に膨らませる可能性があります。
(TBR)

=begin original

On the opposite end of the scale, a declaration like

=end original

反対に次のような宣言があります
(TBR)

  sub foo;

=begin original

may take up to 500 bytes of memory, depending on which release of Perl
you're running.

=end original

は、実行しているPerlのリリースに応じて、最大500バイトのメモリを消費します。
(TBR)

=begin original

Anecdotal estimates of source-to-compiled code bloat suggest an
eightfold increase.  This means that the compiled form of reasonable
(normally commented, properly indented etc.) code will take
about eight times more space in memory than the code took
on disk.

=end original

ソースからコンパイルされたコードの肥大化に関する事例推定では、8倍の増加が示唆されています。
これは、妥当な形式(通常はコメント付き、適切にインデントなど)のコードをコンパイルした場合、ディスク上のコードよりも約8倍のメモリ領域が必要になることを意味します。
(TBR)

=begin original

The B<-DL> command-line switch is obsolete since circa Perl 5.6.0
(it was available only if Perl was built with C<-DDEBUGGING>).
The switch was used to track Perl's memory allocations and possible
memory leaks.  These days the use of malloc debugging tools like
F<Purify> or F<valgrind> is suggested instead.  See also
L<perlhack/PERL_MEM_LOG>.

=end original

B<-DL>コマンドラインスイッチは、Perl 5.6.0(PerlがC<-DDEBUGGING>で構築された場合にのみ使用可能)から廃止されました。
このスイッチは、Perlのメモリ割り当てとメモリリークを追跡するために使用されました。
最近では、代わりにF<Purify>やF<valgrind>のようなmallocデバッグツールの使用が推奨されています。
L<perlhack/PERL_MEM_LOG>も参照してください。
(TBR)

=begin original

One way to find out how much memory is being used by Perl data
structures is to install the Devel::Size module from CPAN: it gives
you the minimum number of bytes required to store a particular data
structure.  Please be mindful of the difference between the size()
and total_size().

=end original

Perlデータ構造で使用されているメモリ量を調べる方法の1つは、CPAN:のDevel::Sizeモジュールをインストールすることです。
これは、特定のデータ構造を保存するために必要な最小バイト数を示します。
size()とtotal_size()の違いに注意してください。
(TBR)

=begin original

If Perl has been compiled using Perl's malloc you can analyze Perl
memory usage by setting the $ENV{PERL_DEBUG_MSTATS}.

=end original

PerlがPerlのmallocを使ってコンパイルされている場合は、$ENV{PERL_DEBUG_MSTATS}を設定することでPerlのメモリ使用量を分析できます。
(TBR)

=head2 Using C<$ENV{PERL_DEBUG_MSTATS}>

(C<$ENV{PERL_DEBUG_MSTATS}> を使う)

=begin original

If your perl is using Perl's malloc() and was compiled with the
necessary switches (this is the default), then it will print memory
usage statistics after compiling your code when C<< $ENV{PERL_DEBUG_MSTATS}
> 1 >>, and before termination of the program when C<<
$ENV{PERL_DEBUG_MSTATS} >= 1 >>.  The report format is similar to
the following example:

=end original

PerlがPerlのmalloc()を使用していて、必要なスイッチ(これがデフォルトです)でコンパイルされている場合、C<<$ENV{PERL_DEBUG_MD ST}>1>>のときはコードのコンパイル後、C<<$ENV{PERL_DEBUG_MD ST}>=1>>のときはプログラムの終了前に、メモリ使用量の統計を出力します。
レポート形式は次の例のようになります。
(TBR)

  $ PERL_DEBUG_MSTATS=2 perl -e "require Carp"
  Memory allocation statistics after compilation: (buckets 4(4)..8188(8192)
     14216 free:   130   117    28     7     9   0   2     2   1 0 0
		437    61    36     0     5
     60924 used:   125   137   161    55     7   8   6    16   2 0 1
		 74   109   304    84    20
  Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail: 0+636+0+2048.
  Memory allocation statistics after execution:   (buckets 4(4)..8188(8192)
     30888 free:   245    78    85    13     6   2   1     3   2 0 1
		315   162    39    42    11
    175816 used:   265   176  1112   111    26  22  11    27   2 1 1
		196   178  1066   798    39
  Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail: 0+2192+0+6144.

=begin original

It is possible to ask for such a statistic at arbitrary points in
your execution using the mstat() function out of the standard
Devel::Peek module.

=end original

標準のDevel::Peekモジュールのmstat()関数を使用して、実行中の任意の時点でこのような統計を要求することができます。
(TBR)

=begin original

Here is some explanation of that format:

=end original

このフォーマットの説明を以下に示します。
(TBR)

=over 4

=item C<buckets SMALLEST(APPROX)..GREATEST(APPROX)>

=begin original

Perl's malloc() uses bucketed allocations.  Every request is rounded
up to the closest bucket size available, and a bucket is taken from
the pool of buckets of that size.

=end original

Perlのmalloc()はバケット割り当てを使用します。
すべての要求は利用可能な最も近いバケットサイズに切り上げられ、バケットはそのサイズのバケットのプールから取得されます。
(TBR)

=begin original

The line above describes the limits of buckets currently in use.
Each bucket has two sizes: memory footprint and the maximal size
of user data that can fit into this bucket.  Suppose in the above
example that the smallest bucket were size 4.  The biggest bucket
would have usable size 8188, and the memory footprint would be 8192.

=end original

前述の行は、現在使用されているバケットの制限を示しています。
各バケットには、メモリフットプリントと、このバケットに格納できるユーザーデータの最大サイズの2つのサイズがあります。
前述の例で、最小バケットがサイズ4であるとします。
最大バケットの使用可能サイズは8188、メモリフットプリントは8192になります。
(TBR)

=begin original

In a Perl built for debugging, some buckets may have negative usable
size.  This means that these buckets cannot (and will not) be used.
For larger buckets, the memory footprint may be one page greater
than a power of 2.  If so, case the corresponding power of two is
printed in the C<APPROX> field above.

=end original

デバッグ用に構築されたPerlでは、一部のバケットの使用可能サイズが負になる場合があります。
これは、これらのバケットは使用できない(今後も使用されない)ことを意味します。
より大きなバケットの場合、メモリフットプリントは2の累乗より1ページ大きい場合があります。
その場合、対応する2の累乗が前述のC<APPROX>フィールドに印刷されます。
(TBR)

=item Free/Used

=begin original

The 1 or 2 rows of numbers following that correspond to the number
of buckets of each size between C<SMALLEST> and C<GREATEST>.  In
the first row, the sizes (memory footprints) of buckets are powers
of two--or possibly one page greater.  In the second row, if present,
the memory footprints of the buckets are between the memory footprints
of two buckets "above".

=end original

それに続く1行または2行の数字は、C<SMALLEST>とC<LARGEST>の間の各サイズのバケット数に対応します。
1行目では、バケットのサイズ(メモリフットプリント)は2の累乗(1ページ大きい場合もあります)です。
2行目(存在する場合)では、バケットのメモリフットプリントは「上」の2つのバケットのメモリフットプリントの間にあります。
(TBR)

=begin original

For example, suppose under the previous example, the memory footprints
were

=end original

たとえば、前の例で、メモリフットプリントが次のようになっているとします。
(TBR)

     free:    8     16    32    64    128  256 512 1024 2048 4096 8192
	   4     12    24    48    80

=begin original

With non-C<DEBUGGING> perl, the buckets starting from C<128> have
a 4-byte overhead, and thus an 8192-long bucket may take up to
8188-byte allocations.

=end original

C<DEBUGGING>以外のperlでは、C<128>から始まるバケットには4バイトのオーバーヘッドがあります。
したがって、長さが8192のバケットには最大8188バイトの割り当てが必要になります。
(TBR)

=item C<Total sbrk(): SBRKed/SBRKs:CONTINUOUS>

=begin original

The first two fields give the total amount of memory perl sbrk(2)ed
(ess-broken? :-) and number of sbrk(2)s used.  The third number is
what perl thinks about continuity of returned chunks.  So long as
this number is positive, malloc() will assume that it is probable
that sbrk(2) will provide continuous memory.

=end original

最初の2つのフィールドは、perl sbrk(2)ed(ess-broken?:-)の総メモリ量と使用されたsbrk(2)の数を示します。
3番目の数値は、perlが返すチャンクの連続性について考えているものです。
この数値が正である限り、malloc()はsbrk(2)が連続メモリを提供する可能性が高いと想定します。
(TBR)

=begin original

Memory allocated by external libraries is not counted.

=end original

外部ライブラリによって割り当てられたメモリはカウントされません。
(TBR)

=item C<pad: 0>

=begin original

The amount of sbrk(2)ed memory needed to keep buckets aligned.

=end original

バケットの整列を維持するために必要なsbrk(2)edメモリの量。
(TBR)

=item C<heads: 2192>

=begin original

Although memory overhead of bigger buckets is kept inside the bucket, for
smaller buckets, it is kept in separate areas.  This field gives the
total size of these areas.

=end original

大きいバケットのメモリオーバーヘッドはバケット内に保持されますが、小さいバケットの場合は個別の領域に保持されます。
このフィールドは、これらの領域の合計サイズを示します。
(TBR)

=item C<chain: 0>

=begin original

malloc() may want to subdivide a bigger bucket into smaller buckets.
If only a part of the deceased bucket is left unsubdivided, the rest
is kept as an element of a linked list.  This field gives the total
size of these chunks.

=end original

malloc()は、より大きなバケットをより小さなバケットに細分割する必要がある場合があります。
死亡バケットの一部のみが細分割されずに残っている場合、残りはリンクリストの要素として保持されます。
このフィールドは、これらのチャンクの合計サイズを示します。
(TBR)

=item C<tail: 6144>

=begin original

To minimize the number of sbrk(2)s, malloc() asks for more memory.  This
field gives the size of the yet unused part, which is sbrk(2)ed, but
never touched.

=end original

sbrk(2)の数を最小限に抑えるために、malloc()はより多くのメモリを要求します。
このフィールドは、sbrk(2)で処理されるが、まったく処理されない未使用のパートのサイズを示します。
(TBR)

=back

=head1 SEE ALSO

=begin original

L<perldebug>,
L<perlguts>,
L<perlrun>
L<re>,
and
L<Devel::DProf>.

=end original

L<perldebug>,
L<perlguts>,
L<perlrun>,
L<re>,
L<Devel::DProf>

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org> (5.10.1)
Status: in progress

=end meta

