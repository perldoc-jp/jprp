
=encoding euc-jp

=head1 名前

perl5100delta - perl 5.10.0 の新機能

=head1 説明

このドキュメントでは 5.8.8 リリースと 5.10.0 リリースとでの相異点を
説明します.

5.10.0 でのバグ修正の多くは既に 5.8.X 
メンテナンスリリースで見ることができます; 
それらはここには重複しないで, perl58[1-8]?delta の
マニュアルページ群に記載しています.

=head1 コアの機能拡張

=head2 C<feature> プラグマ

C<feature> プラグマは Perl のこれまでのリリースとの
後方互換性がなくなってしまう新しい構文を有効にするために
使われます. これは C<strict> や C<warnings> と同様
レキシカルなプラグマです.

現在, 以下の新しい機能が提供されています:
C<switch> (switch 文を追加), 
C<say> (C<say> 組み込み関数を追加), 
そして C<state> ("静的な"変数を宣言するためのC<state> キーワードを追加).
これらの機能はこのドキュメントのそれぞれのセクションに
記述されています.

C<feature> プラグマは必要な perl のバージョンを
5.9.5 以降で (C<use VERSION>構成子を使って) 要求したときにも
暗黙にロードされます. 
詳細は L<feature> を参照してください.

=head2 新しい B<-E> コマンドラインスイッチ

B<-E> は B<-e> と等価ですが, 
暗黙にすべての追加できる feature を
有効にします(C<use feature ":5.10"> のように).

=head2 Defined-or 演算子

新しい演算子 C<//> (defined-or) が実装されました.
次の式:

    $a // $b

単純に次の式と等価です,

   defined $a ? $a : $b

そして次の文

   $c //= $d;

は, 以下の代わりに使うことができます.

   $c = $d unless defined $c;

C<//> 演算子は C<||> と同じ優先順位及び
結合性を持ちます. 
この演算子が古いコードを壊さずに貴方の意図通りのことを行うことを保証するように
特別注意を払っていますが, 幾つかの空の正規表現を呼び出すエッジケースでは
異なったパースをしてしまうこともあります. 
詳細は L<perlop> を参照してください.

=head2 switch 及びスマートマッチ演算子

Perl 5 にも switch 文が実装されました. 
C<use feature 'switch'> の影響下で利用することが
できます. この機能は３つの新しいキーワード,
C<given>, C<when>, 及び C<default> を導入します:

    given ($foo) {
	when (/^abc/) { $abc = 1; }
	when (/^def/) { $def = 1; }
	when (/^xyz/) { $xyz = 1; }
	default { $nothing = 1; }
    }

Perl が switch 変数をどのように C<when> 条件に
マッチさせるかのより詳細な説明は, L<perlsyn/Switch statements>
にあります.

この種類のマッチは I<スマートマッチ> と呼ばれ, 
これは switch 文以外でも新しい C<~~> 演算子で使うことが
できます. L<perlsyn/Smart matching in detail> を参照してください.

この機能は Robin Houston より寄稿されました.

=head2 正規表現

=over 4

=item 再帰するパターン

再帰するパターンを C<(??{})> を使うことなく
記述できるようになりました. 
この新しい方法はより効率的で, 多くの場合可読性にも
優れています.

それぞれのキャプチャ括弧は, 
C<(?PARNO)> 構文を使って突入できる
独立したパターンとして扱われます
(C<PARNO> は "parenthesis number (括弧番号)" を
表します).
例えば, 以下のパターンはネストしたバランスのとれた角括弧にマッチします:

    /
     ^                      # start of line
     (                      # start capture buffer 1
	<                   #   match an opening angle bracket
	(?:                 #   match one of:
	    (?>             #     don't backtrack over the inside of this group
		[^<>]+      #       one or more non angle brackets
	    )               #     end non backtracking group
	|                   #     ... or ...
	    (?1)            #     recurse to bracket 1 and try it again
	)*                  #   0 or more times.
	>                   #   match a closing angle bracket
     )                      # end capture buffer one
     $                      # end of line
    /x

PCRE ユーザは, PCRE の再帰はアトミック若しくは自然に
"強欲"ですが, Perl の再帰正規表現の機能は
再帰されたパターンの中へのバックトラックを許している
という点に気をつけてください. 上に書いた例のように,
この振る舞いを選んで使いたいときには (?>) を
加えることで制御できます.

=item 名前付きキャプチャバッファ

パターンにおいて名前付きのキャプチャ括弧と
キャプチャされた内容への名前による参照ができるように
なりました. 名前をつける構文は C<< (?<NAME>....) >> です. 
名前をつけたバッファへの後方参照は C<< \k<NAME> >> 構文によって
行えます. コード中では, キャプチャされたバッファの内容に
アクセスするために新しいマジカルハッシュ C<%+> 及び
C<%-> が使えるようになります.

これによって, すべての連続する文字を1文字に置き換えるのに次のように
書くことができます

    s/(?<letter>.)\k<letter>/$+{letter}/g

C<%+> ハッシュには内容の決定したバッファのみが
"見える"ようになるので, 次のようにすることができます

    foreach my $name (keys %+) {
        print "content of buffer '$name' is $+{$name}\n";
    }

C<%-> ハッシュはもう少し複雑です, 
これには名前のついているすべてのキャプチャバッファの
値を複数あったとしても保持している配列リファレンスを含んでいます.

C<%+> 及び C<%-> は新しいモジュール
C<Tie::Hash::NamedCapture> に tie されたハッシュとして
実装されています.

.NET 正規表現にさられてきたユーザは, perl の実装が
"まずは名前なし, それから名前付き"ではなく
順番になっていることに気付くでしょう.
従って次のパターンにおいて

   /(A)(?<B>B)(C)(?<D>D)/

$1 は 'A', $2 は 'B', $3 は 'C' そして $4 は 'D' になり,
.NET プログラマが予期したような
$1 が 'A', $2 が 'C' そして $3 が 'B' そして $4 が 'D' にはなりません. 
これは仕様と考えています. :-) (Yves Orton)

=item 強欲な量指定子

Perl は "アトミックマッチ"パターンの
"強欲な量指定子"構文をサポートしました. 
基本的に強欲な量指定子は可能なだけ多くにマッチし, 
そして後退しません. 従ってこれはバックトラックの制御に
使うことができます. その構文は貪欲でないマッチと似ていますが, 
修飾子として '?' の代わりに '+' を使います. 
従って, C<?+>, C<*+>, C<++>, C<{min,max}+> は正しい
量指定子になります. (Yves Orton)

=item バックトラック制御記号

正規表現エンジンはいくつかの特殊な目的のための
バックトラック制御記号をサポートします:
(*THEN), (*PRUNE), (*MARK), (*SKIP), (*COMMIT), (*FAIL)
及び (*ACCEPT). これらの説明は L<perlre> を
参照してください. (Yves Orton)

=item 相対後方参照

新しい構文 C<\g{N}> 若しくは C<\gN> ("N" は10進整数)
によって相対的な後方参照と同様の安全な形式での
後方参照ができるようになりました. これによって後方参照を含んだ
パターンの生成がより簡単に行えるようになります. 
L<perlre/Capture buffers> を参照してください. (Yves Orton)

=item C<\K> エスケープ

Jeff Pinyan によるモジュール Regexp::Keep の機能が
コアに追加されました. これによって正規表現内で
可変長の正の後読みの言明のようなものとして
特殊なエスケープ C<\K> を使うことができます. 
これは次のような置換で便利です:

  s/(foo)bar/$1/g

これは次のように書き換えることができ

  s/foo\Kbar//g

これはより効率的です. (Yves Orton)

=item 垂直及び水平白空白, 及び行区切り

正規表現は C<\v> 及び C<\h> エスケープを認識するようになりました,
これらはそれぞれ垂直及び水平白空白にマッチします.
C<\V> 及び C<\H> はその補集合に論理的にマッチします.

C<\R> は一般的な行区切りにマッチします, 
つまり, 垂直白空白, それと複数文字のシーケンス C<"\x0D\x0A"> です.

=back

=head2 C<say()>

say() は新しい組み込み関数で, これは C<use feature 'say'> の
影響下でのみ提供され, print() とにていますが
出力される文字列に改行を暗黙に追加します. 
L<perlfunc/say> を参照してください. (Robin Houston)

=head2 レキシカルな C<$_>

デフォルト変数 C<$_> を他のレキシカル変数と同じように
次のように宣言することでレキシカルにできるようになりました

    my $_;

デフォルトで C<$_> を使う演算子はレキシカルな
C<$_> があれば, グローバルな C<$_> の代わりに
それを使うようになります.

C<map> 若しくは C<grep> ブロックでは, 
C<$_> が先に my されていたら内側のブロックでも
同じようにレキシカルです(そしてそのブロックのスコープです).

C<$_> がレキシカル化されたスコープでは, 
C<$::_> によって, 若しくは, より簡単に, C<our $_> で
レキシカル宣言を上書きすることで
グローバル版の C<$_> に アクセスすることができます. (Rafael Garcia-Suarez)

=head2 C<_> プロトタイプ

新しいプロトタイプ文字が追加されました. 
C<_> は C<$> と等価ですが, 対応する引数が渡されなかったときに
デフォルトで C<$_> をとるようになります. 
(C<$> も C<_> も共にスカラーを意味します.)
省略可能な引数として, これはプロトタイプの最後か, 
セミコロンの前でのみ使うことができます.

これは小さな非互換を生じます: 
prototype() 関数はいくつかの適応する組み込み関数で
C<_> を返すようになります(例えば C<prototype('CORE::rmdir')>).
(Rafael Garcia-Suarez)

=head2 UNITCHECK ブロック

C<UNITCHECK> は C<BEGIN>, C<CHECK>, C<INIT> そして C<END>
に加えて新しく導入された特殊コードブロックです.

いくつかの特殊な目的で便利な C<CHECK> 及び C<INIT> ブロックは
常にメインプログラムのコンパイルと実行の間で実行され, 
従ってこれは実行時にロードされるコードには役に立ちません. 
これに対して, C<UNITCHECK> はそれが定義されている単位が
コンパイルされた直後に実行されます.
詳細な情報は L<perlmod> を参照してください. (Alex Gough)

=head2 新しいプラグマ, C<mro>

新しいプラグマ, C<mro> (Method Resolution Order;
メソッド解決順序)が追加されました. 
これを使うことで複数の継承階層がある場合に
perl が継承されたメソッドを探索するときに使うアルゴリズムを
クラス毎に切り替えることができます. 
デフォルトの MRO は変更されません(DFS; Depth First Search,
深さ優先探索). 提供されている MRO にはもう一つ,
C3 アルゴリズムがあります. 
より詳しい情報は L<mro> を参照してください. (Brandon Black)

クラス階層探索の実装変更に伴って, 
C<*ISA> グロブを undef していたコードは
恐らく動かないことに注意してください. 
C<*ISA> を undef することは @ISA 配列の magic を
削除してしまう副作用を発生させるため, まず第一に
それをするべきではありません. 
また, C<*::ISA::CACHE::> はもはや存在しません; @ISA キャッシュを
強制的にリセットしたいときには C<mro> API を使うか, 
より巻単位は @ISA に代入を行う必要があります (例えば C<@ISA = @ISA>).

=head2 Windows 上に於いて readdir() が"短いファイル名"を返すことがあります

長いファイル名(long filename)が ANSI コードページ外の
文字を含んでいる時に readdir() 関数は "短いファイル名
(short filename)" を返すことがあります. 同様に, 
Cwd::cwd() もまた短いディレクトリ名を, そして glob() も
短い名前を同様に返すことがあります. NTFS ファイルシステム
上であればこれらの短い名前は常に ANSI コードページで
表現されます. これは他のシステムドライバでは必ずしも
当てはまりません; 例えば FAT ファイルシステムは
短いファイル名を OEM コードページで格納しているので, 
FAT ボリューム上のいくつかのファイルは ANSI API では
以前アクセスできないままです.

同様に, $^X, @INC, 及び $ENV{PATH} は全てのパスが
(可能であれば)有効な ANSI コードページで表現されたパスと
なるように起動時に前処理されます.

Win32::GetLongPathName() 関数は置換文字を使って名前を強制的に
ANSI コードページとするのではなく, UTF-8 エンコードされた
正しい長いファイル名を返すようになります. 
新しい WIn32::GetANSIPathName() 関数は長いパス名が ANSI
コードページで表現できないときにのみ,
長いパス名を短いパス名へと変換するために使うことができます.

C<Win32> モジュールの他の多くの関数は
UTF-8 エンコードされた引数を受け取ることができるように
改善されました. 詳細は L<Win32> を参照してください.

=head2 readpipe() がオーバーライド可能になりました

組み込み関数 readpipe() がオーバーライド可能になりました. 
これによってこれに対応する演算子, C<qx//> (a.k.a. C<``>)
もオーバーライドすることができます. 
さらに, これは引数が渡されなかったときに C<$_> を
デフォルトの引数とするようになりました. (Rafael Garcia-Suarez)

=head2 readline() のデフォルトの引数

readline() は引数が渡されなかったときにデフォルトの
引数として C<*ARGV> をとるようになりました. (Rafael Garcia-Suarez)

=head2 state() 変数

新しい変数の分類が導入されました. 
state 変数は C<my> 変数とにていますが, 
C<my> の代わりに C<state> キーワードを使って宣言します. 
変数はそのレキシカルスコープで見ることができますが, 
C<my> 変数とは異なりその値は維持され, 
スコープに入ったときに未定義にされる代わりに以前の値を
再び得ます. (Rafael Garcia-Suarez, Nicholas Clark)

state 変数を使うためには次の文で

    use feature 'state';

若しくはワンライナーであれば C<-E> コマンドラインスイッチ
を使うことでそれを有効にする必要があります. 
L<perlsub/"Persistent Private Variables"> を参照してください.

=head2 スタックされたファイルテスト演算子

新しい構文糖として, ファイルテスト演算子を
積み重ねることができるようになりました. 
C<-x $file && -w _ && -f _> の意味で 
C<-f -w -x $file> と一列にかけるようになりました. 
L<perlfunc/-X> を参照してください.

=head2 UNIVERSAL::DOES()

C<UNIVERSAL> は新しいメソッド, C<DOES> を持つようになりました. 
これは C<isa()> メソッドでの意味的(sematic)な
問題を解決するために追加されました. 
C<isa()> は継承を調べますが, 
C<DOES()> はモジュールの作者が(継承に加えて)
クラス間の他の関係を使う場合に上書きするために
設計されています. (chromatic)

L<< UNIVERSAL/$obj->DOES( ROLE ) >> を参照してください.

=head2 フォーマット

フォーマットはいくつかの点で改善されました. 
可変幅, 一回で一行?(one-line-at-a-time)のテキストのために
新しいフィールド C<^*> が使えるようになりました. 
picture 行で Null 文字が正しく処理されるようになりました. 
C<@#> と C<~~> の併用はこれらの整形フィールドに互換がないため
コンパイルエラーを生成するようになりました. 
L<perlform> も改善され, 雑多なバグが修正されました.

=head2 pack() 及び unpack() でのバイト順序修飾子

多くの pack() 及び unpack() テンプレート文字及び
グループでそのタイプ若しくはグループに対して特定の
バイト順序を強制するための2つの新しいバイト順序修飾子,
C<E<gt>> (ビッグエンディアン) 及び
C<E<lt>> (リトルエンディアン) が追加されました. 
詳細は L<perlfunc/pack> 及び L<perlpacktut> を参照してください.

=head2 C<no VERSION>

C<no> のバージョン番号を続けることで, 指定したバージョンより
古いバージョンの perl を使いたいこと表現できるように
なりました.

=head2 ファイルハンドルに対する C<chdir>, C<chmod> 及び C<chown>

C<chdir>, C<chmod> 及び C<chown> はシステムでぞれぞれ
C<fchdir>, C<fchmod> 及び C<fchown> がサポートされいたら
ファイル名と同様にファイルハンドルでも動作するように
なりました, Gisle Aas から提供されたパッチに感謝します.

=head2 OS のグループ

C<$(> 及び C<$)> は OS から返された順番でグループを
返すようになりました, Gisle Aas に感謝します. 
これは以前はそうなっていませんでした.

=head2 再帰する sort 用関数

sort() で再帰する関数を使えるようになりました, 
Robin Houston に感謝します.

=head2 定数畳み込み込み時の例外

定数畳み込み処理が例外ハンドラで保護されるようになりました, 
そして畳み込み時に例外が発生したときには(例えば 0/0 を
評価しようとした場合), perl はプログラム全体をアボート
させるのではなく現在の optree を維持するようになります. 
この変更がないと, プログラムないに例外を生成する式が
含まれていた場合, たとえそれが実行時に処理が通らない
場所であったとしてもコンパイルできません.
(Nicholas Clark, Dave Mitchell)

=head2 @INC でのソースフィルタ

@INC での関数フックメカニズムに於いて, 
フックから返された開いているファイルハンドルの先頭に
ソースフィルタを加えることで強化できるようになりました. 
この機能はだいぶ以前から計画されていましたが, 
これまであまり作業されていませんでした. 
詳細は L<perlfunc/require> を参照してください. (Nicholas Clark)

=head2 新しい内部変数

=over 4

=item C<${^RE_DEBUG_FLAGS}>

この変数は C<use re "debug"> で実行されている時に
その正規表現エンジンで影響を持っているデバッグフラグを
制御します. 詳細は L<re> を参照してください.

=item C<${^CHILD_ERROR_NATIVE}>

=begin original

This variable gives the native status returned by the last pipe close,
backtick command, successful call to wait() or waitpid(), or from the
system() operator. See L<perlvar> for details. (Contributed by Gisle Aas.)

=end original

この変数は最後の pipe close, バックティックコマンド,
wait() 若しくは waitpid() の成功した呼び出し, 
若しくは system() 演算子から返されたネイティブなステータスを
与えます.
詳しくは L<perlvar> を参照してください。
(Gisle Aas によって寄贈されました。)

=item C<${^RE_TRIE_MAXBUF}>

L</Trie optimisation of literal string alternations> 参照.

=item C<${^WIN32_SLOPPY_STAT}>

L</Sloppy stat on Windows> 参照.

=back

=head2 その他の事項

C<unpack()> はデフォルトで C<$_> 変数を unpack するように
なりました.

引数の無い C<mkdir()> は C<$_> をデフォルトと
するようになりました.

内部ダンプ出力が改善されました, これによって改行やバックスペースといった
表示できない文字は8進数でなく C<\x> 記法で出力されるようになります.

B<-C> オプションは C<#!> 行で使えなくなりました. 
どのみち, 標準入出力は perl インタプリタの実行に於いて
その時点では既にセットアップ済みであるためそこでは動作しません. 
その振る舞いを希望する代わりに binmode() を使ってください.

=head2 UCD 5.0.0

Perl 5 に含まれているユニコード文字データベースは
バージョン 5.0.0 にアップデートされました.

=head2 MAD

MAD (Miscellaneous Attribute Decoration)は Perl 5 から Perl 6 への
コンバータに向けて今だ開発継続中です. 
これを有効にするには Configure の引数に C<-Dmad> を渡す必要があります. 
これによって得られる perl は通常の perl 5.10 とのバイナリ互換性が
ありません, そして空間と速度ともにペナルティをとります; 
それに加えてまだパスできていないレグレッションテスとが残っています.
(Larry Wall, Nicholas Clark)

=head2 Windows での kill()

Windows プラットフォームにおいて, C<kill(-9, $pid)> は
プロセスツリーを kill するようになります. 
(Unix ではこれは同じプロセスグループに属するすべてのプロセスに
シグナルを伝達します.

=head1 非互換となる修正

=head2 pack と UTF-8 文字列

UTF-8 エンコードされたデータにおける pack() 及び unpack()
のセマンティクスが変更されました. 処理はデフォルトで
基礎となっているエンコーディングにおいて
バイト毎ではなく文字毎になりました. 
特に, 文字列のエンコーディングを通して見るために
C<pack("a*", $string)> といったかんじで使っているコードは
単純にオリジナルの $string を得るようになります. 
アップグレードされている文字を格納したときには
pack された文字列もまたアップグレードされています. 
C<use bytes> を使うことで以前の振る舞いをとることもできます.

pack() と同じように, unpack() での C<C0> テンプレートも
文字モードで, つまり文字毎に処理されることを示します;
これに対して unpack() での C<U0> は pack された文字列が
バイト毎の処理を基盤とした環境での UTF-8 エンコードされた
ユニコード形式で処理されたと, UTF-8 モードを示します.
これは perl 5.8.X と逆になりますが, 
これによって pack() と unpack() での矛盾が解消されます.

さらに, pack() での C<C0> 及び C<U0> はそれぞれ文字及び
バイトモードのテンプレートとなります.

pack 及び unpack フォーマットの途中にある C<C0> 及び C<U0> は
括弧グループに於いての
指定されたエンコーディングモードへの切り替えとなります.
これまでは, 括弧は無視されていました.

また, 新しい pack() 文字形式, C<W> が追加されました, 
これは以前の C<C> の置き換えを意図しています. 
C<C> は文字列の内部表現でのバイト列を unsigned char 列で
保持します. C<W> は符号なし(論理)文字の値を表現し, 
これは 255 より大きい値もとれます. これによって
UTF-8 エンコードされているかもしれないデータに対して
より強靱になります(C<C>は文字エンコーディングを
考えないので 0..255 の範囲外の値は wrap してしまします).

実際のところ, これは pack フォーマットが C<C> 以外は
エンコーディング対応になったことを意味します.

一貫性のために, unpack() での C<A> フォーマットは
文字列の末尾のすべてのユニコード白空白を取り除く
ようになりました. perl 5.9.2 以前では, 
伝統的な ASCII 空白文字のみを取り除いていました.

=head2 unpack() でのバイト/文字カウント機能

新しい unpack() テンプレート文字, C<".">, 
これはそれまでに読み込まれたバイト数若しくは文字数を返します
(選択されているエンコーディングモードに依る, 前述).

=head2 C<$*> 及び C<$#> 変数は削除されました

C</s> 及び C</m> 正規表現修飾子が導入されたことで
非推奨となっていた C<$*> は削除されました.

非推奨となっていた C<$#> 変数 (数値の出力形式)は
削除されました. 
(編注: 配列の最後の添字を取得する $#VAR ではないです)

2つの厳しい警告, C<$#/$* is no longer supported> が
追加されました.

=head2 substr() の lvalue は固定長でなくなりました

３引数形式の substr() から返される lvalue 値は
オリジナルの文字列での"固定長のウィンドウ"を持っていました. 
いくつかのケースにおいてこれは離れた場所でのびっくりする動作や
他の未定義な振る舞いとなっていました. 
このウィンドウの長さはそれに代入された文字列の長さに
調整されるようになりました.
(編注:C<$x="1234";$y=(substr($x,1,2)="ABCD");> とした時, 
これまでは C<$x="1ABCD4", $y="AB"> となっていたけれど, 
5.10 以降は C<$x="1ABCD4", $y="ABCD"> になる.)

=head2 C<-f _> のパース

識別子 C<_> は, ファイルテスト演算子の後ではベアワードとして
強制されるようにありました. これはグローバルな C<_> 関数が
定義されている時の misparsing な動作を改善します.

=head2 C<:unique>

C<:unique> アトリビュートは no-op になりました, 
この現在の実装が本質的に問題がある上にスレッドセーフで
ないためです.

=head2 eval 内のプラグマの影響

C<%^H> ヒント変数のコンパイル時の値は eval("") されたコードにも
伝播するようになりました. これはレキシカルプラグマを実装するのに
より一層役立ちます.

この副作用として, 定数のオーバーロードされ具合も eval("") に
伝播するようになりました.

=head2 chdir FOO

chdir() へのベアワード引数はファイルハンドルとして
認識されるようになりました. これまでのリリースでは
ベアワードはディレクトリ名として処理されていました. 
(Gisle Aas)

=head2 .pmc ファイルの扱い

perl の古くからある機能で, C<require> 若しくは C<use> は
F<.pm> 拡張子のファイルを探す前に, まず同じファイル名で F<.pmc> の
拡張子のファイルを探していました. これが見つかったとき, 
存在しているかもしれない F<.pm> 拡張子で終わるファイル代わりに
ロードされるようになります.

これまででは, F<.pmc> ファイルはそれが F<.pm> ファイルより
新しい時にのみロードされていました. 
5.9.4 からはこれは存在していれば常にロードされるようになります.

=head2 $^V は v-string ではなく C<version> オブジェクトになります

$^V は printf における C<%vd> 形式で使うことができますが, 
文字レベルでの操作は C<version> オブジェクトの
文字列表現へのアクセスとなり, v-string のではありません. 
C<< substr($^V, 0, 2) >> や  C<< split //, $^V >> 
といった式はもはや動作せず, 書き直さなければなりません.

=head2 パターン内での @- 及び @+

特殊配列 C<@-> 及び C<@+> はもはや正規表現の中に入り込んで(interpolate)
いません. (Sadahiro Tomoyuki)

=head2 $AUTOLOAD の taint 対応

もし taint されたている名前で関数を呼び出した時, 
そしてそれが AUTOLOAD 関数にゆだねられた時, 
$AUTOLOAD は(適切に) taint される用になります. (Rick Delaney)

=head2 taint と printf

perl が taint モードで実行されている時, C<printf()> 及び
C<sprintf()> は taint された書式引数を拒否するようになります. 
(Rafael Garcia-Suarez)

=head2 undef とシグナルハンドラ

シグナルハンドラの C<undef $SIG{FOO}> による未定義化
若しくは削除は C<'DEFAULT'> の設定と等価になります. (Rafael Garcia-Suarez)

=head2 strict と defined() 内のデリファレンス

C<use strict 'refs'> は次のような defined() の引数でのハードリファレンスを
無視していました:

    use strict 'refs';
    my $x = 'foo';
    if (defined $$x) {...}

これは適切に実行時エラー C<Can't use string as a SCALAR ref while
"strict refs" in use> ("struct refs" の影響下では文字列を SCALAR
リファレンスとして使うことは出来ません)を生成するようになります.

C<defined @$foo> 及び C<defined %$bar> は C<strict 'refs'>
にも従うようになります(つまり C<$foo> 及び C<$bar> はその場所において
適切なリファレンスであるべきです). (C<defined(@foo)> 及び
C<defined(%bar)> は推奨されない形ですが.) (Nicholas Clark)

=head2 C<(?p{})> は削除されました

perl 5.8 で非推奨となっていた正規表現構築子 C<(?p{})> は
削除されました. かわりに C<(??{})> を使うようにしてください. (Rafael Garcia-Suarez)

=head2 仮想ハッシュは削除されました

仮想ハッシュのサポートは Perl 5.9 から削除されました.
(C<fields> プラグマは引き続き残りますが, 違う実装を使っています).

=head2 perlcc とバイトコードコンパイラの削除

C<perlcc>, バイトローダ及びそのサポートモジュール(B::C, B::CC, 
B::Bytecode, etc.)は perl ソースと一緒には配布されなくなりました. 
これらの実験的なツールは信頼した動作を行えず, そして, 
perl インタプリタの開発ラインに於いてそれを維持するボランティアの
不足により, 壊れたバージョンを送り出すよりは削除されることとなりました. 
最後のバージョンは perl 5.9.4 にあります.

とはいっても B コンパイラフレームワークは, それによって可能となる
便利なモジュール(とりわけ B::Deparse 及び B::Concise)と共に
perl コアでのサポートが継続されます.

=head2 JPL の削除

JPL (Java-Perl Lingo) は perl ソース tarball から削除されます.

=head2 再帰継承の早期検出

Perl はどこかのパッケージで再帰継承となる C<@ISA> の変更を
行うと直ぐに例外を投げるようになります.

これまでは, Perl がメソッドの解決や C<$foo-E<gt>isa($bar)> の
探索を行うために再帰継承を使おうとするまでは例外は発生していま
せんでした.

=head2 warnings::enabled and warnings::warnif changed to favor users of modules

=begin original

The behaviour in 5.10.x favors the person using the module;
The behaviour in 5.8.x favors the module writer;

=end original

5.10.x の振る舞いは、モジュールを使う人を優先します;
5.8.x の振る舞いは、モジュールの作者を優先します;

=begin original

Assume the following code:

=end original

以下のコードを仮定します:

=begin original

  main calls Foo::Bar::baz()
  Foo::Bar inherits from Foo::Base
  Foo::Bar::baz() calls Foo::Base::_bazbaz()
  Foo::Base::_bazbaz() calls: warnings::warnif('substr', 'some warning message');

=end original

  main が Foo::Bar::baz() を呼び出します
  Foo::Bar は Foo::Base を継承しています
  Foo::Bar::baz() は Foo::Base::_bazbaz() を呼び出します
  Foo::Base::_bazbaz() は: warnings::warnif('substr', 'some warning message');
  を呼び出します

=begin original

On 5.8.x, the code warns when Foo::Bar contains C<use warnings;>
It does not matter if Foo::Base or main have warnings enabled
to disable the warning one has to modify Foo::Bar.

=end original

5.8.x では、Foo::Bar が C<use warnings;> を含んでいる場合、このコードは
警告を出します。
Foo::Base か main で警告が有効になっているなら、警告を無効にするために
Foo::Bar を修正する必要があることは問題ではありません。

=begin original

On 5.10.0 and newer, the code warns when main contains C<use warnings;>
It does not matter if Foo::Base or Foo::Bar have warnings enabled
to disable the warning one has to modify main.

=end original

5.10.0 以降では、main に C<use warnings;> を含んでいる場合にこのコードは
警告を出します。
Foo::Base か Foo::Bar で警告が有効になっているなら、警告を無効にするために
main を修正する必要があること問題ではありません。

=head1 モジュールとプラグマ

=head2 個々のコアモジュールのアップグレード

より多くのコアモジュールが CPAN を通して分離しても提供されています. 
もしこれのらのモジュールのうち一つをアップデートしたいのであれば, 
新しい perl のリリースを待つ必要はありません. 
cpan シェルから, 'r' コマンドを実行することでアップグレードの
提供されているモジュールが一覧されます. 
詳細は C<perldoc CPAN> を参照してください.

=head2 プラグマの変更点

=over 4

=item C<feature>

新しいプラグマ C<feature> は古いコードが動かなくなるかもしれない
新しい機能を有効にするために使われます. 前述の L</The C<feature> pragma>
を参照してください.

=item C<mro>

この新しいプラグマは継承されたメソッドを解決するのに使う
アルゴリズムの変更を可能にします. 前述の L</New Pragma, C<mro>> を
参照してください.

=item C<sort> プラグマのスコープ

C<sort> プラグマはレキシカルスコープになります. 
この影響はかつてはグローバルでした.

=item C<bignum>, C<bigint>, C<bigrat> のスコープ

３つの数値関連のプラグマ C<bignum>, C<bigint> 及び C<bigrat> は
レキシカルスコープになります. (Tels)

=item C<base>

C<base> プラグマはあるクラスがそれ自身を継承しようとした時に
警告をするようになります. (Curtis "Ovid" Poe)

=item C<strict> 及び C<warnings>

C<strict> 及び C<warnings> は大文字小文字が不適切な形で
ロードされると(例えば C<use Strict;>)大声で訴えるように
なります.  (Johan Vromans)

=item C<version>

C<version> モジュールは version オブジェクトのサポートを提供します.

=item C<warnings>

C<warnings> プラグマは C<Carp> をロードしなくなります. 
これによってコンパイル時に C<Carp> のルーティンをロードすることなく
使っていたコードは調整する必要があります; 典型的には, 
次のような(間違った)コードは動作しなくなり, 関数名の後に括弧をつける
必要があります:

    use warnings;
    require Carp;
    Carp::confess 'argh';

=item C<less>

C<less> は便利な何かを行うようになります(若しくは少なくとも
行おうとはします). 実際に, これはレキシカルプラグマです. 
なので, 貴方のモジュールに於いて, ユーザがより少ない CPU, 
メモリ, 魔法, さらには脂肪分を要求しているのかどうかを
チェックすることができます. 詳細は L<less> を参照してください. 
(Joshua ben Jore)

=back

=head2 新しいモジュール

=over 4

=item *



C<encoding::warnings>, Audrey Tang による因る, 高位ビットを含んだ
バイトを含んでいる ASCII 文字が暗黙に UTF-8 に変換された時に
警告を発行するモジュール. Perl 5.9.4 以降であればレキシカルプラグマ, 
それより古い perl ではグローバルです.

=item *



C<Module::CoreList>, Richard Clamp に因る, Perl 5 の任意のバージョンで
コアモジュールのバージョンを教えてくれる小さなハンディモジュール. 
コマンドラインフロントエンド, C<corelist> と共に.

=item *



C<Math::BigInt::FastCalc> は XS を使った, それによって高速になったバージョンの
C<Math::BigInt::Calc> です.

=item *



C<Compress::Zlib> は zlib 圧縮ライブラリのインターフェースです. 
zlib のバンドル版と共に導入されます, その為動作する zlib を
インストールのために前もって準備する必要はありません. 
これは C<Archive::Tar> から利用されます(後述).

=item *



C<IO::Zlib> は C<IO::>-スタイルの C<Compress::Zlib> への
インターフェースです.

=item *



C<Archive::Tar> は C<tar> アーカイブを操作するための
モジュールです.

=item *



C<Digest::SHA> は多くの種類の SHA ダイジェストを計算するための
モジュールです, CPAN モジュールの SHA サポートのために
導入されました.

=item *



C<ExtUtils::CBuilder> 及び C<ExtUtils::ParseXS> が
追加されました.

=item *



C<Hash::Util::FieldHash>, Anno Siegel による. このモジュールは
I<フィールドハッシュ> のサポートを提供します: これは
値への参照の関係をスレッドセーフでガーベージコレクトされる方法で
管理するハッシュです.このようなハッシュは inside-out オブジェクトを
実装するのに便利です.

=item *



C<Module::Build>, Ken Williams に因る. これは perl モジュールを
ビルド及びインストールするための C<ExtUtils::MakeMaker> の別バージョンです.

=item *



C<Module::Load>, Jos Boumans に因る. これは Perl モジュール
及び F<.pl> ファイルをロードするための一つのインターフェースを提供します.

=item *



C<Module::Loaded>, Jos Boumans に因る. モジュールがロードされているのか
アンロードされているのかをマークするために使われます.

=item *



C<Package::Constants>, Jos Boumans に因る. これは
指定したパッケージの中で宣言されている全ての定数を一覧にする
ための簡単なヘルパーです.

=item *



C<Win32API::File>, Tye McQueen に因る (Windows ビルド時).
このモジュールはファイル/ディレクトリのための Win32 システム API 呼び出し
への低レベルなアクセスを提供します.

=item *



C<Locale::Maketext::Simple>, CPANPLUS に必要, これは
C<Locale::Maketext::Lexicon> の簡単なラッパです. 
C<Locale::Maketext::Lexicon> は perl コアには含まれていない点に注意してください;
それが提供されていない場合 C<Locale::Maketext::Simple> の振る舞いは
著しく低下します.

=item *



C<Params::Check> は汎用的な入力のパース/チェックメカニズムを
実装しています. これは CPANPLUS で使われています.

=item *



C<Term::UI> はターミナルのプロンプトで質問をするタスクを
単純にします.

=item *



C<Object::Accessor> はオブジェクト毎のアクセサを作るための
インターフェースを提供します.

=item *



C<Module::Pluggable> はプラガブルなサブモジュールを扱える
モジュールを作るための簡単なフレームワークです.

=item *



C<Module::Load::Conditional> はインストールされているモジュールを
問い合わせる, そして恐らくロードするための
簡単な方法を提供します.

=item *



C<Time::Piece> は組み込みの localtime() 及び gmtime() を
オーバーライドして時間関数へのオブジェクト指向なインターフェースを提供します.

=item *



C<IPC::Cmd> はおそらくはインタラクティブに外部コマンドを
探索そして実行することを手助けします.

=item *



C<File::Fetch> は汎用的なファイル fetch メカニズムを提供します.

=item *



C<Log::Message> 及び C<Log::Message::Simple> は
C<CPANPLUS> のログ機能に使われてます.

=item *



C<Archive::Extract> は F<.tar> (単なるそれ, gzip, 若しくはbzip)
若しくは F<.zip> ファイルのアーカイブを展開する汎用的な
メカニズムです.

=item *



C<CPANPLUS> は CPAN ミラーへアクセスするための
API 及びコマンドラインツールを提供します.

=item *



C<Pod::Escapes> は Pod の EE<lt>...E<gt> シーケンスを
デコードする便利なユーティリティを提供します.

=item *



C<Pod::Simple> は Perl に含まれるいくつかの Pod 関連のモジュール
のバックエンドになりました.

=back

=head2 コアモジュール変更点のピックアップ

=over 4

=item C<Attribute::Handlers>

C<Attribute::Handlers> は呼び出し元のファイル及び行番号を
報告てきるようになりました. (David Feldman)

全ての処理された属性は配列リファレンスとして渡されるように
なりまｓｈちあ. (Damian Conway)

=item C<B::Lint>

C<B::Lint> は C<Module::Pluggable> を基底とするようになりました,
これによってプラグインで拡張できるようになりました. (Joshua ben Jore)

=item C<B>

レキシカルプラグマヒント(C<%^H>)に
B::COP::hints_hash() メソッドを使うことでアクセスできるようになりました. 
これは C<B::RHE> オブジェクトを返し, さらに B::RHE::HASH() メソッドを
通してhハッシュリファレンスを取得するために使うことができます.
(Joshua ben Jore)

=item C<Thread>

古い 5005thread スレッドモデルは削除されました, 
ithread スキームによって, C<Thread> モジュールはそれを使っている
古いコードのみのための互換ラッパになります. これはダイナミック
拡張のデフォルトリストから削除されます.

=back

=head1 ユーティリティの変更点

=over 4

=item perl -d

Perl デバッガは後で利用するための全てのデバッガコマンドを
保存するようになりました; とりわけ, リスタートしてこの保存されたコマンド履歴から
最後のコマンドの前まで再度実行することで, 後退をエミュレートできるように
なりあした.

また与えたクラスの親継承ツリーを C<i> コマンドで表示できるように
なりました.

=item ptar

C<ptar> は C<tar> のピュアperl実装です, C<Archive::Tar> と共に
導入されます.

=item ptardiff

C<ptardiff> は tar アーカイブとディレクトリツリーとの内容の diff を
とるための小さなユーティリティです, C<Archive::Tar> と共に
導入されます.

=item shasum

C<shasum> は SHA ダイジェストを表示, 若しくは検証するための
コマンドラインユーティリティです. C<Digest::SHA> モジュールと共に
導入されます.

=item corelist

C<corelist> ユーティリティが perl と共にインストールされるように
なります(L</New modules> 参照).

=item h2ph and h2xs

C<h2ph> 及び C<h2xs> は"今風の" C コードを出力することで
より強靭になります.

C<h2xs> に後方互換モジュールであっても C<XSLoader> の使用を
強制させる C<--use-xsloader> オプションが新しく実装されます.

アポストロフィを含んだ作者名の処理が修正されました.

負の値の enum シンボルはスキップされるようになりました.

=item perlivp

C<perlivp> はデフォルトで F<*.ph> をチェックしなくなりました. 
I<全ての>テストを実行するには新しく出来た C<-a> オプションを
使うようにしてください.

=item find2perl

C<find2perl> は C<-print> をデフォルトの動作とするようになりました. 
これまではこれを明示的に指定する必要がありました.

C<-exec> 及び C<-eval> に関する C<find2perl> の幾つかのバグは修正
されました. またオプション C<-path>, C<-ipath> 及び C<-iname> が
追加されました.

=item config_data

C<config_data> は C<Module::Build> と共に導入される新しい
ユーティリティです. これは Module::Build の設定フレームワーク
(つまり, その親モジュールのためのローカル設定情報を C<*::ConfigData> が
持つ)を使っている Perl モジュールの設定のためのコマンドライン
インターフェースを提供します.

=item cpanp

C<cpanp> CPANPLUS シェルが追加されました. 
(CPANPLUS 操作のためのヘルパ, C<cpanp-run-perl>, も追加されていますが, 
これは直接の利用を意図しているものではありません).

=item cpan2dist

C<cpan2dist> は CPANPLUS と共に導入される新しいユーティリティです. 
これは CPAN モジュールから配布物(若しくはパッケージ)を作るための
ツールです.

=item pod2html

C<pod2html> の出力が CSS でカスタマイズでよりカスタマイズ
できるように強化されました. 
幾つかの整形上の問題も修正されました. (Jari Aalto)

=back

=head1 新しいドキュメント

L<perlpragma> マニュアルページには自分用の
レキシカルプラグマを Perl のみで書く方法が記載されています
(これは 5.9.4 から可能です).

L<perlglossary> は Perl ドキュメントで使われている技術的, 及びその他の
単語の用語集です, 親切な O'Reilly Media, Inc. から提供されました.

Yves Orton の好意による L<perlreguts> マニュアルページには
Perl 正規表現エンジンの内部が記述されています.

L<perlreapi> マニュアルページにはプラガブルな
正規表現エンジンを書くための perl インタプリタへの
インターフェースが記述されています. 
(by E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason).

L<perlunitut> マニュアルページは Perl での Unicode 及び
文字列エンコーディングを使ったプログラミングのための
チュートリアルです, Juerd Waalboer の好意によります.

L<perlunifaq> (Perl Unicode FAQ) が追加されました  (Juerd Waalboer).

L<perlcommunity> マニュアルページではインターネット上及び
実生活上での Perl コミュニティについての説明がされています. 
(Edgar "Trizor" Bering)

L<CORE> マニュアルページには C<CORE::> 名前空間について記述されています.

だいぶ前から存在していた C</(?{...})/> 正規表現が
C<$_> 及び pos() を設定する機能がドキュメント化されました.

=head1 パフォーマンスの強化

=head2 インプレースなソート

配列のインプレースなソート (C<@a = sort @a>) は
配列の一時的な複製を作らないよう最適化されるようになりました.

同じように, C<reverse sort ...> も一時的な中間リストの生成を押さえて
逆順にソートするように最適化されました.

=head2 レキシカルな配列へのアクセス

0 から 255 の間で数値定数によってレキシカルな配列の要素に
アクセスするのが高速になりました. 
(これはグローバルな配列でのみ行われていました)

=head2 XS による SWASHGET

Unicode 属性及び変換マップを取得するために使われていた幾つかのpure-perlコードは
XS で再実装されました.

=head2 定数関数

インタプリタ内部に於いてよりメモリ効率の良いインライン定数の形式が
サポートされました. シンボルテーブルに定数のリファレンスを格納すると, 
それは定数関数を参照する完全なタイプグロブと等価ですが, 
およそ 400 バイトメモリを節約します. この代理定数関数は
必要であれば関数を持った実際のタイプグロブに
自動的にアップグレードされます. ここで採用しているアプローチは, 
関数スタブの宣言で使われている, 完全なタイプグロブの代わりに
プレインなスカラーを格納するという既存の空間最適化と似たものです.

幾つかのコアモジュールがシステムに依存する定数において
この機能を使うように変換されました - この結果
C<use POSIX;> はおよそ 200K 程メモリ消費が削減されました.

=head2 C<PERL_DONT_CREATE_GVSV>

perl 5.8.8 で任意として導入された新しいコンパイルフラグ
C<PERL_DONT_CREATE_GVSV> は perl 5.9.3 からデフォルトで使われるように
なりました. これは新しいタイプグロブに対して空のスカラーを生成していたのを
抑制するようになります. 詳細は L<perl589delta> を参照してください.

=head2 弱い参照のコスト減少

Nicholas Clark の好意により, 弱い参照は I<O(n)> ではなく 
I<O(1)> で作成できるようになりました. 削除は I<O(n)> のままですが, 
削除がプログラムの終了でのみ発生するのなら, これは完全にスキップされます.

=head2 sort() の強化

Salvador FandiE<ntilde>o は C<sort> のメモリ抑制と幾つかのケースでの
高速化の実装を提供してくれました.

=head2 メモリの最適化

幾つかの内部データ構造(タイプグロブ, GV, CV, フォーマット)は
メモリ効率が良くなるよう再構成されました. (Nicholas Clark)

=head2 UTF-8 キャッシュの最適化

UTF-8 キャッシュを行うコードがより効率的になり,
より使われるようになりました.  (Nicholas Clark)

=head2 Windows でのおおざっぱな stat

Windows において, perl の stat() 関数はリンク数を調べるため及び
ハードリンクによって属性が変更されていないかを調べるために
通常はファイルをオープンしています. ${^WIN32_SLOPPY_STAT} を
真にするとこの処理を抑制することで stat() の速度が改善します.
(Jan Dubois)

=head2 正規表現の最適化

=over 4

=item エンジンの非再帰化

正規表現エンジンは再帰を行わなくなりました, 
これによってスタックを使い果たしていたようなパターンは
もっと役に立つ説明を伴って die するか, ちゃんと実行できるように
なりました, それらは以前であればスタックを打ちのめすことが
できましたが, それにはとても長い時間がかかるでしょう. 
もしそのようなスタックあふれ(若しくはsegfault)を経験していて
今の perl もどうやらハングするらしいことを見つけたら,
悪化した正規表現を探してみてください. (Dave Mitchell)

=item １文字の文字クラスはリテラル扱いに

１文字からなる文字クラスはリテラルと同じように扱われるように
なりました, これはエスケープ代わりに文字クラスを
使っているようなコードで高速化となるでしょう. (Yves Orton)

=item リテラル文字列代替のトライ最適化

代替は, 可能であれば, より効率的なマッチング構造へと
最適化されるようになりました. 文字列リテラル代替は
トライへとメージされ, 同時にマッチが行われます. 
これはある地点で N 個の代替のマッチを行うのに O(N) 
かかっていたのに対し, 新しいコードでは O(1) で処理
されるようになります. 
新しい特殊変数, ${^RE_TRIE_MAXBUF} が, この最適化を
調整するために追加されました. (Yves Orton)

B<補足:> 代替において perl の経験的で貧弱な
パフォーマンスに対処させているコードはたくさんあります. 
それを行うためにしばしば使われているトリックは
新しい最適化では効果がなくなるでしょう. 願わくば, 
この目的のために使われているユーティリティモジュールが
新しい最適化についての教育を受けますように.

=item Aho-Corasick 法による開始位置の最適化

パターンがトライ化可能な選択で始まっていてよりよい最適化が
なかった場合, 正規表現エンジンは開始位置を探すために 
Aho-Corasick マッチを使います. (Yves Orton)

=back

=head1 インストールとコンフィグレーションの改善

=head2 設定の向上

=over 4

=item C<-Dusesitecustomize>

@INC の実行時カスタマイズは Configure に 
C<-Dusesitecustomize> を渡すことで有効になります. 
これが有効になると, すべてに先立って F<$sitelibexp/sitecustomize.pl>
を実行するようになります. このスクリプトで @INC に
追加の項目を加えるようなセットアップができます.

=item 再配置可能なインストール

再配置可能な perl ツリーを作るための新しい Configure 
サポートができました. C<-Duserelocatableinc> で Configure 
を行うと, @INC (及び %Config にあるその他の全て)が
perl 実行形式のパスを通して配置することが任意でできるようになります.

これはつまり, パスの最初に C<".../"> という文字列が
見つかったら, それが $^X のディレクトリで置換されます. 
つまり, 再配置はディレクトリ単位で設定することができます, 
けれども C<-Duserelocatableinc> のデフォルトでは全てが
再配置されます. 最初のインストールはオリジナルの 
configure された prefix に行われます.

=item strlcat() 及び strlcpy()

configuration プロセスで strlcat() 及び strlcpy() が
提供されているかを検出するようになりました. 
これらが提供されていなかったときには, perl の
自分で持っているバージョンが使われます(Russ Allbery
のパブリックドメイン実装より). 
perl インタプリタの様々な場所でこれらが使われるように
なりました. (Steve Peters)

=item C<d_pseudofork> 及び C<d_printf_format_null>

新しい設定変数, C<$Config{d_pseudofork}> が L<Config> モジュールに
追加されました, これによって実際の fork() のサポートを
Windows プラットフォームにおいて使われている疑似forkと
区別することができるようになります.

新しい設定変数 C<d_printf_format_null> が追加され, 
これによって printf-ライクの書式で NULL が許されるかを
確認することができます.

=item 設定のヘルプ

C<Configure -h> はよく使われるオプションに
拡張されました.

=back

=head2 コンパイルの向上

=over 4

=item 並列ビルド

並列 make が適切に動作するようになります, 
けれども C<make test> は並列に実行されるとまだ問題があります.

=item Borland コンパイラのサポート

Borland の Win32 でのコンパイラがよりスムーズに
動作するようになりました. 特に Steve Hay はそれらの
コンパイラで発行される多くの警告と, 少なくとも1つの
C コンパイラの内部エラーを取り除いてくれました.

=item Windows でのスタティックビルド

Windows での Perl 拡張は Perl DLL に静的にビルドできるように
なりました.

また, Win32 において Perl DLL に依存しない C<perl-static.exe>
をビルドできるようにもなりました. 詳細は Win32 makefile群を
参照してください. 
(Vadim Konovalov)

=item ppport.h ファイル

perl に同梱されている XS モジュールの全ての F<ppport.h> ファイルは
ビルド時に自動生成されるようになりました. (Marcus Holland-Moritz)

=item C++ との互換性

perl 及びコアとなる XS モジュールが様々な C++ コンパイラと
互換がとれるように取り組みが行われました(けれども
テストされた幾つかのプラットフォームでの幾つかの
コンパイラでは完全はありません)

=item Microsoft 64-bit コンパイラのサポート

Microsoft の 64-bit コンパイラでの perl ビルドの
サポートが改善されました. (ActiveState)

=item Visual C++

Perl は Microsoft Visual C++ 2005 (及び 2008 Beta 2) で
コンパイルできるようになりました.

=item Win32 ビルド

全ての win32 ビルド (MS-Win, WinCE)は統合され, 整理されました.

=back

=head2 インストールの向上

=over 4

=item モジュール補助ファイル

perl に同梱されている CPAN モジュールの README ファイル及び
changelog はもはやインストールされなくなりました.

=back

=head2 新しい及び向上したプラットフォーム

Symbian OS での Perl の稼働が報告されました. 
詳細は L<perlsymbian> を参照してください.

z/OS で Perl を正しく動作させるようにする多くの改善が
行われました.

DragonFlyBSD 及び MidnightBSD での Perl の稼働が報告されました.

NexentaOS での Perl 動作報告も受けました
( http://www.gnusolaris.org/ ).

VMS ポートが改善しました. L<perlvms> を参照してください.

Cray XT4 Catamount/Qk のサポートが追加されました. 
詳細はソース配布物内の F<hints/catamount.sh> を
参照してください.

RedHat 及び Gentoo のベンダーパッチがマージされました.

DynaLoader::dl_unload_file() が Windows でも
動作するようになりました.

=head1 バグ修正のピックアップ

=over 4

=item regexp-eval ブロックにおける strict

C<strict> は regexp-eval ブロック (C</(?{...})/>) には影響していませんでした.

=item CORE::require() の呼び出し

CORE::require() 及び CORE::do() はオーバーライドされている時は
require() and do() に常にパースされていました. これは修正されました.

=item スライスの添字

次のように, リストスライスの後は添字のチェインに矢印の無い形式を
使えるようになりました:

    ({foo => "bar"})[0]{foo}

これはこれまでは構文エラー; C<< -> >> が必要です(a C<< -> >> was required)
となっていました.

=item C<no warnings 'category'> は -w でも正しく動作するようになりました

これまではC<-w>によって全体的に警告が有効な状態で実行していると, 
特定の警告カテゴリの選択的無効化は実際には全ての警告を
解除していました. これは修正されました; C<no warnings 'io';>
は C<io> クラスに属する警告のみを解除するようになりました. 
これまでは誤って全ての警告を解除していました.

=item スレッドの改善

ithreads における幾つかのメモリリークは収束しました. 
また, メモリ消費量具合が減少しました.

C<threads> はデュアルライフモジュールになり, 
CPAN でも提供されるようになります. 
これは多くの方法を展開します. 
スレッドシグナルのために kill() メソッドが提供されます. 
これはスレッドの状態, 若しくは実行中若しくはjoin可能な
スレッドのリストを取得できます.

新しい C<< threads->exit() >> を使って, 
アプリケーションを終了(メインスレッドでのデフォルト)若しくは
現在のスレッドのみを終了(それ以外の全てのスレッドでのデフォルト)が
行えるようになります. 一方, exit() 組み込み関数は, 
常にアプリケーション全体を終了させるようになります. 
(Jerry D. Hedden)

=item chr() と負の値

負の値での chr() は C<\x{FFFD}>, Unicode 置き換え文字を
返すようになります, C<bytes> プラグマの影響下ではそうではなく, 
下位 8 ビットの値が使われます.

=item PERL5SHELL と taint

Windows 環境において, PERL5SHELL 環境変数の taint 性が
確認されるようになります. (Rafael Garcia-Suarez)

=item *FILE{IO} の活用

C<stat()> 及び C<-X> ファイルテストは *FILE ファイルハンドルのように
*FILE{IO} ファイルハンドルを扱います.  (Steve Peters)

=item オーバーロードと再bless

リファレンスが別のクラスへと bless し直された時でも
オーバーロードが正しく動作するようになりました.
内部的には, これは"オーバーロードしている"フラグを
リファレンスからリファレンスへと必要な場所で常に
移動していくことで実装しています. (Nicholas Clark)

=item オーバーロードと UTF-8

文字列化をオーバーロードしているオブジェクトでの
UTF-8 処理に関連する幾つかのバグが修正されました. 
(Nicholas Clark)

=item eval メモリリークの修正

伝統的に, C<eval 'syntax error'> は悪いことにリークしていました. 
多くの(けれども全てではない)これらのバグは除去若しくは軽減
されました. (Dave Mitchell)

=item Windows でのランダムデバイス

これまでのバージョンにおいて, ランダム生成器の種をとる時に, 
F</dev/urandom> が存在していればそれを読んでいました. 
このファイルが Windows で運の悪いことに存在していても, 
それは恐らく適切なデータを含んでいないので, Windows では
このファイルを読まないようになりました. (Alex Davies)

=item PERLIO_DEBUG

C<PERLIO_DEBUG> 環境変数は setuid スクリプト及び
B<-T> で実行されているスクリプトでは影響を持たなくなりました.

さらに, スレッドが有効な perl において, 
C<PERLIO_DEBUG> の利用は内部的なバッファオーバーフローの
元となっていました. これは修正されました.

=item PerlIO::scalar と読み込み専用のスカラー

PerlIO::scalar は読み込み専用のスカラーに書き込まないように
なりました. さらに, PerlIO::scalar ベースのファイルハンドルで
seek() がサポートされるようになりました, 元となっている文字列は
必要であればゼロで埋められます. (Rafael, Jarkko Hietaniemi)

=item study() 及び UTF-8

study() は UTF-8 文字列では動作しておらず, 間違った結果を
返すだけでした. これは UTF-8 データではなにもしないように
なりました. (Yves Orton)

=item 致命的なシグナル

SIGILL, SIGBUS 及び SIGSEGV の各シグナルは, 
常に"安全でない"形式で配送されるようになります
(perl インタプリタが安定した状態に達するまで
遅延させる他のシグナルとは異なります; 
L<perlipc/Deferred Signals (Safe Signals)> を
参照してください). (Rafael)

=item @INC-フックの修正

@INC フックを通してモジュール若しくはファイルがロードされた時,
及びこのフックが %INC にファイル名を設定したとき, 
そのモジュールのための __FILE__ は %INC エントリの内容に即したものが
設定されます. (Rafael)

=item C<-t> スイッチの修正

C<-w> 及び C<-t> スイッチを一緒に使った時に
有効になる警告のカテゴリを失うこと無く使えるようになります. (Rafael)

=item UTF-8 ファイルハンドルの dup

C<:utf8> PerlIO レイヤを持っているファイルハンドルを
dup した時に dup されたファイルハンドルのレイヤにも
適切に運ぶようになります. (Rafael)

=item ハッシュ要素の local 化

ハッシュの要素を変数をキーとして local 化したとき, 
local() の効果のあるうちにキーとした変数の値が
変更された時に(C<local $h{$x}; ++$x> のように)
正しく動作していませんでした. (Bo Lindbergh)

=back

=head1 新しく追加された及び変更された診断メッセージ

=over 4

=item 初期化されていない値の使用

Perl は未定義だった変数の名前を(もしあれば)伝えようと
試みるようになります.

=item 廃止された到達しない条件下での my() の使用

新しい廃止警告, I<Deprecated use of my() in false conditional>
(廃止された, 到達しない条件下での my() の使用)が追加されました, 
これは曖昧で廃止された構築に対して警告します.

    my $x if 0;

L<perldiag> を参照してください. 代わりに C<state> 変数を使ってください.

=item !=~ は !~ とするべきです

否定マッチ演算子のスペルミスを防止するために, 
新しい警告, C<!=~ should be !~>, が発行されます.

=item 左詰めの文字列の改行

警告 I<Newline in left-justified string> は削除されました.

=item "-T" オプションには遅すぎます

エラー I<Too late for "-T" option> はより分かり易くするために
再編成されました.

=item "%s" 変数 %s は以前の宣言を隠します

この警告はより矛盾の無いケースで発行されます;
簡単に言うと, 呼び出される宣言は C<my> 変数です:

    my $x;   my $x;	# warns
    my $x;  our $x;	# warns
    our $x;  my $x;	# warns

一方,

    our $x; our $x;

これは C<"our" variable %s redeclared> 警告となります.

=item readdir()/closedir()/etc. 無効なディレクトリハンドルで処理されました

ディレクトリハンドルが使われているけれど閉じているか実際には
ディレクトリハンドルでは無い時に
これらの新しい警告が発行されます.

=item 開こうとしている dirhandle/filehandle %s は file/directory でもあります

2つの廃止警告が追加されました: (Rafael)

    Opening dirhandle %s also as a file
    Opening filehandle %s also as a directory

=item -P の使用は廃止されます

Perl のコマンドラインスイッチ C<-P> は廃止されます.

=item use/require での v-string はポータブルではありません

C<use VERSION> 構文での潜在的な後方互換問題を警告するようになります.

=item perl -V

C<perl -V> で幾つか改善があります, 
シェルスクリプトから設定変数の値を取り出し易くしています. 
詳細は L<perlrun> を参照してください.

=back

=head1 内部処理の変更

一般的に, perl のソースコードは様々な場所でリファクタリングされ, 
整頓され, そして最適化されました. また, メモリ管理及び
確保は幾つかの点で改善されました.

perl コアを gcc でコンパイルするとき, 
そのプラットフォームで可能なだけの gcc 警告フラグが
有効にされます. (この清潔探訪は XS コードには
適用されません, なぜなら私たちが書いたわけではないコードの
きれいさは保証できないからです.) 他の C コンパイラでは
strict フラグのようなものが追加もしくは適用されます.

=head2 SVt_* 定数の再配置

幾つかのタイプの C<SV> を定義する定数の相対的な順序が変更されました;
特に, C<SVt_PVGV> は C<SVt_PVLV>, C<SVt_PVAV>, C<SVt_PVHV> そして C<SVt_PVCV>
の前に移動しました. これは明示的にその順序を前提としている
コードを持っているのでなければ何らかの違いを作るでしょう. (C<B::*>
オブジェクトの継承階層はこれを反映して変更されました.)

=head2 SVt_PVBM の除去

これに関連して, 内部的なタイプ C<SVt_PVBM> は削除されました. 
この C<SV> の献身的なタイプは C<index> 演算子と正規表現エンジンの
一部で, 高速な Boyer-Moore マッチを補助するために使われていました. 
この利用は内部的にタイプ C<SVt_PVGV> の C<SV> によって置き換えられました.

=head2 新しいタイプ SVt_BIND

新しいタイプ C<SVt_BIND> が追加されました, Perl 5 で Perl 6 を
実装するプロジェクトを考慮してです. これは意図的に実装されていません,
そして作成も破棄もされません.

=head2 CPP シンボルの除去

渡したバージョンに対して一番古いバイナリ互換のある perl のバージョンを
与えると推測される C プリプロセッサシンボル C<PERL_PM_APIVERSION> 及び
C<PERL_XS_APIVERSION> は利用されておらず, 
時々間違った値を返しています. 
これらは削除されます.

=head2 op に必要な空間の削減

C<BASEOP> 構造はより省スペースになりました. 
C<op_seq> フィールドは削除され, １ビットのビットフィールド C<op_opt> 
に沖かられました. C<op_type> は 9 bit 長になりました. 
この結果, C<B::OP> クラスは C<seq> メソッドを提供しなくなります.)

=head2 新しいパーサ

perl のパーサが bison で生成されるようになりました
(これまでは byacc で生成されていました).
この結果, ちょこっと強靭になると思います.

また, Dave Mitchell は C<-DT> における字句解析デバッグ出力を改善しました.

=head2 C<const> の使用

Andy Lester はどの関数パラメータやローカル変数が実際には
C コンパイラに対して C<const> で宣言することが出来るかを
決定するための多くの改良を提供してくれました. 
Steve Peters は新しい C<*_set> マクロを提供し, 
コアが LVALUE コンテキストでマクロに代入する代わりに
これらを使うように書き直してくれました.

=head2 Mathoms

新しいファイル, F<mathoms.c> が追加されました. 
これには perl コアでは使われていないけれど
バイナリ若しくはソース互換性の理由から提供を続ける関数が
含まれています. とはいってもこれらの関数は
コンパイラフラグに C<-DNO_MATHOMS> を加えるとコンパイルされなくなります.

=head2 C<AvFLAGS> は削除されました

C<AvFLAGS> マクロは削除されました.

=head2 C<av_*> の変更

配列を操作するために使われる C<av_*()> 関数は
null の C<AV*> パラメータを受理しなくなりました.

=head2 $^H 及び %^H

特殊変数 $^H 及び %^H の実装が, pure Perl で
レキシカルプラグマを実装できるように変更されました.

=head2 B:: モジュールの継承の変更

C<B::> モジュールの継承階層が変更されました. 
C<B::NV> は C<B::SV> から継承されるようになります
(以前は C<B::IV> から継承していました).

=head2 無名のハッシュ及び配列の構築子

無名のハッシュ及び配列の構築子は optree において 3 つから 1 つの
op となりました, pp_anonhash 及び pp_anonlist は
op に OPf_SPECIAL フラグが経っている時にはハッシュ/配列への
リファレンスを返すようになります. (Nicholas Clark)

=head1 既知の問題

レキシカルな C<$_> の実装における問題があります:
これは C</(?{...})/> ブロックの内側では動作しません.
(F<t/op/mydef.t> にある TODO テストを参照)

スタックされたファイルテスト演算子は C<filetest>
プラグマの影響下では動作しません, なぜならそれらは C<_> の
stat() バッファを利用していますが, filetest は stat() を
バイパスするためです.

=head2 UTF-8 に関する問題

Unicode の処理は幾つかの箇所で文字列が内部的に UTF-8 フラグを
持っているかに依存して明白になっていません.
これは perl 5.12 でより奇麗になるでしょう, しかしそれには
ある程度の後方互換の消失がさけられません.

=head1 プラットホーム固有の問題

Linux 上で g++ 及びスレッドサポートでコンパイルすると,
C<$!> が正常な動作をしていないと報告されます.
これは glibc が２つの strerror_r(3) の実装を
提供していて, perl は正しくない方を選択してしまうことに
起因します.

=head1 バグ報告

もしバグと思われるものが見つかったら, comp.lang.perl.misc ニュース
グループに最近投稿された記事や http://rt.perl.org/rt3/ にある perl 
バグデータベースを確認してください. 
Perl ホームページ, http://www.perl.org/ にも情報はあります.

もしまだ報告されていないバグだと確信したら, そのリリースに含まれている
B<perlbug> プログラムをを実行してください. バグの再現スクリプトを
十分小さく, しかし有効なコードに切りつめることを意識してください. 
バグレポートは C<perl -V> の出力と一緒に perlbug@perl.org に送られ 
Perl porting チームによって解析されます.

=head1 関連項目

F<Changes> 及び perl590delta から perl595delta の
マニュアルページ群に完全な変更箇所があります.

F<INSTALL> には Perl をビルドする方法があります.

F<README> には一般的な事項があります.

F<Artistic> 及び F<Copying> には著作権情報があります.

=begin meta

Translate: 山科 氷魚 (YAMASHINA Hio) <hio@hio.jp> (5.10.0)
Update: Kentaro Shirakata <argrath@ub32.org> (5.10.1-)

=end meta

