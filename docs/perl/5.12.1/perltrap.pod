
=encoding euc-jp

=head1 NAME

=begin original

perltrap - Perl traps for the unwary

=end original

perltrap - 不注意による Perl の罠

=head1 DESCRIPTION

=begin original

The biggest trap of all is forgetting to C<use warnings> or use the B<-w>
switch; see L<perllexwarn> and L<perlrun>. The second biggest trap is not
making your entire program runnable under C<use strict>.  The third biggest
trap is not reading the list of changes in this version of Perl; see
L<perldelta>.

=end original

最も大きな罠とは、C<use warnings> あるいは B<-w> スイッチを使うのを
忘れてしまうということです;  L<perllexwarn> と L<perlrun> を
参照してください。
二番目に大きな罠とは、あなたのプログラム全体を C<use strict> の元で
実行しないということです。
三番目の罠は、このバージョンの Perl での変更点を読まないということです;
L<perldelta> を参照してください。

=head2 Awk Traps

(awk の罠)

=begin original

Accustomed B<awk> users should take special note of the following:

=end original

B<awk> に慣れた方は、以下のようなことに特に注意してください:

=over 4

=item *

=begin original

A Perl program executes only once, not once for each input line.  You can
do an implicit loop with C<-n> or C<-p>.

=end original

Perl のプログラムは、1 度だけ実行されます; 入力行毎ではありません。
C<-n> や C<-p> を使って暗黙のループを使えます。

=item *

=begin original

The English module, loaded via

=end original

Englishモジュールを

    use English;

=begin original

allows you to refer to special variables (like C<$/>) with names (like
$RS), as though they were in B<awk>; see L<perlvar> for details.

=end original

のようにしてロードすれば、B<awk> でそうであったように
(C<$/> のような)特殊変数を($RS のような)名前で参照することができます。
詳しくは L<perlvar> を参照してください。

=item *

=begin original

Semicolons are required after all simple statements in Perl (except
at the end of a block).  Newline is not a statement delimiter.

=end original

Perlでは、すべての単純文(simple statement)の末尾にセミコロンが必要です
(ブロックの最後に置かれたときを除きます)。
改行は文の区切りとはなりません。

=item *

=begin original

Curly brackets are required on C<if>s and C<while>s.

=end original

C<if> や C<while> では中かっこが必要です。

=item *

=begin original

Variables begin with "$", "@" or "%" in Perl.

=end original

Perlでは、変数は“$”"か“@”か“%”で始まります。

=item *

=begin original

Arrays index from 0.  Likewise string positions in substr() and
index().

=end original

配列の添え字は 0 から始まります。
substr() や index() での文字列の位置も同様です。

=item *

=begin original

You have to decide whether your array has numeric or string indices.

=end original

配列の添え字が数値であるか、文字列であるかを決めなければなりません。

=item *

=begin original

Hash values do not spring into existence upon mere reference.

=end original

ハッシュ(連想配列)の値は、単に参照するだけでは存在することに
なりません。

=item *

=begin original

You have to decide whether you want to use string or numeric
comparisons.

=end original

比較を文字列によって行うのか、数値によって行うのかを
決めなければなりません。

=item *

=begin original

Reading an input line does not split it for you.  You get to split it
to an array yourself.  And the split() operator has different
arguments than B<awk>'s.

=end original

入力を読み込むだけでは split は行われません。
配列への split は自分で行います。
また、split() 演算子の引数は B<awk> のものと異なっています。

=item *

=begin original

The current input line is normally in $_, not $0.  It generally does
not have the newline stripped.  ($0 is the name of the program
executed.)  See L<perlvar>.

=end original

通常、カレント行は $0 ではなく $_ にあります。
一般的に、改行は取り除かれません。
($0 には実行しているプログラムの名前があります)。
L<perlvar> を参照してください。

=item *

=begin original

$<I<digit>> does not refer to fields--it refers to substrings matched
by the last match pattern.

=end original

$<I<digit>> はフィールドを参照しません。
これは直前に行ったパターンマッチングの部分文字列を参照します。

=item *

=begin original

The print() statement does not add field and record separators unless
you set C<$,> and C<$\>.  You can set $OFS and $ORS if you're using
the English module.

=end original

print() 文は、C<$,> や C<$\> に値を設定しない限りフィールド区切り子や
レコード区切り子を付加しません
English モジュールを使っていれば、$OFS や $ORS に対して設定することでも
OK です。

=item *

=begin original

You must open your files before you print to them.

=end original

ファイルに対して出力する前には、そのファイルをあらかじめオープンして
おかなければなりません。

=item *

=begin original

The range operator is "..", not comma.  The comma operator works as in
C.

=end original

範囲演算子は“..”であって、カンマではありません。
カンマ演算子は C と同じような振る舞いをします。

=item *

=begin original

The match operator is "=~", not "~".  ("~" is the one's complement
operator, as in C.)

=end original

マッチ演算子は“=~”であって、“~”ではありません。
(“~”はCと同様に、1の補数を取る演算子です)。

=item *

=begin original

The exponentiation operator is "**", not "^".  "^" is the XOR
operator, as in C.  (You know, one could get the feeling that B<awk> is
basically incompatible with C.)

=end original

べき乗の演算子は“**”であって、“^”ではありません。
“^”は C と同様、XOR 演算子です。
(B<awk> が基本的に C と非互換であることにお気付きかもしれませんね)。

=item *

=begin original

The concatenation operator is ".", not the null string.  (Using the
null string would render C</pat/ /pat/> unparsable, because the third slash
would be interpreted as a division operator--the tokenizer is in fact
slightly context sensitive for operators like "/", "?", and ">".
And in fact, "." itself can be the beginning of a number.)

=end original

連接演算子は“.”であって、空文字列ではありません。
(空文字列を使ってしまうと C</pat/ /pat/> が、その 3 番目のスラッシュが
除算演算子と解釈されてしまうので正しく解析できなくなります。
Perl の字句解析器は "/", "?", ">" といった演算子に対して
多少文脈依存となっています。
実際、"." 自身も数値の始まりとなる可能性もあります。)

=item *

=begin original

The C<next>, C<exit>, and C<continue> keywords work differently.

=end original

キーワード C<next>, C<exit>, C<continue> の振る舞いが異なります。

=item *

=begin original

The following variables work differently:

=end original

以下の変数の働きが異なります。

      Awk	Perl
      ARGC	scalar @ARGV (compare with $#ARGV)
      ARGV[0]	$0
      FILENAME	$ARGV
      FNR	$. - something
      FS	(whatever you like)
      NF	$#Fld, or some such
      NR	$.
      OFMT	$#
      OFS	$,
      ORS	$\
      RLENGTH	length($&)
      RS	$/
      RSTART	length($`)
      SUBSEP	$;

=item *

=begin original

You cannot set $RS to a pattern, only a string.

=end original

$RS に正規表現をセットすることはできません; できるのは文字列だけです。

=item *

=begin original

When in doubt, run the B<awk> construct through B<a2p> and see what it
gives you.

=end original

妙だと思ったときには B<awk> の構文を B<a2p> に通して、出力されたものを
見てみましょう。

=back

=head2 C/C++ Traps

(C/++ の罠)

=begin original

Cerebral C and C++ programmers should take note of the following:

=end original

知的な C と C++ のプログラマは以下のことに注意すべきです:

=over 4

=item *

=begin original

Curly brackets are required on C<if>'s and C<while>'s.

=end original

C<if> や C<while> には中かっこが必要です。

=item *

=begin original

You must use C<elsif> rather than C<else if>.

=end original

C<else if> ではなく、C<elsif> を使わなければなりません。

=item *

=begin original

The C<break> and C<continue> keywords from C become in Perl C<last>
and C<next>, respectively.  Unlike in C, these do I<not> work within a
C<do { } while> construct.  See L<perlsyn/"Loop Control">.

=end original

C の C<break> と C<continue> は、Perl ではそれぞれ C<last> と
C<next> となります。
C とは異なり、これらは C<do { } while> 構文では I<使えません>。
L<perlsyn/"Loop Control"> を参照してください。

=item *

=begin original

The switch statement is called C<given/when> and only available in
perl 5.10 or newer. See L<perlsyn/"Switch statements">.

=end original

switch 文は C<given/when> と呼ばれ、perl 5.10 以降でのみ利用可能です。
L<perlsyn/"Switch statements"> を参照してください。

=item *

=begin original

Variables begin with "$", "@" or "%" in Perl.

=end original

Perlでは、変数は“$”"か“@”か“%”で始まります。

=item *

=begin original

Comments begin with "#", not "/*" or "//".  Perl may interpret C/C++
comments as division operators, unterminated regular expressions or
the defined-or operator.

=end original

コメントの始まりは、“#”であり、“/*”や "//" ではありません。
Perl は C/C++ のコメントを除算演算子、終端していない正規表現、
定義性和演算子として解釈するかもしれません。

=item *

=begin original

You can't take the address of anything, although a similar operator
in Perl is the backslash, which creates a reference.

=end original

なにかのアドレスを得ることはできません。
Perl には似たような演算子であるバックスラッシュがありますが、これは
リファレンスを生成します。

=item *

=begin original

C<ARGV> must be capitalized.  C<$ARGV[0]> is C's C<argv[1]>, and C<argv[0]>
ends up in C<$0>.

=end original

C<ARGV> は大文字でなければなりません。
C<$ARGV[0]> が C での C<argv[1]> に相当し、C<argv[0]> にあたるものは
C<$0> です。

=item *

=begin original

System calls such as link(), unlink(), rename(), etc. return nonzero for
success, not 0. (system(), however, returns zero for success.)

=end original

link(), unlink(), rename() などのシステムコールは、成功時に
0 ではなく非 0 の値を返します。
(但し、system() は成功時に 0 を返します。)

=item *

=begin original

Signal handlers deal with signal names, not numbers.  Use C<kill -l>
to find their names on your system.

=end original

シグナルハンドラは、シグナル番号ではなくシグナル名を扱います。
使用できるシグナル名は、kill -l として確かめてください。

=back

=head2 Sed Traps

(sed の罠)

=begin original

Seasoned B<sed> programmers should take note of the following:

=end original

熟練した B<sed> プログラマは以下のことに注意すべきです:

=over 4

=item *

=begin original

A Perl program executes only once, not once for each input line.  You can
do an implicit loop with C<-n> or C<-p>.

=end original

Perl のプログラムは、1 度だけ実行されます; 入力行毎ではありません。
C<-n> や C<-p> を使って暗黙のループを使えます。

=item *

=begin original

Backreferences in substitutions use "$" rather than "\".

=end original

置換における後方参照には、“\”ではなく“$”を使います。

=item *

=begin original

The pattern matching metacharacters "(", ")", and "|" do not have backslashes
in front.

=end original

"(", ")", "|" といったパターンマッチのメタキャラクタは、その直前に
バックスラッシュを置く必要はありません。

=item *

=begin original

The range operator is C<...>, rather than comma.

=end original

範囲演算子は C<...> であって、カンマではありません。

=back

=head2 Shell Traps

(shell の罠)

=begin original

Sharp shell programmers should take note of the following:

=end original

鋭いシェルプログラマは以下のことに注意すべきです:

=over 4

=item *

=begin original

The backtick operator does variable interpolation without regard to
the presence of single quotes in the command.

=end original

バッククォート演算子は、コマンド内にシングルクォートがあっても
変数の展開を行ないます。

=item *

=begin original

The backtick operator does no translation of the return value, unlike B<csh>.

=end original

バッククォート演算子は B<csh> とは違って、返された値を変換しません。

=item *

=begin original

Shells (especially B<csh>) do several levels of substitution on each
command line.  Perl does substitution in only certain constructs
such as double quotes, backticks, angle brackets, and search patterns.

=end original

シェル (特に B<csh>) は、コマンドラインごとに何段階もの置換を行ないます。
Perl はダブルクォート、バッククォート、山かっこ、検索パターンといった
特定の構造でだけ置換を行ないます。

=item *

=begin original

Shells interpret scripts a little bit at a time.  Perl compiles the
entire program before executing it (except for C<BEGIN> blocks, which
execute at compile time).

=end original

シェルは一度に少しずつ解釈を行ないます。 
Perl は実行前にプログラム全体をコンパイルします
(コンパイル時に実行される C<BEGIN> ブロックを除く)。

=item *

=begin original

The arguments are available via @ARGV, not $1, $2, etc.

=end original

引数は $1, $2 などではなく、@ARGV から得られます。

=item *

=begin original

The environment is not automatically made available as separate scalar
variables.

=end original

環境変数は、自動的には独立したスカラ変数として利用できるように
なりません。

=item *

=begin original

The shell's C<test> uses "=", "!=", "<" etc for string comparisons and "-eq",
"-ne", "-lt" etc for numeric comparisons. This is the reverse of Perl, which
uses C<eq>, C<ne>, C<lt> for string comparisons, and C<==>, C<!=> C<< < >> etc
for numeric comparisons.

=end original

シェルの C<test> は "=", "!=", "<" などを文字列比較に使い、"-eq", "-ne",
"-lt" などを数値比較に使います。
これは Perl とは逆です; Perl では C<eq>, C<ne>, C<lt> を文字列比較に使い、
C<==>, C<!=> C<< < >> などを数値比較に使います。

=back

=head2 Perl Traps

(Perl の罠)

=begin original

Practicing Perl Programmers should take note of the following:

=end original

実践的な Perl プログラマは以下のことに注意すべきです:

=over 4

=item *

=begin original

Remember that many operations behave differently in a list
context than they do in a scalar one.  See L<perldata> for details.

=end original

多くの演算子がリストコンテキストとスカラコンテキストとで
振る舞いが変わることを忘れないでください。
詳しくは L<perldata> を参照してください。

=item *

=begin original

Avoid barewords if you can, especially all lowercase ones.
You can't tell by just looking at it whether a bareword is
a function or a string.  By using quotes on strings and
parentheses on function calls, you won't ever get them confused.

=end original

裸の単語、特に全てが小文字のものはできる限り使わないでください。
見た目だけではその「裸の単語」が関数なのか、
文字列なのかが判断できません。文字列にはクォートを、
関数呼び出しには括弧をつければ、迷うこともないでしょう。

=item *

=begin original

You cannot discern from mere inspection which builtins
are unary operators (like chop() and chdir())
and which are list operators (like print() and unlink()).
(Unless prototyped, user-defined subroutines can B<only> be list
operators, never unary ones.)  See L<perlop> and L<perlsub>.

=end original

組込み関数のどれが(chop() や chdir())のような単項演算子で、
どれが(print() や unlink())のような
リスト演算子であるかは見ただけではわかりません
(プロトタイプがなければ、ユーザー定義サブルーチンは
リスト演算子として B<のみ> 定義でき、単項演算子にはできません)。
L<perlop> と L<perlsub> を参照してください。

=item *

=begin original

People have a hard time remembering that some functions
default to $_, or @ARGV, or whatever, but that others which
you might expect to do not.

=end original

いくつかの関数が $_ や @ARGV などをデフォルトにしていますが、
同じことを期待する他の関数がデフォルトになっていないことを覚えるのに、
辛いタイピングが必要でしょう。

=item *

=begin original

The <FH> construct is not the name of the filehandle, it is a readline
operation on that handle.  The data read is assigned to $_ only if the
file read is the sole condition in a while loop:

=end original

<FH> 構造はファイルハンドルではなく、そのハンドルに対する行読み込みの
操作(readline operation)です。
while ループの条件式の中にこのファイル読み込みだけがあった場合には
読み込まれたデータは $_ に代入されます。

    while (<FH>)      { }
    while (defined($_ = <FH>)) { }..
    <FH>;  # data discarded!

=item *

=begin original

Remember not to use C<=> when you need C<=~>;
these two constructs are quite different:

=end original

C<=~> が必要なところで c<=> を使わない、ということを忘れないでください。
これら二つの構造はかなり違います。

    $x =  /foo/;
    $x =~ /foo/;

=item *

=begin original

The C<do {}> construct isn't a real loop that you can use
loop control on.

=end original

C<do {}> 構造は、ループ制御を行えるような本当のループではありません。

=item *

=begin original

Use C<my()> for local variables whenever you can get away with
it (but see L<perlform> for where you can't).
Using C<local()> actually gives a local value to a global
variable, which leaves you open to unforeseen side-effects
of dynamic scoping.

=end original

ローカル変数は、my() で済むところではこれで済ませること
(使えない場所については、L<perlform> を参照してください)。
local() を使えばグローバル変数に対するローカルな値を与えますが、
動的スコープの不慮の副作用の可能性は、そのままです。

=item *

=begin original

If you localize an exported variable in a module, its exported value will
not change.  The local name becomes an alias to a new value but the
external name is still an alias for the original.

=end original

モジュールにある export された変数を局所化すると、その export された
値は変更されません。
ローカル名は新しい値の別名(alias)となりますが、
外部名は元々の値の別名のままです。

=back

=head2 Perl4 to Perl5 Traps

(Perl4 から Perl5 への罠)

=begin original

Practicing Perl4 Programmers should take note of the following
Perl4-to-Perl5 specific traps.

=end original

実践的な Perl4 プログラマは
以下に挙げる Perl4 と Perl5 の違いに特有な罠に気をつけた
方が良いでしょう。

=begin original

They're crudely ordered according to the following list:

=end original

以下は順不同のリストです。

=over 4

=item Discontinuance, Deprecation, and BugFix traps

=begin original

Anything that's been fixed as a perl4 bug, removed as a perl4 feature
or deprecated as a perl4 feature with the intent to encourage usage of
some other perl5 feature.

=end original

修正された perl4 のバグや、なくなった perl4 の仕様、
perl5 で仕様の変わったもの。

=item Parsing Traps

=begin original

Traps that appear to stem from the new parser.

=end original

新しい構文解析器によって引き起こされるもの。

=item Numerical Traps

=begin original

Traps having to do with numerical or mathematical operators.

=end original

数値や算術演算子に関する罠。

=item General data type traps

=begin original

Traps involving perl standard data types.

=end original

perlの標準的なデータ型に内包される罠。

=item Context Traps - scalar, list contexts

=begin original

Traps related to context within lists, scalar statements/declarations.

=end original

リスト内のコンテキストや、スカラ文/宣言に関する罠。

=item Precedence Traps

=begin original

Traps related to the precedence of parsing, evaluation, and execution of
code.

=end original

構文解析、評価、コードの実行の優先順に関係した罠。

=item General Regular Expression Traps using s///, etc.

=begin original

Traps related to the use of pattern matching.

=end original

パターンマッチングの仕様に関する罠。

=item Subroutine, Signal, Sorting Traps

=begin original

Traps related to the use of signals and signal handlers, general subroutines,
and sorting, along with sorting subroutines.

=end original

シグナル及びシグナルハンドラ、一般的なサブルーチン、ソート、
ソートのためのサブルーチンに関連した罠。

=item OS Traps

=begin original

OS-specific traps.

=end original

OS特有の罠。

=item DBM Traps

=begin original

Traps specific to the use of C<dbmopen()>, and specific dbm implementations.

=end original

C<dbmopen()> の使用や、dbm の実装に関連した罠。

=item Unclassified Traps

=begin original

Everything else.

=end original

その他の罠。

=back

=begin original

If you find an example of a conversion trap that is not listed here,
please submit it to <F<perlbug@perl.org>> for inclusion.
Also note that at least some of these can be caught with the
C<use warnings> pragma or the B<-w> switch.

=end original

もしここで挙げたリストにはないような変換の罠の
例を見つけたら、それを <F<perlbug@perl.org>> まで送ってください。
また、少なくともこれらのいくつかは C<use warnings> プラグマか
B<-w> スイッチで捕捉できることに注意してください。

=head2 Discontinuance, Deprecation, and BugFix traps

(なくなったり非推奨になったりバグ修正されたことによる罠)

=begin original

Anything that has been discontinued, deprecated, or fixed as
a bug from perl4.

=end original

perl4 から、なくなったり修正されたことがら。

=over 4

=item * Symbols starting with "_" no longer forced into main

("_" で始まるシンボルはもはや main パッケージに強制的に結び付けられません)

=begin original

Symbols starting with "_" are no longer forced into package main, except
for C<$_> itself (and C<@_>, etc.).

=end original

“_”で始まるシンボルはもはや main パッケージに強制的に結び付けられることは、
C<$_> 自身(と C<@-> など)を除いてはなくなりました。

    package test;
    $_legacy = 1;

    package main;
    print "\$_legacy is ",$_legacy,"\n";

    # perl4 prints: $_legacy is 1
    # perl5 prints: $_legacy is

=item * Double-colon valid package separator in variable name

(ダブルコロンは変数名の中で有効なパッケージセパレータです)

=begin original

Double-colon is now a valid package separator in a variable name.  Thus these
behave differently in perl4 vs. perl5, because the packages don't exist.

=end original

ダブルコロンは、変数名の中でパッケージセパレータになるようになりました。
このため、以下の例では perl4 と perl5 とでは振る舞いが変わります。
これはパッケージが実在してないためです。

    $a=1;$b=2;$c=3;$var=4;
    print "$a::$b::$c ";
    print "$var::abc::xyz\n";

    # perl4 prints: 1::2::3 4::abc::xyz
    # perl5 prints: 3

=begin original

Given that C<::> is now the preferred package delimiter, it is debatable
whether this should be classed as a bug or not.
(The older package delimiter, ' ,is used here)

=end original

C<::> は今では、(これがバグとして分類すべきかどうかはともかく)
パッケージデリミタとしてみなされるようになっています
(ここでは古いパッケージデリミタの ' を使っています)。

    $x = 10;
    print "x=${'x}\n";

    # perl4 prints: x=10
    # perl5 prints: Can't find string terminator "'" anywhere before EOF

=begin original

You can avoid this problem, and remain compatible with perl4, if you
always explicitly include the package name:

=end original

常にパッケージ名を含めることで、この問題を避けつつ、perl4 との
互換性を維持することができます:

    $x = 10;
    print "x=${main'x}\n";

=begin original

Also see precedence traps, for parsing C<$:>.

=end original

C<$:> の解析については、優先順位の罠 も参照してください。

=item * 2nd and 3rd args to C<splice()> are now in scalar context

(C<splice()> の第 2、第 3 引数はスカラコンテキストになりました)

=begin original

The second and third arguments of C<splice()> are now evaluated in scalar
context (as the Camel says) rather than list context.

=end original

C<splice()> の第 2、第 3 引数は
(ラクダ本にある通り)リストコンテキストではなく
スカラコンテキストで評価されるようになりました。

    sub sub1{return(0,2) }          # return a 2-element list
    sub sub2{ return(1,2,3)}        # return a 3-element list
    @a1 = ("a","b","c","d","e");
    @a2 = splice(@a1,&sub1,&sub2);
    print join(' ',@a2),"\n";

    # perl4 prints: a b
    # perl5 prints: c d e

=item * Can't do C<goto> into a block that is optimized away

(最適化によってなくなってしまうようなブロックの中に飛び込む C<goto> は使えません)

=begin original

You can't do a C<goto> into a block that is optimized away.  Darn.

=end original

最適化によってなくなってしまうようなブロックの中に
飛び込む C<goto> は使えなくなりました。
ちぇっ。

    goto marker1;

    for(1){
    marker1:
        print "Here I is!\n";
    }

    # perl4 prints: Here I is!
    # perl5 errors: Can't "goto" into the middle of a foreach loop

=item * Can't use whitespace as variable name or quote delimiter

(空白を変数名やクォートの区切りに使えません)

=begin original

It is no longer syntactically legal to use whitespace as the name
of a variable, or as a delimiter for any kind of quote construct.
Double darn.

=end original

空白を変数の名前や、クォート構造の区切りに使うことは
構文的に正当なものではなくなりました。ちぇっ、ちぇっ。

    $a = ("foo bar");
    $b = q baz;
    print "a is $a, b is $b\n";

    # perl4 prints: a is foo bar, b is baz
    # perl5 errors: Bareword found where operator expected

=item * C<while/if BLOCK BLOCK> gone

(C<while/if BLOCK BLOCK> 対応はなくなりました)

=begin original

The archaic while/if BLOCK BLOCK syntax is no longer supported.

=end original

古い while/if BLOCK BLOCK の構文は、もはやサポートされていません。

    if { 1 } {
        print "True!";
    }
    else {
        print "False!";
    }

    # perl4 prints: True!
    # perl5 errors: syntax error at test.pl line 1, near "if {"

=item * C<**> binds tighter than unary minus

(C<**> は単項のマイナスよりも優先順位が高いです)

=begin original

The C<**> operator now binds more tightly than unary minus.
It was documented to work this way before, but didn't.

=end original

C<**> 演算子の優先順位は、単項のマイナスよりも高くなりました。
これは以前からドキュメントにはそうあったのですが、実際は違っていました。

    print -4**2,"\n";

    # perl4 prints: 16
    # perl5 prints: -16

=item * C<foreach> changed when iterating over a list

(リストを反復するときの C<foreach> が変わりました)

=begin original

The meaning of C<foreach{}> has changed slightly when it is iterating over a
list which is not an array.  This used to assign the list to a
temporary array, but no longer does so (for efficiency).  This means
that you'll now be iterating over the actual values, not over copies of
the values.  Modifications to the loop variable can change the original
values.

=end original

配列ではないリストに対する繰り返しで
あるときの C<foreach{}> の意味が変わりました。
以前はそういったリストはテンポラリな配列に代入されていましたが、
現在はそうではありません(効率上の理由です)。
これは、現在では値のコピーに対して繰り返しをするのではなく
実際の値に対して繰り返しをするということです。

    @list = ('ab','abc','bcd','def');
    foreach $var (grep(/ab/,@list)){
        $var = 1;
    }
    print (join(':',@list));

    # perl4 prints: ab:abc:bcd:def
    # perl5 prints: 1:1:bcd:def

=begin original

To retain Perl4 semantics you need to assign your list
explicitly to a temporary array and then iterate over that.  For
example, you might need to change

=end original

perl4 と同じようにするには、自分で陽にテンポラリの配列へと
コピーしてからその配列に対して繰り返しを行います。
例えば、次のものを変更する必要があるかもしれません:

    foreach $var (grep(/ab/,@list)){

=begin original

to

=end original

このように:

    foreach $var (@tmp = grep(/ab/,@list)){

=begin original

Otherwise changing $var will clobber the values of @list.  (This most often
happens when you use C<$_> for the loop variable, and call subroutines in
the loop that don't properly localize C<$_>.)

=end original

そうしないと、$var を変更したときに @list の値に影響が出ます
(これはループ変数に C<$_> を使っていて、かつ、
C<$_> を局所化していないようなサブルーチンを
ループの中で呼ぶようなときに良く起こります)。

=item * C<split> with no args behavior changed

(引数なしの C<split> の振る舞いが変わりました)

=begin original

C<split> with no arguments now behaves like C<split ' '> (which doesn't
return an initial null field if $_ starts with whitespace), it used to
behave like C<split /\s+/> (which does).

=end original

引数なしの C<split> の振る舞いは、C<split /\s+/>
($_ が空白から始まっているときに先頭のフィールドが空になる)

    $_ = ' hi mom';
    print join(':', split);

    # perl4 prints: :hi:mom
    # perl5 prints: hi:mom

=item * B<-e> behavior fixed

(B<-e> の振る舞いが修正されました)

=begin original

Perl 4 would ignore any text which was attached to an B<-e> switch,
always taking the code snippet from the following arg.  Additionally, it
would silently accept an B<-e> switch without a following arg.  Both of
these behaviors have been fixed.

=end original

perl4 では、B<-e> スイッチにアタッチされたテキストは無視されて、常に
後に続く引数からプログラムが取り出されていました。さらに、
B<-e> スイッチの後に引数を渡さない場合も受け付けていました。
これらの振る舞いは両方とも修正されました。

    perl -e'print "attached to -e"' 'print "separate arg"'

    # perl4 prints: separate arg
    # perl5 prints: attached to -e

    perl -e

    # perl4 prints:
    # perl5 dies: No code specified for -e.

=item * C<push> returns number of elements in resulting list

(C<push> は結果リストの要素数を返すようになりました)

=begin original

In Perl 4 the return value of C<push> was undocumented, but it was
actually the last value being pushed onto the target list.  In Perl 5
the return value of C<push> is documented, but has changed, it is the
number of elements in the resulting list.

=end original

perl4 では C<push> の戻り値はドキュメントに書かれていませんでしたが、
実際には対象となるリストに最後にpushした値が返されていました。
Perl5 では、C<push> の戻り値はドキュメントに明記され、かつそれは
perl4 から変更されました。これは push した後のリストにある要素の数を
返します。

    @x = ('existing');
    print push(@x, 'first new', 'second new');

    # perl4 prints: second new
    # perl5 prints: 3

=item * Some error messages differ

(一部のエラーメッセージが異なっています)

=begin original

Some error messages will be different.

=end original

一部のエラーメッセージが異なっています。

=item * C<split()> honors subroutine args

(C<split()> はサブルーチンの引数を尊重します)

=begin original

In Perl 4, if in list context the delimiters to the first argument of
C<split()> were C<??>, the result would be placed in C<@_> as well as
being returned.   Perl 5 has more respect for your subroutine arguments.

=end original

Perl 4 では、リストコンテキストで C<split()> の最初の引数の
デリミタが C<??> だった場合、返される結果が C<@_> にも設定されました。
Perl 5 ではサブルーチンの引数により多くの敬意を払います。

=item * Bugs removed

(バグが修正されました)

=begin original

Some bugs may have been inadvertently removed.  :-)

=end original

幾つかのバグがうかつにも修正されているかもしれません :-)

=back

=head2 Parsing Traps

(パースの罠)

=begin original

Perl4-to-Perl5 traps from having to do with parsing.

=end original

パースに関する Perl4 と Perl5 の違いの罠です。

=over 4

=item * Space between . and = triggers syntax error

(. と = の間に空白を入れると文法エラーになります)

=begin original

Note the space between . and =

=end original

. と = の間にあるスペースに注意。

    $string . = "more string";
    print $string;

    # perl4 prints: more string
    # perl5 prints: syntax error at - line 1, near ". ="

=item * Better parsing in perl 5

(perl 5 でのよりよいパース)

=begin original

Better parsing in perl 5

=end original

perl5 では構文解析が改良されました。

    sub foo {}
    &foo
    print("hello, world\n");

    # perl4 prints: hello, world
    # perl5 prints: syntax error

=item * Function parsing

(関数のパース)

=begin original

"if it looks like a function, it is a function" rule.

=end original

“それが関数に見えるのなら、それは関数だ”のルール。

  print
    ($foo == 1) ? "is one\n" : "is zero\n";

    # perl4 prints: is zero
    # perl5 warns: "Useless use of a constant in void context" if using -w

=item * String interpolation of C<$#array> differs

(C<$#array> の文字列展開が異なります)

=begin original

String interpolation of the C<$#array> construct differs when braces
are to used around the name.

=end original

C<$#array> 構造の文字列展開で名前の周りにブレースがあるときには
違いがあります。

    @a = (1..3);
    print "${#a}";

    # perl4 prints: 2
    # perl5 fails with syntax error

    @ = (1..3);
    print "$#{a}";

    # perl4 prints: {a}
    # perl5 prints: 2

=item * Perl guesses on C<map>, C<grep> followed by C<{> if it starts BLOCK or hash ref

(Perl は C<map>, C<grep> の後の C<{> が BLOCK の開始かハッシュリファレンスかを推測します)

=begin original

When perl sees C<map {> (or C<grep {>), it has to guess whether the C<{>
starts a BLOCK or a hash reference. If it guesses wrong, it will report
a syntax error near the C<}> and the missing (or unexpected) comma.

=end original

perl が C<map {> (または C<grep {>) を見つけると、C<{> が BLOCK の開始か
ハッシュリファレンスかを推測します。
推測に失敗すると、C<}> の近くでカンマがない (あるいは予想外の位置に
カンマがある) という文法エラーが報告されます。

=begin original

Use unary C<+> before C<{> on a hash reference, and unary C<+> applied
to the first thing in a BLOCK (after C<{>), for perl to guess right all
the time. (See L<perlfunc/map>.)

=end original

ハッシュリファレンスの C<{> の前に単項の C<+> を、また BLOCK 内の最初の
ものに(C<{> の後に) 単項の C<+> を使ってください; perl がいつでも正しく
推測できるようにするためです (L<perlfunc/map> を参照してください)。

=back

=head2 Numerical Traps

(数値の罠)

=begin original

Perl4-to-Perl5 traps having to do with numerical operators,
operands, or output from same.

=end original

同じものに対する数値演算子、オペランド、出力に関する
Perl4 と Perl5 の違いの罠です。

=over 5

=item * Formatted output and significant digits

(書式指定された出力と最下位の数字)

=begin original

Formatted output and significant digits.  In general, Perl 5
tries to be more precise.  For example, on a Solaris Sparc:

=end original

書式指定された出力と、最下位の数字。
一般的に Perl 5 はより的確に試します。
例えば、Solaris Sparc では:

    print 7.373504 - 0, "\n";
    printf "%20.18f\n", 7.373504 - 0;

    # Perl4 prints:
    7.3750399999999996141
    7.375039999999999614

    # Perl5 prints:
    7.373504
    7.375039999999999614

=begin original

Notice how the first result looks better in Perl 5.

=end original

Perl 5 では、最初の結果がより良いものであることに注目してください。

=begin original

Your results may vary, since your floating point formatting routines
and even floating point format may be slightly different.

=end original

あなたが実行した結果は違うかもしれません; あなたの浮動小数点フォーマット
ルーチンや、そもそも浮動小数点フォーマットが少し違うかもしれないからです。

=item * Auto-increment operator over signed int limit deleted

(符号付き整数の限界を超えたオートインクリメント演算子は削除されました)

=begin original

This specific item has been deleted.  It demonstrated how the auto-increment
operator would not catch when a number went over the signed int limit.  Fixed
in version 5.003_04.  But always be wary when using large integers.
If in doubt:

=end original

ここに記述されていた項目は削除されました。
以前あったものでは、オートインクリメント演算子が符号付き整数の限界を越えたことを
検知しないということを紹介していました。
これはバージョン 5.003_04 で修正されましたが、大きな整数を取り扱うことに
不安を感じているのであれば

   use Math::BigInt;

=item * Assignment of return values from numeric equality tests doesn't work

(数値の等価性の比較の結果を代入は正しく動作しません)

=begin original

Assignment of return values from numeric equality tests
does not work in perl5 when the test evaluates to false (0).
Logical tests now return a null, instead of 0

=end original

数値の等価性の比較の結果を代入しても、perl ではその比較の結果が
偽 (0) であったときにはうまくいきません。
論理比較は、現在 0 ではなく null を返します。

    $p = ($test == 1);
    print $p,"\n";

    # perl4 prints: 0
    # perl5 prints:

=begin original

Also see L<"General Regular Expression Traps using s///, etc.">
for another example of this new feature...

=end original

この新しい仕様の別の例は L<"General Regular Expression Traps using s///, etc.">
を参照してください。

=item * Bitwise string ops

(ビット単位文字列演算子)

=begin original

When bitwise operators which can operate upon either numbers or
strings (C<& | ^ ~>) are given only strings as arguments, perl4 would
treat the operands as bitstrings so long as the program contained a call
to the C<vec()> function. perl5 treats the string operands as bitstrings.
(See L<perlop/Bitwise String Operators> for more details.)

=end original

数値としても文字列としても操作可能なビット操作演算子 (C<& | ^ ~>) が
文字列のみを引数として与えられた場合、
perl4 は、プログラムが C<vec()> 関数の呼び出しを含んでいればオペランドを
ビット文字列として扱います。
perl5 は文字列オペランドをビット文字列として扱います
(さらなる詳細については L<perlop/Bitwise String Operators> を参照してください)。

    $fred = "10";
    $barney = "12";
    $betty = $fred & $barney;
    print "$betty\n";
    # Uncomment the next line to change perl4's behavior
    # ($dummy) = vec("dummy", 0, 0);

    # Perl4 prints:
    8

    # Perl5 prints:
    10

    # If vec() is used anywhere in the program, both print:
    10

=back

=head2 General data type traps

(一般的なデータ型の罠)

=begin original

Perl4-to-Perl5 traps involving most data-types, and their usage
within certain expressions and/or context.

=end original

ほとんどのデータ型と、それらの特定の表現やコンテキストでの
使い方に関する Perl4 と Perl5 の違いの罠です。

=over 5

=item * Negative array subscripts now count from the end of array

(配列の添え字が負であったとき配列の終端から数えられるようになりました)

=begin original

Negative array subscripts now count from the end of the array.

=end original

配列の添え字が負であったとき、それは配列の終端から数えられるように
なりました。

    @a = (1, 2, 3, 4, 5);
    print "The third element of the array is $a[3] also expressed as $a[-2] \n";

    # perl4 prints: The third element of the array is 4 also expressed as
    # perl5 prints: The third element of the array is 4 also expressed as 4

=item * Setting C<$#array> lower now discards array elements

(C<$#array> により小さな値を設定すると配列要素が捨てられるようになりました)

=begin original

Setting C<$#array> lower now discards array elements, and makes them
impossible to recover.

=end original

C<$#array> に(それまでよりも)小さな値を設定したときには、余計な
配列要素は捨てられ、さらにそれが元に戻せないようになりました。

    @a = (a,b,c,d,e);
    print "Before: ",join('',@a);
    $#a =1;
    print ", After: ",join('',@a);
    $#a =3;
    print ", Recovered: ",join('',@a),"\n";

    # perl4 prints: Before: abcde, After: ab, Recovered: abcd
    # perl5 prints: Before: abcde, After: ab, Recovered: ab

=item * Hashes get defined before use

(ハッシュは使われる前に定義されます)

=begin original

Hashes get defined before use

=end original

ハッシュは使われる前に定義されます。

    local($s,@a,%h);
    die "scalar \$s defined" if defined($s);
    die "array \@a defined" if defined(@a);
    die "hash \%h defined" if defined(%h);

    # perl4 prints:
    # perl5 dies: hash %h defined

=begin original

Perl will now generate a warning when it sees defined(@a) and
defined(%h).

=end original

Perl は defined(@a) と defined(%h) に警告を出すようになりました。

=item * Glob assignment from localized variable to variable

(ある変数から別の変数へのグロブの代入)

=begin original

glob assignment from variable to variable will fail if the assigned
variable is localized subsequent to the assignment

=end original

ある変数から別の変数へのグロブの代入は、
代入された変数が代入の後で局所化されているときには
失敗します。

    @a = ("This is Perl 4");
    *b = *a;
    local(@a);
    print @b,"\n";

    # perl4 prints: This is Perl 4
    # perl5 prints:

=item * Assigning C<undef> to glob

(C<undef> のグロブへの代入)

=begin original

Assigning C<undef> to a glob has no effect in Perl 5.   In Perl 4
it undefines the associated scalar (but may have other side effects
including SEGVs). Perl 5 will also warn if C<undef> is assigned to a
typeglob. (Note that assigning C<undef> to a typeglob is different
than calling the C<undef> function on a typeglob (C<undef *foo>), which
has quite a few effects.

=end original

C<undef> のグロブへの代入は Perl5 では何の影響も及ぼしません。
Perl4 では結び付けられたスカラを undefine します
(しかし SEGV を含め、なんらかの副作用があるかもしれません)。
Perl 5 はまた型グロブに C<undef> を代入すると警告されます。
(型グロブに C<undef> を代入するのは、型グロブに対して
C<undef> 関数を呼び出すのとは違います)。いくつかの効果があります。

    $foo = "bar";
    *foo = undef;
    print $foo;

    # perl4 prints:
    # perl4 warns: "Use of uninitialized variable" if using -w
    # perl5 prints: bar
    # perl5 warns: "Undefined value assigned to typeglob" if using -w

=item * Changes in unary negation (of strings)

((文字列に対する)単項の符号反転の意味が変わりました)

=begin original

Changes in unary negation (of strings)
This change effects both the return value and what it
does to auto(magic)increment.

=end original

(文字列に対する)単項の符号反転の意味が変わりました。
この変更は戻り値と、マジックインクリメントの両方に影響します。

    $x = "aaa";
    print ++$x," : ";
    print -$x," : ";
    print ++$x,"\n";

    # perl4 prints: aab : -0 : 1
    # perl5 prints: aab : -aab : aac

=item * Modifying of constants prohibited

(定数の修正は禁止されました)

=begin original

perl 4 lets you modify constants:

=end original

perl4 では定数を変更してしまいます。

    $foo = "x";
    &mod($foo);
    for ($x = 0; $x < 3; $x++) {
        &mod("a");
    }
    sub mod {
        print "before: $_[0]";
        $_[0] = "m";
        print "  after: $_[0]\n";
    }

    # perl4:
    # before: x  after: m
    # before: a  after: m
    # before: m  after: m
    # before: m  after: m

    # Perl5:
    # before: x  after: m
    # Modification of a read-only value attempted at foo.pl line 12.
    # before: a

=item * C<defined $var> behavior changed

(C<defined $var> の振る舞いは変わりました)

=begin original

The behavior is slightly different for:

=end original

perl4 と perl5 とで全然違う動作:

    print "$x", defined $x

    # perl 4: 1
    # perl 5: <no output, $x is not called into existence>

=item * Variable Suicide

(変数の自殺)

=begin original

Variable suicide behavior is more consistent under Perl 5.
Perl5 exhibits the same behavior for hashes and scalars,
that perl4 exhibits for only scalars.

=end original

perl5 では、変数の自殺(variable sucide)の振る舞いはより
首尾一貫したものとなりました。
perl4 ではスカラのみがそうであるような振る舞いを、
perl5 ではハッシュとスカラで示します。

    $aGlobal{ "aKey" } = "global value";
    print "MAIN:", $aGlobal{"aKey"}, "\n";
    $GlobalLevel = 0;
    &test( *aGlobal );

    sub test {
        local( *theArgument ) = @_;
        local( %aNewLocal ); # perl 4 != 5.001l,m
        $aNewLocal{"aKey"} = "this should never appear";
        print "SUB: ", $theArgument{"aKey"}, "\n";
        $aNewLocal{"aKey"} = "level $GlobalLevel";   # what should print
        $GlobalLevel++;
        if( $GlobalLevel<4 ) {
            &test( *aNewLocal );
        }
    }

    # Perl4:
    # MAIN:global value
    # SUB: global value
    # SUB: level 0
    # SUB: level 1
    # SUB: level 2

    # Perl5:
    # MAIN:global value
    # SUB: global value
    # SUB: this should never appear
    # SUB: this should never appear
    # SUB: this should never appear

=back

=head2 Context Traps - scalar, list contexts

(コンテキストの罠 - スカラコンテキストとリストコンテキスト)

=over 5

=item * Elements of argument lists for formats evaluated in list context

(フォーマットに対する引数リストの要素はリストコンテキストで評価されるようになりました)

=begin original

The elements of argument lists for formats are now evaluated in list
context.  This means you can interpolate list values now.

=end original

フォーマットに対する引数リストの要素は、リストコンテキストで
評価されるようになりました。
これは、今やリストの値が
展開できるようになったということです。

    @fmt = ("foo","bar","baz");
    format STDOUT=
    @<<<<< @||||| @>>>>>
    @fmt;
    .
    write;

    # perl4 errors:  Please use commas to separate fields in file
    # perl5 prints: foo     bar      baz

=item * C<caller()> returns false value in scalar context if no caller present

(C<caller()> 関数は呼び出し元がなくスカラコンテキストで呼ばれた場合には偽を返します)

=begin original

The C<caller()> function now returns a false value in a scalar context
if there is no caller.  This lets library files determine if they're
being required.

=end original

C<caller()> 関数は呼び出し元がなく、スカラコンテキストで呼ばれた
場合には偽を返すようになりました。
これによりライブラリファイルが
(自分が)require されたのかを判断することができます。

    caller() ? (print "You rang?\n") : (print "Got a 0\n");

    # perl4 errors: There is no caller
    # perl5 prints: Got a 0

=item * Comma operator in scalar context gives scalar context to args

(スカラコンテキストにあるカンマ演算子はその引数に対してスカラコンテキストを与えます)

=begin original

The comma operator in a scalar context is now guaranteed to give a
scalar context to its arguments.

=end original

スカラコンテキストにあるカンマ演算子は、その引数に対して
スカラコンテキストを与えるようになりました。

    @y= ('a','b','c');
    $x = (1, 2, @y);
    print "x = $x\n";

    # Perl4 prints:  x = c   # Thinks list context interpolates list
    # Perl5 prints:  x = 3   # Knows scalar uses length of list

=item * C<sprintf()> prototyped as C<($;@)>

(C<sprintf()> のプロトタイプは C<($;@)>)

=begin original

C<sprintf()> is prototyped as ($;@), so its first argument is given scalar
context. Thus, if passed an array, it will probably not do what you want,
unlike Perl 4:

=end original

C<sprintf()> のプロトタイプは ($;@) なので、最初の引数は
スカラコンテキストです。従って、配列を渡すと、
Perl 4 とは違っておそらくあなたの望まない結果になるでしょう。

    @z = ('%s%s', 'foo', 'bar');
    $x = sprintf(@z);
    print $x;

    # perl4 prints: foobar
    # perl5 prints: 3

=begin original

C<printf()> works the same as it did in Perl 4, though:

=end original

しかし、C<printf()> のほうは Perl 4 と同じように動きます:

    @z = ('%s%s', 'foo', 'bar');
    printf STDOUT (@z);

    # perl4 prints: foobar
    # perl5 prints: foobar

=back

=head2 Precedence Traps

(評価順序の罠)

=begin original

Perl4-to-Perl5 traps involving precedence order.

=end original

評価順序に関する Perl4 と Perl5 の違いの罠です。

=begin original

Perl 4 has almost the same precedence rules as Perl 5 for the operators
that they both have.  Perl 4 however, seems to have had some
inconsistencies that made the behavior differ from what was documented.

=end original

Perl4 はほとんどの演算子で Perl5 と同じ優先順位を持っています。
しかし Perl4 では、ドキュメントとは少々異なるような
一貫性に欠けるものがあります。

=over 5

=item * LHS vs. RHS of any assignment operator

(代入演算子の LHS 対 RHS)

=begin original

LHS vs. RHS of any assignment operator.  LHS is evaluated first
in perl4, second in perl5; this can affect the relationship
between side-effects in sub-expressions.

=end original

左辺と右辺は両方とも演算子を取るようになりました。
LHS は perl4 では最初に、perl5 では 2 番目に評価されます; これは
部分式の副作用の関係に影響を与えることがあります。

    @arr = ( 'left', 'right' );
    $a{shift @arr} = shift @arr;
    print join( ' ', keys %a );

    # perl4 prints: left
    # perl5 prints: right

=item * Semantic errors introduced due to precedence

=begin original

These are now semantic errors because of precedence:

=end original

以下の例は、優先順位の関係で意味エラー(semantic error)となるようになりました。

    @list = (1,2,3,4,5);
    %map = ("a",1,"b",2,"c",3,"d",4);
    $n = shift @list + 2;   # first item in list plus 2
    print "n is $n, ";
    $m = keys %map + 2;     # number of items in hash plus 2
    print "m is $m\n";

    # perl4 prints: n is 3, m is 6
    # perl5 errors and fails to compile

=item * Precedence of assignment operators same as the precedence of assignment

(代入演算子の優先順位は代入と同じ)

=begin original

The precedence of assignment operators is now the same as the precedence
of assignment.  Perl 4 mistakenly gave them the precedence of the associated
operator.  So you now must parenthesize them in expressions like

=end original

代入演算子の優先順位は、代入と同じとなりました。
perl4 は間違って、この優先順位が関連演算子と同じものに
なっています。このため、式の中にあるのと同じように括弧でくくらなければ
ならなくなりました。

    /foo/ ? ($a += 2) : ($a -= 2);

=begin original

Otherwise

=end original

下のようにしてしまうと、

    /foo/ ? $a += 2 : $a -= 2

=begin original

would be erroneously parsed as

=end original

これは

    (/foo/ ? $a += 2 : $a) -= 2;

=begin original

On the other hand,

=end original

のように間違って解析されてしまいます。
その一方で、

    $a += /foo/ ? 1 : 2;

=begin original

now works as a C programmer would expect.

=end original

これは C プログラマーが期待するであろう動作になりました。

=item * C<open> requires parentheses around filehandle

(C<open> はファイルハンドルの周りにかっこが必要です)

    open FOO || die;

=begin original

is now incorrect.  You need parentheses around the filehandle.
Otherwise, perl5 leaves the statement as its default precedence:

=end original

これはもはや正しくなくなりました。ここではファイルハンドルを
括弧で括る必要があります。さもなければ、perl5 はこういった文を
そのデフォルトの優先順位のまま放っておきます(以下の例参照)。

    open(FOO || die);

    # perl4 opens or dies
    # perl5 opens FOO, dying only if 'FOO' is false, i.e. never

=item * C<$:> precedence over C<$::> gone

(C<$:> は C<$::> と同じ優先順位)

=begin original

perl4 gives the special variable, C<$:> precedence, where perl5
treats C<$::> as main C<package>

=end original

perl4 は特殊変数 C<$:> の優先順位に、perl5 が C<$::> を main パッケージと
みなすのと同じ優先順位を与えます。

    $a = "x"; print "$::a";

    # perl 4 prints: -:a
    # perl 5 prints: x

=item * Precedence of file test operators documented

(ファイルテスト演算子の優先順位が文書化)

=begin original

perl4 had buggy precedence for the file test operators vis-a-vis
the assignment operators.  Thus, although the precedence table
for perl4 leads one to believe C<-e $foo .= "q"> should parse as
C<((-e $foo) .= "q")>, it actually parses as C<(-e ($foo .= "q"))>.
In perl5, the precedence is as documented.

=end original

perl には、ファイルテスト演算子と代入演算子を組み合わせたときに
優先順位のバグがありました。したがって、Perl4 の優先順位テーブルでは
C<-e $foo .= "q"> は
C<((-e $foo) .= "q")> と解釈すべきなのに実際には
C<((-e $foo) .= "q")> と解釈していました。
Perl5 ではドキュメントにある通りの優先順位です。

    -e $foo .= "q"

    # perl4 prints: no output
    # perl5 prints: Can't modify -e in concatenation

=item * C<keys>, C<each>, C<values> are regular named unary operators

(C<keys>, C<each>, C<values> は通常の名前付き単項演算子)

=begin original

In perl4, keys(), each() and values() were special high-precedence operators
that operated on a single hash, but in perl5, they are regular named unary
operators.  As documented, named unary operators have lower precedence
than the arithmetic and concatenation operators C<+ - .>, but the perl4
variants of these operators actually bind tighter than C<+ - .>.
Thus, for:

=end original

perl4 では、key()、each()、values() はシングルハッシュに対する
特別に高い評価順序を持った演算子でした。
しかし perl5 では、これらの演算子は通常の名前付き単項演算子となりました。
ドキュメントにある通り、名前付き単項演算子は、C<+ - .> のような
数学演算子や連結演算子よりも低い優先順位を持っています。
しかし、perl4 ではこれらの演算子よりも key() などのほうが強く演算対象と
結び付いていたのです。
したがって、以下の例のようになります:

    %foo = 1..10;
    print keys %foo - 1

    # perl4 prints: 4
    # perl5 prints: Type of arg 1 to keys must be hash (not subtraction)

=begin original

The perl4 behavior was probably more useful, if less consistent.

=end original

この perl4 の振る舞いは便利であるかもしれませんが、一貫性に欠けます。

=back

=head2 General Regular Expression Traps using s///, etc.

(s/// などを使ったときの一般的な正規表現の罠)

=begin original

All types of RE traps.

=end original

正規表現に関する全てのタイプの罠。

=over 5

=item * C<s'$lhs'$rhs'> interpolates on either side

=begin original

C<s'$lhs'$rhs'> now does no interpolation on either side.  It used to
interpolate $lhs but not $rhs.  (And still does not match a literal
'$' in string)

=end original

C<s'$lhs'$rhs'> はもはやいずれの辺にあっても展開されなくなりました。
以前は $lhs は展開し、$rhs を展開しませんでした。
(文字列にあるリテラルの '$' にはいまでもマッチしません)。

    $a=1;$b=2;
    $string = '1 2 $a $b';
    $string =~ s'$a'$b';
    print $string,"\n";

    # perl4 prints: $b 2 $a $b
    # perl5 prints: 1 2 $a $b

=item * C<m//g> attaches its state to the searched string

=begin original

C<m//g> now attaches its state to the searched string rather than the
regular expression.  (Once the scope of a block is left for the sub, the
state of the searched string is lost)

=end original

C<m//g> は、その状態を正規表現ではなく検索対象の文字列に
結び付けるようになりました
(sub に対するブロックのスコープが残っているのであれば、
検索文字列の状態は失われます)。

    $_ = "ababab";
    while(m/ab/g){
        &doit("blah");
    }
    sub doit{local($_) = shift; print "Got $_ "}

    # perl4 prints: Got blah Got blah Got blah Got blah
    # perl5 prints: infinite loop blah...

=item * C<m//o> used within an anonymous sub

=begin original

Currently, if you use the C<m//o> qualifier on a regular expression
within an anonymous sub, I<all> closures generated from that anonymous
sub will use the regular expression as it was compiled when it was used
the very first time in any such closure.  For instance, if you say

=end original

現在のところ、C<m//o> 量指定子を無名サブルーチンの中にある正規表現で
使った場合、I<すべての> クロージャーはそのような無名サブルーチンから、
そういったクロージャの中で一番最初に使われたものの中で
コンパイルされたかのような正規表現を生成します。

    sub build_match {
        my($left,$right) = @_;
        return sub { $_[0] =~ /$left stuff $right/o; };
    }
    $good = build_match('foo','bar');
    $bad = build_match('baz','blarch');
    print $good->('foo stuff bar') ? "ok\n" : "not ok\n";
    print $bad->('baz stuff blarch') ? "ok\n" : "not ok\n";
    print $bad->('foo stuff bar') ? "not ok\n" : "ok\n";

=begin original

For most builds of Perl5, this will print:
ok
not ok
not ok

=end original

Perl5 のほとんどのビルドでは、これは以下のように出力します:

=begin original

build_match() will always return a sub which matches the contents of
$left and $right as they were the I<first> time that build_match()
was called, not as they are in the current call.

=end original

この例の場合、build_match() は常にC<最初>に build_match() が呼ばれたときの
$left と $right の内容にマッチするようなサブルーチンを返します。
呼び出されたその時点での値ではありません。

=item * C<$+> isn't set to whole match

=begin original

If no parentheses are used in a match, Perl4 sets C<$+> to
the whole match, just like C<$&>. Perl5 does not.

=end original

マッチングの中で括弧が使われなかった場合、perl4 では
C<$+> には C<$&> と同じようにマッチした全体がセットされますが、
Perl5 ではそうではありません。

    "abcdef" =~ /b.*e/;
    print "\$+ = $+\n";

    # perl4 prints: bcde
    # perl5 prints:

=item * Substitution now returns null string if it fails

=begin original

substitution now returns the null string if it fails

=end original

置換は、失敗したときには空文字列を返すようになりました。

    $string = "test";
    $value = ($string =~ s/foo//);
    print $value, "\n";

    # perl4 prints: 0
    # perl5 prints:

=begin original

Also see L<Numerical Traps> for another example of this new feature.

=end original

この新しい仕様に関しては L<Numerical Traps> も参照してください。

=item * C<s`lhs`rhs`> is now a normal substitution

=begin original

C<s`lhs`rhs`> (using backticks) is now a normal substitution, with no
backtick expansion

=end original

C<s`lhs`rhs`> (バッククォートの使用)は通常の置換となり、
バッククォートの展開は行われなくなりました。

    $string = "";
    $string =~ s`^`hostname`;
    print $string, "\n";

    # perl4 prints: <the local hostname>
    # perl5 prints: hostname

=item * Stricter parsing of variables in regular expressions

=begin original

Stricter parsing of variables used in regular expressions

=end original

正規表現中の変数の使用に関する構文解析がより厳密になりました。

    s/^([^$grpc]*$grpc[$opt$plus$rep]?)//o;

    # perl4: compiles w/o error
    # perl5: with Scalar found where operator expected ..., near "$opt$plus"

=begin original

an added component of this example, apparently from the same script, is
the actual value of the s'd string after the substitution.
C<[$opt]> is a character class in perl4 and an array subscript in perl5

=end original

同じスクリプトでこの例に付け加えことは、置換後の文字列の実際の値です。
C<[$opt]> は perl4 ではキャラクタクラスであり、perl5 では配列の
添え字となります。

    $grpc = 'a';
    $opt  = 'r';
    $_ = 'bar';
    s/^([^$grpc]*$grpc[$opt]?)/foo/;
    print;

    # perl4 prints: foo
    # perl5 prints: foobar

=item * C<m?x?> matches only once

=begin original

Under perl5, C<m?x?> matches only once, like C<?x?>. Under perl4, it matched
repeatedly, like C</x/> or C<m!x!>.

=end original

perl5 では、C<m?x?> は C<?x?> と同様に一回だけマッチします。
perl4 では、C</x/> や C<m!x!> と同じように何度でもマッチします。

    $test = "once";
    sub match { $test =~ m?once?; }
    &match();
    if( &match() ) {
        # m?x? matches more then once
        print "perl4\n";
    } else {
        # m?x? matches only once
        print "perl5\n";
    }

    # perl4 prints: perl4
    # perl5 prints: perl5

=item * Failed matches don't reset the match variables

=begin original

Unlike in Ruby, failed matches in Perl do not reset the match variables
($1, $2, ..., C<$`>, ...).

=end original

Ruby と違って、Perl ではマッチングに失敗してもマッチング変数
($1, $2, ..., C<$`>, ...) はリセットされません。

=back

=head2 Subroutine, Signal, Sorting Traps

(サブルーチン、シグナル、ソートの罠)

=begin original

The general group of Perl4-to-Perl5 traps having to do with
Signals, Sorting, and their related subroutines, as well as
general subroutine traps.  Includes some OS-Specific traps.

=end original

Perl4 と Perl5 の違いの罠に分類される一般的なものは
シグナル、ソート、そしてそれらに関連する
サブルーチンで、いくつかの OS 固有の罠を含めた
サブルーチンの罠と同じ様なものです。

=over 5

=item * Barewords that used to look like strings look like subroutine calls

=begin original

Barewords that used to look like strings to Perl will now look like subroutine
calls if a subroutine by that name is defined before the compiler sees them.

=end original

文字列のように見える裸の単語は、その名前が使うよりも前に
サブルーチンの名前として定義されている場合にはサブルーチンとして
みなされます。

    sub SeeYa { warn"Hasta la vista, baby!" }
    $SIG{'TERM'} = SeeYa;
    print "SIGTERM is now $SIG{'TERM'}\n";

    # perl4 prints: SIGTERM is now main'SeeYa
    # perl5 prints: SIGTERM is now main::1 (and warns "Hasta la vista, baby!")

=begin original

Use B<-w> to catch this one

=end original

B<-w> を使って、これを発見できます。

=item * Reverse is no longer allowed as the name of a sort subroutine

=begin original

reverse is no longer allowed as the name of a sort subroutine.

=end original

reverse はもはやソートのサブルーチンの名前としては
使えなくなりました。

    sub reverse{ print "yup "; $a <=> $b }
    print sort reverse (2,1,3);

    # perl4 prints: yup yup 123
    # perl5 prints: 123
    # perl5 warns (if using -w): Ambiguous call resolved as CORE::reverse()

=item * C<warn()> won't let you specify a filehandle.

=begin original

Although it _always_ printed to STDERR, warn() would let you specify a
filehandle in perl4.  With perl5 it does not.

=end original

常に STDERR に出力していたにもかかわらず、perl4 では warn() はファイルハンドルの
指定を必要としていましたが、perl5 では必要なくなりました。

    warn STDERR "Foo!";

    # perl4 prints: Foo!
    # perl5 prints: String found where operator expected

=back

=head2 OS Traps

(OS の罠)

=over 5

=item * SysV resets signal handler correctly

=begin original

Under HPUX, and some other SysV OSes, one had to reset any signal handler,
within  the signal handler function, each time a signal was handled with
perl4.  With perl5, the reset is now done correctly.  Any code relying
on the handler _not_ being reset will have to be reworked.

=end original

HPUX 及び一部の SysV OS では、perl4 のときには
シグナルが発生する度にそのシグナルハンドラ関数の中で
シグナルハンドラを再設定しなければなりませんでした。
perl5 では、この再設定を正しく行うようになりました。
ハンドラを再設定しないということに依存したプログラムは
作業しなおす必要があります。

=begin original

Since version 5.002, Perl uses sigaction() under SysV.

=end original

5.002 以降の perl では、SysV のときには sigaction() を使います。

    sub gotit {
        print "Got @_... ";
    }
    $SIG{'INT'} = 'gotit';

    $| = 1;
    $pid = fork;
    if ($pid) {
        kill('INT', $pid);
        sleep(1);
        kill('INT', $pid);
    } else {
        while (1) {sleep(10);}
    }

    # perl4 (HPUX) prints: Got INT...
    # perl5 (HPUX) prints: Got INT... Got INT...

=item * SysV C<seek()> appends correctly

=begin original

Under SysV OSes, C<seek()> on a file opened to append C<<< >> >>> now does
the right thing w.r.t. the fopen() manpage. e.g., - When a file is opened
for append,  it  is  impossible to overwrite information already in
the file.

=end original

SysV OS では、追記モード (C<<< >> >>>) でオープンしたファイルに対する
C<seek()> は fopen() マニュアルページにあるように正しく動作するように
なりました。
例えば、追記モードでファイルをオープンした場合には既にファイルにある情報を
上書きすることはできません。

    open(TEST,">>seek.test");
    $start = tell TEST;
    foreach(1 .. 9){
        print TEST "$_ ";
    }
    $end = tell TEST;
    seek(TEST,$start,0);
    print TEST "18 characters here";

    # perl4 (solaris) seek.test has: 18 characters here
    # perl5 (solaris) seek.test has: 1 2 3 4 5 6 7 8 9 18 characters here

=back

=head2 Interpolation Traps

(展開の罠)

=begin original

Perl4-to-Perl5 traps having to do with how things get interpolated
within certain expressions, statements, contexts, or whatever.

=end original

Perl4 と Perl5 の違いの罠には、式や文、コンテキストなどにおける
展開に関するものがあります。

=over 5

=item * C<@> always interpolates an array in double-quotish strings

=begin original

@ now always interpolates an array in double-quotish strings.

=end original

ダブルクォートで囲まれた文字列にある @ は常に配列に展開されます。

    print "To: someone@somewhere.com\n";

    # perl4 prints: To:someone@somewhere.com
    # perl < 5.6.1, error : In string, @somewhere now must be written as \@somewhere
    # perl >= 5.6.1, warning : Possible unintended interpolation of @somewhere in string

=item * Double-quoted strings may no longer end with an unescaped $

=begin original

Double-quoted strings may no longer end with an unescaped $.

=end original

ダブルクォートで括られた文字列がエスケープされていない $  で
終了することがなくなりました。

    $foo = "foo$";
    print "foo is $foo\n";

    # perl4 prints: foo is foo$
    # perl5 errors: Final $ should be \$ or $name

=begin original

Note: perl5 DOES NOT error on the terminating @ in $bar

=end original

注意: perl5 は、$bar の終端にある @ については“エラーにしません”

=item * Arbitrary expressions are evaluated inside braces within double quotes

=begin original

Perl now sometimes evaluates arbitrary expressions inside braces that occur
within double quotes (usually when the opening brace is preceded by C<$>
or C<@>).

=end original

Perl はダブルクォート中にあるブレースの内側の任意の式を
評価するようになりました(一般的には、C<$> や C<@> に続いて
開きのブレースがきたときです)。

    @www = "buz";
    $foo = "foo";
    $bar = "bar";
    sub foo { return "bar" };
    print "|@{w.w.w}|${main'foo}|";

    # perl4 prints: |@{w.w.w}|foo|
    # perl5 prints: |buz|bar|

=begin original

Note that you can C<use strict;> to ward off such trappiness under perl5.

=end original

C<use strict;> を使って、perl5 におけるこのような罠を避けることが
できることに注意してください。

=item * C<$$x> now tries to dereference $x

=begin original

The construct "this is $$x" used to interpolate the pid at that point, but
now tries to dereference $x.  C<$$> by itself still works fine, however.

=end original

"this is $$x" はプロセス ID を展開するようになっていましたが、
今は $x の参照外し(dereference)を試みます。
それでも C<$$> 自身は今でもきちんと動作します。

    $s = "a reference";
    $x = *s;
    print "this is $$x\n";

    # perl4 prints: this is XXXx   (XXX is the current pid)
    # perl5 prints: this is a reference

=item * Creation of hashes on the fly with C<eval "EXPR"> requires protection

=begin original

Creation of hashes on the fly with C<eval "EXPR"> now requires either both
C<$>'s to be protected in the specification of the hash name, or both curlies
to be protected.  If both curlies are protected, the result will be compatible
with perl4 and perl5.  This is a very common practice, and should be changed
to use the block form of C<eval{}>  if possible.

=end original

C<eval "EXPR"> を使ったその場(on the fly)でのハッシュの生成は
ハッシュの名前を指定する C<$> がプロテクトされているか、もしくは
両方の中かっこがプロテクトされていることを要求します。
両方の中かっこがプロテクトされている場合には、perl4 と
perl5 の結果は同じです。

    $hashname = "foobar";
    $key = "baz";
    $value = 1234;
    eval "\$$hashname{'$key'} = q|$value|";
    (defined($foobar{'baz'})) ?  (print "Yup") : (print "Nope");

    # perl4 prints: Yup
    # perl5 prints: Nope

=begin original

Changing

=end original

以下のものを変更します:

    eval "\$$hashname{'$key'} = q|$value|";

=begin original

to

=end original

このように:

    eval "\$\$hashname{'$key'} = q|$value|";

=begin original

causes the following result:

=end original

結果はこうなります:

    # perl4 prints: Nope
    # perl5 prints: Yup

=begin original

or, changing to

=end original

以下のように変更した場合には

    eval "\$$hashname\{'$key'\} = q|$value|";

=begin original

causes the following result:

=end original

結果はこうなります:

    # perl4 prints: Yup
    # perl5 prints: Yup
    # and is compatible for both versions

=item * Bugs in earlier perl versions

=begin original

perl4 programs which unconsciously rely on the bugs in earlier perl versions.

=end original

以前のバージョンにあったバグに依存しているような perl4 プログラム。

    perl -e '$bar=q/not/; print "This is $foo{$bar} perl5"'

    # perl4 prints: This is not perl5
    # perl5 prints: This is perl5

=item * Array and hash brackets during interpolation

=begin original

You also have to be careful about array and hash brackets during
interpolation.

=end original

展開中の配列とハッシュの大かっこについても注意する必要があります。

    print "$foo["

    perl 4 prints: [
    perl 5 prints: syntax error

    print "$foo{"

    perl 4 prints: {
    perl 5 prints: syntax error

=begin original

Perl 5 is expecting to find an index or key name following the respective
brackets, as well as an ending bracket of the appropriate type.  In order
to mimic the behavior of Perl 4, you must escape the bracket like so.

=end original

Perl 5 は、個々のかっこには添え字かキー名が続き、さらに適切な種類の
閉じかっこが続くと仮定しています。
Perl 4 の振る舞いを模倣するためには、そのようなかっこを
エスケープしなければなりません。

    print "$foo\[";
    print "$foo\{";

=item * Interpolation of C<\$$foo{bar}>

=begin original

Similarly, watch out for: C<\$$foo{bar}>

=end original

同様に、C<\$$foo{bar}> にも注意してください:

    $foo = "baz";
    print "\$$foo{bar}\n";

    # perl4 prints: $baz{bar}
    # perl5 prints: $

=begin original

Perl 5 is looking for C<$foo{bar}> which doesn't exist, but perl 4 is
happy just to expand $foo to "baz" by itself.  Watch out for this
especially in C<eval>'s.

=end original

perl5 は存在しない C<$foo{bar}> を探しに行きますが、perl4 は
$foo を“baz”に展開しただけで満足します。
C<eval> でもこの事に注意してください。

=item * C<qq()> string passed to C<eval> will not find string terminator

=begin original

C<qq()> string passed to C<eval>

=end original

C<eval> に C<qq()> された文字列を渡した場合

    eval qq(
        foreach \$y (keys %\$x\) {
            \$count++;
        }
    );

    # perl4 runs this ok
    # perl5 prints: Can't find string terminator ")"

=back

=head2 DBM Traps

(DBM の罠)

=begin original

General DBM traps.

=end original

DBMに関する一般的な罠。

=over 5

=item * Perl5 must have been linked with same dbm/ndbm as the default for C<dbmopen()>

=begin original

Existing dbm databases created under perl4 (or any other dbm/ndbm tool)
may cause the same script, run under perl5, to fail.  The build of perl5
must have been linked with the same dbm/ndbm as the default for C<dbmopen()>
to function properly without C<tie>'ing to an extension dbm implementation.

=end original

perl4 で(もしくは他の dbm/ndbm ツールで)作成した dbm データベースを、
perl5 の元で同じスクリプトで扱おうとすると失敗します。
perl5 の作成において、拡張 dbm の実装を C<tie> しないときに
C<dbmopen()> がデフォルトで使用する関数のために
(perl4 のときと同じ)同じ dbm/ndbm をリンクしていなければなりません。

    dbmopen (%dbm, "file", undef);
    print "ok\n";

    # perl4 prints: ok
    # perl5 prints: ok (IFF linked with -ldbm or -lndbm)

=item * DBM exceeding limit on the key/value size will cause perl5 to exit immediately

=begin original

Existing dbm databases created under perl4 (or any other dbm/ndbm tool)
may cause the same script, run under perl5, to fail.  The error generated
when exceeding the limit on the key/value size will cause perl5 to exit
immediately.

=end original

perl4 (またはその他の dbm/ndbm ツール)で作成された dbm は、perl5 で
このスクリプトの実行に失敗することがあります。
key/value のサイズに関する制限を超えたときに発生するエラーにより、
perl5 では即座にプログラムから exit します。

    dbmopen(DB, "testdb",0600) || die "couldn't open db! $!";
    $DB{'trap'} = "x" x 1024;  # value too large for most dbm/ndbm
    print "YUP\n";

    # perl4 prints:
    dbm store returned -1, errno 28, key "trap" at - line 3.
    YUP

    # perl5 prints:
    dbm store returned -1, errno 28, key "trap" at - line 3.

=back

=head2 Unclassified Traps

(未分類の罠)

=begin original

Everything else.

=end original

その他の罠。

=over 5

=item * C<require>/C<do> trap using returned value

(C<require>/C<do> の戻り値を使ったときの罠)

=begin original

If the file doit.pl has:

=end original

doit.pl というファイルが

    sub foo {
        $rc = do "./do.pl";
        return 8;
    }
    print &foo, "\n";

=begin original

And the do.pl file has the following single line:

=end original

であって、do.pl が以下のような内容だったとすると、

    return 3;

=begin original

Running doit.pl gives the following:

=end original

doit.pl の実行結果はこうなります。

    # perl 4 prints: 3 (aborts the subroutine early)
    # perl 5 prints: 8

=begin original

Same behavior if you replace C<do> with C<require>.

=end original

C<do> を C<require> に置き換えても同じ振る舞いとなります。

=item * C<split> on empty string with LIMIT specified

(空文字列に LIMIT を指定して C<split> を使った場合)

    $string = '';
    @list = split(/foo/, $string, 2)

=begin original

Perl4 returns a one element list containing the empty string but Perl5
returns an empty list.

=end original

Perl4 は空文字列を持った一要素のリストを返しますが、Perl5 は
空リストを返します。

=back

=begin original

As always, if any of these are ever officially declared as bugs,
they'll be fixed and removed.

=end original

いつものように、バグとして公式に宣言されたものがあれば、
それは修正されて取り除かれるでしょう。

=begin meta

Translate: KIMURA Koichi (5.005_03)
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.6.1-)
Status: completed

=end meta

