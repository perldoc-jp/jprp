
=encoding euc-jp

=head1 NAME

=begin original

perlpodspec - Plain Old Documentation: format specification and notes

=end original

perlpodspec - Plain Old Documentation: フォーマット仕様とメモ

=head1 DESCRIPTION

=begin original

This document is detailed notes on the Pod markup language.  Most
people will only have to read L<perlpod|perlpod> to know how to write
in Pod, but this document may answer some incidental questions to do
with parsing and rendering Pod.

=end original

この文書は、Pod マークアップ言語の詳細なメモです。
ほとんどの人にとっては、Pod の書き方を知るには L<perlpod|perlpod> だけを
読む必要がありますが、この文書は Pod のパースとレンダリングに関する
付随的な質問に答えているかも知れません。

=begin original

In this document, "must" / "must not", "should" /
"should not", and "may" have their conventional (cf. RFC 2119)
meanings: "X must do Y" means that if X doesn't do Y, it's against
this specification, and should really be fixed.  "X should do Y"
means that it's recommended, but X may fail to do Y, if there's a
good reason.  "X may do Y" is merely a note that X can do Y at
will (although it is up to the reader to detect any connotation of
"and I think it would be I<nice> if X did Y" versus "it wouldn't
really I<bother> me if X did Y").

=end original

この文書では、"must" / "must not", "should" /
"should not", "may" は形式的な意味 (RFC 2119 参照) を持ちます:
"X must do Y" は、もし X は Y していない場合、これは仕様に反しているので、
本当に修正されるべきということを意味します。
"X should do Y" は、推奨はしますが、もし適切な理由があるなら、
X が Y しないこともあることを意味します。
"X may do Y" は、単に X が自分の意志で Y できることを示しています
(しかし、これは読者が
「そして、私はもし X が Y するなら I<すてきだ> と思う」と、
「X が Y するかどうかは I<どうでもいい>」という言外の意味を識別できるように
するようにしています)(訳注: 原文がどの表現を用いているかは文末にかっこで
示します)。

=begin original

Notably, when I say "the parser should do Y", the
parser may fail to do Y, if the calling application explicitly
requests that the parser I<not> do Y.  I often phrase this as
"the parser should, by default, do Y."  This doesn't I<require>
the parser to provide an option for turning off whatever
feature Y is (like expanding tabs in verbatim paragraphs), although
it implicates that such an option I<may> be provided.

=end original

特に、「パーサは Y するべきです(should)」と書いた場合、
呼び出し元のアプリケーションが明示的に Y I<しない> ように指定した場合、
Y しないかもしれません。
これはしばしば、「パーサはデフォルトでは Y するべきです(should)」と
表現されます。
これはパーサが(そのままの段落でタブを展開するといった)機能 Y を
オフにするかどうかのオプションを提供することをI<要求している>
わけではありませんが、
このようなオプションが提供されている I<かもしれない> ことを示しています。

=head1 Pod Definitions

(Pod の定義)

=begin original

Pod is embedded in files, typically Perl source files, although you
can write a file that's nothing but Pod.

=end original

Pod は他のファイル (典型的には Perl ソースファイル) に埋め込まれていますが、
Pod 以外のことは全く知らなくても Pod を書けます。

=begin original

A B<line> in a file consists of zero or more non-newline characters,
terminated by either a newline or the end of the file.

=end original

ファイルの B<行> (line) は 0 個以上の改行でない文字で構成され、
改行かファイルの終わりで終端されます。

=begin original

A B<newline sequence> is usually a platform-dependent concept, but
Pod parsers should understand it to mean any of CR (ASCII 13), LF
(ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in
addition to any other system-specific meaning.  The first CR/CRLF/LF
sequence in the file may be used as the basis for identifying the
newline sequence for parsing the rest of the file.

=end original

B<改行シーケンス> (newline sequence) は普通プラットフォーム依存の
概念ですが、Pod パーサは CR (ASCII 13), LF
(ASCII 10), CRLF (ASCII 13 の直後に ASCII 10) に加えて、その他の
システム固有の意味ののどれでも認識するべきです(should)。
ファイルの最初の CR/CRLF/LF シーケンスを、ファイルの残りをパースするための
改行を識別するための基準として使ってもかまいません(may)。

=begin original

A B<blank line> is a line consisting entirely of zero or more spaces
(ASCII 32) or tabs (ASCII 9), and terminated by a newline or end-of-file.
A B<non-blank line> is a line containing one or more characters other
than space or tab (and terminated by a newline or end-of-file).

=end original

B<空行> (blank line) は 0 個以上のスペース (ASCII 32) かタブ (ASCII 9) のみで
構成され、改行かファイルの終わりで終端されます。
B<非空行> (non-blank line) はスペースとタブ以外の文字 1 個以上を含みます
(そして改行かファイルの終わりで終端されます)。

=begin original

(I<Note:> Many older Pod parsers did not accept a line consisting of
spaces/tabs and then a newline as a blank line. The only lines they
considered blank were lines consisting of I<no characters at all>,
terminated by a newline.)

=end original

(I<注意:> 古い Pod パーサの多くはスペースとタブで構成される行を
受け付けず、改行を空行として扱います。
これらのパーサは I<何の文字も含まれていない> 行だけを空行として
扱います。)

=begin original

B<Whitespace> is used in this document as a blanket term for spaces,
tabs, and newline sequences.  (By itself, this term usually refers
to literal whitespace.  That is, sequences of whitespace characters
in Pod source, as opposed to "EE<lt>32>", which is a formatting
code that I<denotes> a whitespace character.)

=end original

B<空白> (whitespace) は、この文書ではスペース、タブ、改行シーケンスを
総称する用語です。
(それ自体、この用語は普通リテラルな空白を参照します。
これは、Pod ソース中の空白文字の並びです; 一方 "EE<lt>32>" は
空白文字を I<意味する> フォーマッティングコードです。)

=begin original

A B<Pod parser> is a module meant for parsing Pod (regardless of
whether this involves calling callbacks or building a parse tree or
directly formatting it).  A B<Pod formatter> (or B<Pod translator>)
is a module or program that converts Pod to some other format (HTML,
plaintext, TeX, PostScript, RTF).  A B<Pod processor> might be a
formatter or translator, or might be a program that does something
else with the Pod (like counting words, scanning for index points,
etc.).

=end original

B<Pod パーサ> (Pod parser) は Pod をパースするためのモジュールです
(これはコールバックを呼び出すかパース木を構築するか直接フォーマットするかに
関わりません)。
B<Pod フォーマッタ> (Pod formatter) (または B<Pod トランスレータ>
(Pod translator)) は Pod を他の形式 (HTML, プレーンテキスト、Tex,
PostScript, RTF) に変換するモジュールかプログラムです。
B<Pod プロセッサ> (Pod processor) はフォーマッタあるいはトランスレータか、
あるいは Pod に何かの処理(単語を数える、インデックスをスキャンする、など)を
行うプログラムかも知れません。

=begin original

Pod content is contained in B<Pod blocks>.  A Pod block starts with a
line that matches C<m/\A=[a-zA-Z]/>, and continues up to the next line
that matches C<m/\A=cut/> or up to the end of the file if there is
no C<m/\A=cut/> line.

=end original

Pod の内容は B<Pod ブロック> (Pod blocks) に含まれています。
一つの Pod ブロックは C<m/\A=[a-zA-Z]/> にマッチングする行で開始し、
C<m/\A=cut/> にマッチングする次の行までか、もし
C<m/\A=cut/> 行がなければファイルの最後まで続きます。

=for comment
 The current perlsyn says:
 [beginquote]
   Note that pod translators should look at only paragraphs beginning
   with a pod directive (it makes parsing easier), whereas the compiler
   actually knows to look for pod escapes even in the middle of a
   paragraph.  This means that the following secret stuff will be ignored
   by both the compiler and the translators.
      $a=3;
      =secret stuff
       warn "Neither POD nor CODE!?"
      =cut back
      print "got $a\n";
   You probably shouldn't rely upon the warn() being podded out forever.
   Not all pod translators are well-behaved in this regard, and perhaps
   the compiler will become pickier.
 [endquote]
 I think that those paragraphs should just be removed; paragraph-based
 parsing  seems to have been largely abandoned, because of the hassle
 with non-empty blank lines messing up what people meant by "paragraph".
 Even if the "it makes parsing easier" bit were especially true,
 it wouldn't be worth the confusion of having perl and pod2whatever
 actually disagree on what can constitute a Pod block.

=begin original

Within a Pod block, there are B<Pod paragraphs>.  A Pod paragraph
consists of non-blank lines of text, separated by one or more blank
lines.

=end original

Pod ブロックの内部は、B<Pod 段落>(Pod paragraphs) です。
一つの Pod 段落は、1 以上の空行で分割された非空行のテキストで構成されます。

=begin original

For purposes of Pod processing, there are four types of paragraphs in
a Pod block:

=end original

Pod 処理のために、Pod ブロックには 4 種類の段落があります:

=over

=item *

=begin original

A command paragraph (also called a "directive").  The first line of
this paragraph must match C<m/\A=[a-zA-Z]/>.  Command paragraphs are
typically one line, as in:

=end original

コマンド段落 (command paragraph) (「指示子」(directive) とも呼ばれます)。
段落の最初の行は C<m/\A=[a-zA-Z]/> にマッチングしなければなりません(must)。
コマンド段落は典型的には以下のように 1 行です:

  =head1 NOTES

  =item *

=begin original

But they may span several (non-blank) lines:

=end original

しかし複数の (非空行の) 行にわたってもかまいません(may):

  =for comment
  Hm, I wonder what it would look like if
  you tried to write a BNF for Pod from this.

  =head3 Dr. Strangelove, or: How I Learned to
  Stop Worrying and Love the Bomb

=begin original

I<Some> command paragraphs allow formatting codes in their content
(i.e., after the part that matches C<m/\A=[a-zA-Z]\S*\s*/>), as in:

=end original

I<一部の> コマンド段落は、以下のように、内容 (つまり、
C<m/\A=[a-zA-Z]\S*\s*/> にマッチングする部分の後)にフォーマッティングコードを
許しています:

  =head1 Did You Remember to C<use strict;>?

=begin original

In other words, the Pod processing handler for "head1" will apply the
same processing to "Did You Remember to CE<lt>use strict;>?" that it
would to an ordinary paragraph (i.e., formatting codes like
"CE<lt>...>") are parsed and presumably formatted appropriately, and
whitespace in the form of literal spaces and/or tabs is not
significant.

=end original

言い換えると、"head1" の Pod 処理ハンドラは、
"Did You Remember to CE<lt>use strict;>?" を、通常の段落
(つまり、"CE<lt>...>" のようなフォーマッティングコード) が
パースされ、おそらくは適切にフォーマットされ、リテラルのスペースや
タブといった形の空白は無視されるというのと同じ処理を適用します。

=item *

=begin original

A B<verbatim paragraph>.  The first line of this paragraph must be a
literal space or tab, and this paragraph must not be inside a "=begin
I<identifier>", ... "=end I<identifier>" sequence unless
"I<identifier>" begins with a colon (":").  That is, if a paragraph
starts with a literal space or tab, but I<is> inside a
"=begin I<identifier>", ... "=end I<identifier>" region, then it's
a data paragraph, unless "I<identifier>" begins with a colon.

=end original

B<そのままの段落> (verbatim paragraph)。
この段落の最初の行はリテラルのスペースかタブでなければならず(must)、
この段落は "I<identifier>" がコロン (":") で始まっていない限り
"=begin I<identifier>", ... "=end I<identifier>" を内部に
含んではいけません(must not)。
つまり、もし段落がリテラルのスペースかタブで始まっているけれども、
内部に "=begin I<identifier>", ... "=end I<identifier>" 領域がある場合、
"I<identifier>" がコロンで始まっていない限りデータ段落です。

=begin original

Whitespace I<is> significant in verbatim paragraphs (although, in
processing, tabs are probably expanded).

=end original

空白はそのままの段落では I<意味を持ちます> (しかし、処理中に、タブは
おそらく展開されます)。

=item *

=begin original

An B<ordinary paragraph>.  A paragraph is an ordinary paragraph
if its first line matches neither C<m/\A=[a-zA-Z]/> nor
C<m/\A[ \t]/>, I<and> if it's not inside a "=begin I<identifier>",
... "=end I<identifier>" sequence unless "I<identifier>" begins with
a colon (":").

=end original

B<通常の段落> (ordinary paragraph)。
最初の行が C<m/\A=[a-zA-Z]/> にも C<m/\A[ \t]/> にもマッチングせず、
I<かつ>、コロン (":") 以外で始まる "I<identifier>" に対する
"=begin I<identifier>" ... "=end I<identifier>" シーケンスの内側で
ない段落は、通常の段落です。

=item *

=begin original

A B<data paragraph>.  This is a paragraph that I<is> inside a "=begin
I<identifier>" ... "=end I<identifier>" sequence where
"I<identifier>" does I<not> begin with a literal colon (":").  In
some sense, a data paragraph is not part of Pod at all (i.e.,
effectively it's "out-of-band"), since it's not subject to most kinds
of Pod parsing; but it is specified here, since Pod
parsers need to be able to call an event for it, or store it in some
form in a parse tree, or at least just parse I<around> it.

=end original

B<データ段落> (data paragraph)。
これは "=begin I<identifier>" ... "=end I<identifier>" シーケンスの
内部で、"I<identifier>" がリテラルのコロン (":") で
始まって I<いない> ものです。
ある意味では、データ段落は Pod の一部ではありません
(事実上「帯域外」です); なぜならほとんどの種類の Pod パーサが
想定していないからです; しかし、Pod パーサはこれのためのイベントを
呼び出したり、パース木に何らかの形で補完したり、あるいは少なくとも
単にその I<周り> をパースする必要があるからです。

=back

=begin original

For example: consider the following paragraphs:

=end original

例えば: 以下の段落を考えます:

  # <- that's the 0th column

  =head1 Foo

  Stuff

    $foo->bar

  =cut

=begin original

Here, "=head1 Foo" and "=cut" are command paragraphs because the first
line of each matches C<m/\A=[a-zA-Z]/>.  "I<[space][space]>$foo->bar"
is a verbatim paragraph, because its first line starts with a literal
whitespace character (and there's no "=begin"..."=end" region around).

=end original

ここで、"=head1 Foo" と "=cut" は、それぞれ最初の行が C<m/\A=[a-zA-Z]/> に
マッチングするのでコマンド段落です。
"I<[space][space]>$foo->bar" は、最初の行がリテラルの空白文字で始まる
(そして周りに "=begin"..."=end" 領域がない)のでそのままの段落です。

=begin original

The "=begin I<identifier>" ... "=end I<identifier>" commands stop
paragraphs that they surround from being parsed as ordinary or verbatim
paragraphs, if I<identifier> doesn't begin with a colon.  This
is discussed in detail in the section
L</About Data Paragraphs and "=beginE<sol>=end" Regions>.

=end original

"=begin I<identifier>" ... "=end I<identifier>" コマンドは、
I<identifier> がコロンで始まっていないなら、その内部の段落を、
通常の段落やそのままの段落として解釈するのを停止させます。
これは L</About Data Paragraphs and "=beginE<sol>=end" Regions> の節で詳しく
議論しています。

=head1 Pod Commands

(Pod コマンド)

=begin original

This section is intended to supplement and clarify the discussion in
L<perlpod/"Command Paragraph">.  These are the currently recognized
Pod commands:

=end original

この章は L<perlpod/"Command Paragraph"> での議論を補完して明確化することを
目的にしています。
現在認識されている Pod コマンドは以下の通りです:

=over

=item "=head1", "=head2", "=head3", "=head4"

=begin original

This command indicates that the text in the remainder of the paragraph
is a heading.  That text may contain formatting codes.  Examples:

=end original

このコマンドは、この段落の残りの文章が見出しであることを示します。
この文章にはフォーマッティングコードを含むことができます。
例:

  =head1 Object Attributes

  =head3 What B<Not> to Do!

=item "=pod"

=begin original

This command indicates that this paragraph begins a Pod block.  (If we
are already in the middle of a Pod block, this command has no effect at
all.)  If there is any text in this command paragraph after "=pod",
it must be ignored.  Examples:

=end original

このコマンドは、この段落から Pod ブロックが始まることを示します。
(すでに Pod ブロックの内部である場合は、このコマンドは何の効果も
ありません。)
もしこのコマンド段落の "=pod" の後に何らかの文章がある場合、
無視しなければなりません(must)。
例:

  =pod

  This is a plain Pod paragraph.

  =pod This text is ignored.

=item "=cut"

=begin original

This command indicates that this line is the end of this previously
started Pod block.  If there is any text after "=cut" on the line, it must be
ignored.  Examples:

=end original

このコマンドは、この行が Pod ブロックの終わりであることを示します。
この行の "=cut" の後にテキストがあれば、これは
無視しなければなりません(must)。
例:

  =cut

  =cut The documentation ends here.

  =cut
  # This is the first line of program text.
  sub foo { # This is the second.

=begin original

It is an error to try to I<start> a Pod block with a "=cut" command.  In
that case, the Pod processor must halt parsing of the input file, and
must by default emit a warning.

=end original

Pod ブロックを "=cut" コマンドで I<開始> しようとするとエラーになります。
この場合、Pod プロセッサは入力ファイルのパースを中止しなければならず(must)、
デフォルトでは警告を出力しなければなりません(must)。

=item "=over"

=begin original

This command indicates that this is the start of a list/indent
region.  If there is any text following the "=over", it must consist
of only a nonzero positive numeral.  The semantics of this numeral is
explained in the L</"About =over...=back Regions"> section, further
below.  Formatting codes are not expanded.  Examples:

=end original

このコマンドは、これがリスト/インデント領域の開始であることを示します。
"=over" に引き続いてなんらかのテキストがある場合は、それは非ゼロの
正数のみでなければなりません(must)。
この数値の意味論はかなり後ろの L</"About =over...=back Regions"> の節に
あります。
フォーマッティングコードは展開されません。
例:

  =over 3

  =over 3.5

  =over

=item "=item"

=begin original

This command indicates that an item in a list begins here.  Formatting
codes are processed.  The semantics of the (optional) text in the
remainder of this paragraph are
explained in the L</"About =over...=back Regions"> section, further
below.  Examples:

=end original

このコマンドは、ここからリストの中のアイテムが始まることを示します。
フォーマッティングコードは処理されます。
この段落の(オプションである)残りのテキストの意味論はかなり後ろの
L</"About =over...=back Regions"> の節にあります。
例:

  =item

  =item *

  =item      *    

  =item 14

  =item   3.

  =item C<< $thing->stuff(I<dodad>) >>

  =item For transporting us beyond seas to be tried for pretended
  offenses

  =item He is at this time transporting large armies of foreign
  mercenaries to complete the works of death, desolation and
  tyranny, already begun with circumstances of cruelty and perfidy
  scarcely paralleled in the most barbarous ages, and totally
  unworthy the head of a civilized nation.

=item "=back"

=begin original

This command indicates that this is the end of the region begun
by the most recent "=over" command.  It permits no text after the
"=back" command.

=end original

このコマンドは、ここがもっとも近い位置の "=over" コマンドで始まった領域の
終わりであることを示します。
"=back" コマンドの後にテキストを置くことは許されません。

=item "=begin formatname"

=item "=begin formatname parameter"

=begin original

This marks the following paragraphs (until the matching "=end
formatname") as being for some special kind of processing.  Unless
"formatname" begins with a colon, the contained non-command
paragraphs are data paragraphs.  But if "formatname" I<does> begin
with a colon, then non-command paragraphs are ordinary paragraphs
or data paragraphs.  This is discussed in detail in the section
L</About Data Paragraphs and "=beginE<sol>=end" Regions>.

=end original

これは、引き続く段落 (マッチングする "=end formatname" まで) が
なんらかの特殊な処理をするためのものであることを示します。
"formatname" がコロンで始まっていなければ、含まれている非コマンド段落は
データ段落です。
しかし、もし "formatname" がコロンで I<始まっている> なら、非コマンド段落は
通常の段落かデータ段落です。
これは L</About Data Paragraphs and "=beginE<sol>=end" Regions> の節で詳しく
議論しています。

=begin original

It is advised that formatnames match the regexp
C<m/\A:?[-a-zA-Z0-9_]+\z/>.  Everything following whitespace after the
formatname is a parameter that may be used by the formatter when dealing
with this region.  This parameter must not be repeated in the "=end"
paragraph.  Implementors should anticipate future expansion in the
semantics and syntax of the first parameter to "=begin"/"=end"/"=for".

=end original

formatname は正規表現 C<m/\A:?[-a-zA-Z0-9_]+\z/> にマッチングすることを
勧めます。
formatname の後ろの空白に引き続く全てのものは、フォーマッタがこの
領域を扱うときに使われるかも知れないパラメータです。
このパラメータは "=end" 段落では繰り返されてはいけません(must not)。
実装者は "=begin"/"=end"/"=for" の最初の引数の意味論と文法の将来の拡張に
備えるべきです(should)。

=item "=end formatname"

=begin original

This marks the end of the region opened by the matching
"=begin formatname" region.  If "formatname" is not the formatname
of the most recent open "=begin formatname" region, then this
is an error, and must generate an error message.  This
is discussed in detail in the section
L</About Data Paragraphs and "=beginE<sol>=end" Regions>.

=end original

これはマッチングする "=begin formatname"  領域によって開かれた領域の
終わりを示します。
"formatname" が直近に開かれた "=begin formatname" 領域の formatname では
ない場合、これはエラーであり、エラーメッセージを
生成しなければなりません(must)。
これは L</About Data Paragraphs and "=beginE<sol>=end" Regions> の節で詳しく
議論しています。

=item "=for formatname text..."

=begin original

This is synonymous with:

=end original

これは以下と同等です:

     =begin formatname

     text...

     =end formatname

=begin original

That is, it creates a region consisting of a single paragraph; that
paragraph is to be treated as a normal paragraph if "formatname"
begins with a ":"; if "formatname" I<doesn't> begin with a colon,
then "text..." will constitute a data paragraph.  There is no way
to use "=for formatname text..." to express "text..." as a verbatim
paragraph.

=end original

つまり、これは単一の段落からなる領域を作成します; この段落は、
"formatname" が ":" で始まっているなら通常の段落として扱われます;
"formatname" がコロンで I<始まっていない> なら、"text..." は
データ段落を構成します。
"text..." をそのままの段落として記述するために "=for formatname text..." を
使う方法はありません。

=item "=encoding encodingname"

=begin original

This command, which should occur early in the document (at least
before any non-US-ASCII data!), declares that this document is
encoded in the encoding I<encodingname>, which must be
an encoding name that L<Encode> recognizes.  (Encode's list
of supported encodings, in L<Encode::Supported>, is useful here.)
If the Pod parser cannot decode the declared encoding, it 
should emit a warning and may abort parsing the document
altogether.

=end original

このコマンドは(文書の最初の方に(少なくとも非 US-ASCII データが出てくる
前に!)書くべきです(should))、この文書がエンコーディング I<encodingname> で
エンコードされていることを宣言します; これは L<Encode> が認識する
エンコーディングでなければなりません(must)。
(L<Encode::Supported> にある、Encode が対応するエンコーディングの一覧が
便利です。)
Pod パーサが宣言されたエンコーディングでデコードできない場合は、
警告を出力するべき(should)で、文書のパースを中断してもかまいません(may)。

=begin original

A document having more than one "=encoding" line should be
considered an error.  Pod processors may silently tolerate this if
the not-first "=encoding" lines are just duplicates of the
first one (e.g., if there's a "=encoding utf8" line, and later on
another "=encoding utf8" line).  But Pod processors should complain if
there are contradictory "=encoding" lines in the same document
(e.g., if there is a "=encoding utf8" early in the document and
"=encoding big5" later).  Pod processors that recognize BOMs
may also complain if they see an "=encoding" line
that contradicts the BOM (e.g., if a document with a UTF-16LE
BOM has an "=encoding shiftjis" line).

=end original

複数の "=encoding" 行を持つ文書はエラーとして扱われるべきです(should)。
Pod プロセッサは、最初以外の "=encoding" 行が最初のものと同じ場合
(例えば、"=encoding utf8" 行があって、その後また "=encoding utf8" 行が
あった場合)は黙って許容してもかまいません(may)。
しかし Pod プロセッサは、同じ文書に矛盾する "=encoding" 行がある場合
(例えば、文書の最初の方に "=encoding utf8" があって、その後 "=encoding big5"
行があった場合) エラーにするべきです(should)。
BOM を認識する Pod プロセッサは、BOM と矛盾する "=encoding" 行がある場合
(例えば、文書が UTF-16LE BOM で始まっていて "=encoding shiftjis" 行がある
場合)、エラーにしてもかまいません(may)。

=back

=begin original

If a Pod processor sees any command other than the ones listed
above (like "=head", or "=haed1", or "=stuff", or "=cuttlefish",
or "=w123"), that processor must by default treat this as an
error.  It must not process the paragraph beginning with that
command, must by default warn of this as an error, and may
abort the parse.  A Pod parser may allow a way for particular
applications to add to the above list of known commands, and to
stipulate, for each additional command, whether formatting
codes should be processed.

=end original

Pod プロセッサが上に示した以外のコマンド ("=head", "=haed1", "=stuff",
"=cuttlefish", "=w123" など)に遭遇した場合、プロセッサはデフォルトでは
エラーとして扱わなければなりません(must)。
このようなコマンドで始まる段落を処理してはならず(must not)、デフォルトでは
エラーとして警告しなければならず(must)、パースを
中断してもかまいません(may)。
Pod パーサは、特定のアプリケーションのために、上述の既知のコマンドの一覧に
追加して、それぞれの追加コマンドに対して、フォーマッティングコードを
処理するかどうかを規定する方法を認めてもかまいません(may)。

=begin original

Future versions of this specification may add additional
commands.

=end original

この仕様の将来のバージョンでは追加のコマンドが追加されるかもしれません。

=head1 Pod Formatting Codes

(Pod フォーマッティングコード)

=begin original

(Note that in previous drafts of this document and of perlpod,
formatting codes were referred to as "interior sequences", and
this term may still be found in the documentation for Pod parsers,
and in error messages from Pod processors.)

=end original

(この文書の以前の草案と以前の perlpod では、フォーマッティングコードは
「内部シーケンス」(interior sequences) として参照されていて、
この用語は Pod パーサの文書や、Pod プロセッサのエラーメッセージに
まだ残っていることに注意してください。)

=begin original

There are two syntaxes for formatting codes:

=end original

フォーマッティングコードには二つの文法があります:

=over

=item *

=begin original

A formatting code starts with a capital letter (just US-ASCII [A-Z])
followed by a "<", any number of characters, and ending with the first
matching ">".  Examples:

=end original

英大文字 (ちょうど US-ASCII [A-Z]) で始まり、次に "<"、その次に
任意の数の文字が続き、最初にマッチングする ">" で終わる
フォーマッティングコード。
例:

    That's what I<you> think!

    What's C<dump()> for?

    X<C<chmod> and C<unlink()> Under Different Operating Systems>

=item *

=begin original

A formatting code starts with a capital letter (just US-ASCII [A-Z])
followed by two or more "<"'s, one or more whitespace characters,
any number of characters, one or more whitespace characters,
and ending with the first matching sequence of two or more ">"'s, where
the number of ">"'s equals the number of "<"'s in the opening of this
formatting code.  Examples:

=end original

英大文字 (ちょうど US-ASCII [A-Z]) で始まり、2 個以上の "<"、
1 個以上の空白文字、任意の数の文字、1 個以上の空白文字が続き、
このフォーマッティングコードの最初にあった "<" と同じ数の ">" で
終わるフォーマッティングコード。
例:

    That's what I<< you >> think!

    C<<< open(X, ">>thing.dat") || die $! >>>

    B<< $foo->bar(); >>

=begin original

With this syntax, the whitespace character(s) after the "CE<lt><<"
and before the ">>>" (or whatever letter) are I<not> renderable. They
do not signify whitespace, are merely part of the formatting codes
themselves.  That is, these are all synonymous:

=end original

この文法では、"CE<lt><<" の後ろと ">>>" (やその他の文字) の前の空白文字は
レンダリング I<されません> 。
空白は認識せず、単にフォーマッティングコード自身の一部となります。
つまり、以下のものは全て同じ意味です:

    C<thing>
    C<< thing >>
    C<<           thing     >>
    C<<<   thing >>>
    C<<<<
    thing
               >>>>

=begin original

and so on.

=end original

および同様なものです。

=begin original

Finally, the multiple-angle-bracket form does I<not> alter the interpretation
of nested formatting codes, meaning that the following four example lines are
identical in meaning:

=end original

最後に、複数山かっこ形式はネストしたフォーマッティングコードの解釈を
変更 I<しません>; つまり、以下の四つの例は意味としては同じです:

  B<example: C<$a E<lt>=E<gt> $b>>

  B<example: C<< $a <=> $b >>>

  B<example: C<< $a E<lt>=E<gt> $b >>>

  B<<< example: C<< $a E<lt>=E<gt> $b >> >>>

=back

=begin original

In parsing Pod, a notably tricky part is the correct parsing of
(potentially nested!) formatting codes.  Implementors should
consult the code in the C<parse_text> routine in Pod::Parser as an
example of a correct implementation.

=end original

Pod をパースするときに特にトリッキーな部分は、(ネストしているかもしれない!)
フォーマッティングコードを正しくパースすることです。
実装者は正しい実装の例として、Pod::Parsar の C<parse_text> ルーチンの
コードを参考にするべきです。

=over

=item C<IE<lt>textE<gt>> -- italic text

(C<IE<lt>textE<gt>> -- イタリック文字)

=begin original

See the brief discussion in L<perlpod/"Formatting Codes">.

=end original

L<perlpod/"Formatting Codes"> にある簡潔な議論を参照してください。

=item C<BE<lt>textE<gt>> -- bold text

(C<BE<lt>textE<gt>> -- ボールド文字)

=begin original

See the brief discussion in L<perlpod/"Formatting Codes">.

=end original

L<perlpod/"Formatting Codes"> にある簡潔な議論を参照してください。

=item C<CE<lt>codeE<gt>> -- code text

(C<CE<lt>codeE<gt>> -- コード文字)

=begin original

See the brief discussion in L<perlpod/"Formatting Codes">.

=end original

L<perlpod/"Formatting Codes"> にある簡潔な議論を参照してください。

=item C<FE<lt>filenameE<gt>> -- style for filenames

(C<FE<lt>filenameE<gt>> -- ファイル名用のスタイル)

=begin original

See the brief discussion in L<perlpod/"Formatting Codes">.

=end original

L<perlpod/"Formatting Codes"> にある簡潔な議論を参照してください。

=item C<XE<lt>topic nameE<gt>> -- an index entry

(C<XE<lt>topic nameE<gt>> -- インデックスエントリ)

=begin original

See the brief discussion in L<perlpod/"Formatting Codes">.

=end original

L<perlpod/"Formatting Codes"> にある簡潔な議論を参照してください。

=begin original

This code is unusual in that most formatters completely discard
this code and its content.  Other formatters will render it with
invisible codes that can be used in building an index of
the current document.

=end original

このコードは特殊で、ほとんどのフォーマッタはこのコードとその内容は
完全に捨てられます。
その他のフォーマッタは現在の文書のインデックス構築に使える
見えないコードとしてレンダリングされます。

=item C<ZE<lt>E<gt>> -- a null (zero-effect) formatting code

=begin original

Discussed briefly in L<perlpod/"Formatting Codes">.

=end original

L<perlpod/"Formatting Codes"> で簡潔に議論されています。

=begin original

This code is unusual is that it should have no content.  That is,
a processor may complain if it sees C<ZE<lt>potatoesE<gt>>.  Whether
or not it complains, the I<potatoes> text should ignored.

=end original

このコードは特殊で、内容はなしであるべきです(should)。
つまり、プロセッサが C<ZE<lt>potatoesE<gt>> を見ると異常とみなしても
かまいません(may)。
異常とみなすかどうかに関わらず、I<potatoes> という文字は
無視されるべきです(should)。

=item C<LE<lt>nameE<gt>> -- a hyperlink

(C<LE<lt>nameE<gt>> -- ハイパーリンク)

=begin original

The complicated syntaxes of this code are discussed at length in
L<perlpod/"Formatting Codes">, and implementation details are
discussed below, in L</"About LE<lt>...E<gt> Codes">.  Parsing the
contents of LE<lt>content> is tricky.  Notably, the content has to be
checked for whether it looks like a URL, or whether it has to be split
on literal "|" and/or "/" (in the right order!), and so on,
I<before> EE<lt>...> codes are resolved.

=end original

このコードの複雑な文法は L<perlpod/"Formatting Codes"> で詳細に
議論されていて、実装の詳細は後述する L</"About LE<lt>...E<gt> Codes"> に
あります。
LE<lt>content> の内容のパースはトリッキーです。
特に、EE<lt>...> コードが解決される I<前に> 、
内容が URL のように見えるか、あるいは内容が "|" や "/" で
分割する必要があるか (右順序で!) などです。 

=item C<EE<lt>escapeE<gt>> -- a character escape

(C<EE<lt>escapeE<gt>> -- 文字エスケープ)

=begin original

See L<perlpod/"Formatting Codes">, and several points in
L</Notes on Implementing Pod Processors>.

=end original

L<perlpod/"Formatting Codes"> と、
L</Notes on Implementing Pod Processors> にあるいくつかのポイントを
参照してください。

=item C<SE<lt>textE<gt>> -- text contains non-breaking spaces

(C<SE<lt>textE<gt>> -- ノーブレークスペースを含む文字列)

=begin original

This formatting code is syntactically simple, but semantically
complex.  What it means is that each space in the printable
content of this code signifies a non-breaking space.

=end original

このフォーマッティングコードは文法的には単純ですが、意味論的には複雑です。
これが意味することは、このコードの内容にあるそれぞれのスペースは
ノーブレークスペースとして認識されるということです。

=begin original

Consider:

=end original

以下のものを考えます:

    C<$x ? $y    :  $z>

    S<C<$x ? $y     :  $z>>

=begin original

Both signify the monospace (c[ode] style) text consisting of
"$x", one space, "?", one space, ":", one space, "$z".  The
difference is that in the latter, with the S code, those spaces
are not "normal" spaces, but instead are non-breaking spaces.

=end original

どちらも "$x"、一つのスペース、"?"、一つのスペース、":"、一つのスペース、
"$z" からなる、固定幅 (コードスタイル) 文字列として認識されます。
違いは、S コードの付いている後者は、これらのスペースは「普通の」
スペースではなく、ノーブレークスペースであるということです。

=back

=begin original

If a Pod processor sees any formatting code other than the ones
listed above (as in "NE<lt>...>", or "QE<lt>...>", etc.), that
processor must by default treat this as an error.
A Pod parser may allow a way for particular
applications to add to the above list of known formatting codes;
a Pod parser might even allow a way to stipulate, for each additional
command, whether it requires some form of special processing, as
LE<lt>...> does.

=end original

Pod プロセッサが ("NE<lt>...>" や "QE<lt>...>" のような) 上述のもの
以外のフォーマットコードに出会った場合、プロセッサはデフォルトでは
エラーとして扱わなければなりません (must)。
Pod パーサは、特定のアプリケーションのために、上述の既知のフォーマッティング
コードの一覧に追加する方法を認めてもかまいません(may);
Pod パーサは追加されたコマンドそれぞれに対して、LE<lt>...> が
しているように、特殊処理のためのある種の形式を要求するかどうかを
規定しているかもしれません。

=begin original

Future versions of this specification may add additional
formatting codes.

=end original

この仕様の将来のバージョンでは追加のフォーマッティングコードが
追加されるかもしれません。

=begin original

Historical note:  A few older Pod processors would not see a ">" as
closing a "CE<lt>" code, if the ">" was immediately preceded by
a "-".  This was so that this:

=end original

ヒストリカルノート: いくつかの古い Pod プロセッサは、"-" の直後にある
">" を、閉じ "CE<lt>" コードとして扱いません。
これにより、以下のようなものが:

    C<$foo->bar>

=begin original

would parse as equivalent to this:

=end original

以下のものと等価として扱われ:

    C<$foo-E<gt>bar>

=begin original

instead of as equivalent to a "C" formatting code containing 
only "$foo-", and then a "bar>" outside the "C" formatting code.  This
problem has since been solved by the addition of syntaxes like this:

=end original

"$foo-" だけが含まれる "C" フォーマッティングコードの後
"C" フォーマッティングコード の外にある "bar>"、と等価にはなりません。
この問題は以下のような文法の追加によって解決されました:

    C<< $foo->bar >>

=begin original

Compliant parsers must not treat "->" as special.

=end original

準拠しているパーサは "->" を特別扱いしてはいけません (must not)。

=begin original

Formatting codes absolutely cannot span paragraphs.  If a code is
opened in one paragraph, and no closing code is found by the end of
that paragraph, the Pod parser must close that formatting code,
and should complain (as in "Unterminated I code in the paragraph
starting at line 123: 'Time objects are not...'").  So these
two paragraphs:

=end original

フォーマッティングコードは絶対に段落をまたげません。
もしコードがある段落で開き、その段落の終わりまでに閉じコードがない場合、
Pod パーサはフォーマッティングを閉じなければならず(must)、
また ("Unterminated I code in the paragraph starting at line 123:
'Time objects are not...'" のような) エラーを出力するべきです (should)。
従って、これら二つの段落は:

  I<I told you not to do this!

  Don't make me say it again!>

=begin original

...must I<not> be parsed as two paragraphs in italics (with the I
code starting in one paragraph and starting in another.)  Instead,
the first paragraph should generate a warning, but that aside, the
above code must parse as if it were:

=end original

(I コードが一つ目の段落から始まって次の段落でも始まっているという形で)
二つの段落をイタリックとしてパース I<してはいけません>(must not)。
代わりに、最初の段落は警告を生成するべきです(should)ですが、それを
置いておいて、上述のコードは以下のようであるかのように
パースしなければなりません(must):

  I<I told you not to do this!>

  Don't make me say it again!E<gt>

=begin original

(In SGMLish jargon, all Pod commands are like block-level
elements, whereas all Pod formatting codes are like inline-level
elements.)

=end original

(SGML 的な jargon で言うなら、全ての Pod コマンドはブロックレベル要素の
ようなもので、一方全ての Pod フォーマッティングコードはインライン要素の
ようなものです。)

=head1 Notes on Implementing Pod Processors

(Pod プロセッサの実装に関するメモ)

=begin original

The following is a long section of miscellaneous requirements
and suggestions to do with Pod processing.

=end original

以下は、Pod の処理を行うためのさまざまな要求と提案の長いリストです。

=over

=item *

=begin original

Pod formatters should tolerate lines in verbatim blocks that are of
any length, even if that means having to break them (possibly several
times, for very long lines) to avoid text running off the side of the
page.  Pod formatters may warn of such line-breaking.  Such warnings
are particularly appropriate for lines are over 100 characters long, which
are usually not intentional.

=end original

Pod フォーマッタは、たとえテキストがページからはみ出すのを避けるために
(とても長い行に対しては複数回)分割しないといけないとしても、
任意の長さのそのままのブロックの行を許容するべきです(should)。
Pod フォーマッタはそのような行分割に対して警告を出してもかまいません(may)。
この警告は特に、(普通は意図したものではない) 100 文字以上の行に対して
出すのが適切です。

=item *

=begin original

Pod parsers must recognize I<all> of the three well-known newline
formats: CR, LF, and CRLF.  See L<perlport|perlport>.

=end original

Pod パーサは 3 種類のよく知られた改行 (CR, LF, CRLF) の I<全て> を
認識しなければなりません(must)。
L<perlport|perlport> を参照してください。

=item *

=begin original

Pod parsers should accept input lines that are of any length.

=end original

Pod パーサは任意の長さの入力行を受け付けるべきです(should)。

=item *

=begin original

Since Perl recognizes a Unicode Byte Order Mark at the start of files
as signaling that the file is Unicode encoded as in UTF-16 (whether
big-endian or little-endian) or UTF-8, Pod parsers should do the
same.  Otherwise, the character encoding should be understood as
being UTF-8 if the first highbit byte sequence in the file seems
valid as a UTF-8 sequence, or otherwise as CP-1252 (earlier versions of
this specification used Latin-1 instead of CP-1252).

=end original

Perl は、ファイルの先頭に付けることでファイルが UTF-16
(ビッグエンディアンかリトルエンディアンか)あるいは UTF-8 かを
示すためにファイルの先頭に付けるバイト順マーク(Byte Order Mark)を
認識するので、Pod パーサも同様であるべきです(should)。
さもなければ、ファイル中の最初の最上位ビットの立ったバイトシーケンスが
UTF-8 シーケンスとして有効であるように見える場合は文字エンコーディング
UTF-8 と、そうでなければ CP-1252 と認識するべきです(should)
(この仕様の以前の版では CP-1252 ではなく Latin-1 を使っていました)。

=begin original

Future versions of this specification may specify
how Pod can accept other encodings.  Presumably treatment of other
encodings in Pod parsing would be as in XML parsing: whatever the
encoding declared by a particular Pod file, content is to be
stored in memory as Unicode characters.

=end original

この仕様の将来のバージョンでは Pod がその他のエンコーディングをどのように
受け入れるかが指定されるかもしれません。
おそらく Pod パース中のその他のエンコーディングの扱いは XML のパースと
同じようになるでしょう: 特定の Pod ファイルでどのエンコーディングが
宣言されたとしても、内容は Unicode 文字としてメモリに補完されます。

=item *

=begin original

The well known Unicode Byte Order Marks are as follows:  if the
file begins with the two literal byte values 0xFE 0xFF, this is
the BOM for big-endian UTF-16.  If the file begins with the two
literal byte value 0xFF 0xFE, this is the BOM for little-endian
UTF-16.  On an ASCII platform, if the file begins with the three literal
byte values
0xEF 0xBB 0xBF, this is the BOM for UTF-8.
A mechanism portable to EBCDIC platforms is to:

=end original

よく知られているバイト順マークには以下のものがあります:
もしファイルが二つのリテラルバイト値 0xFE 0xFF で始まっているなら、
これはビッグエンディアン UTF-16 の BOM です。
もしファイルが二つのリテラルバイト値 0xFF 0xFE で始まっているなら、
これはリトルエンディアン UTF-16 の BOM です。
ASCII プラットフォームでは、もしファイルが三つのリテラルバイト値
0xEF 0xBB 0xBF で始まっているなら、これは UTF-8 の BOM です。
EBCDIC プラットフォームと移植性のある機構は:

  my $utf8_bom = "\x{FEFF}";
  utf8::encode($utf8_bom);

=for comment
 use bytes; print map sprintf(" 0x%02X", ord $_), split '', "\x{feff}";
 0xEF 0xBB 0xBF

=for comment
 If toke.c is modified to support UTF-32, add mention of those here.

=item *

=begin original

A naive, but often sufficient heuristic on ASCII platforms, for testing
the first highbit
byte-sequence in a BOM-less file (whether in code or in Pod!), to see
whether that sequence is valid as UTF-8 (RFC 2279) is to check whether
that the first byte in the sequence is in the range 0xC2 - 0xFD
I<and> whether the next byte is in the range
0x80 - 0xBF.  If so, the parser may conclude that this file is in
UTF-8, and all highbit sequences in the file should be assumed to
be UTF-8.  Otherwise the parser should treat the file as being
in CP-1252.  (A better check, and which works on EBCDIC platforms as
well, is to pass a copy of the sequence to
L<utf8::decode()|utf8> which performs a full validity check on the
sequence and returns TRUE if it is valid UTF-8, FALSE otherwise.  This
function is always pre-loaded, is fast because it is written in C, and
will only get called at most once, so you don't need to avoid it out of
performance concerns.)
In the unlikely circumstance that the first highbit
sequence in a truly non-UTF-8 file happens to appear to be UTF-8, one
can cater to our heuristic (as well as any more intelligent heuristic)
by prefacing that line with a comment line containing a highbit
sequence that is clearly I<not> valid as UTF-8.  A line consisting
of simply "#", an e-acute, and any non-highbit byte,
is sufficient to establish this file's encoding.

=end original

並びが有効な UTF-8 (RFC 2279) かどうかを見るための、
BOM なしファイルの(コード内か POD内内かに関わらず)最初の最上位ビットが
立ったバイト並びをテストするという単純だけれども ASCII プラットフォームでは
十分な発見法は、並びの最初のバイトが 0xC2 - 0xFD の範囲 I<かつ> 次のバイトの
範囲が 0x80 - 0xBF であるかどうかを調べることです。
もしそうなら、パーサはこのファイルが UTF-8 で、そのファイルの全ての
最上位ビットが立った並びが UTF-8 であると結論づけてもかまいません(may)。
さもなければパーサはそのファイルを CP-1252 として扱うべきです (should)。
(より良く、EBCDIC プラットフォームでも動作するチェックは、
並びのコピーを L<utf8::decode()|utf8> に渡すことで、これは並びの
完全な正当性チェックを実行し、これが有効な UTF-8 なら TRUE を、さもなければ
FALSE を返します。
この関数は常に事前読み込みされ、C で書かれているので高速で、
最大でも 1 回だけしか呼び出されないので、性能を考慮してこれを避ける
必要はありません。)
真に 非 UTF-8 のファイルの最初の最上位ビットが立った並びがたまたま
UTF-8 に見えるというのはありそうにない状況なので、明確に UTF-8 として
有効 I<ではない>、最上位ビットが立った並びを含むコメント行を置くことで
我々のヒューリスティック(およびさらに賢いヒューリスティック)を
満たすことができます。
単なる "#"、鋭アクセント e、最上位ビットが立っていないバイト、からなる
行は、このファイルのエンコーディングを決定するのに十分です。

=for comment
 If/WHEN some brave soul makes these heuristics into a generic
 text-file class (or PerlIO layer?), we can presumably delete
 mention of these icky details from this file, and can instead
 tell people to just use appropriate class/layer.
 Auto-recognition of newline sequences would be another desirable
 feature of such a class/layer.
 HINT HINT HINT.

=for comment
 "The probability that a string of characters
 in any other encoding appears as valid UTF-8 is low" - RFC2279

=item *

=begin original

Pod processors must treat a "=for [label] [content...]" paragraph as
meaning the same thing as a "=begin [label]" paragraph, content, and
an "=end [label]" paragraph.  (The parser may conflate these two
constructs, or may leave them distinct, in the expectation that the
formatter will nevertheless treat them the same.)

=end original

Pod プロセッサは、"=for [label] [content...]" 段落を、
"=begin [label]" 段落、内容、"=end [label]" 段落と同じように
扱わなければなりません(must)。
(パーサはこれら二つの構文を融合してもかまいません(may)し、別々のままに
してもかまいません(may); フォーマッタはどちらにしても同じように扱います。)

=item *

=begin original

When rendering Pod to a format that allows comments (i.e., to nearly
any format other than plaintext), a Pod formatter must insert comment
text identifying its name and version number, and the name and
version numbers of any modules it might be using to process the Pod.
Minimal examples:

=end original

Pod を、コメントが許されるフォーマット (つまり、ほぼ、プレーンテキスト以外の
あらゆるフォーマット) にレンダリングするとき、
Pod フォーマッタは、自身の名前とバージョン番号、および Pod を
処理するときに使った全てのモジュールの名前とバージョン番号が識別できる
コメントを挿入しなければなりません(must)。
最小限の例:

 %% POD::Pod2PS v3.14159, using POD::Parser v1.92

 <!-- Pod::HTML v3.14159, using POD::Parser v1.92 -->

 {\doccomm generated by Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}

 .\" Pod::Man version 3.14159, using POD::Parser version 1.92

=begin original

Formatters may also insert additional comments, including: the
release date of the Pod formatter program, the contact address for
the author(s) of the formatter, the current time, the name of input
file, the formatting options in effect, version of Perl used, etc.

=end original

フォーマッタは、Pod フォーマッタプログラムのリリース日、フォーマッタの
作者への連絡アドレス、現在時刻、入力ファイル名、適用された
フォーマットオプション、使われた Perl のバージョンといった
追加のコメントを挿入してもかまいません(may)。

=begin original

Formatters may also choose to note errors/warnings as comments,
besides or instead of emitting them otherwise (as in messages to
STDERR, or C<die>ing).

=end original

フォーマッタは、エラー/警告を、(STDERR へのメッセージや C<die> として)
その他の場所への出力に加えて、またはそれに代えて、コメントとして
記録することを選択してもかまいません(may)。

=item *

=begin original

Pod parsers I<may> emit warnings or error messages ("Unknown E code
EE<lt>zslig>!") to STDERR (whether through printing to STDERR, or
C<warn>ing/C<carp>ing, or C<die>ing/C<croak>ing), but I<must> allow
suppressing all such STDERR output, and instead allow an option for
reporting errors/warnings
in some other way, whether by triggering a callback, or noting errors
in some attribute of the document object, or some similarly unobtrusive
mechanism -- or even by appending a "Pod Errors" section to the end of
the parsed form of the document.

=end original

Pod パーサは警告やエラーメッセージ ("Unknown E code EE<lt>zslig>!") を
(STDERR に print するか C<warn> や C<carp> を使うか C<die> や C<croak> を
使うかに関わらず) STDERR に出力しても I<かまいません> (may) が、
そのような全ての STDERR 出力を抑制して、代わりに、コールバックを
引き起こすことによってか、エラーを文書オブジェクトの何らかの属性または
同様の控えめな機構によって記録するか、あるいは文書のパースされた形式の
末尾に "Pod Errors" 節を追加する方法でも、何らかの他の方法でエラー/警告を
報告するためのオプションをI<認めなければなりません>(must)。

=item *

=begin original

In cases of exceptionally aberrant documents, Pod parsers may abort the
parse.  Even then, using C<die>ing/C<croak>ing is to be avoided; where
possible, the parser library may simply close the input file
and add text like "*** Formatting Aborted ***" to the end of the
(partial) in-memory document.

=end original

極端に異常な文書の場合は、Pod パーサはパースを中断してもかまいません(may)。
それでも、C<die>/C<croak> の使用は避けます; 可能なら、パーサは単に
入力ファイルを閉じて、メモリにある文書(の一部)の末尾に
"*** Formatting Aborted ***" のような文章を追加してもかまいません(may)。

=item *

=begin original

In paragraphs where formatting codes (like EE<lt>...>, BE<lt>...>)
are understood (i.e., I<not> verbatim paragraphs, but I<including>
ordinary paragraphs, and command paragraphs that produce renderable
text, like "=head1"), literal whitespace should generally be considered
"insignificant", in that one literal space has the same meaning as any
(nonzero) number of literal spaces, literal newlines, and literal tabs
(as long as this produces no blank lines, since those would terminate
the paragraph).  Pod parsers should compact literal whitespace in each
processed paragraph, but may provide an option for overriding this
(since some processing tasks do not require it), or may follow
additional special rules (for example, specially treating
period-space-space or period-newline sequences).

=end original

(EE<lt>...>, BE<lt>...> のような)フォーマッティングコードを理解する
段落 (つまり、そのままの段落は I<含みません> が、通常の段落および
"=head1" のようなレンダリングされるテキストを出力するコマンド段落を
I<含みます>)では、リテラルな空白は一般的に「重要でない」と
考えられるべきです(should); 一つのリテラルな空白は任意の(非 0 の)
数のリテラルな空白、リテラルな改行、リテラルなタブは
(これにより空行(これは段落の終わりになるので)を出力しない限り)、
同じ意味になります。
Pod パーサはそれ園れの処理された段落でのリテラルな空白を
詰めるべきです(should)が、(いくつかの処理タスクはこれを必要としないので)、
これを上書きするオプションを提供してもかまいません(may)し、
追加の特殊ルール(例えば、ピリオド-空白-空白やピリオド-改行の並びを
特別扱いするなど)に従ってもかまいません(may)。

=item *

=begin original

Pod parsers should not, by default, try to coerce apostrophe (') and
quote (") into smart quotes (little 9's, 66's, 99's, etc), nor try to
turn backtick (`) into anything else but a single backtick character
(distinct from an open quote character!), nor "--" into anything but
two minus signs.  They I<must never> do any of those things to text
in CE<lt>...> formatting codes, and never I<ever> to text in verbatim
paragraphs.

=end original

Pod パーサはデフォルトでは、アポストロフィ (') とクォート (") を
スマートクォート (小さい 9's, 66's, 99's, など)にしようとしたり、
逆クォート (`) を(開きクォート文字と区別するために!)単一の
逆クォート文字以外に変えようとしたり、"--" を二つのマイナス記号以外に
変えようとするべきではありません(should not)。
これらを CE<lt>...> 中のテキストには I<決して> 行っては
いけません(must not)し、そのままの段落のテキストには I<決して決して>
行ってはいけません(must not)。

=item *

=begin original

When rendering Pod to a format that has two kinds of hyphens (-), one
that's a non-breaking hyphen, and another that's a breakable hyphen
(as in "object-oriented", which can be split across lines as
"object-", newline, "oriented"), formatters are encouraged to
generally translate "-" to non-breaking hyphen, but may apply
heuristics to convert some of these to breaking hyphens.

=end original

Pod を、改行なしのハイフン (-) と改行可能なハイフン
("object-oriented" のようなときに、"object-"、改行、"oriented" と
分割できるもの) の 2 種類があるフォーマットにレンダリングするときは、
フォーマッタは一般的に "-" を改行なしのハイフンに変換することが
推奨されますが、これらの一部を改行するハイフンに変換するための
発見的手法を適用してもかまいません(may)。

=item *

=begin original

Pod formatters should make reasonable efforts to keep words of Perl
code from being broken across lines.  For example, "Foo::Bar" in some
formatting systems is seen as eligible for being broken across lines
as "Foo::" newline "Bar" or even "Foo::-" newline "Bar".  This should
be avoided where possible, either by disabling all line-breaking in
mid-word, or by wrapping particular words with internal punctuation
in "don't break this across lines" codes (which in some formats may
not be a single code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a word.)

=end original

Pod フォーマッタは、Perl コードの単語が行をまたがないように合理的な努力を
行うべきです(should)。
例えば、一部のフォーマッティングシステムでの"Foo::Bar" は、
"Foo::" 改行 "Bar" や、"Foo::-" 改行 "Bar" のように行をまたいで
分割しても有効です。
これは、可能なところでは、単語の途中での全ての行分割を無効にするか、
特定の単語を「これは行をまたがない」コードの内部的な句読点
(一部のフォーマットでは単一のコードではなく、非分割ゼロ幅空白を単語の文字の
それぞれの組の間に挿入するという形かもしれません)で包むことで
防ぐべきです(should)。

=item *

=begin original

Pod parsers should, by default, expand tabs in verbatim paragraphs as
they are processed, before passing them to the formatter or other
processor.  Parsers may also allow an option for overriding this.

=end original

Pod パーサは、デフォルトでは、フォーマッタやその他のプロセッサに
渡す前に、そのままの段落のタブを展開するべきです(should)。
パーサはこれを上書きするオプションを許してもかまいません(may)。

=item *

=begin original

Pod parsers should, by default, remove newlines from the end of
ordinary and verbatim paragraphs before passing them to the
formatter.  For example, while the paragraph you're reading now
could be considered, in Pod source, to end with (and contain)
the newline(s) that end it, it should be processed as ending with
(and containing) the period character that ends this sentence.

=end original

Pod パーサは、デフォルトでは、通常の段落とそのままの段落の末尾の
改行を、フォーマッタに渡す前に削除するべきです(should)。
例えば、今読み込んでいる段落が Pod ソースでは空行を含んでいて、
それで終わっていると考えられる一方、
この文を終わらせるピリオド文字を含んでいて、それで終わっているかのように
処理するべきです(should)。

=item *

=begin original

Pod parsers, when reporting errors, should make some effort to report
an approximate line number ("Nested EE<lt>>'s in Paragraph #52, near
line 633 of Thing/Foo.pm!"), instead of merely noting the paragraph
number ("Nested EE<lt>>'s in Paragraph #52 of Thing/Foo.pm!").  Where
this is problematic, the paragraph number should at least be
accompanied by an excerpt from the paragraph ("Nested EE<lt>>'s in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the CE<lt>interest rate> attribute...'").

=end original

Pod パーサは、エラーを報告するときは、単に段落番号を報告する
("Nested EE<lt>>'s in Paragraph #52 of Thing/Foo.pm!") のではなく、
およその行番号を報告するための
努力を行うべきです ("Nested EE<lt>>'s in Paragraph #52, near
line 633 of Thing/Foo.pm!")(should)。
これが難しいところでは、段落番号は少なくとも段落の抜粋と共に
報告されるべきです ("Nested EE<lt>>'s in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the CE<lt>interest rate> attribute...'")(should)。

=item *

=begin original

Pod parsers, when processing a series of verbatim paragraphs one
after another, should consider them to be one large verbatim
paragraph that happens to contain blank lines.  I.e., these two
lines, which have a blank line between them:

=end original

Pod パーサは、連続したそのままの段落を処理するときには、たまたま空行を
含んでいる大きな一つのそのままの段落として扱うべきです(should)。
つまり、以下のような、空行を挟んだ 2 つの行は:

	use Foo;

	print Foo->VERSION

=begin original

should be unified into one paragraph ("\tuse Foo;\n\n\tprint
Foo->VERSION") before being passed to the formatter or other
processor.  Parsers may also allow an option for overriding this.

=end original

フォーマッタや他のプロセッサに渡される前に一つの段落
("\tuse Foo;\n\n\tprint Foo->VERSION") 統合されるべきです(should)。
パーサはこれを上書きするオプションを許してもかまいません(may)。

=begin original

While this might be too cumbersome to implement in event-based Pod
parsers, it is straightforward for parsers that return parse trees.

=end original

これはイベントベースの Pod パーサを実装するには厄介すぎるかもしれない一方、
パース木を返すパーサにとっては直感的です。

=item *

=begin original

Pod formatters, where feasible, are advised to avoid splitting short
verbatim paragraphs (under twelve lines, say) across pages.

=end original

Pod フォーマッタは、可能なところでは、短いそのままの段落 (例えば 12 行
以下) がページをまたぐことを避けるように勧めます。

=item *

=begin original

Pod parsers must treat a line with only spaces and/or tabs on it as a
"blank line" such as separates paragraphs.  (Some older parsers
recognized only two adjacent newlines as a "blank line" but would not
recognize a newline, a space, and a newline, as a blank line.  This
is noncompliant behavior.)

=end original

Pod パーサは空白やタブだけからなる行を、段落を分割する「空行」として
扱わなければなりません(must)。
(一部の古いパーサは、二つの連続した改行のみを「空行」として認識し、
改行、空白、改行は空行として認識しません。
これは非準拠の振る舞いです。)

=item *

=begin original

Authors of Pod formatters/processors should make every effort to
avoid writing their own Pod parser.  There are already several in
CPAN, with a wide range of interface styles -- and one of them,
Pod::Parser, comes with modern versions of Perl.

=end original

Pod フォーマッタ/プロセッサの作者は、独自の Pod パーサを書くことを
避けるためにあらゆる努力を行うべきです(should)。
既に様々なインターフェーススタイルを持ったものがいくつか CPAN にあり --
その一つである Pod::Parser か最近のバージョンの Perl に同梱されています。

=item *

=begin original

Characters in Pod documents may be conveyed either as literals, or by
number in EE<lt>n> codes, or by an equivalent mnemonic, as in
EE<lt>eacute> which is exactly equivalent to EE<lt>233>.  The numbers
are the Latin1/Unicode values, even on EBCDIC platforms.

=end original

Pod 文書中の文字は、リテラル、EE<lt>n> コード、(EE<lt>233> と等価な
EE<lt>eacute> のように) 等価なニーモニック、のいずれで伝達しても
かまいません(may)。
数値は、EBCDIC プラットフォームでも Latin1/Unicode の値です。

=begin original

When referring to characters by using a EE<lt>n> numeric code, numbers
in the range 32-126 refer to those well known US-ASCII characters (also
defined there by Unicode, with the same meaning), which all Pod
formatters must render faithfully.  Characters whose EE<lt>E<gt> numbers
are in the ranges 0-31 and 127-159 should not be used (neither as
literals,
nor as EE<lt>number> codes), except for the literal byte-sequences for
newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).

=end original

EE<lt>n> 数値コードを使って文字を参照するとき、
よく知られている US-ASCII で参照されている範囲 32-126 の数値
(Unicode でも同じ意味で定義されいます) は、全ての Pod フォーマッタは
充実にレンダリングしなければなりません(must)。
EE<lt>E<gt> 数値が 0-31 と 127-159 の範囲の文字は、改行 (ASCII 13,
ASCII 13 ASCII 10, ASCII 10 のいずれか)またはタブ (ASCII 9) のための
リテラルなバイト並びを除いて、(リテラルとしてと EE<lt>number> コードとしての
どちらとしても)
使われるべきではありません (should not)。

=begin original

Numbers in the range 160-255 refer to Latin-1 characters (also
defined there by Unicode, with the same meaning).  Numbers above
255 should be understood to refer to Unicode characters.

=end original

範囲 160-255 の数値は Latin-1 文字 (Unicode でも同じ意味で
定義されています) を参照します。
255 を超える数値は Unicode 文字を参照していると理解するべきです(should)。

=item *

=begin original

Be warned
that some formatters cannot reliably render characters outside 32-126;
and many are able to handle 32-126 and 160-255, but nothing above
255.

=end original

一部のフォーマッタは 32-126 の範囲外の文字を確実にレンダリングすることが
出来ず、多くのフォーマッタは 32-126 と 160-255 は扱えるものの、
255 を超える文字は扱えないことを警告しておきます。

=item *

=begin original

Besides the well-known "EE<lt>lt>" and "EE<lt>gt>" codes for
less-than and greater-than, Pod parsers must understand "EE<lt>sol>"
for "/" (solidus, slash), and "EE<lt>verbar>" for "|" (vertical bar,
pipe).  Pod parsers should also understand "EE<lt>lchevron>" and
"EE<lt>rchevron>" as legacy codes for characters 171 and 187, i.e.,
"left-pointing double angle quotation mark" = "left pointing
guillemet" and "right-pointing double angle quotation mark" = "right
pointing guillemet".  (These look like little "<<" and ">>", and they
are now preferably expressed with the HTML/XHTML codes "EE<lt>laquo>"
and "EE<lt>raquo>".)

=end original

小なりと大なりを表すよく知られた "EE<lt>lt>" と "EE<lt>gt>" の他に、
Pod パーサは "/" (スラッシュ) のための "EE<lt>sol>" と "|" (垂直バー、
パイプ) のための "EE<lt>verbar>" を理解しなければなりません(must)。
Pod パーサはまた、"EE<lt>lchevron>" と "EE<lt>rchevron>" を
文字 171 と 187 の古いコードとして理解するべきです(should); つまり、
"left-pointing double angle quotation mark" = "left pointing
guillemet" で、"right-pointing double angle quotation mark" = "right
pointing guillemet" です。
(これらは小さい "<<" や ">>" のように見え、HTML/XHTML コードの
"EE<lt>laquo>" や "EE<lt>raquo>" として表現されます。)

=item *

=begin original

Pod parsers should understand all "EE<lt>html>" codes as defined
in the entity declarations in the most recent XHTML specification at
C<www.W3.org>.  Pod parsers must understand at least the entities
that define characters in the range 160-255 (Latin-1).  Pod parsers,
when faced with some unknown "EE<lt>I<identifier>>" code,
shouldn't simply replace it with nullstring (by default, at least),
but may pass it through as a string consisting of the literal characters
E, less-than, I<identifier>, greater-than.  Or Pod parsers may offer the
alternative option of processing such unknown
"EE<lt>I<identifier>>" codes by firing an event especially
for such codes, or by adding a special node-type to the in-memory
document tree.  Such "EE<lt>I<identifier>>" may have special meaning
to some processors, or some processors may choose to add them to
a special error report.

=end original

Pod パーサは、C<www.W3.org> にある最新の XHTML 仕様の実体宣言で
定義されている全ての "EE<lt>html>" コードを理解するべきです(should)。
Pod パーサは少なくとも範囲 160-255 (Latin-1) の文字を定義する
エンティティを理解しなければなりません(must)。
Pod パーサは、不明な "EE<lt>I<identifier>>" コードに出会ったとき、
(少なくともデフォルトでは)単にから文字列と置き換えるべきではなく
(should not)、リテラル文字 E、小なり、I<identifier>、大なりで構成される
文字列として渡されたものとしてもかまいません(may)。
または、Pod パーサは、そのような不明な "EE<lt>I<identifier>>" コードを、
特にそのようなコードのためのイベントを起動するか、メモリ内文書木に
特別なノード型を追加することで処理する代替オプションを
提供してもかまいません(may)。
そのような "EE<lt>I<identifier>>" は一部のプロセッサでは特別な意味を
持たせてもかまいませんし(may)、一部のプロセッサはこれを特別なエラー報告に
加えることを選んでもかまいません(may)。

=item *

=begin original

Pod parsers must also support the XHTML codes "EE<lt>quot>" for
character 34 (doublequote, "), "EE<lt>amp>" for character 38
(ampersand, &), and "EE<lt>apos>" for character 39 (apostrophe, ').

=end original

Pod パーサは XHTML コードのうち、文字 34 (ダブルクォート, ") の
ための "EE<lt>quot>"、文字 38 (アンパサンド, &) のための "EE<lt>amp>"、
文字 39 (アポストロフィ、 ') のための "EE<lt>apos>" にも
対応しなければなりません(must)。

=item *

=begin original

Note that in all cases of "EE<lt>whateverE<gt>", I<whatever> (whether
an htmlname, or a number in any base) must consist only of
alphanumeric characters -- that is, I<whatever> must match
C<m/\A\w+\z/>.  So S<"EE<lt> 0 1 2 3 E<gt>"> is invalid, because
it contains spaces, which aren't alphanumeric characters.  This
presumably does not I<need> special treatment by a Pod processor;
S<" 0 1 2 3 "> doesn't look like a number in any base, so it would
presumably be looked up in the table of HTML-like names.  Since
there isn't (and cannot be) an HTML-like entity called S<" 0 1 2 3 ">,
this will be treated as an error.  However, Pod processors may
treat S<"EE<lt> 0 1 2 3 E<gt>"> or "EE<lt>e-acute>" as I<syntactically>
invalid, potentially earning a different error message than the
error message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as in "EE<lt>qacute>"
[sic].  However, Pod parsers are not required to make this
distinction.

=end original

"EE<lt>whateverE<gt>" 形式の全ての場合において、I<whatever> (html 名でも
どの基数の数値でも) は英数字のみから構成されていなければなりません(must) --
つまり、I<whatever> は C<m/\A\w+\z/> にマッチングしなければなりません。
つまり、S<"EE<lt> 0 1 2 3 E<gt>"> は不正です; これには空白が含まれていて、
空白は英数字ではないからです。
これはおそらく Pod プロセッサによる特別扱いは I<必要ありません>;
S<" 0 1 2 3 "> はどの基数でも数値のようには見えないので、おそらく HTML 風の
名前のテーブルを探します。
S<" 0 1 2 3 "> と呼ばれる HTML 風の実体はない(そしてあり得ない)ので、
これはエラーとして扱われます。
Pod プロセッサは S<"EE<lt> 0 1 2 3 E<gt>"> や "EE<lt>e-acute>" を I<文法的に>
不正として扱って、単に "EE<lt>qacute>" (原文のまま) のような不明な(しかし
理論的には有効な)html として生成されるエラーメッセージ(または警告や
イベント) とは異なるエラーメッセージを出力するかもしれません(may)。
しかし、Pod パーサはこの区別をすることを要求はされません。

=item *

=begin original

Note that EE<lt>number> I<must not> be interpreted as simply
"codepoint I<number> in the current/native character set".  It always
means only "the character represented by codepoint I<number> in
Unicode."  (This is identical to the semantics of &#I<number>; in XML.)

=end original

EE<lt>number> は単に「現在の/ネイティブな文字集合における符号位置
I<number>」と I<扱ってはいけない> (must not) ことに注意してください。
これは常に「Unicode で符号位置 I<number> として表現される文字」という
意味しかありません。
(これは XML での &#I<number>; の意味論と同じです。)

=begin original

This will likely require many formatters to have tables mapping from
treatable Unicode codepoints (such as the "\xE9" for the e-acute
character) to the escape sequences or codes necessary for conveying
such sequences in the target output format.  A converter to *roff
would, for example know that "\xE9" (whether conveyed literally, or via
a EE<lt>...> sequence) is to be conveyed as "e\\*'".
Similarly, a program rendering Pod in a Mac OS application window, would
presumably need to know that "\xE9" maps to codepoint 142 in MacRoman
encoding that (at time of writing) is native for Mac OS.  Such
Unicode2whatever mappings are presumably already widely available for
common output formats.  (Such mappings may be incomplete!  Implementers
are not expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any
of the other weird things that Unicode can encode.)  And
if a Pod document uses a character not found in such a mapping, the
formatter should consider it an unrenderable character.

=end original

これにより、おそらく多くのフォーマッタは Unicode 符号位置
(e-acute 文字のための "\xE9") からターゲット出力形式でそのような並びを
伝えるためのエスケープシーケンスやコードへのマッピングを行う表を
持つことを要求されます。
*roff の世界へのコンバータでは、例えば "\xE9" (リテラルか
EE<lt>...> 並びかに関わらず) は "e\\*'" として伝えられます。
同様に、Mac OS アプリケーションウィンドウに Pod をレンダリングする
プログラムはおそらく "\xE9" を、(これを書いている時点では) Mac OS に
ネイティブな MacRoman エンコーディングの部号位置 142 に
マッピングされることを知っている必要があります。
このような「Unicode から何か」へのマッピングはおそらく一般的な
出力形式については既に広く利用可能です。
(このようなマッピングは不完全かも知れません!
実装者は、チェロキー音節、エルトリア語のルーン、ビザンツの音楽記号、
その他 Unicode がエンコード出来る変なものをレンダリングしようとして
最大の努力をすることを想定しません。)
そして、Pod 文書がこのようなマッピングにない文字が使うと、
フォーマッタはこれをレンダリングできない文字として扱うべきです(should)。

=item *

=begin original

If, surprisingly, the implementor of a Pod formatter can't find a
satisfactory pre-existing table mapping from Unicode characters to
escapes in the target format (e.g., a decent table of Unicode
characters to *roff escapes), it will be necessary to build such a
table.  If you are in this circumstance, you should begin with the
characters in the range 0x00A0 - 0x00FF, which is mostly the heavily
used accented characters.  Then proceed (as patience permits and
fastidiousness compels) through the characters that the (X)HTML
standards groups judged important enough to merit mnemonics
for.  These are declared in the (X)HTML specifications at the
www.W3.org site.  At time of writing (September 2001), the most recent
entity declaration files are:

=end original

もし、驚くべきことに、Pod フォーマッタの実装者が、Unicode 文字から
ターゲット形式のエスケープへのマッピングに関する、満足できる既に存在する
表(例えば Unicode 文字から *roff エスケープへのまともな表) を
発見できない場合、そのような表を構築する必要があります。
もしこのような状況にいるのなら、範囲 0x00A0 - 0x00FF の文字から
始めるべきです; これはほとんどアクセント付きの文字が使われます。
それから(忍耐が許して潔癖症が強いるなら)、(X)HTML 標準グループが、
省略形を作る価値があるほど重要であると判断した文字に進みます。
これらは www.W3.org  のサイトの (X)HTML 定義で宣言されています。
これを書いている時点(2001 年 9 月)で、もっとも新しい実体定義ファイルは:

  http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
  http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
  http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent

=begin original

Then you can progress through any remaining notable Unicode characters
in the range 0x2000-0x204D (consult the character tables at
www.unicode.org), and whatever else strikes your fancy.  For example,
in F<xhtml-symbol.ent>, there is the entry:

=end original

それから範囲 0x2000-0x204D (www.unicode.org にある文字表を
参照してください)の残りの注目するべき Unicode 文字と、あなたの
興味を引いたものなんでもに進んでください。
例えば、F<xhtml-symbol.ent> には、以下のようなエントリがあります:

  <!ENTITY infin    "&#8734;"> <!-- infinity, U+221E ISOtech -->

=begin original

While the mapping "infin" to the character "\x{221E}" will (hopefully)
have been already handled by the Pod parser, the presence of the
character in this file means that it's reasonably important enough to
include in a formatter's table that maps from notable Unicode characters
to the codes necessary for rendering them.  So for a Unicode-to-*roff
mapping, for example, this would merit the entry:

=end original

"infin" から文字 "\x{221E}" へのマッピングは(できれば)既に Pod パーサによって
扱われている一方、このファイルにこの文字があるということは、
注目すべき Unicode 文字からそれをレンダリングするために必要なコードへの
マッピングを行うフォーマッタの表に含めることが十分に合理的なほど
重要であることを意味します。
それで、例えば Unicode-to-*roff のマッピングのためには、これはエントリに
値します:

  "\x{221E}" => '\(in',

=begin original

It is eagerly hoped that in the future, increasing numbers of formats
(and formatters) will support Unicode characters directly (as (X)HTML
does with C<&infin;>, C<&#8734;>, or C<&#x221E;>), reducing the need
for idiosyncratic mappings of Unicode-to-I<my_escapes>.

=end original

将来、より多くの形式(とフォーマッタ)が((X)HTML が C<&infin;>, C<&#8734;>,
C<&#x221E;> で行うように) Unicode 文字を直接扱えるようになって、
Unicode-to-I<私のエスケープ> への風変わりなマッピングの必要性が
減少することが熱望されています。

=item *

=begin original

It is up to individual Pod formatter to display good judgement when
confronted with an unrenderable character (which is distinct from an
unknown EE<lt>thing> sequence that the parser couldn't resolve to
anything, renderable or not).  It is good practice to map Latin letters
with diacritics (like "EE<lt>eacute>"/"EE<lt>233>") to the corresponding
unaccented US-ASCII letters (like a simple character 101, "e"), but
clearly this is often not feasible, and an unrenderable character may
be represented as "?", or the like.  In attempting a sane fallback
(as from EE<lt>233> to "e"), Pod formatters may use the
%Latin1Code_to_fallback table in L<Pod::Escapes|Pod::Escapes>, or
L<Text::Unidecode|Text::Unidecode>, if available.

=end original

レンダリングできない文字(これは、レンダリング出来るかどうかに関わらず
パーサが解決できない、不明な EE<lt>thing> 並びとは異なります)に
直面したときに良い判断を表示するのは個々の Pod 次第です。
("EE<lt>eacute>"/"EE<lt>233>" のような)ダイアクリティカルマーク付きの
Latin 文字を、(単純な文字 101, "e" のような)対応するアクセントなしの
US-ASCII 文字にマッピングするのはよいプラクティスですが、明らかに
これはしばしば実行不可能で、レンダリングできない文字は "?" のようなもので
表現されるかもしれません(may)。
(EE<lt>233> から "e" のような) 健全なフォールバックのために、
Pod フォーマッタは、もし利用可能なら L<Pod::Escapes|Pod::Escapes> または
L<Text::Unidecode|Text::Unidecode> にある %Latin1Code_to_fallback テーブルを
つかってもかまいません(may)。

=begin original

For example, this Pod text:

=end original

例えば、以下の Pod 文章:

  magic is enabled if you set C<$Currency> to 'E<euro>'.

=begin original

may be rendered as:
"magic is enabled if you set C<$Currency> to 'I<?>'" or as
"magic is enabled if you set C<$Currency> to 'B<[euro]>'", or as
"magic is enabled if you set C<$Currency> to '[x20AC]', etc.

=end original

は、以下のようにレンダリングされるでしょう:
"magic is enabled if you set C<$Currency> to 'I<?>'" または
"magic is enabled if you set C<$Currency> to 'B<[euro]>'" または
"magic is enabled if you set C<$Currency> to '[x20AC]' など。

=begin original

A Pod formatter may also note, in a comment or warning, a list of what
unrenderable characters were encountered.

=end original

Pod フォーマッタは、レンダリングできない文字に出会ったときのリストを
コメントや警告の形で記してもかまいません(may)。

=item *

=begin original

EE<lt>...> may freely appear in any formatting code (other than
in another EE<lt>...> or in an ZE<lt>>).  That is, "XE<lt>The
EE<lt>euro>1,000,000 Solution>" is valid, as is "LE<lt>The
EE<lt>euro>1,000,000 Solution|Million::Euros>".

=end original

EE<lt>...> は (他の EE<lt>...> および ZE<lt>> の中を除く) 任意の
フォーマッティングコードの中に自由に現れてもかまいません(may)。
つまり、"XE<lt>The EE<lt>euro>1,000,000 Solution>" は、
"LE<lt>The EE<lt>euro>1,000,000 Solution|Million::Euros>" と同様
有効ということです。

=item *

=begin original

Some Pod formatters output to formats that implement non-breaking
spaces as an individual character (which I'll call "NBSP"), and
others output to formats that implement non-breaking spaces just as
spaces wrapped in a "don't break this across lines" code.  Note that
at the level of Pod, both sorts of codes can occur: Pod can contain a
NBSP character (whether as a literal, or as a "EE<lt>160>" or
"EE<lt>nbsp>" code); and Pod can contain "SE<lt>foo
IE<lt>barE<gt> baz>" codes, where "mere spaces" (character 32) in
such codes are taken to represent non-breaking spaces.  Pod
parsers should consider supporting the optional parsing of "SE<lt>foo
IE<lt>barE<gt> baz>" as if it were
"fooI<NBSP>IE<lt>barE<gt>I<NBSP>baz", and, going the other way, the
optional parsing of groups of words joined by NBSP's as if each group
were in a SE<lt>...> code, so that formatters may use the
representation that maps best to what the output format demands.

=end original

Pod フォーマッタによっては、改行なし空白を独立した文字 (ここでは
"NBSP" と呼ぶことにします) として実装しているフォーマットへ出力したり、
改行なし空白を「この線の場所で改行しない」コードでラップしている
フォーマットに出力したりします。
Pod のレベルでは、どちらのコードもあり得ます: Pod は
(リテラル、"EE<lt>160>"、"EE<lt>nbsp>"という形で) NBSP 文字を
含めることもできます; そして Pod は "SE<lt>foo IE<lt>barE<gt> baz>" という
コードを含むことができます; ここでそのようなコードでの「単なる空白」
(文字 32)は非分割空白を表現します。
Pod パーサは、"SE<lt>foo IE<lt>barE<gt> baz>" を
"fooI<NBSP>IE<lt>barE<gt>I<NBSP>baz" であるかのように、
また NBSP で連結された単語のグループを それぞれのグループが
SE<lt>...> コードで囲まれているかのようにパースするオプションに
対応することを考慮するべきです(should); これによりフォーマッタは
出力形式が要求する最良のものにマッピングされる表現を使えるかもしれません。

=item *

=begin original

Some processors may find that the C<SE<lt>...E<gt>> code is easiest to
implement by replacing each space in the parse tree under the content
of the S, with an NBSP.  But note: the replacement should apply I<not> to
spaces in I<all> text, but I<only> to spaces in I<printable> text.  (This
distinction may or may not be evident in the particular tree/event
model implemented by the Pod parser.)  For example, consider this
unusual case:

=end original

一部のプロセッサは、C<SE<lt>...E<gt>> コードを最も簡単に実装するには
S の内容のパース木の中にあるそれぞれの空白を NBSP に置き換えることで
あることを発見するかもしれません。
しかし注意してください: 変換は I<全て> のテキストの空白では I<なく>、
I<表示される> テキストの空白 I<のみ> に適用するべきです(should)。
(この区別は、その Pod パーサによって実装されている特定のツリー/イベント
モデルによって明らかかもしれませんしそうではないかもしれません。)
例えば、次のような普通ではない場合を考えます:

   S<L</Autoloaded Functions>>

=begin original

This means that the space in the middle of the visible link text must
not be broken across lines.  In other words, it's the same as this:

=end original

これは、表示されるリンクテキストの途中にある空白は行をまたいではいけない
(must not)ということです。
言い換えると、以下と同じです:

   L<"AutoloadedE<160>Functions"/Autoloaded Functions>

=begin original

However, a misapplied space-to-NBSP replacement could (wrongly)
produce something equivalent to this:

=end original

しかし、空白から NBSP への変換を間違って適用すると、以下のようなものと
等価なものを(間違って)生成してしまうかもしれません:

   L<"AutoloadedE<160>Functions"/AutoloadedE<160>Functions>

=begin original

...which is almost definitely not going to work as a hyperlink (assuming
this formatter outputs a format supporting hypertext).

=end original

これはほぼ確実にハイパーリンクとしては動作しません (このフォーマッタが
ハイパーテキストに対応した形式に出力すると仮定しています)。

=begin original

Formatters may choose to just not support the S format code,
especially in cases where the output format simply has no NBSP
character/code and no code for "don't break this stuff across lines".

=end original

フォーマッタは、単に S フォーマッティングコードに対応しないことを
選択してもかまいません(may); 特に出力形式に NBSP 文字/コードや
「この内容は行をまたがない」ためのコードがない場合です。

=item *

=begin original

Besides the NBSP character discussed above, implementors are reminded
of the existence of the other "special" character in Latin-1, the
"soft hyphen" character, also known as "discretionary hyphen",
i.e. C<EE<lt>173E<gt>> = C<EE<lt>0xADE<gt>> =
C<EE<lt>shyE<gt>>).  This character expresses an optional hyphenation
point.  That is, it normally renders as nothing, but may render as a
"-" if a formatter breaks the word at that point.  Pod formatters
should, as appropriate, do one of the following:  1) render this with
a code with the same meaning (e.g., "\-" in RTF), 2) pass it through
in the expectation that the formatter understands this character as
such, or 3) delete it.

=end original

先に議論した NBSP 文字の他に、実装者は Latin-1 にその他の「特殊」文字の
存在を思い出させます; "soft hyphen" 文字、またの名を
"discretionary hyphen"、例えば C<EE<lt>173E<gt>> = C<EE<lt>0xADE<gt>> =
C<EE<lt>shyE<gt>>) です。
この文字はオプションのハイフン位置を表現します。
これは、普通は何もレンダリングしませんが、フォーマッタがこの位置で
単語を分割したとき、"-" としてレンダリングされます。
Pod フォーマッタは、必要に応じて、次のうちどれか一つを
行うべきです(should): 1) これを同じ意味を持つコードとしてレンダリングする
(例えば RTF の "\-" in RTF) 2) フォーマッタがこの文字を理解すると仮定して
そのまま流す 3) 削除する。

=begin original

For example:

=end original

例えば:

  sigE<shy>action
  manuE<shy>script
  JarkE<shy>ko HieE<shy>taE<shy>nieE<shy>mi

=begin original

These signal to a formatter that if it is to hyphenate "sigaction"
or "manuscript", then it should be done as
"sig-I<[linebreak]>action" or "manu-I<[linebreak]>script"
(and if it doesn't hyphenate it, then the C<EE<lt>shyE<gt>> doesn't
show up at all).  And if it is
to hyphenate "Jarkko" and/or "Hietaniemi", it can do
so only at the points where there is a C<EE<lt>shyE<gt>> code.

=end original

これらは、もし "sigaction" や "manuscript" をハイフネーションするときは、
"sig-I<[linebreak]>action" や "manu-I<[linebreak]>script" として
行うべき(should)であることを示します(そしてもし
ハイフネーションしないなら、 C<EE<lt>shyE<gt>> は全く現れません)。
そして "Jarkko" や "Hietaniemi" をハイフネーションするときは、
C<EE<lt>shyE<gt>> コードがある場所でのみ行えます。

=begin original

In practice, it is anticipated that this character will not be used
often, but formatters should either support it, or delete it.

=end original

実際には、この文字はそう頻繁に使われないであろうと推測されますが、
フォーマッタはこれに対応するか、削除するかのどちらかをするべきです(should)。

=item *

=begin original

If you think that you want to add a new command to Pod (like, say, a
"=biblio" command), consider whether you could get the same
effect with a for or begin/end sequence: "=for biblio ..." or "=begin
biblio" ... "=end biblio".  Pod processors that don't understand
"=for biblio", etc, will simply ignore it, whereas they may complain
loudly if they see "=biblio".

=end original

Pod に (例えば "=biblio" コマンドのような) 新しいコマンドを追加したいと
考えているなら、同じ効果を for や begin/end の並びで得られないかどうかを
考慮してください: "=for biblio ..." または "=begin
biblio" ... "=end biblio"。
"=for biblio" などを理解しない Pod プロセッサは単にこれを無視しますが、
"=biblio" を見つけると大声で警告を発生させるかもしれません。

=item *

=begin original

Throughout this document, "Pod" has been the preferred spelling for
the name of the documentation format.  One may also use "POD" or
"pod".  For the documentation that is (typically) in the Pod
format, you may use "pod", or "Pod", or "POD".  Understanding these
distinctions is useful; but obsessing over how to spell them, usually
is not.

=end original

この文書を通じて、"Pod" は文書フォーマットの名前として使われている
綴りです。
"POD" や "pod" を使う人もいるかもしれません。
(典型的には Pod 形式の文書では、"pod", "Pod", "POD" のいずれかを使えます。
これらの違いを理解することは有用です; しかしどう綴るかに捕らわれすぎるのは
普通は有用ではありません。

=back

=head1 About LE<lt>...E<gt> Codes

(LE<lt>...E<gt> コードについて)

=begin original

As you can tell from a glance at L<perlpod|perlpod>, the LE<lt>...>
code is the most complex of the Pod formatting codes.  The points below
will hopefully clarify what it means and how processors should deal
with it.

=end original

L<perlpod|perlpod> をちらっと見るだけでわかることは、LE<lt>...> コードは
Pod フォーマッティングコードの中で最も複雑であると言うことです。
以下に示すポイントは、これが何を意味し、プロセッサがこれを
どのように扱うべきかをできれば明確化しようとするものです。

=over

=item *

=begin original

In parsing an LE<lt>...> code, Pod parsers must distinguish at least
four attributes:

=end original

LE<lt>...> コードをパースするときに、Pod パーサは少なくとも四つの
属性を区別しなければなりません(must):

=over

=item First:

(第一:)

=begin original

The link-text.  If there is none, this must be C<undef>.  (E.g., in
"LE<lt>Perl Functions|perlfunc>", the link-text is "Perl Functions".
In "LE<lt>Time::HiRes>" and even "LE<lt>|Time::HiRes>", there is no
link text.  Note that link text may contain formatting.)

=end original

リンクテキスト。
もしなければ、C<undef> でなければなりません(must)。
(例えば、"LE<lt>Perl Functions|perlfunc>" では、リンクテキストは
"Perl Functions" です。
"LE<lt>Time::HiRes>" や、"LE<lt>|Time::HiRes>" でも、リンクテキストは
ありません。
リンクテキストにはフォーマッティングコードを含んでいるかもしれないことに
注意してください。)

=item Second:

(第二:)

=begin original

The possibly inferred link-text; i.e., if there was no real link
text, then this is the text that we'll infer in its place.  (E.g., for
"LE<lt>Getopt::Std>", the inferred link text is "Getopt::Std".)

=end original

リンクテキストと推論されるもの; つまり、もし実際のリンクテキストが
なければ、これはリンクテキストと推論されたものです。
(例えば、"LE<lt>Getopt::Std>" では、推論されたリンクテキストは
"Getopt::Std" です。)

=item Third:

(第三:)

=begin original

The name or URL, or C<undef> if none.  (E.g., in "LE<lt>Perl
Functions|perlfunc>", the name (also sometimes called the page)
is "perlfunc".  In "LE<lt>/CAVEATS>", the name is C<undef>.)

=end original

名前または URL (なければ C<undef>)。
(例えば、"LE<lt>Perl Functions|perlfunc>" では、名前 (また時々ページと
呼ばれるもの) は "perlfunc" です。
"LE<lt>/CAVEATS>" では、名前は C<undef> です。)

=item Fourth:

(第四:)

=begin original

The section (AKA "item" in older perlpods), or C<undef> if none.  E.g.,
in "LE<lt>Getopt::Std/DESCRIPTIONE<gt>", "DESCRIPTION" is the section.  (Note
that this is not the same as a manpage section like the "5" in "man 5
crontab".  "Section Foo" in the Pod sense means the part of the text
that's introduced by the heading or item whose text is "Foo".)

=end original

章 (古い perlpod では「アイテム」と呼ばれていたもの)(なければ C<undef>)。
例えば、"LE<lt>Getopt::Std/DESCRIPTIONE<gt>" では、"DESCRIPTION" が章です。
(これは "man 5 crontab" での "5" のような man ページの章と同じでは
ないことに注意してください。
Pod での "○○の章" というのはテキストが "○○" である見出しや
アイテムによって導入されるテキストの一部を意味します。)

=back

=begin original

Pod parsers may also note additional attributes including:

=end original

また、Pod パーサは以下のような追加の属性に留意してもかまいません(may):

=over

=item Fifth:

(第五:)

=begin original

A flag for whether item 3 (if present) is a URL (like
"http://lists.perl.org" is), in which case there should be no section
attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
possibly a man page name (like "crontab(5)" is).

=end original

(もしあれば) 第三のアイテムが ("http://lists.perl.org" のような)
URL かどうかを示すフラグ; この場合章の属性; はありません;
("perldoc" や "Getopt::Std" のような) Pod 名 ;
("crontab(5)" のような) man ページ名かもしれないものではありません。

=item Sixth:

(第六:)

=begin original

The raw original LE<lt>...> content, before text is split on
"|", "/", etc, and before EE<lt>...> codes are expanded.

=end original

"|", "/" などで分割したり EE<lt>...> コードを展開したりする前の生の
LE<lt>...> の内容。

=back

=begin original

(The above were numbered only for concise reference below.  It is not
a requirement that these be passed as an actual list or array.)

=end original

(上述の番号付けは以下での参照のためだけのものです。
これらが実際のリストや配列として渡されることは必須ではありません。)

=begin original

For example:

=end original

例えば:

  L<Foo::Bar>
    =>  undef,                         # link text
        "Foo::Bar",                    # possibly inferred link text
        "Foo::Bar",                    # name
        undef,                         # section
        'pod',                         # what sort of link
        "Foo::Bar"                     # original content

  L<Perlport's section on NL's|perlport/Newlines>
    =>  "Perlport's section on NL's",  # link text
        "Perlport's section on NL's",  # possibly inferred link text
        "perlport",                    # name
        "Newlines",                    # section
        'pod',                         # what sort of link
        "Perlport's section on NL's|perlport/Newlines"
                                       # original content

  L<perlport/Newlines>
    =>  undef,                         # link text
        '"Newlines" in perlport',      # possibly inferred link text
        "perlport",                    # name
        "Newlines",                    # section
        'pod',                         # what sort of link
        "perlport/Newlines"            # original content

  L<crontab(5)/"DESCRIPTION">
    =>  undef,                         # link text
        '"DESCRIPTION" in crontab(5)', # possibly inferred link text
        "crontab(5)",                  # name
        "DESCRIPTION",                 # section
        'man',                         # what sort of link
        'crontab(5)/"DESCRIPTION"'     # original content

  L</Object Attributes>
    =>  undef,                         # link text
        '"Object Attributes"',         # possibly inferred link text
        undef,                         # name
        "Object Attributes",           # section
        'pod',                         # what sort of link
        "/Object Attributes"           # original content

  L<http://www.perl.org/>
    =>  undef,                         # link text
        "http://www.perl.org/",        # possibly inferred link text
        "http://www.perl.org/",        # name
        undef,                         # section
        'url',                         # what sort of link
        "http://www.perl.org/"         # original content

  L<Perl.org|http://www.perl.org/>
    =>  "Perl.org",                    # link text
        "http://www.perl.org/",        # possibly inferred link text
        "http://www.perl.org/",        # name
        undef,                         # section
        'url',                         # what sort of link
        "Perl.org|http://www.perl.org/" # original content

=begin original

Note that you can distinguish URL-links from anything else by the
fact that they match C<m/\A\w+:[^:\s]\S*\z/>.  So
C<LE<lt>http://www.perl.comE<gt>> is a URL, but
C<LE<lt>HTTP::ResponseE<gt>> isn't.

=end original

URL リンクは C<m/\A\w+:[^:\s]\S*\z/> でマッチングするという事実でその他の
ものと区別できると言うことに注意してください。
従って C<LE<lt>http://www.perl.comE<gt>> は URL ですが、
C<LE<lt>HTTP::ResponseE<gt>> は違います。

=item *

=begin original

In case of LE<lt>...> codes with no "text|" part in them,
older formatters have exhibited great variation in actually displaying
the link or cross reference.  For example, LE<lt>crontab(5)> would render
as "the C<crontab(5)> manpage", or "in the C<crontab(5)> manpage"
or just "C<crontab(5)>".

=end original

"text|" 部分がない LE<lt>...> コードの場合、古いフォーマッタが実際に
表示するリンクやクロスリファレンスには様々なパターンがあります。
例えば、LE<lt>crontab(5)> は "the C<crontab(5)> manpage" あるいは
"in the C<crontab(5)> manpage" あるいは単に "C<crontab(5)>" と
レンダリングされます。

=begin original

Pod processors must now treat "text|"-less links as follows:

=end original

Pod プロセッサは "text|" の内リンクを以下のように
扱わなければなりません(must):

  L<name>         =>  L<name|name>
  L</section>     =>  L<"section"|/section>
  L<name/section> =>  L<"section" in name|name/section>

=item *

=begin original

Note that section names might contain markup.  I.e., if a section
starts with:

=end original

セクション名にはマークアップを含んでいるかも知れないことに注意してください。
つまり、セクションが以下のいずれかで始まっていると:

  =head2 About the C<-M> Operator

=begin original

or with:

=end original

または:

  =item About the C<-M> Operator

=begin original

then a link to it would look like this:

=end original

これへのリンクは以下のようになります:

  L<somedoc/About the C<-M> Operator>

=begin original

Formatters may choose to ignore the markup for purposes of resolving
the link and use only the renderable characters in the section name,
as in:

=end original

フォーマッタはリンクを解決する目的でマークアップを無視して、
以下のようにセクション名としてレンダリング可能な文字だけを使うことを
選択してもかまいません(may):

  <h1><a name="About_the_-M_Operator">About the <code>-M</code>
  Operator</h1>

  ...

  <a href="somedoc#About_the_-M_Operator">About the <code>-M</code>
  Operator" in somedoc</a>

=item *

=begin original

Previous versions of perlpod distinguished C<LE<lt>name/"section"E<gt>>
links from C<LE<lt>name/itemE<gt>> links (and their targets).  These
have been merged syntactically and semantically in the current
specification, and I<section> can refer either to a "=headI<n> Heading
Content" command or to a "=item Item Content" command.  This
specification does not specify what behavior should be in the case
of a given document having several things all seeming to produce the
same I<section> identifier (e.g., in HTML, several things all producing
the same I<anchorname> in <a name="I<anchorname>">...</a>
elements).  Where Pod processors can control this behavior, they should
use the first such anchor.  That is, C<LE<lt>Foo/BarE<gt>> refers to the
I<first> "Bar" section in Foo.

=end original

以前のバージョンの perlpod は C<LE<lt>name/"section"E<gt>> リンクを
C<LE<lt>name/itemE<gt>> リンク (およびそのターゲット) と区別していました。
現在の仕様ではこれらは文法的および意味論的にマージされ、
I<section> は "=headI<n> Heading Content" コマンドまたは "=item Item Content"
コマンドのどちらかを参照できるようになりました。
この仕様は、一つの文書に同じ I<section> 識別子を出力するように見えるものが
複数ある場合 (例えば、HTML では、<a name="I<anchorname>">...</a> で
同じ I<anchorname> を生成するものが複数ある場合) の振る舞いは
規定していません。
Pod プロセッサがこの振る舞いを制御できるところでは、そのようなアンカーの
最初のものを使うべきです(should)。
つまり、C<LE<lt>Foo/BarE<gt>> は Foo にある I<最初の> "Bar" を参照します。

=begin original

But for some processors/formats this cannot be easily controlled; as
with the HTML example, the behavior of multiple ambiguous
<a name="I<anchorname>">...</a> is most easily just left up to
browsers to decide.

=end original

しかし一部のプロセッサ/形式はこれは簡単には制御できません; HTML の例では、
複数の曖昧な <a name="I<anchorname>">...</a> の振る舞いは、ブラウザが
決定するに任せるのがもっとも簡単です。

=item *

=begin original

In a C<LE<lt>text|...E<gt>> code, text may contain formatting codes
for formatting or for EE<lt>...> escapes, as in:

=end original

C<LE<lt>text|...E<gt>> コードは、以下のようにフォーマッティングや
EE<lt>...> のためのフォーマッティングコードを含んでいてもかまいません(may):

  L<B<ummE<234>stuff>|...>

=begin original

For C<LE<lt>...E<gt>> codes without a "name|" part, only
C<EE<lt>...E<gt>> and C<ZE<lt>E<gt>> codes may occur.  That is,
authors should not use "C<LE<lt>BE<lt>Foo::BarE<gt>E<gt>>".

=end original

"name|" 部分のない C<LE<lt>...E<gt>> コードでは、
C<EE<lt>...E<gt>> と C<ZE<lt>E<gt>> のコードのみ使ってもかまいません(may)。
つまり、著者は "C<LE<lt>BE<lt>Foo::BarE<gt>E<gt>>" を使うべきではありません
(should not)。

=begin original

Note, however, that formatting codes and ZE<lt>>'s can occur in any
and all parts of an LE<lt>...> (i.e., in I<name>, I<section>, I<text>,
and I<url>).

=end original

しかし、フォーマッティングコードと ZE<lt>> は LE<lt>...> の全ての部分
(つまり in I<name>, I<section>, I<text>, I<url>) に現れることに
注意してください。

=begin original

Authors must not nest LE<lt>...> codes.  For example, "LE<lt>The
LE<lt>Foo::Bar> man page>" should be treated as an error.

=end original

著者は LE<lt>...> コードをネストさせてはいけません(must not)。
例えば、"LE<lt>The LE<lt>Foo::Bar> man page>" はエラーとして扱われるべきです
(should)。

=item *

=begin original

Note that Pod authors may use formatting codes inside the "text"
part of "LE<lt>text|name>" (and so on for LE<lt>text|/"sec">).

=end original

Pod 著者は "LE<lt>text|name>" (および LE<lt>text|/"sec">)の "text" 部分には
フォーマッティングコードを使ってもかまわない(may)ことに注意してください。

=begin original

In other words, this is valid:

=end original

言い換えると、次のものは有効です:

  Go read L<the docs on C<$.>|perlvar/"$.">

=begin original

Some output formats that do allow rendering "LE<lt>...>" codes as
hypertext, might not allow the link-text to be formatted; in
that case, formatters will have to just ignore that formatting.

=end original

"LE<lt>...>" コードをハイパーテキストとしてレンダリングする一部の出力形式は
フォーマットされたリンクテキストを許さないかもしれません;
この場合、フォーマッタは単にフォーマッティングを無視する必要があります。

=item *

=begin original

At time of writing, C<LE<lt>nameE<gt>> values are of two types:
either the name of a Pod page like C<LE<lt>Foo::BarE<gt>> (which
might be a real Perl module or program in an @INC / PATH
directory, or a .pod file in those places); or the name of a Unix
man page, like C<LE<lt>crontab(5)E<gt>>.  In theory, C<LE<lt>chmodE<gt>>
is ambiguous between a Pod page called "chmod", or the Unix man page
"chmod" (in whatever man-section).  However, the presence of a string
in parens, as in "crontab(5)", is sufficient to signal that what
is being discussed is not a Pod page, and so is presumably a
Unix man page.  The distinction is of no importance to many
Pod processors, but some processors that render to hypertext formats
may need to distinguish them in order to know how to render a
given C<LE<lt>fooE<gt>> code.

=end original

これを書いている時点で、C<LE<lt>nameE<gt>> の値は二つの種類があります:
C<LE<lt>Foo::BarE<gt>> のような Pod ページの名前 (@INC / PATH
ディレクトリにある実際の Perl モジュールやプログラムかもしれませんし、
それらの場所にある .pod ファイルかもしれません); または
C<LE<lt>crontab(5)E<gt>> のような Unix man ページの名前です。
理論的には、C<LE<lt>chmodE<gt>> は "chmod" という名前の Pod ページか
"chmod" (man セクションのどこかにある) Unix man ページかがあいまいです。
しかし、"crontab(5)" のように、かっこの中に文字があるなら、対象となっている
ものが Pod ページでないことを示すには十分なので、これはおそらく
Unix man ページです。
区別は多くの Pod プロセッサにとっては重要ではありませんが、
ハイパーテキスト形式にレンダリングするプロセッサは、指定された
C<LE<lt>fooE<gt>> コードをどのようにレンダリングするかを知るために
これらを区別する必要があるかもしれません。

=item *

=begin original

Previous versions of perlpod allowed for a C<LE<lt>sectionE<gt>> syntax (as in
C<LE<lt>Object AttributesE<gt>>), which was not easily distinguishable from
C<LE<lt>nameE<gt>> syntax and for C<LE<lt>"section"E<gt>> which was only
slightly less ambiguous.  This syntax is no longer in the specification, and
has been replaced by the C<LE<lt>/sectionE<gt>> syntax (where the slash was
formerly optional).  Pod parsers should tolerate the C<LE<lt>"section"E<gt>>
syntax, for a while at least.  The suggested heuristic for distinguishing
C<LE<lt>sectionE<gt>> from C<LE<lt>nameE<gt>> is that if it contains any
whitespace, it's a I<section>.  Pod processors should warn about this being
deprecated syntax.

=end original

以前のバージョンの perlpod では(C<LE<lt>Object AttributesE<gt>> のような)
C<LE<lt>sectionE<gt>> 文法を許していました; これは
C<LE<lt>nameE<gt>> 文法と簡単には区別できず、
C<LE<lt>"section"E<gt>> とはほんの少しだけしか曖昧性が少なくなりません。
この文法は現在の仕様には含まれず、C<LE<lt>/sectionE<gt>> 文法で
置き換えられました(以前はスラッシュはオプションでした)。
Pod パーサは、少なくともしばらくの間は、C<LE<lt>"section"E<gt>> 文法を
許容するべきです(should)。
C<LE<lt>nameE<gt>> を C<LE<lt>sectionE<gt>> と区別するための推奨される
ヒューリスティックは、もし空白が含まれていれば、それは I<section> と
いうことです。
Pod プロセッサはこれらの廃止予定の文法に関して警告するべきです(should)。

=back

=head1 About =over...=back Regions

(=over...=back 領域について)

=begin original

"=over"..."=back" regions are used for various kinds of list-like
structures.  (I use the term "region" here simply as a collective
term for everything from the "=over" to the matching "=back".)

=end original

"=over"..."=back" 領域は、様々な種類のリスト風の構造に使われます。
(ここでは、「領域」という用語は単に "=over" からそれに対応する
"=back" までの全てを含むものという意味使っています。)

=over

=item *

=begin original

The non-zero numeric I<indentlevel> in "=over I<indentlevel>" ...
"=back" is used for giving the formatter a clue as to how many
"spaces" (ems, or roughly equivalent units) it should tab over,
although many formatters will have to convert this to an absolute
measurement that may not exactly match with the size of spaces (or M's)
in the document's base font.  Other formatters may have to completely
ignore the number.  The lack of any explicit I<indentlevel> parameter is
equivalent to an I<indentlevel> value of 4.  Pod processors may
complain if I<indentlevel> is present but is not a positive number
matching C<m/\A(\d*\.)?\d+\z/>.

=end original

"=over I<indentlevel>" ... "=back" での非ゼロ数値 I<indentlevel> は、
フォーマッタに、いくつの「空白」(ems またはおよそ等価な単位) を
空けるべきかに関する手がかりを与えますが、多くのフォーマッタはこれを、
文書の基本フォントの空白 (あるいは M) のサイズと正確に一致しない
全体的な長さに変換する必要があります。
その他のフォーマッタは数値を完全に無視する必要があるかもしれません。
明示的な I<indentlevel> パラメータがない場合、I<indentlevel> の値が
4 の場合と等価です。
Pod プロセッサは、I<indentlevel> が存在するけれども
C<m/\A(\d*\.)?\d+\z/> にマッチングする正数ではない場合に警告を
出してもかまいません(may)。

=item *

=begin original

Authors of Pod formatters are reminded that "=over" ... "=back" may
map to several different constructs in your output format.  For
example, in converting Pod to (X)HTML, it can map to any of
<ul>...</ul>, <ol>...</ol>, <dl>...</dl>, or
<blockquote>...</blockquote>.  Similarly, "=item" can map to <li> or
<dt>.

=end original

Pod フォーマッタの作者は、"=over" ... "=back" は出力フォーマットによっては
複数の異なった構造に割り当てられるかもしれない(may)ことに留意してください。
例えば、Pod を (X)HTML に変換する場合、<ul>...</ul>, <ol>...</ol>,
<dl>...</dl>, <blockquote>...</blockquote> のいずれかに
割り当てられるかもしれません。
同様に、"=item" は <li> または <dt> に割り当てられるかもしれません。

=item *

=begin original

Each "=over" ... "=back" region should be one of the following:

=end original

それぞれの "=over" ... "=back" 領域は以下のうちの一つであるべきです(should):

=over

=item *

=begin original

An "=over" ... "=back" region containing only "=item *" commands,
each followed by some number of ordinary/verbatim paragraphs, other
nested "=over" ... "=back" regions, "=for..." paragraphs, and
"=begin"..."=end" regions.

=end original

"=item *" 段落および、
通常の段落、そのままの段落、ネストした
"=over" ... "=back" 領域、"=for..." 段落、"=begin"..."=end" コード
のいずれかが任意の数引き続いたもののみからなる "=over" ... "=back" 領域。

=begin original

(Pod processors must tolerate a bare "=item" as if it were "=item
*".)  Whether "*" is rendered as a literal asterisk, an "o", or as
some kind of real bullet character, is left up to the Pod formatter,
and may depend on the level of nesting.

=end original

(Pod プロセッサは、生の "=item" を、"=item *" であるかのように
扱わなければなりません(must)。)
"*" をそのままアスタリスクとして表示するか、"o" を使うか、あるいは
ある種の実際の黒丸を使うかは Pod フォーマッタに任されていて、
これはネストレベルに依存するかも知れません。

=item *

=begin original

An "=over" ... "=back" region containing only
C<m/\A=item\s+\d+\.?\s*\z/> paragraphs, each one (or each group of them)
followed by some number of ordinary/verbatim paragraphs, other nested
"=over" ... "=back" regions, "=for..." paragraphs, and/or
"=begin"..."=end" codes.  Note that the numbers must start at 1
in each section, and must proceed in order and without skipping
numbers.

=end original

C<m/\A=item\s+\d+\.?\s*\z/> 段落および、
通常の段落、そのままの段落、ネストした
"=over" ... "=back" 領域、"=for..." 段落、"=begin"..."=end" コード
のいずれかが任意の数引き続いたもののみからなる "=over" ... "=back" 領域。
各章の番号は 1 から始まり、省略されることなく続かなければならないことに
注意してください。

=begin original

(Pod processors must tolerate lines like "=item 1" as if they were
"=item 1.", with the period.)

=end original

(Pod プロセッサは、"=item 1" のような行を、ピリオド付きの
"=item 1." であるかのように扱わなければなりません(must)。)

=item *

=begin original

An "=over" ... "=back" region containing only "=item [text]"
commands, each one (or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested "=over" ... "=back"
regions, or "=for..." paragraphs, and "=begin"..."=end" regions.

=end original

"=item [text]" 段落および、
通常の段落、そのままの段落、ネストした
"=over" ... "=back" 領域、"=for..." 段落、"=begin"..."=end" コード
のいずれかが任意の数引き続いたもののみからなる "=over" ... "=back" 領域。

=begin original

The "=item [text]" paragraph should not match
C<m/\A=item\s+\d+\.?\s*\z/> or C<m/\A=item\s+\*\s*\z/>, nor should it
match just C<m/\A=item\s*\z/>.

=end original

"=item [text]" 段落は、C<m/\A=item\s+\d+\.?\s*\z/>,
C<m/\A=item\s+\*\s*\z/> にマッチングしたり、単に
C<m/\A=item\s*\z/> にマッチングしたりするべきではありません(should not)。

=item *

=begin original

An "=over" ... "=back" region containing no "=item" paragraphs at
all, and containing only some number of 
ordinary/verbatim paragraphs, and possibly also some nested "=over"
... "=back" regions, "=for..." paragraphs, and "=begin"..."=end"
regions.  Such an itemless "=over" ... "=back" region in Pod is
equivalent in meaning to a "<blockquote>...</blockquote>" element in
HTML.

=end original

"=item" 段落がまったくなく、いくつかの普通/そのままの段落と、
おそらくはいくつかのネストした "=over" ... "=back" 領域、"=for..." 段落、
"=begin"..."=end" 領域のみがある "=over" ... "=back" 領域。
Pod にあるこのような item なしの "=over" ... "=back" 領域は、HTML での
"<blockquote>...</blockquote>" 要素と等価な意味を持ちます。

=back

=begin original

Note that with all the above cases, you can determine which type of
"=over" ... "=back" you have, by examining the first (non-"=cut", 
non-"=pod") Pod paragraph after the "=over" command.

=end original

上述の全ての場合において、"=over" コマンドの後の ("=cut" と "=pod" を
除く) 最初の Pod 段落を調べることで、どの形式の
"=over" ... "=back" であるかを決定できることに注意してください。

=item *

=begin original

Pod formatters I<must> tolerate arbitrarily large amounts of text
in the "=item I<text...>" paragraph.  In practice, most such
paragraphs are short, as in:

=end original

Pod フォーマッタは "=item I<text...>" に任意の長さのテキストを
許容 I<しなければなりません> (must)。
実際には、このような段落のほとんどは以下のような短いものです:

  =item For cutting off our trade with all parts of the world

=begin original

But they may be arbitrarily long:

=end original

しかし任意に長くなるかも知れません:

  =item For transporting us beyond seas to be tried for pretended
  offenses

  =item He is at this time transporting large armies of foreign
  mercenaries to complete the works of death, desolation and
  tyranny, already begun with circumstances of cruelty and perfidy
  scarcely paralleled in the most barbarous ages, and totally
  unworthy the head of a civilized nation.

=item *

=begin original

Pod processors should tolerate "=item *" / "=item I<number>" commands
with no accompanying paragraph.  The middle item is an example:

=end original

Pod プロセッサは、対応する段落のない "=item *" / "=item I<number>"
コマンドを許容するべきです(should)。
中間の item が例です:

  =over

  =item 1

  Pick up dry cleaning.

  =item 2

  =item 3

  Stop by the store.  Get Abba Zabas, Stoli, and cheap lawn chairs.

  =back

=item *

=begin original

No "=over" ... "=back" region can contain headings.  Processors may
treat such a heading as an error.

=end original

"=over" ... "=back" 領域に見出しを含めることはできません。
プロセッサはそのような見出しをエラーとして扱ってもかまいません(may)。

=item *

=begin original

Note that an "=over" ... "=back" region should have some
content.  That is, authors should not have an empty region like this:

=end original

"=over" ... "=back" 領域には内容があるべきであることに注意してください。
つまり、作者は以下のような空の領域を作るべきではありません:

  =over

  =back

=begin original

Pod processors seeing such a contentless "=over" ... "=back" region,
may ignore it, or may report it as an error.

=end original

Pod プロセッサがこのような、内容のない "=over" ... "=back" 領域を
発見した場合、無視してもかまいません(may)し、エラーとして
報告してもかまいません(may)。

=item *

=begin original

Processors must tolerate an "=over" list that goes off the end of the
document (i.e., which has no matching "=back"), but they may warn
about such a list.

=end original

プロセッサは、文書の末尾まで続く(つまり対応する "=back" がない)
"=over" リストを許容しなければなりません(must)が、そのようなリストに
警告を出してもかまいません(may)。

=item *

=begin original

Authors of Pod formatters should note that this construct:

=end original

Pod フォーマッタの作者はこのような構造に注意するべきです:

  =item Neque

  =item Porro

  =item Quisquam Est

  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
  velit, sed quia non numquam eius modi tempora incidunt ut
  labore et dolore magnam aliquam quaerat voluptatem.

  =item Ut Enim

=begin original

is semantically ambiguous, in a way that makes formatting decisions
a bit difficult.  On the one hand, it could be mention of an item
"Neque", mention of another item "Porro", and mention of another
item "Quisquam Est", with just the last one requiring the explanatory
paragraph "Qui dolorem ipsum quia dolor..."; and then an item
"Ut Enim".  In that case, you'd want to format it like so:

=end original

というのは意味論としてはあいまいで、フォーマッティング方法の決定は
少し難しいです。
まず、これはアイテム "Neque" への言及、次のアイテム "Porro" への
言及、次のアイテム "Quisquam Est" への言及で、単に最後のものだけ
説明の段落 "Qui dolorem ipsum quia dolor..." があって、それから
アイテム "Ut Enim" があります。
この場合、以下のようにフォーマットしてほしいでしょう:

  Neque

  Porro

  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.

  Ut Enim

=begin original

But it could equally well be a discussion of three (related or equivalent)
items, "Neque", "Porro", and "Quisquam Est", followed by a paragraph
explaining them all, and then a new item "Ut Enim".  In that case, you'd
probably want to format it like so:

=end original

しかし、同様に、三つの(関係のある、あるいは等価な)アイテムである
"Neque", "Porro", "Quisquam Est" があり、引き続いてこれら全てを
説明する段落があり、それから新しいアイテム "Ut Enim" がある、とも取れます。
この場合、おそらく以下のようにフォーマットしてほしいでしょう:

  Neque
  Porro
  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.

  Ut Enim

=begin original

But (for the foreseeable future), Pod does not provide any way for Pod
authors to distinguish which grouping is meant by the above
"=item"-cluster structure.  So formatters should format it like so:

=end original

しかし(予測可能な未来において)、Pod は Pod 作者に上述の "=item" の
塊の構造を意味するようなグルーピングを区別する方法を提供しません。
従ってフォーマッタは以下のようにフォーマットするべきです(should):

  Neque

  Porro

  Quisquam Est

    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.

  Ut Enim

=begin original

That is, there should be (at least roughly) equal spacing between
items as between paragraphs (although that spacing may well be less
than the full height of a line of text).  This leaves it to the reader
to use (con)textual cues to figure out whether the "Qui dolorem
ipsum..." paragraph applies to the "Quisquam Est" item or to all three
items "Neque", "Porro", and "Quisquam Est".  While not an ideal
situation, this is preferable to providing formatting cues that may
be actually contrary to the author's intent.

=end original

つまり、(少なくともおおよそは)アイテム間の空白は段落間の空白と
同じであるべきです(should)(しかしこの空白はテキストの行の高さより
少なくてもかまいません(may))。
これにより、"Qui dolorem ipsum..." 段落が "Quisquam Est" アイテムのみと
"Neque", "Porro", "Quisquam Est" の三つのアイテム全てのどちらに
掛かるのかを判断する文脈上の手がかりを使えるように読者に残しておきます。
理想的な状況ではありませんが、実際には著者の意図に反した
フォーマッティングの手がかりを提供するよりは好ましいです。

=back

=head1 About Data Paragraphs and "=begin/=end" Regions

(データ段落と "=begin/=end" 領域について)

=begin original

Data paragraphs are typically used for inlining non-Pod data that is
to be used (typically passed through) when rendering the document to
a specific format:

=end original

データ段落は典型的には文書を特定のフォーマットでレンダリングするときに
使われる(典型的にはそのまま渡される)非 Pod データを含ませるために
使います:

  =begin rtf

  \par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}

  =end rtf

=begin original

The exact same effect could, incidentally, be achieved with a single
"=for" paragraph:

=end original

正確に同じ効果は、偶然ながら、単一の "=for" 段落でも達成できます:

  =for rtf \par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}

=begin original

(Although that is not formally a data paragraph, it has the same
meaning as one, and Pod parsers may parse it as one.)

=end original

(これは形式的にはデータ段落ではありませんが、同じ意味を持ち、
Pod パーサは同じようにパースするでしょう。)

=begin original

Another example of a data paragraph:

=end original

データ段落のもう一つの例です:

  =begin html

  I like <em>PIE</em>!

  <hr>Especially pecan pie!

  =end html

=begin original

If these were ordinary paragraphs, the Pod parser would try to
expand the "EE<lt>/em>" (in the first paragraph) as a formatting
code, just like "EE<lt>lt>" or "EE<lt>eacute>".  But since this
is in a "=begin I<identifier>"..."=end I<identifier>" region I<and>
the identifier "html" doesn't begin have a ":" prefix, the contents
of this region are stored as data paragraphs, instead of being
processed as ordinary paragraphs (or if they began with a spaces
and/or tabs, as verbatim paragraphs).

=end original

通常の段落の場合、Pod パーサは (最初の段落にある) "EE<lt>/em>" を
"EE<lt>lt>" や "EE<lt>eacute>" と同じように、
フォーマッティングコードとして展開しようとします。
しかし、これは "=begin I<identifier>"..."=end I<identifier>" 領域の
中にあり、I<かつ> 識別子 "html" は ":" 接頭辞で始まっていないので、
この領域の内容は、通常の段落(あるいは、もしスペースやタブで
始まっている場合はそのままの段落)としてされるのではなく、データ段落として
保管されます。

=begin original

As a further example: At time of writing, no "biblio" identifier is
supported, but suppose some processor were written to recognize it as
a way of (say) denoting a bibliographic reference (necessarily
containing formatting codes in ordinary paragraphs).  The fact that
"biblio" paragraphs were meant for ordinary processing would be
indicated by prefacing each "biblio" identifier with a colon:

=end original

さらなる例: これを書いている時点で、"biblio" 識別子には対応していませんが、
一部のプロセッサがこれを(例えば、必然的に通常の段落に
フォーマッティングコードを含んでいる)参考文献を示すものとして認識する
ように書かれているとします。
"biblio" 段落が通常通り処理されるということは、"biblio" 識別子にコロンが
付いていることで示されています:

  =begin :biblio

  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
  Programs.>  Prentice-Hall, Englewood Cliffs, NJ.

  =end :biblio

=begin original

This would signal to the parser that paragraphs in this begin...end
region are subject to normal handling as ordinary/verbatim paragraphs
(while still tagged as meant only for processors that understand the
"biblio" identifier).  The same effect could be had with:

=end original

これはパーサに、この begin...end 領域は普通の/そのままの段落として
通常通り扱われることを前提としていることを示します (一方
"biblio" 識別子を理解するプロセッサのみのためのものであるという
意味も持ちます)。
同じ効果は以下のようにしても得られます:

  =for :biblio
  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
  Programs.>  Prentice-Hall, Englewood Cliffs, NJ.

=begin original

The ":" on these identifiers means simply "process this stuff
normally, even though the result will be for some special target".
I suggest that parser APIs report "biblio" as the target identifier,
but also report that it had a ":" prefix.  (And similarly, with the
above "html", report "html" as the target identifier, and note the
I<lack> of a ":" prefix.)

=end original

これらの識別子の ":" は単に「結果が特別なターゲットのためのものであっても、
この内容を通常通り処理する」ことを意味します。
私はパーサ API が "biblio" をターゲット識別子として報告するだけでなく、
":" 接頭辞があることも報告することを推奨します。
(そして同じように、上述の "html" では、"html" をターゲット識別子として、
また ":" 接頭辞が I<ない> ことを報告します。)

=begin original

Note that a "=begin I<identifier>"..."=end I<identifier>" region where
I<identifier> begins with a colon, I<can> contain commands.  For example:

=end original

I<identifier> がコロンで始まっている
"=begin I<identifier>"..."=end I<identifier>" 領域は、コマンドを含むことが
I<できる> ことに注意してください。
例えば:

  =begin :biblio

  Wirth's classic is available in several editions, including:

  =for comment
   hm, check abebooks.com for how much used copies cost.

  =over

  =item

  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
  Teubner, Stuttgart.  [Yes, it's in German.]

  =item

  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
  Programs.>  Prentice-Hall, Englewood Cliffs, NJ.

  =back

  =end :biblio

=begin original

Note, however, a "=begin I<identifier>"..."=end I<identifier>"
region where I<identifier> does I<not> begin with a colon, should not
directly contain "=head1" ... "=head4" commands, nor "=over", nor "=back",
nor "=item".  For example, this may be considered invalid:

=end original

しかし、"=begin I<identifier>"..."=end I<identifier>" 領域で I<identifier> が
コロンで始まって I<いない> 場合、直接 "=head1" ... "=head4" コマンドや
"=over", "=back","=item" を直接含むべきではありません(should not)。
例えば、以下のものは不正となります:

  =begin somedata

  This is a data paragraph.

  =head1 Don't do this!

  This is a data paragraph too.

  =end somedata

=begin original

A Pod processor may signal that the above (specifically the "=head1"
paragraph) is an error.  Note, however, that the following should
I<not> be treated as an error:

=end original

Pod プロセッサは上述のようなもの (特に "=head1" 段落) をエラーとして
扱ってもかまいません(may)。
しかし、以下のようなものをエラーとして扱う I<べきではない> (should not)
ことに注意してください。

  =begin somedata

  This is a data paragraph.

  =cut

  # Yup, this isn't Pod anymore.
  sub excl { (rand() > .5) ? "hoo!" : "hah!" }

  =pod

  This is a data paragraph too.

  =end somedata

=begin original

And this too is valid:

=end original

そしてこれも正当です:

  =begin someformat

  This is a data paragraph.

    And this is a data paragraph.

  =begin someotherformat

  This is a data paragraph too.

    And this is a data paragraph too.

  =begin :yetanotherformat

  =head2 This is a command paragraph!

  This is an ordinary paragraph!

    And this is a verbatim paragraph!

  =end :yetanotherformat

  =end someotherformat

  Another data paragraph!

  =end someformat

=begin original

The contents of the above "=begin :yetanotherformat" ...
"=end :yetanotherformat" region I<aren't> data paragraphs, because
the immediately containing region's identifier (":yetanotherformat")
begins with a colon.  In practice, most regions that contain
data paragraphs will contain I<only> data paragraphs; however, 
the above nesting is syntactically valid as Pod, even if it is
rare.  However, the handlers for some formats, like "html",
will accept only data paragraphs, not nested regions; and they may
complain if they see (targeted for them) nested regions, or commands,
other than "=end", "=pod", and "=cut".

=end original

上述の "=begin :yetanotherformat" ... "=end :yetanotherformat" 領域の
内容はデータ段落 I<ではありません>; なぜなら 領域の識別子
(":yetanotherformat") がコロンで始まっているからです。
実際のところ、データ段落を含んでいる領域のほとんどはデータ段落
I<のみ> を含んでいます; しかし、上述のようなネスティングは(稀で
あるとしても)文法的にはPod として正当です。
しかし、"html" のような一部の形式のハンドラは、データ段落のみをつけつけ、
ネストした領域を受け付けません; また、ネストした領域や、
"=end", "=pod", and "=cut" 以外のコマンドを(ターゲットとしている中に)
発見すると、エラーとなるかもしれません。

=begin original

Also consider this valid structure:

=end original

また、以下の正当な構造を考えてみます:

  =begin :biblio

  Wirth's classic is available in several editions, including:

  =over

  =item

  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
  Teubner, Stuttgart.  [Yes, it's in German.]

  =item

  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
  Programs.>  Prentice-Hall, Englewood Cliffs, NJ.

  =back

  Buy buy buy!

  =begin html

  <img src='wirth_spokesmodeling_book.png'>

  <hr>

  =end html

  Now now now!

  =end :biblio

=begin original

There, the "=begin html"..."=end html" region is nested inside
the larger "=begin :biblio"..."=end :biblio" region.  Note that the
content of the "=begin html"..."=end html" region is data
paragraph(s), because the immediately containing region's identifier
("html") I<doesn't> begin with a colon.

=end original

ここで、"=begin html"..."=end html" 領域は、より大きい
"=begin :biblio"..."=end :biblio" 領域の内側にネストしています。
"=begin html"..."=end html" 領域の内容はデータ段落です; なぜなら
直接含んでいる領域の識別子 ("html") はコロンで始まって I<いない> からです。

=begin original

Pod parsers, when processing a series of data paragraphs one
after another (within a single region), should consider them to
be one large data paragraph that happens to contain blank lines.  So
the content of the above "=begin html"..."=end html" I<may> be stored
as two data paragraphs (one consisting of
"<img src='wirth_spokesmodeling_book.png'>\n"
and another consisting of "<hr>\n"), but I<should> be stored as
a single data paragraph (consisting of 
"<img src='wirth_spokesmodeling_book.png'>\n\n<hr>\n").

=end original

Pod パーサは、(一つの領域に含まれた)連続したデータ段落を処理するときには、
たまたま空行を含んでいる一つの大きなデータ段落として考えるべきです(should)。
それで上述の "=begin html"..."=end html" の内容は二つのデータ段落
(一つは "<img src='wirth_spokesmodeling_book.png'>\n" で、もう一つは
"<hr>\n") として保管しても I<かまいません> が(may)、一つの大きな
データ段落 ("<img src='wirth_spokesmodeling_book.png'>\n\n<hr>\n") として
保管される I<べき> です(should)。

=begin original

Pod processors should tolerate empty
"=begin I<something>"..."=end I<something>" regions,
empty "=begin :I<something>"..."=end :I<something>" regions, and
contentless "=for I<something>" and "=for :I<something>"
paragraphs.  I.e., these should be tolerated:

=end original

Pod プロセッサは 空の "=begin I<something>"..."=end I<something>" 領域、
空の "=begin :I<something>"..."=end :I<something>" 領域、中身のない
"=for I<something>" 段落と "=for :I<something>" 段落を
許容するべきです(should)。
つまり、いかのようなものは許容されるべきです(should):

  =for html

  =begin html

  =end html

  =begin :biblio

  =end :biblio

=begin original

Incidentally, note that there's no easy way to express a data
paragraph starting with something that looks like a command.  Consider:

=end original

ところで、コマンドのように見えるもので始まるデータ段落を記述する簡単な
方法はないことに注意してください。
以下を考えます:

  =begin stuff

  =shazbot

  =end stuff

=begin original

There, "=shazbot" will be parsed as a Pod command "shazbot", not as a data
paragraph "=shazbot\n".  However, you can express a data paragraph consisting
of "=shazbot\n" using this code:

=end original

ここで、"=shazbot" はデータ段落 "=shazbot\n" ではなく Pod コマンド
"shazbot" としてパースされます。
しかし、"=shazbot\n" からなるデータ段落は以下のようにして記述できます:

  =for stuff =shazbot

=begin original

The situation where this is necessary, is presumably quite rare.

=end original

これが必要な状況は、おそらくかなり稀です。

=begin original

Note that =end commands must match the currently open =begin command.  That
is, they must properly nest.  For example, this is valid:

=end original

なお、=end コマンドは現在開いている =begin コマンドと
一致しなければならないことに注意してください。
これは、適切にネストしなければならないということです。
例えば、以下は正当です:

  =begin outer

  X

  =begin inner

  Y

  =end inner

  Z

  =end outer

=begin original

while this is invalid:

=end original

一方、以下は不正です:

  =begin outer

  X

  =begin inner

  Y

  =end outer

  Z

  =end inner

=begin original

This latter is improper because when the "=end outer" command is seen, the
currently open region has the formatname "inner", not "outer".  (It just
happens that "outer" is the format name of a higher-up region.)  This is
an error.  Processors must by default report this as an error, and may halt
processing the document containing that error.  A corollary of this is that
regions cannot "overlap". That is, the latter block above does not represent
a region called "outer" which contains X and Y, overlapping a region called
"inner" which contains Y and Z.  But because it is invalid (as all
apparently overlapping regions would be), it doesn't represent that, or
anything at all.

=end original

"=end outer" コマンドが現れたとき、現在開いている領域のフォーマット名は
"outer" ではなく "inner" なので、これは不適切です。
("outer" はより高いレベルの領域のフォーマット名です。)
これはエラーです。
プロセッサはデフォルトではこれをエラーと報告しなければならず(must)、
エラーを含む文書の処理を停止してもかまいません(may)。
ここから導かれる結論は、領域は「重複」できないということです。
つまり、上述の後者のブロックは X と Y を含む "outer" と呼ばれる領域と、
Y と Z を含む "inner" と呼ばれる重複した領域を表現しているわけではないと
いうことです。
しかし、これは (明らかに重複している領域全てのように) 不正なので、
これは表現されなかったり、あるいはまったく表示されなかったりします。

=begin original

Similarly, this is invalid:

=end original

同様に、以下のものも不正です:

  =begin thing

  =end hting

=begin original

This is an error because the region is opened by "thing", and the "=end"
tries to close "hting" [sic].

=end original

これは、領域が "thing" で開かれていて "=end" が "hting" (原文のまま) を
閉じようとしているので、エラーです。

=begin original

This is also invalid:

=end original

また、以下のものも不正です:

  =begin thing

  =end

=begin original

This is invalid because every "=end" command must have a formatname
parameter.

=end original

これは、全ての "=end" コマンドにはフォーマット名引数が必要なので、
不正です。

=head1 SEE ALSO

L<perlpod>, L<perlsyn/"PODs: Embedded Documentation">,
L<podchecker>

=head1 AUTHOR

Sean M. Burke

=cut

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org>
Status: completed

=end meta

