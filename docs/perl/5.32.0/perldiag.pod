
=encoding euc-jp

=head1 NAME

=begin original

perldiag - various Perl diagnostics

=end original

perldiag - さまざまな Perl 診断メッセージ

=head1 DESCRIPTION

=begin original

These messages are classified as follows (listed in increasing order of
desperation):

=end original

これらのメッセージは以下のように分類されます (重要度が増す順に
並べてあります):

=begin original

    (W) A warning (optional).
    (D) A deprecation (enabled by default).
    (S) A severe warning (enabled by default).
    (F) A fatal error (trappable).
    (P) An internal error you should never see (trappable).
    (X) A very fatal error (nontrappable).
    (A) An alien error message (not generated by Perl).

=end original

    (W) 警告 (オプション)。
    (D) 非推奨 (デフォルトでは有効)。
    (S) 重大な警告 (デフォルトでは有効)。
    (F) 致命的エラー (トラップ可能)。
    (P) 起こるはずのない内部エラー (トラップ可能)。
    (X) 重大致命的エラー (トラップ不可能)。
    (A) 外部エラーメッセージ (Perl 以外で生成されたもの)。

=begin original

The majority of messages from the first three classifications above
(W, D & S) can be controlled using the C<warnings> pragma.

=end original

上記のうち、最初の三つ (W, D, S) に分類されるメッセージの大部分は
C<warings> プラグマで制御できます。

=begin original

If a message can be controlled by the C<warnings> pragma, its warning
category is included with the classification letter in the description
below.  E.g. C<(W closed)> means a warning in the C<closed> category.

=end original

メッセージが C<warnings> プラグマで制御できる場合、警告カテゴリは以下の
説明で分類文字と共に記されています。
例えば、C<(W closed)> は C<closed> カテゴリの警告を意味します。

=begin original

Optional warnings are enabled by using the C<warnings> pragma or the B<-w>
and B<-W> switches.  Warnings may be captured by setting C<$SIG{__WARN__}>
to a reference to a routine that will be called on each warning instead
of printing it.  See L<perlvar>.

=end original

C<warnings> プラグマか B<-w> と B<-W> のオプションを使うと追加の警告が
有効になります。
警告は、表示する変わりに警告が出るたびに呼び出されるサブルーチンへの
リファレンスを C<$SIG{__WARN__}> にセットすることで捕捉できます。
L<perlvar> を参照してください。

=begin original

Severe warnings are always enabled, unless they are explicitly disabled
with the C<warnings> pragma or the B<-X> switch.

=end original

C<warnings> プラグマか B<-X> オプションで明示的に無効にされない限り、
厳しい警告は常に有効です。

=begin original

Trappable errors may be trapped using the eval operator.  See
L<perlfunc/eval>.  In almost all cases, warnings may be selectively
disabled or promoted to fatal errors using the C<warnings> pragma.
See L<warnings>.

=end original

トラップ可能なエラーは評価演算子を使ってトラップできます。
L<perlfunc/eval> を参照してください。
ほとんど全ての場合、警告は C<warnings> プラグマを使うことで選択的に
無効にしたり致命的エラーに昇格させたりできます。
L<warnings> を参照してください。

=begin original

The messages are in alphabetical order, without regard to upper or
lower-case.  Some of these messages are generic.  Spots that vary are
denoted with a %s or other printf-style escape.  These escapes are
ignored by the alphabetical order, as are all characters other than
letters.  To look up your message, just ignore anything that is not a
letter.

=end original

メッセージは大文字小文字を無視してアルファベット順に並んでいます。
これらの中には一般的なものもあります。
変化する部分は %s またはその他の printf スタイルの表記をしています。
これらの表記や、その他の英文字以外の文字は並び順に関しては
無視されています。
メッセージを探すには、英文字以外は無視してください。

=over 4

=item accept() on closed socket %s

=begin original

(W closed) You tried to do an accept on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/accept>.

=end original

(W closed) クローズされたソケットに accept を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/accept> を参照してください。

=item Aliasing via reference is experimental

=begin original

(S experimental::refaliasing) This warning is emitted if you use
a reference constructor on the left-hand side of an assignment to
alias one variable to another.  Simply suppress the warning if you
want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be
removed in a future Perl version:

=end original

(S experimental::refaliasing) この警告は、ある変数を別の変数の別名とする代入の
左側でリファレンスコンストラクタを使うと出力されます。
この機能を使いたいけれども、そうすることで将来の Perl バージョンで
変更されるかもしれない実験的機能を使うリスクを取ることを分かっている場合は、
単に警告を抑制してください:

    no warnings "experimental::refaliasing";
    use feature "refaliasing";
    \$x = \$y;

=item Allocation too large: %x

=begin original

(X) You can't allocate more than 64K on an MS-DOS machine.

=end original

(X) MS-DOS マシンでは、64K を越えるメモリアロケートをおこなえません。

=item '%c' allowed only after types %s in %s

=begin original

(F) The modifiers '!', '<' and '>' are allowed in pack() or unpack() only
after certain types.  See L<perlfunc/pack>.

=end original

(F) pack() や unpack() での '!', '<', '>''!' の修飾子は特定のタイプの
後にのみつけることができます。
L<perlfunc/pack> を参照してください。

=item alpha->numify() is lossy

=begin original

(W numeric) An alpha version can not be numified without losing
information.

=end original

(W numeric) アルファバージョンは、情報を失うことなく数値化できません。

=item Ambiguous call resolved as CORE::%s(), qualify as such or use &

=begin original

(W ambiguous) A subroutine you have declared has the same name as a Perl
keyword, and you have used the name without qualification for calling
one or the other.  Perl decided to call the builtin because the
subroutine is not imported.

=end original

(W ambiguous) 定義したサブルーチンの名前が Perl のキーワードと同じで、
どちらかを呼び出すために修飾なしで名前を使っています。
Perl は、サブルーチンがインポートされたものではないので、組み込みのものを
呼び出すことにしました。

=begin original

To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the C<use subs> pragma).

=end original

サブルーチン呼び出しとして解釈することを強制させるためには、サブルーチン名の
前にアンパサンドをつけるか、名前をパッケージ名で修飾してください。
他の方法として、サブルーチンをインポートする(あるいは C<use subs>
プラグマを使ってインポートされたふりをする)方法もあります。

=begin original

To silently interpret it as the Perl operator, use the C<CORE::> prefix
on the operator (e.g. C<CORE::log($x)>) or declare the subroutine
to be an object method (see L<perlsub/"Subroutine Attributes"> or
L<attributes>).

=end original

警告なしに Perl 演算子として解釈させるためには、(C<CORE::log($x)> のように)
演算子に C<CORE::> 接頭辞をつけるか、サブルーチンをオブジェクト
メソッド(L<perlsub/"Subroutine Attributes"> や L<attributes> を
参照してください)として定義してください。

=item Ambiguous range in transliteration operator

=begin original

(F) You wrote something like C<tr/a-z-0//> which doesn't mean anything at
all.  To include a C<-> character in a transliteration, put it either
first or last.  (In the past, C<tr/a-z-0//> was synonymous with
C<tr/a-y//>, which was probably not what you would have expected.)

=end original

(F) C<tr/a-z-0//> のような、何の意味もないことをしようとしました。
文字変換の文字に C<-> を加える時は、最初か最後に置いてください。
(以前は C<tr/a-z-0//> は C<tr/a-y//> と同義でしたが、これはおそらく
予想していたものと違うでしょう。)

=item Ambiguous use of %s resolved as %s

=begin original

(S ambiguous) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.

=end original

(S ambiguous) 何か、あなたが考えているようには解釈できないものがありました。
普通は、不足しているクォート、演算子、かっこ、宣言を追加することでかなり
簡単にあいまいさを解消できます。

=item Ambiguous use of -%s resolved as -&%s()

=begin original

(S ambiguous) You wrote something like C<-foo>, which might be the
string C<"-foo">, or a call to the function C<foo>, negated.  If you meant
the string, just write C<"-foo">.  If you meant the function call,
write C<-foo()>.

=end original

(S ambiguous) C<-foo> のようなものを書きました; これは文字列 C<"-foo"> かも
知れませんし、関数 C<foo> を呼び出してその否定かも知れません。
文字列のつもりなら、単に C<"-foo"> と書いてください。
関数呼び出しのつもりなら、C<-foo()> と書いてください。

=item Ambiguous use of %c resolved as operator %c

=begin original

(S ambiguous) C<%>, C<&>, and C<*> are both infix operators (modulus,
bitwise and, and multiplication) I<and> initial special characters
(denoting hashes, subroutines and typeglobs), and you said something
like C<*foo * foo> that might be interpreted as either of them.  We
assumed you meant the infix operator, but please try to make it more
clear -- in the example given, you might write C<*foo * foo()> if you
really meant to multiply a glob by the result of calling a function.

=end original

(S ambiguous) C<%>, C<&>, C<*> は、中置演算子(剰余、ビット単位論理和、乗算)
I<および> 初期特殊文字(ハッシュ、サブルーチン、型グロブを示す)の
両方に使われますが、どちらとも解釈できる C<*foo * foo> のようなものが
書かれました。
これは中置演算子を意味していると仮定しますが、どうかより明確にするように
してください -- 上述の例では、もし本当にグロブと関数呼び出しの結果の
積を意味しているなら、C<*foo * foo()> と書けます。

=item Ambiguous use of %c{%s} resolved to %c%s

=begin original

(W ambiguous) You wrote something like C<@{foo}>, which might be
asking for the variable C<@foo>, or it might be calling a function
named foo, and dereferencing it as an array reference.  If you wanted
the variable, you can just write C<@foo>.  If you wanted to call the
function, write C<@{foo()}> ... or you could just not have a variable
and a function with the same name, and save yourself a lot of trouble.

=end original

(W ambiguous) C<@{foo}> のようなものを書きました; これは変数 C<@foo> のこと
かもしれませんし、foo という名前の関数を呼び出して、それを配列
リファレンスとしてデリファレンスするかもしれません。
もし変数がほしいなら、単に C<@foo> と書いてください。
関数を呼び出したいなら、C<@{foo()}> と書いてください…あるいは単に
変数と関数で同じ名前を使わないでください; これにより多くの問題から身を
守れます。

=item Ambiguous use of %c{%s[...]} resolved to %c%s[...]

=item Ambiguous use of %c{%s{...}} resolved to %c%s{...}

=begin original

(W ambiguous) You wrote something like C<${foo[2]}> (where foo represents
the name of a Perl keyword), which might be looking for element number
2 of the array named C<@foo>, in which case please write C<$foo[2]>, or you
might have meant to pass an anonymous arrayref to the function named
foo, and then do a scalar deref on the value it returns.  If you meant
that, write C<${foo([2])}>.

=end original

(W ambiguous) C<${foo[2]}> のようなものを書きました (ここで foo は Perl の
キーワード名を表します); これは C<@foo> という名前の配列の要素番号 2 を
探しているのかも知れません(その場合は C<$foo[2]> と書いてください)し、
foo という名前の関数に無名配列リファレンスを渡して、返り値をスカラ
デリファレンスしているのかも知れません。
それを意味しているなら、C<${foo([2])}> と書いてください。

=begin original

In regular expressions, the C<${foo[2]}> syntax is sometimes necessary
to disambiguate between array subscripts and character classes.
C</$length[2345]/>, for instance, will be interpreted as C<$length> followed
by the character class C<[2345]>.  If an array subscript is what you
want, you can avoid the warning by changing C</${length[2345]}/> to the
unsightly C</${\$length[2345]}/>, by renaming your array to something
that does not coincide with a built-in keyword, or by simply turning
off warnings with C<no warnings 'ambiguous';>.

=end original

正規表現の中で、C<${foo[2]}> 文法は配列添え字と文字クラスを区別するために
必要になります。
例えば、C</$length[2345]/> は、C<$length> に文字クラス C<[2345]> が
引き続くと解釈されます。
配列添え字が求めているものなら、C</${length[2345]}/> を
(見にくい) C</${\$length[2345]}/>と変更する、配列の名前を組み込みキーワードと
衝突しないものに変える、単に C<no warnings 'ambiguous';> として
警告をオフにする、のいずれかで警告を回避できます。

=item '|' and '<' may not both be specified on command line

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and found that STDIN was a pipe, and that you also tried to
redirect STDIN using '<'.  Only one STDIN stream to a customer, please.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、STDIN がパイプで
あることを発見しましたが、さらに '<' を使って STDIN をリダイレクトしようと
しました。
STDIN ストリームは一つだけにしてください; お願いします。

=item '|' and '>' may not both be specified on command line

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and thinks you tried to redirect stdout both to a file and
into a pipe to another command.  You need to choose one or the other,
though nothing's stopping you from piping into a program or Perl script
which 'splits' output into two streams, such as

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、STDOUT を
ファイルと他のコマンドへのパイプと両方にリダイレクトしようとしていると
判断しました。
どちらかを選ぶ必要がありますが、以下のように出力を二つのストリームに
「分割」するプログラムや Perl スクリプトにパイプすることを止めるものは
何もありません。

    open(OUT,">$ARGV[0]") or die "Can't write to $ARGV[0]: $!";
    while (<STDIN>) {
        print;
        print OUT;
    }
    close OUT;

=item Applying %s to %s will act on scalar(%s)

=begin original

(W misc) The pattern match (C<//>), substitution (C<s///>), and
transliteration (C<tr///>) operators work on scalar values.  If you apply
one of them to an array or a hash, it will convert the array or hash to
a scalar value (the length of an array, or the population info of a
hash) and then work on that scalar value.  This is probably not what
you meant to do.  See L<perlfunc/grep> and L<perlfunc/map> for
alternatives.

=end original

(W misc) パターンマッチ (C<//>), 置換 (C<s///>), 文字置換
(C<tr///>) 演算子はスカラ値に対して動作します。
これらを配列やハッシュに適用すると、配列やハッシュをスカラ値 (配列の長さか
ハッシュの大きさの情報) に変換し、そのスカラ値に対して動作します。
これはおそらくしたいこととは違うでしょう。
代替案については L<perlfunc/grep> と L<perlfunc/map> を参照してください。

=item Arg too short for msgsnd

=begin original

(F) msgsnd() requires a string at least as long as sizeof(long).

=end original

(F) msgsnd() に渡す文字列は、少なくとも sizeof(long) の長さが必要です。

=item Argument "%s" isn't numeric%s

=begin original

(W numeric) The indicated string was fed as an argument to an operator
that expected a numeric value instead.  If you're fortunate the message
will identify which operator was so unfortunate.

=end original

(W numeric) ここに示した文字列は、数値が必要な演算子の引数として、
与えられました。
運がよければ、このメッセージによって、どの演算子が問題となったかが
わかります。

=begin original

Note that for the C<Inf> and C<NaN> (infinity and not-a-number) the
definition of "numeric" is somewhat unusual: the strings themselves
(like "Inf") are considered numeric, and anything following them is
considered non-numeric.

=end original

Note that for the 
C<Inf> と C<NaN> (無限と非数) については、「数値」の定義が少し
変わっていることに注意してください:
("Inf" のような) これらの文字列自身は数値として扱われますが、それに
何かが引き続いている場合は非数値として扱われます。

=item Argument list not closed for PerlIO layer "%s"

=begin original

(W layer) When pushing a layer with arguments onto the Perl I/O
system you forgot the ) that closes the argument list.  (Layers
take care of transforming data between external and internal
representations.)  Perl stopped parsing the layer list at this
point and did not attempt to push this layer.  If your program
didn't explicitly request the failing operation, it may be the
result of the value of the environment variable PERLIO.

=end original

(W layer) Perl I/O システムに層を引数付きで追加するときに、引数リストを
閉じる ) を忘れています。
(層はデータの外部表現と内部表現の変換を扱います。)
Perl はここで層のリストのパースを中止し、この層の追加は行われませんでした。
明示的に失敗する操作を要求していないのであれば、これは環境変数 PERLIO の
値が原因かもしれません。

=item Argument "%s" treated as 0 in increment (++)

=begin original

(W numeric) The indicated string was fed as an argument to the C<++>
operator which expects either a number or a string matching
C</^[a-zA-Z]*[0-9]*\z/>.  See L<perlop/Auto-increment and
Auto-decrement> for details.

=end original

(W numeric) 数値または C</^[a-zA-Z]*[0-9]*\z/> にマッチングする文字列を
想定しているC<++> 演算子に、示された文字列が指定されました。
詳しくは L<perlop/Auto-increment and Auto-decrement> を参照してください。

=item Array passed to stat will be coerced to a scalar%s

=begin original

(W syntax) You called stat() on an array, but the array will be
coerced to a scalar - the number of elements in the array.

=end original

(W syntax) 配列に対して stat() が呼び出されましたが、配列は
スカラ - 配列の要素数 - に強制されました。

=item A signature parameter must start with '$', '@' or '%'

=begin original

(F) Each subroutine signature parameter declaration must start with a valid
sigil; for example:

=end original

(F) それぞれのサブルーチンシグネチャ引数宣言は、妥当な印で
始まらなければなりません; 例えば:

    sub foo ($a, $, $b = 1, @c) {}

=item A slurpy parameter may not have a default value

=begin original

(F) Only scalar subroutine signature parameters may have a default value;
for example:

=end original

(F) スカラサブルーチンシグネチャ引数のみがデフォルト値を持てます;
例えば:

    sub foo ($a = 1)        {} # legal
    sub foo (@a = (1))      {} # invalid
    sub foo (%a = (a => b)) {} # invalid

=item assertion botched: %s

=begin original

(X) The malloc package that comes with Perl had an internal failure.

=end original

(X) Perl に付属の malloc ルーティンが内部エラーを起こしました。

=item Assertion %s failed: file "%s", line %d

=begin original

(X) A general assertion failed.  The file in question must be examined.

=end original

(X) 一般的なアサーションが失敗しました。
問題の file を調べる必要があります。

=item Assigned value is not a reference

=begin original

(F) You tried to assign something that was not a reference to an lvalue
reference (e.g., C<\$x = $y>).  If you meant to make $x an alias to $y, use
C<\$x = \$y>.

=end original

(F) リファレンスでないものを左辺値リファレンスに代入しようとしました
(例: C<\$x = $y>)。
$x を $y の別名にすることを意図しているなら、C<\$x = \$y> を使ってください。

=item Assigned value is not %s reference

=begin original

(F) You tried to assign a reference to a reference constructor, but the
two references were not of the same type.  You cannot alias a scalar to
an array, or an array to a hash; the two types must match.

=end original

(F) あるリファレンスにリファレンスコンストラクタを代入しようとしましたが、
二つのリファレンスが同じ型ではありません。
スカラから配列への別名や配列からハッシュへの別名はできません;
二つの型は一致していなければなりません。

    \$x = \@y;  # error
    \@x = \%y;  # error
     $y = [];
    \$x = $y;   # error; did you mean \$y?

=item Assigning non-zero to $[ is no longer possible

=begin original

(F) When the "array_base" feature is disabled
(e.g., and under C<use v5.16;>, and as of Perl 5.30)
the special variable C<$[>, which is deprecated, is now a fixed zero value.

=end original

(F) (C<use v5.16;> のように、そして Perl 5.30 から) "array_base" 機能が
無効の場合、廃止予定である特殊変数 C<$[> は 0 固定です。

=item Assignment to both a list and a scalar

=begin original

(F) If you assign to a conditional operator, the 2nd and 3rd arguments
must either both be scalars or both be lists.  Otherwise Perl won't
know which context to supply to the right side.

=end original

(F) 条件演算子へ代入を行なう場合には、二つめの引数と、3 つめの引数は、
ともにスカラか、ともにリストでなければなりません。
そうでないと、Perl は右辺のコンテキストを決めることができません。

=item Assuming NOT a POSIX class since %s in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) You had something like these:

=end original

(W regexp) 次のようなことをしました:

 [[:alnum]]
 [[:digit:xyz]

=begin original

They look like they might have been meant to be the POSIX classes
C<[:alnum:]> or C<[:digit:]>.  If so, they should be written:

=end original

これらは、POSIX クラス C<[:alnum:]> や C<[:digit:]> を意味しようと
していたように見えます。
もしそうなら、次のように書くべきです:

 [[:alnum:]]
 [[:digit:]xyz]

=begin original

Since these aren't legal POSIX class specifications, but are legal
bracketed character classes, Perl treats them as the latter.  In the
first example, it matches the characters C<":">, C<"[">, C<"a">, C<"l">,
C<"m">, C<"n">, and C<"u">.

=end original

これらは有効な POSIX クラスしようではありませんが、有効な
大かっこ文字クラスなので、Perl これらを後者として扱います。
一つ目の例では、これは C<":">, C<"[">, C<"a">, C<"l">,
C<"m">, C<"n">, C<"u"> にマッチングします。

=begin original

If these weren't meant to be POSIX classes, this warning message is
spurious, and can be suppressed by reordering things, such as

=end original

これらが POSIX クラスを意味していないなら、この警告は誤りで、
次のように文字を入れ替えることで抑制できます:

 [[al:num]]

=begin original

or

=end original

または

 [[:munla]]

=item <> at require-statement should be quotes

=begin original

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

=end original

(F) C<require 'file'> と書くべきところで C<< require <file> >> と
書いています。

=item Attempt to access disallowed key '%s' in a restricted hash

=begin original

(F) The failing code has attempted to get or set a key which is not in
the current set of allowed keys of a restricted hash.

=end original

(F) 制限ハッシュで許されているキーの集合に含まれていないキーに対して
取得または設定しようとして失敗しました。

=item Attempt to bless into a freed package

=begin original

(F) You wrote C<bless $foo> with one argument after somehow causing
the current package to be freed.  Perl cannot figure out what to
do, so it throws up its hands in despair.

=end original

(F) 現在のパッケージが解放されるような何かが起きた後で 1 引数の
C<bless $foo> を書きました。
何がしたいのかが分からないので Perl はお手上げになりました。

=item Attempt to bless into a reference

=begin original

(F) The CLASSNAME argument to the bless() operator is expected to be
the name of the package to bless the resulting object into.  You've
supplied instead a reference to something: perhaps you wrote

=end original

(F) bless() 演算子の CLASSNAME 引数は結果のオブジェクトに bless する
パッケージ名を想定しています。
そこに何かへのリファレンスが与えられました:
おそらく以下のようにしたのでしょう:

    bless $self, $proto;

=begin original

when you intended

=end original

以下を意図していたはずです:

    bless $self, ref($proto) || $proto;

=begin original

If you actually want to bless into the stringified version
of the reference supplied, you need to stringify it yourself, for
example by:

=end original

実際に与えられたリファレンスを文字列化したものに bless したい場合は、
以下のようにして自分で文字列化する必要があります:

    bless $self, "$proto";

=item Attempt to clear deleted array

=begin original

(S debugging) An array was assigned to when it was being freed.
Freed values are not supposed to be visible to Perl code.  This
can also happen if XS code calls C<av_clear> from a custom magic
callback on the array.

=end original

(S debugging) 配列が、解放されるときに代入されました。
解放された値は Perl コードからは見えないはずです。
これはまた、XS コードが配列のカスタムマジックコールバックから
C<av_clear> を呼び出したときにも起こります。

=item Attempt to delete disallowed key '%s' from a restricted hash

=begin original

(F) The failing code attempted to delete from a restricted hash a key
which is not in its key set.

=end original

(F) 制限ハッシュで、キー集合に含まれていないキーから削除しようとしました。

=item Attempt to delete readonly key '%s' from a restricted hash

=begin original

(F) The failing code attempted to delete a key whose value has been
declared readonly from a restricted hash.

=end original

(F) 制限ハッシュで、読み込み専用として宣言されている値のキーを
削除しようとしました。

=item Attempt to free non-arena SV: 0x%x

=begin original

(S internal) All SV objects are supposed to be allocated from arenas
that will be garbage collected on exit.  An SV was discovered to be
outside any of those arenas.

=end original

(S internal) すべての SV オブジェクトは、exit 時にガーベジコレクションが
行なわれるアリーナに割り当てるようになっています。
ある SV が、そういったアリーナに入っていないことが、見つかりました。

=item Attempt to free nonexistent shared string '%s'%s

=begin original

(S internal) Perl maintains a reference-counted internal table of
strings to optimize the storage and access of hash keys and other
strings.  This indicates someone tried to decrement the reference count
of a string that can no longer be found in the table.

=end original

(S internal) Perl はストレージおよびハッシュキーとその他の文字列への
アクセスを最適化するために、文字列の参照数テーブルを管理しています。
これは誰かがもうテーブルにない文字列の参照カウントを減らそうとしたことを
示します。

=item Attempt to free temp prematurely: SV 0x%x

=begin original

(S debugging) Mortalized values are supposed to be freed by the
free_tmps() routine.  This indicates that something else is freeing the
SV before the free_tmps() routine gets a chance, which means that the
free_tmps() routine will be freeing an unreferenced scalar when it does
try to free it.

=end original

(S debugging) 消滅する値は、free_tmps() ルーティンで解放されるように
なっています。
このメッセージは、free_tmps() ルーティンの前に何ものかが、SV を
解放しようとしていることを示していて、これは、free_tmps() が
解放しようとしたときには、どこからも参照されていないスカラを
解放することになるということです。

=item Attempt to free unreferenced glob pointers

=begin original

(S internal) The reference counts got screwed up on symbol aliases.

=end original

(S internal) シンボルのエイリアスについて、参照カウントの値がおかしな
状態になりました。

=item Attempt to free unreferenced scalar: SV 0x%x

=begin original

(S internal) Perl went to decrement the reference count of a scalar to
see if it would go to 0, and discovered that it had already gone to 0
earlier, and should have been freed, and in fact, probably was freed.
This could indicate that SvREFCNT_dec() was called too many times, or
that SvREFCNT_inc() was called too few times, or that the SV was
mortalized when it shouldn't have been, or that memory has been
corrupted.

=end original

(S internal) Perl がスカラの参照カウントをデクリメントしようとして、0 に
なるかを見たところ、既に 0 になっていることがわかりました;
これは、既に解放されているべきものであり、実際は、おそらく、
解放されたものでしょう。
これは、SvREFCNT_dec() が必要以上に呼ばれたか、SvREFCNT_inc() が必要な
ときに呼ばれなかったか、SV が消滅すべきで無いときに消滅してしまったか、
メモリ異常になったことが考えられます。

=item Attempt to pack pointer to temporary value

=begin original

(W pack) You tried to pass a temporary value (like the result of a
function, or a computed expression) to the "p" pack() template.  This
means the result contains a pointer to a location that could become
invalid anytime, even before the end of the current statement.  Use
literals or global values as arguments to the "p" pack() template to
avoid this warning.

=end original

(W pack) (関数の結果や計算された式といった)一時的な値を pack() の
"p" テンプレートに渡そうとしました。
これは、たとえ現在の文の終了前でも、不正な値となり得ます。
この警告を避けるためには、pack テンプレート "p" の引数として、リテラルか
グローバルな値を使ってください。

=item Attempt to reload %s aborted.

=begin original

(F) You tried to load a file with C<use> or C<require> that failed to
compile once already.  Perl will not try to compile this file again
unless you delete its entry from %INC.  See L<perlfunc/require> and
L<perlvar/%INC>.

=end original

(F) 既に一度コンパイルに失敗しているファイルを C<use> や C<require> で
読み込もうとしました。
Perl は %INC からこのファイルのエントリを削除するまで再びファイルを
コンパイルしようとはしません。
L<perlfunc/require> と L<perlvar/%INC> を参照してください。

=item Attempt to set length of freed array

=begin original

(W misc) You tried to set the length of an array which has
been freed.  You can do this by storing a reference to the
scalar representing the last index of an array and later
assigning through that reference.  For example

=end original

(W misc) 既に解放された配列の長さを設定しようとしました。
配列の最後のインデックスを表現するスカラをリファレンスに保存して、
後でこのリファレンスを通して代入することでこれを行えます。
例えば:

    $r = do {my @a; \$#a};
    $$r = 503

=item Attempt to use reference as lvalue in substr

=begin original

(W substr) You supplied a reference as the first argument to substr()
used as an lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See L<perlfunc/substr>.

=end original

(W substr) 左辺値として使われる substr() の 1 番目の引数としてリファレンスを
渡しました; これはやや奇妙なことです。
おそらくはまずデリファレンスするのを忘れたのでしょう。
L<perlfunc/substr> を参照してください。

=item Attribute prototype(%s) discards earlier prototype attribute in same sub

=begin original

(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for
example.  Since each sub can only have one prototype, the earlier
declaration(s) are discarded while the last one is applied.

=end original

(W misc) あるサブルーチンが、例えば
sub foo : prototype(A) : prototype(B) {} のように宣言されました。
それぞれのサブルーチンは一つのプロトタイプしか持てないので、先に
宣言されたものは破棄され、最後のものが適用されます。

=item av_reify called on tied array

=begin original

(S debugging) This indicates that something went wrong and Perl got I<very>
confused about C<@_> or C<@DB::args> being tied.

=end original

(S debugging) これは、C<@_> や C<@DB::args> が tie されたことに関して何かが
うまくいかなくて Perl が I<とても> 混乱したことを示しています。

=item Bad arg length for %s, is %u, should be %d

=begin original

(F) You passed a buffer of the wrong size to one of msgctl(), semctl()
or shmctl().  In C parlance, the correct sizes are, respectively,
S<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)>, and
S<sizeof(struct shmid_ds *)>.

=end original

(F) msgctl()、semctl()、shmctl() のいずれかに、間違ったサイズのバッファを
渡してしまいました。
C の言い方で書くと、正しいサイズはそれぞれ、sizeof(struct msqid_ds *)、
sizeof(struct semid_ds *)、sizeof(struct shmid_ds *) です。

=item Bad evalled substitution pattern

=begin original

(F) You've used the C</e> switch to evaluate the replacement for a
substitution, but perl found a syntax error in the code to evaluate,
most likely an unexpected right brace '}'.

=end original

(F)置換のための置き換え文字列を評価するために C</e> オプションを指定して
いますが、評価するコードに文法エラーがありました;
最もありそうなことは、予期しない位置に右中かっこ '}' があったことです。

=item Bad filehandle: %s

=begin original

(F) A symbol was passed to something wanting a filehandle, but the
symbol has no filehandle associated with it.  Perhaps you didn't do an
open(), or did it in another package.

=end original

(F) ファイルハンドルが必要なものに、シンボルを渡しましたが、そのシンボルは、
それに伴うファイルハンドルがありません。
おそらく、open() を忘れたか、別のパッケージで open() したかでしょう。

=item Bad free() ignored

=begin original

(S malloc) An internal routine called free() on something that had never
been malloc()ed in the first place.  Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 0.

=end original

(S malloc) まず、malloc() されていないものに対して、内部ルーティンが
free() を呼びました。
強制ですが、環境変数 C<PERL_BADFREE> を 0 にすることで無効化できます。

=begin original

This message can be seen quite often with DB_File on systems with "hard"
dynamic linking, like C<AIX> and C<OS/2>.  It is a bug of C<Berkeley DB>
which is left unnoticed if C<DB> uses I<forgiving> system malloc().

=end original

このメッセージ は、C<AIX> や C<OS/2> のような、「ハード」動的リンクを
行うシステムで DB_File を使うとしばしば表示されます。
これは C<DB> がシステムの malloc() を許していることに気が付かない
C<Berkeley DB> のバグです。

=item Bad hash

=begin original

(P) One of the internal hash routines was passed a null HV pointer.

=end original

(P) 内部ハッシュルーティンで、ヌル HV ポインタを渡されたものがありました。

=item Badly placed ()'s

=begin original

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Bad name after %s

=begin original

(F) You started to name a symbol by using a package prefix, and then
didn't finish the symbol.  In particular, you can't interpolate outside
of quotes, so

=end original

(F) パッケージプレフィクスでシンボル名を書き始めましたが、そのシンボルが
終了しませんでした。
特に、クォートの外で、変数展開はできませんから、

    $var = 'myvar';
    $sym = mypack::$var;

=begin original

is not the same as

=end original

は、以下と同じではありません。

    $var = 'myvar';
    $sym = "mypack::$var";

=item Bad plugin affecting keyword '%s'

=begin original

(F) An extension using the keyword plugin mechanism violated the
plugin API.

=end original

(F) キーワードプラグイン機構を使っているエクステンションがプラグイン API に
違反しました。

=item Bad realloc() ignored

=begin original

(S malloc) An internal routine called realloc() on something that
had never been malloc()ed in the first place.  Mandatory, but can
be disabled by setting the environment variable C<PERL_BADFREE> to 1.

=end original

(S malloc) 内部ルーチンが、最初に malloc() されていない何かに対して
realloc() を呼び出しました。
必須ですが、環境変数 C<PERL_BADFREE> に 1 をセットすることで無効化できます。

=item Bad symbol for array

=begin original

(P) An internal request asked to add an array entry to something that
wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、配列エントリを登録するような
内部要求があがりました。

=item Bad symbol for dirhandle

=begin original

(P) An internal request asked to add a dirhandle entry to something
that wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、ディレクトリハンドルエントリを
登録するような内部要求があがりました。

=item Bad symbol for filehandle

=begin original

(P) An internal request asked to add a filehandle entry to something
that wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、ファイルハンドルエントリを
登録するような内部要求があがりました。

=item Bad symbol for hash

=begin original

(P) An internal request asked to add a hash entry to something that
wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、ハッシュエントリを
登録するような内部要求があがった。

=item Bad symbol for scalar

=begin original

(P) An internal request asked to add a scalar entry to something that
wasn't a symbol table entry.

=end original

(P) 内部で、シンボルテーブルエントリでないものに対してスカラエントリを
追加するよう要求がありました。

=item Bareword found in conditional

=begin original

(W bareword) The compiler found a bareword where it expected a
conditional, which often indicates that an || or && was parsed as part
of the last argument of the previous construct, for example:

=end original

(W bareword) コンパイラが、条件が想定される位置に裸の単語を発見しました;
これはしばしば、|| や && が直前の構造の最後の引数の一部として
パースされたことを意味します; 例えば:

    open FOO || die;

=begin original

It may also indicate a misspelled constant that has been interpreted as
a bareword:

=end original

これはまた、裸の単語として解釈されるような定数をタイプミスしたことを
示している場合もあります:

    use constant TYPO => 1;
    if (TYOP) { print "foo" }

=begin original

The C<strict> pragma is useful in avoiding such errors.

=end original

C<strict> プラグマはこのようなエラーを防ぐのに便利です。

=item Bareword in require contains "%s"

=item Bareword in require maps to disallowed filename "%s"

=item Bareword in require maps to empty filename

=begin original

(F) The bareword form of require has been invoked with a filename which could
not have been generated by a valid bareword permitted by the parser.  You
shouldn't be able to get this error from Perl code, but XS code may throw it
if it passes an invalid module name to C<Perl_load_module>.

=end original

(F) 裸の単語形式の require は、パーサによって許された妥当な裸の単語によって
生成することができないファイル名で起動されました。
このエラーを Perl コードから得るようにできるべきではありませんが、
C<Perl_load_module> に不正なモジュール名を渡した XS コードは
これを投げるかもしれません。

=item Bareword in require must not start with a double-colon: "%s"

=begin original

(F) In C<require Bare::Word>, the bareword is not allowed to start with a
double-colon.  Write C<require ::Foo::Bar> as  C<require Foo::Bar> instead.

=end original

(F) C<require Bare::Word> で、裸の単語はダブルコロンから
開始することはできません。
C<require ::Foo::Bar> ではなく C<require Foo::Bar> と書いてください。

=item Bareword "%s" not allowed while "strict subs" in use

=begin original

(F) With "strict subs" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the "=>"
symbol.  Perhaps you need to predeclare a subroutine?

=end original

"strict subs" が有効の場合、裸の単語はサブルーチンの識別子、中かっこの中、
シンボル "=>" の左側でのみ許されます。
おそらくサブルーチンを先行宣言する必要があるのでは?

=item Bareword "%s" refers to nonexistent package

=begin original

(W bareword) You used a qualified bareword of the form C<Foo::>, but the
compiler saw no other uses of that namespace before that point.  Perhaps
you need to predeclare a package?

=end original

(W bareword) C<Foo::> の形で修飾された裸の単語が使われていますが、
コンパイラはこの場所以外でこの名前空間が使われている場所を
発見できませんでした。
おそらくパッケージを専攻宣言する必要があるのでは?

=item BEGIN failed--compilation aborted

=begin original

(F) An untrapped exception was raised while executing a BEGIN
subroutine.  Compilation stops immediately and the interpreter is
exited.

=end original

(F) BEGIN サブルーチンの実行中にトラップ不可能な例外が発生しました。
コンパイルは即座に停止し、インタプリタは中止します。

=item BEGIN not safe after errors--compilation aborted

=begin original

(F) Perl found a C<BEGIN {}> subroutine (or a C<use> directive, which
implies a C<BEGIN {}>) after one or more compilation errors had already
occurred.  Since the intended environment for the C<BEGIN {}> could not
be guaranteed (due to the errors), and since subsequent code likely
depends on its correct operation, Perl just gave up.

=end original

(F) Perl は既にコンパイルエラーが発生した後に C<BEGIN {}> サブルーチン
(または C<use> 指示子(これは C<BEGIN {}> を暗示します))を発見しました。
C<BEGIN {}> が意図した環境は(エラーのために)保証されず、引き続くコードは
正しい処理に依存していると考えられるので、Perl は単に諦めました。

=item \%d better written as $%d

=begin original

(W syntax) Outside of patterns, backreferences live on as variables.
The use of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if
there are more than 9 backreferences.

=end original

(W syntax) パターンの外では、後方参照は変数の形で存在します。
後方参照の利用は、置換の右側の部分で扱われますが、スタイル的には、他の
Perl プログラマが期待し、9 個以上の後方参照があるときにもうまく動作する、
変数形式を使う方が良いでしょう。

=item Binary number > 0b11111111111111111111111111111111 non-portable

=begin original

(W portable) The binary number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=end original

(W portable) 指定された 2 進数が 2**32-1 (4294967295) を越えるので、
システム間での移植性がありません。
移植性に関するさらなる考察については L<perlport> を参照してください。

=item bind() on closed socket %s

=begin original

(W closed) You tried to do a bind on a closed socket.  Did you forget to
check the return value of your socket() call?  See L<perlfunc/bind>.

=end original

(W closed) クローズされたソケットに bind を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/bind> を参照してください。

=item binmode() on closed filehandle %s

=begin original

(W unopened) You tried binmode() on a filehandle that was never opened.
Check your control flow and number of arguments.

=end original

(W unopened) 開いていないファイルハンドルに binmode() を使おうとしました。
制御フローと引数の数をチェックしてください。

=item Bit vector size > 32 non-portable

=begin original

(W portable) Using bit vector sizes larger than 32 is non-portable.

=end original

(W portable) 32 を越えるサイズのビットベクタは移植性がありません。

=item Bizarre copy of %s

=begin original

(P) Perl detected an attempt to copy an internal value that is not
copiable.

=end original

(P) コピーできない内部の値をコピーしようとしました。

=item Bizarre SvTYPE [%d]

=begin original

(P) When starting a new thread or returning values from a thread, Perl
encountered an invalid data type.

=end original

(P) 新しいスレッドを始めたりスレッドから値を返したときに、Perl は不正な
データ型に遭遇しました。

=item Both or neither range ends should be Unicode in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

=end original

(W regexp) (C<S<use re 'strict'>> の基か C<(?[...])> の内側のみ)

=begin original

In a bracketed character class in a regular expression pattern, you
had a range which has exactly one end of it specified using C<\N{}>, and
the other end is specified using a non-portable mechanism.  Perl treats
the range as a Unicode range, that is, all the characters in it are
considered to be the Unicode characters, and which may be different code
points on some platforms Perl runs on.  For example, C<[\N{U+06}-\x08]>
is treated as if you had instead said C<[\N{U+06}-\N{U+08}]>, that is it
matches the characters whose code points in Unicode are 6, 7, and 8.
But that C<\x08> might indicate that you meant something different, so
the warning gets raised.

=end original

正規表現中の大かっこ文字クラスの中で、範囲指定の片方は C<\N{}> を使って
指定し、もう片方は移植性のない方法を使って指定しました。
Perl はこの範囲を Unicode の範囲として扱います; つまり、その中の全ての文字は
Unicode 文字として扱われ、Perl が実行される一部のプラットフォームでは
異なる符号位置になるかもしれません。
例えば、C<[\N{U+06}-\x08]> は、C<[\N{U+06}-\N{U+08}]> と
書いたかのように扱われ、Unicode の符号位置 6, 7, 8 の文字にマッチングします。
しかし、C<\x08> はなにか違うことを意味していることを示しているので、
警告が発生します。

=item Buffer overflow in prime_env_iter: %s

=begin original

(W internal) A warning peculiar to VMS.  While Perl was preparing to
iterate over %ENV, it encountered a logical name or symbol definition
which was too long, so it was truncated to the string shown.

=end original

(W internal) VMS に固有の警告です。
Perl が %ENV を反復する準備中、長すぎる論理名かシンボル定義に遭遇したので、
文字列は表示したように切り詰められました。

=item Callback called exit

=begin original

(F) A subroutine invoked from an external package via call_sv()
exited by calling exit.

=end original

(F) 外部パッケージから call_sv() で起動されたサブルーチンが exit を呼んで
終了しました。

=item %s() called too early to check prototype

=begin original

(W prototype) You've called a function that has a prototype before the
parser saw a definition or declaration for it, and Perl could not check
that the call conforms to the prototype.  You need to either add an
early prototype declaration for the subroutine in question, or move the
subroutine definition ahead of the call to get proper prototype
checking.  Alternatively, if you are certain that you're calling the
function correctly, you may put an ampersand before the name to avoid
the warning.  See L<perlsub>.

=end original

(W prototype) 以前にパーサが宣言または定義されているのを見た、
プロトタイプ付きの関数を呼び出しましたが、Perl は呼び出しがプロトタイプに
従っているかどうかをチェックできませんでした。
問題になっているサブルーチンのプロトタイプ宣言を最初の方に追加するか、
適切なプロトタイプチェックを行うためにサブルーチン定義を呼び出しの前に
移動させる必要があります。
または、関数を正しく呼び出していることが確かな場合は、名前の前に
アンパサンドを付けることで警告を回避できます。
L<perlsub> を参照してください。

=item Cannot chr %f

=begin original

(F) You passed an invalid number (like an infinity or not-a-number) to C<chr>.

=end original

(F) (無限や非数のような) 不正な数値を C<chr> に渡しました。

=item Cannot complete in-place edit of %s: %s

=begin original

(F) Your perl script appears to have changed directory while
performing an in-place edit of a file specified by a relative path,
and your system doesn't include the directory relative POSIX functions
needed to handle that.

=end original

(F) perl スクリプトが、相対パスで指定されたファイルのその場編集を
実行中にディレクトリを変更し、システムにはこれに対応するために必要な
ディレクトリ相対 POSIX 関数がないようです。

=item Cannot compress %f in pack

=begin original

(F) You tried compressing an infinity or not-a-number as an unsigned
integer with BER, which makes no sense.

=end original

(F) 無限や非数を BER で符号なし整数に圧縮しようとしました; これは無意味です。

=item Cannot compress integer in pack

=begin original

(F) An argument to pack("w",...) was too large to compress.
The BER compressed integer format can only be used with positive
integers, and you attempted to compress a very large number (> 1e308).
See L<perlfunc/pack>.

=end original

(F) pack("w",...) の引数が、圧縮するには大きすぎます。
BER 圧縮整数フォーマットは正の整数のみ扱えますが、とても大きい数
(> 1e308) を圧縮しようとしました。
L<perlfunc/pack> を参照してください。

=item Cannot compress negative numbers in pack

=begin original

(F) An argument to pack("w",...) was negative.  The BER compressed integer
format can only be used with positive integers.  See L<perlfunc/pack>.

=end original

(F) pack("w",...) の引数が負数です。
BER 圧縮整数フォーマットは正の整数のみ扱えます。
L<perlfunc/pack> を参照してください。

=item Cannot convert a reference to %s to typeglob

=begin original

(F) You manipulated Perl's symbol table directly, stored a reference
in it, then tried to access that symbol via conventional Perl syntax.
The access triggers Perl to autovivify that typeglob, but it there is
no legal conversion from that type of reference to a typeglob.

=end original

(F) あなたは Perl のシンボルテーブルを直接操作して、リファレンスをその中に
補完し、それからそのシンボルを伝統的な Perl の文法のよって
アクセスしようとしました。
このアクセスによって、Perl はこの型グロブを自動有効化しますが、
リファレンス型から型グロブへの正当な変換方法はありません。

=item Cannot copy to %s

=begin original

(P) Perl detected an attempt to copy a value to an internal type that cannot
be directly assigned to.

=end original

(P) Perl が、直接代入できない内部型に値をコピーしようとする試みを
検出しました。

=item Cannot find encoding "%s"

=begin original

(S io) You tried to apply an encoding that did not exist to a filehandle,
either with open() or binmode().

=end original

(S io) open() または binmode() のファイルハンドルに存在しない
エンコーディングを適用しようとしました。

=item Cannot open %s as a dirhandle: it is already open as a filehandle

=begin original

(F) You tried to use opendir() to associate a dirhandle to a symbol (glob
or scalar) that already holds a filehandle.  Since this idiom might render
your code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it
is a fatal error.

=end original

(F) すでにファイルハンドルを保持しているシンボル
(グロブまたはスカラ)にディレクトリハンドルを関連付けるために
opendir() を使おうとしました。
この用法はコードを間違えて解釈する可能性があるので、
Perl 5.10 で廃止予定になりました。
Perl 5.28 から、これは致命的エラーです。

=item Cannot open %s as a filehandle: it is already open as a dirhandle

=begin original

(F) You tried to use open() to associate a filehandle to a symbol (glob
or scalar) that already holds a dirhandle.  Since this idiom might render
your code confusing, it was deprecated in Perl 5.10.  As of Perl 5.28, it
is a fatal error.

=end original

(F) すでにディレクトリハンドルを保持しているシンボル
(グロブまたはスカラ)にファイルハンドルを関連付けるために
open() を使おうとしました。
この用法はコードを間違えて解釈する可能性があるので、
Perl 5.10 で廃止予定になりました。
Perl 5.28 から、これは致命的エラーです。

=item Cannot pack %f with '%c'

=begin original

(F) You tried converting an infinity or not-a-number to an integer,
which makes no sense.

=end original

(F) 無限や非数を整数に変換しようとしました; これは無意味です。

=item Cannot printf %f with '%c'

=begin original

(F) You tried printing an infinity or not-a-number as a character (%c),
which makes no sense.  Maybe you meant '%s', or just stringifying it?

=end original

(F) 無限や非数を文字 (%c) として表示しようとしました; これは無意味です。
おそらく '%s' か、単に文字列化したかったのでは?

=item Cannot set tied @DB::args

=begin original

(F) C<caller> tried to set C<@DB::args>, but found it tied.  Tying C<@DB::args>
is not supported.  (Before this error was added, it used to crash.)

=end original

(F) C<caller> は C<@DB::args> を設定しようとしましたが、tie されていました。
C<@DB::args> の tie は非対応です。
(このエラーが追加する前は、クラッシュしていました。)

=item Cannot tie unreifiable array

=begin original

(P) You somehow managed to call C<tie> on an array that does not
keep a reference count on its arguments and cannot be made to
do so.  Such arrays are not even supposed to be accessible to
Perl code, but are only used internally.

=end original

(P) 参照カウントを保持していない配列を引数にして C<tie> を
呼び出そうとしましたがそうできませんでした。
このような配列は Perl コードからアクセスできると想定してはならず、
内部だけで使われます。

=item Cannot yet reorder sv_vcatpvfn() arguments from va_list

=begin original

(F) Some XS code tried to use C<sv_vcatpvfn()> or a related function with a
format string that specifies explicit indexes for some of the elements, and
using a C-style variable-argument list (a C<va_list>).  This is not currently
supported.  XS authors wanting to do this must instead construct a C array
of C<SV*> scalars containing the arguments.

=end original

(F) 一部の XS コードは、要素の一部の明示的なインデックスを指定した
フォーマット文字列を使って C<sv_vcatpvfn()> や関連する関数を使おうとして、
C 形式の可変引数リスト (C<va_list>) を使っています。
これは現在のところ対応していません。
これをしたい XS 作者は代わりに、引数を含む
C<SV*> スカラの C 配列を構築しなければなりません。

=item Can only compress unsigned integers in pack

=begin original

(F) An argument to pack("w",...) was not an integer.  The BER compressed
integer format can only be used with positive integers, and you attempted
to compress something else.  See L<perlfunc/pack>.

=end original

(F) pack("w",...) の引数が整数ではありません。
BER 圧縮整数フォーマットは正の整数のみ扱えますが、何か他のものを
圧縮しようとしました。
L<perlfunc/pack> を参照してください。

=item Can't bless non-reference value

=begin original

(F) Only hard references may be blessed.  This is how Perl "enforces"
encapsulation of objects.  See L<perlobj>.

=end original

(F) ハードリファレンスのみが bless できます。
これによって、Perl はオブジェクトのカプセル化を「強制」します。
L<perlobj> を参照してください。

=item Can't "break" in a loop topicalizer

=begin original

(F) You called C<break>, but you're in a C<foreach> block rather than
a C<given> block.  You probably meant to use C<next> or C<last>.

=end original

(F) C<break> を呼び出しましたが、C<given> ブロックではなく C<foreach>
ブロック内でした。
おそらく C<next> や C<last> を使いたかったのでしょう。

=item Can't "break" outside a given block

=begin original

(F) You called C<break>, but you're not inside a C<given> block.

=end original

(F) C<break> を呼び出しましたが、C<given> ブロックの内側ではありません。

=item Can't call method "%s" on an undefined value

=begin original

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an undefined value.  Something
like this will reproduce the error:

=end original

(F) メソッド呼び出しの文法が使われていますが、オブジェクトリファレンスか
パッケージ名であるべきところが未定義値です。
以下のように書くとエラーが再現します:

    $BADREF = undef;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't call method "%s" on unblessed reference

=begin original

(F) A method call must know in what package it's supposed to run.  It
ordinarily finds this out from the object reference you supply, but you
didn't supply an object reference in this case.  A reference isn't an
object reference until it has been blessed.  See L<perlobj>.

=end original

(F) メソッド呼び出しは、自分が呼び出されたパッケージがどれであるかを
知る必要があります。　普通は、渡したオブジェクトリファレンスから
その情報を受け取りますが、この場合にはオブジェクトリファレンスが
渡されませんでした。
リファレンスは、bless されて始めて、オブジェクトリファレンスとなります。
L<perlobj> を参照してください。

=item Can't call method "%s" without a package or object reference

=begin original

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an expression that returns a
defined value which is neither an object reference nor a package name.
Something like this will reproduce the error:

=end original

(F) メソッド呼び出しの構文を用いましたが、オブジェクトリファレンス、
もしくはパッケージ名が書かれるべき場所に、オブジェクトリファレンスも
パッケージ名も返さない定義された式が書かれています。
以下のように書くとエラーが再現します:

    $BADREF = 42;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't call mro_isa_changed_in() on anonymous symbol table

=begin original

(P) Perl got confused as to whether a hash was a plain hash or a
symbol table hash when trying to update @ISA caches.

=end original

(P) @ISA キャッシュを更新しようとしたときに、ハッシュが普通のハッシュか
シンボルテーブルハッシュかについて perl は混乱しました。

=item Can't call mro_method_changed_in() on anonymous symbol table

=begin original

(F) An XS module tried to call C<mro_method_changed_in> on a hash that was
not attached to the symbol table.

=end original

(F) XS モジュールが、シンボルテーブルにアタッチされていないハッシュに対して
C<mro_method_changed_in> を呼び出しました。

=item Can't chdir to %s

=begin original

(F) You called C<perl -x/foo/bar>, but F</foo/bar> is not a directory
that you can chdir to, possibly because it doesn't exist.

=end original

(F) C<perl -x/foo/bar> のようにして起動しましたが、F</foo/bar> に
chdir することができません; おそらく、存在しないのではないでしょうか。

=item Can't check filesystem of script "%s" for nosuid

=begin original

(P) For some reason you can't check the filesystem of the script for
nosuid.

=end original

(P) なぜかスクリプトが nosuid かどうかをファイルシステムから
調べることができません。

=item Can't coerce %s to %s in %s

=begin original

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.  So you can't
say things like:

=end original

(F) ある種の SV、特に本物のシンボルテーブルエントリ (型グロブ) は、
一つの型に留めておくことができません。
したがって、以下のようにすることはできません:

    *foo += 1;

=begin original

You CAN say

=end original

以下のようにはできますが:

    $foo = *foo;
    $foo += 1;

=begin original

but then $foo no longer contains a glob.

=end original

$foo にはもはやグロブは残っていません。

=item Can't "continue" outside a when block

=begin original

(F) You called C<continue>, but you're not inside a C<when>
or C<default> block.

=end original

(F) C<continue> を呼び出しましたが、C<when> か C<default> のブロックの
内側ではありません。

=item Can't create pipe mailbox

=begin original

(P) An error peculiar to VMS.  The process is suffering from exhausted
quotas or other plumbing problems.

=end original

(P) VMS に固有のエラーです。
プロセスはクォータを使い切ったか、その他の設備問題の影響を受けました。

=item Can't declare %s in "%s"

=begin original

(F) Only scalar, array, and hash variables may be declared as "my", "our" or
"state" variables.  They must have ordinary identifiers as names.

=end original

(F) スカラ変数、配列変数、ハッシュ変数だけが、"my", "our", "state" 変数として
宣言できます。
これらは、名前として通常の識別子を持たなければなりません。

=item Can't "default" outside a topicalizer

=begin original

(F) You have used a C<default> block that is neither inside a
C<foreach> loop nor a C<given> block.  (Note that this error is
issued on exit from the C<default> block, so you won't get the
error if you use an explicit C<continue>.)

=end original

(F) C<foreach> ループや C<given> ブロックの内側でないところで
C<default> ブロックを使いました。
(このエラーは C<default> ブロックから出るときに発生するので、明示的な
C<continue> を使うとエラーは発生しません。)

=item Can't determine class of operator %s, assuming BASEOP

=begin original

(S) This warning indicates something wrong in the internals of perl.
Perl was trying to find the class (e.g. LISTOP) of a particular OP,
and was unable to do so. This is likely to be due to a bug in the perl
internals, or due to a bug in XS code which manipulates perl optrees.

=end original

(S) この警告は、perl の内部で何かがおかしいことを示しています。
Perl は (LISTOP のような) 特定の OP のクラスを見つけようとして、
そうすることができませんでした。
これはおそらく perl 内部のバグによるものか、perl の op 木を操作する
XS コードのバグによるものです。

=item Can't do inplace edit: %s is not a regular file

=begin original

(S inplace) You tried to use the B<-i> switch on a special file, such as
a file in /dev, a FIFO or an uneditable directory.  The file was ignored.

=end original

(S inplace) /dev, FIFO, 変更できないディレクトリのような、特殊ファイルに対して
B<-i> スイッチを使おうとしました。
このファイルは無視されます。

=item Can't do inplace edit on %s: %s

=begin original

(S inplace) The creation of the new file failed for the indicated
reason.

=end original

(S inplace) 表示された理由により、新しいファイルの生成に失敗しました。

=item Can't do inplace edit: %s would not be unique

=begin original

(S inplace) Your filesystem does not support filenames longer than 14
characters and Perl was unable to create a unique filename during
inplace editing with the B<-i> switch.  The file was ignored.

=end original

(S inplace) ファイルシステムが 14 文字より長いファイル名に対応しておらず、
Perl は B<-i> オプションによるその場編集の間のユニークなファイル名の
作成ができませんでした。
このファイルは無視されます。

=item Can't do %s("%s") on non-UTF-8 locale; resolved to "%s".

=begin original

(W locale) You are 1) running under "C<use locale>"; 2) the current
locale is not a UTF-8 one; 3) you tried to do the designated case-change
operation on the specified Unicode character; and 4) the result of this
operation would mix Unicode and locale rules, which likely conflict.
Mixing of different rule types is forbidden, so the operation was not
done; instead the result is the indicated value, which is the best
available that uses entirely Unicode rules.  That turns out to almost
always be the original character, unchanged.

=end original

(W locale) あなたは 1) "C<use locale>" の基で実行していて;
2) 現在のロケールは UTF-8 ではなく;
3) 特定の Unicode 文字に指定された大文字小文字変換をしようとして;
4) この操作の結果、おそらく衝突する、Unicode とロケールの規則を混ぜました。
異なる種類の規則を混ぜるのは禁止されているので、この操作は行われません;
代わりに結果は示された値になります; これは全体的に Unicode の規則を
使うという、最も利用可能なものです。
これは、ほとんど常に、元の文字を変更しないままにします。

=begin original

It is generally a bad idea to mix non-UTF-8 locales and Unicode, and
this issue is one of the reasons why.  This warning is raised when
Unicode rules would normally cause the result of this operation to
contain a character that is in the range specified by the locale,
0..255, and hence is subject to the locale's rules, not Unicode's.

=end original

非 UTF-8 ロケールと Unicode を混ぜるのは一般的に悪い考えで、
この問題はその理由の一つです。
この警告は、Unicode の規則が、ロケールで指定された範囲 0..255 である文字を
含むこの操作の結果を通常引き起こし、結果として Unicode ではなくロケールの
規則を想定される場合に発生します。

=begin original

If you are using locale purely for its characteristics related to things
like its numeric and time formatting (and not C<LC_CTYPE>), consider
using a restricted form of the locale pragma (see L<perllocale/The "use
locale" pragma>) like "S<C<use locale ':not_characters'>>".

=end original

ロケールを、純粋に数値や時刻形式のようなものに関連する特徴だけに
使っている (そして C<LC_CTYPE> は使っていない)場合、
"S<C<use locale ':not_characters'>>" のような、locale プラグマの制限された
形式 (L<perllocale/The "use locale" pragma> 参照) を使うことを
検討してください。

=begin original

Note that failed case-changing operations done as a result of
case-insensitive C</i> regular expression matching will show up in this
warning as having the C<fc> operation (as that is what the regular
expression engine calls behind the scenes.)

=end original

大文字小文字無視 C</i> 正規表現マッチングの結果として
大文字小文字変換操作が失敗した場合、この警告は
C<fc> 操作に対して出力されることに注意してください
(正規表現エンジンが裏でこれを使っているからです)。

=item Can't do waitpid with flags

=begin original

(F) This machine doesn't have either waitpid() or wait4(), so only
waitpid() without flags is emulated.

=end original

(F) このマシンには、waitpid() も wait4() もありませんので、
フラグの無い waitpid() のみがエミュレート可能です。

=item Can't emulate -%s on #! line

=begin original

(F) The #! line specifies a switch that doesn't make sense at this
point.  For example, it'd be kind of silly to put a B<-x> on the #!
line.

=end original

(F) #! 行にその時点で意味をなさないスイッチが指定されました。
たとえば、#! 行に B<-x> をおいても意味がありません。

=item Can't %s %s-endian %ss on this platform

=begin original

(F) Your platform's byte-order is neither big-endian nor little-endian,
or it has a very strange pointer size.  Packing and unpacking big- or
little-endian floating point values and pointers may not be possible.
See L<perlfunc/pack>.

=end original

(F) プラットフォームのバイト順序がビッグエンディアンでも
リトルエンディアンでもないか、ポインタサイズがとても変わっています。
ビッグエンディアンやリトルエンディアンの不動小数点数やポインタの
pack や unpack はできません。
L<perlfunc/pack> を参照してください。

=item Can't exec "%s": %s

=begin original

(W exec) A system(), exec(), or piped open call could not execute the
named program for the indicated reason.  Typical reasons include: the
permissions were wrong on the file, the file wasn't found in
C<$ENV{PATH}>, the executable in question was compiled for another
architecture, or the #! line in a script points to an interpreter that
can't be run for similar reasons.  (Or maybe your system doesn't support
#! at all.)

=end original

(W exec) 提示した理由によって、system() や exec() やパイプオープン
呼び出しの指定されたプログラムが実行できませんでした。
考えられる理由には: ファイルのパーミッションが間違っている、
ファイルが C<$ENV{PATH}> の中にない、問題の実行ファイルが
このマシン用ではない、スクリプトの #! 行が同じような理由で実行できない
インタプリタを指している、というようなものがあります。
(あるいは、このシステムで、#! がサポートされていません。)

=item Can't exec %s

=begin original

(F) Perl was trying to execute the indicated program for you because
that's what the #! line said.  If that's not what you wanted, you may
need to mention "perl" on the #! line somewhere.

=end original

(F) #! 行に書かれた内容にしたがって、Perl は示されたプログラムを
実行しようとしました。
そうしたくないのであれば、#! 行のどこかに、"perl" と書いておいてください。

=item Can't execute %s

=begin original

(F) You used the B<-S> switch, but the copies of the script to execute
found in the PATH did not have correct permissions.

=end original

(F) B<-S> スイッチを使いましたが、PATH に見つかった実行するスクリプトが
正しいパーミッションではありませんでした。

=item Can't find an opnumber for "%s"

=begin original

(F) A string of a form C<CORE::word> was given to prototype(), but there
is no builtin with the name C<word>.

=end original

(F) C<CORE::word> の形の文字列が prototype() に与えられましたが、
名前 C<word> は組み込みではありません。

=item Can't find label %s

=begin original

(F) You said to goto a label that isn't mentioned anywhere that it's
possible for us to go to.  See L<perlfunc/goto>.

=end original

(F) どこにも見つからないラベルへ goto を行なおうとしました。
L<perlfunc/goto> を参照してください。

=item Can't find %s on PATH

=begin original

(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH.

=end original

B<-S> オプションを使いましたが、実行するスクリプトは PATH に
見つかりませんでした。

=item Can't find %s on PATH, '.' not in PATH

=begin original

(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH, or at least not with the correct permissions.  The
script exists in the current directory, but PATH prohibits running it.

=end original

(F) B<-S> オプションが使われましたが、 PATH に実行するスクリプトが
見つからないか、少なくとも適切なパーミッションがありません。
スクリプトはカレントディレクトリにはありますが、PATH に
カレントディレクトリは含まれていません。

=item Can't find string terminator %s anywhere before EOF

=begin original

(F) Perl strings can stretch over multiple lines.  This message means
that the closing delimiter was omitted.  Because bracketed quotes count
nesting levels, the following is missing its final parenthesis:

=end original

(F) Perl の文字列は、複数行に渡ることができます。このメッセージは、
文字列を終わる区切り文字が見つからなかったことを意味します。
かっこ類の区切り文字では、ネストを数えるので、以下では、最後のかっこが
無いと言われます:

    print q(The character '(' starts a side comment.);

=begin original

If you're getting this error from a here-document, you may have
included unseen whitespace before or after your closing tag or there
may not be a linebreak after it.  A good programmer's editor will have
a way to help you find these characters (or lack of characters).  See
L<perlop> for the full details on here-documents.

=end original

このエラーがヒアドキュメントで起きた場合、閉じタグの前か後に
見えない空白を含んでいるか、その後に改行がないのかもしれません。
よいプログラマ用エディタには、このような文字(または文字がないこと)を探す
助けになる方法があります。
ヒアドキュメントに関する完全な詳細については L<perlop> を参照してください。

=item Can't find Unicode property definition "%s"

=item Can't find Unicode property definition "%s" in regex; marked by <-- HERE in m/%s/

=begin original

(F) The named property which you specified via C<\p> or C<\P> is not one
known to Perl.  Perhaps you misspelled the name?  See
L<perluniprops/Properties accessible through \p{} and \P{}>
for a complete list of available official
properties.  If it is a
L<user-defined property|perlunicode/User-Defined Character Properties>
it must have been defined by the time the regular expression is
matched.

=end original

(F)
C<\p> や C<\P> で指定した名前付き特性は Perl が知らないものです。
おそらく名前をタイプミスしたのでは?
公式に利用可能な特性の完全な一覧については
L<perluniprops/Properties accessible through \p{} and \P{}> を
参照してください。
これが L<ユーザー定義特性|perlunicode/User-Defined Character Properties> の
場合は、正規表現がマッチングした時点で定義されていなければなりません。

=begin original

If you didn't mean to use a Unicode property, escape the C<\p>, either
by C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, or
until C<\E>).

=end original

Unicode 特性を使うつもりでない場合は、C<\\p> (単に C<\p>) または
C<\Q\p> (残りの文字列 または C<\E> まで) を使って C<\p> を
エスケープしてください。

=item Can't fork: %s

=begin original

(F) A fatal error occurred while trying to fork while opening a
pipeline.

=end original

(F) パイプラインをオープンしようとして、fork を行なおうとして、
致命的エラーが発生しました。

=item Can't fork, trying again in 5 seconds

=begin original

(W pipe) A fork in a piped open failed with EAGAIN and will be retried
after five seconds.

=end original

(W pipe) パイプの open での fork が EAGAIN で失敗し、5 秒後に
再試行されます。

=item Can't get filespec - stale stat buffer?

=begin original

(S) A warning peculiar to VMS.  This arises because of the difference
between access checks under VMS and under the Unix model Perl assumes.
Under VMS, access checks are done by filename, rather than by bits in
the stat buffer, so that ACLs and other protections can be taken into
account.  Unfortunately, Perl assumes that the stat buffer contains all
the necessary information, and passes it, instead of the filespec, to
the access-checking routine.  It will try to retrieve the filespec using
the device name and FID present in the stat buffer, but this works only
if you haven't made a subsequent call to the CRTL stat() routine,
because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access-checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access-checking
routine knows about the Perl C<stat> operator and file tests, so you
shouldn't ever see this warning in response to a Perl command; it arises
only if some internal code takes stat buffers lightly.)

=end original

(S) VMS に固有の警告です。
これは VMS と、Perl が仮定している Unix モデルでは、アクセスチェックに違いが
あることによって起こります。
VMS では、アクセスチェックは stat バッファのビットではなくファイル名によって
行われるので、ACL やその他の保護が考慮されます。
残念ながら、Perl は stat バッファに全ての必要な情報が含まれていると仮定して、
アクセスチェックルーチンにはファイルスペックではなくこれを渡します。
stat バッファにあるデバイス名と FID を使ってファイルスペックを
取得しようとしますが、これは引き続いて CRTL stat() ルーチンを呼び出さない
場合にのみ動作します; なぜならデバイス名は呼出し毎に上書きされるからです。
この警告が出ると、名前の検索が失敗し、アクセスチェックルーチンは諦めて、
安全のためだけに FALSE を返します。
(注意: アクセスチェックルーチンは Perl の C<stat> 演算子とファイル
テストについて知っているので、Perl コマンドの結果としてこの警告を見ることは
ないはずです; これは内部コートが stat バッファを軽率に扱った場合にのみ
発生します。)

=item Can't get pipe mailbox device name

=begin original

(P) An error peculiar to VMS.  After creating a mailbox to act as a
pipe, Perl can't retrieve its name for later use.

=end original

(P) VMS に固有のエラーです。
パイプとして働くメールボックスの作成後、後で使うための名前を
Perl が取得できませんでした。

=item Can't get SYSGEN parameter value for MAXBUF

=begin original

(P) An error peculiar to VMS.  Perl asked $GETSYI how big you want your
mailbox buffers to be, and didn't get an answer.

=end original

(P) VMS に固有のエラーです。
メールボックスバッファをどれくらいとるべきかを $GETSYI に
問い合わせましたが、答えが得られませんでした。

=item Can't "goto" into a binary or list expression

=begin original

(F) A "goto" statement was executed to jump into the middle of a binary
or list expression.  You can't get there from here.  The reason for this
restriction is that the interpreter would get confused as to how many
arguments there are, resulting in stack corruption or crashes.  This
error occurs in cases such as these:

=end original

(F) "goto" 文で 2 項式またはリスト式の途中に飛び込もうとしました。
ここからそこへは行けません。
この制限の理由は、そこにいくつの引数があるかに関してインタプリタが混乱し、
結果としてスタックは解約ラッシュを引き起こすからです。
このエラーは次のような場合に起こります:

    goto F;
    print do { F: }; # Can't jump into the arguments to print

    goto G;
    $x + do { G: $y }; # How is + supposed to get its first operand?

=item Can't "goto" into a "given" block

=begin original

(F) A "goto" statement was executed to jump into the middle of a C<given>
block.  You can't get there from here.  See L<perlfunc/goto>.

=end original

(F) "goto" 文で C<given> ブロックの中に飛び込もうとしました。
ここからそこへは行けません。
L<perlfunc/goto> を参照してください。

=item Can't "goto" into the middle of a foreach loop

=begin original

(F) A "goto" statement was executed to jump into the middle of a foreach
loop.  You can't get there from here.  See L<perlfunc/goto>.

=end original

(F) "goto" 文で foreach ループの中に飛び込もうとしました。
ここからそこへは行けません。
L<perlfunc/goto> を参照してください。

=item Can't "goto" out of a pseudo block

=begin original

(F) A "goto" statement was executed to jump out of what might look like
a block, except that it isn't a proper block.  This usually occurs if
you tried to jump out of a sort() block or subroutine, which is a no-no.
See L<perlfunc/goto>.

=end original

(F) "goto" 文でブロックのように見えるけれども、適切な
ブロックではないところから飛び出そうとしました。
これは普通 sort() ブロックやサブルーチンから飛び出そうとしたときに
起きますが、それはできません。
L<perlfunc/goto> を参照してください。

=item Can't goto subroutine from an eval-%s

=begin original

(F) The "goto subroutine" call can't be used to jump out of an eval
"string" or block.

=end original

(F) "goto subroutine" 呼び出しは eval "string" やブロックから
飛び出すことはできません。

=item Can't goto subroutine from a sort sub (or similar callback)

=begin original

(F) The "goto subroutine" call can't be used to jump out of the
comparison sub for a sort(), or from a similar callback (such
as the reduce() function in List::Util).

=end original

(F) "goto subroutine" 呼び出しは、sort() のための比較サブルーチンや、
(List::Util の reduce() 関数のような) 似たようなコールバックから
飛び出すことはできません。

=item Can't goto subroutine outside a subroutine

=begin original

(F) The deeply magical "goto subroutine" call can only replace one
subroutine call for another.  It can't manufacture one out of whole
cloth.  In general you should be calling it out of only an AUTOLOAD
routine anyway.  See L<perlfunc/goto>.

=end original

(F) 結構マジカルな "goto subroutine" の呼び出しは、あるサブルーチン
呼び出しを別のもので置き換えるだけです。
反物の状態から作り上げることはできません。
一般に、これを行なうのは、AUTOLOAD ルーティンから抜け出すときだけに
しておくべきです。
L<perlfunc/goto> を参照してください。

=item Can't ignore signal CHLD, forcing to default

=begin original

(W signal) Perl has detected that it is being run with the SIGCHLD
signal (sometimes known as SIGCLD) disabled.  Since disabling this
signal will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.  This
situation typically indicates that the parent program under which Perl
may be running (e.g. cron) is being very careless.

=end original

(W signal) Perl は、SIGCHLD (SIGCLD としても知られます) シグナルが
無効化された状態で実行されていることを検出しました。
このシグナルが無効化されると子プロセスの終了ステータスを適切に
決定できなくなるので、Perl はシグナルをデフォルト値にリセットしました。
この状況は典型的には Perl が動作している親プログラム(cron など)が
とても不注意であることを示しています。

=item Can't kill a non-numeric process ID

=begin original

(F) Process identifiers must be (signed) integers.  It is a fatal error to
attempt to kill() an undefined, empty-string or otherwise non-numeric
process identifier.

=end original

(F) プロセス識別子は(符号付き)整数でなければなりません。
未定義値、空文字列、その他の非数値プロセス識別子を使って
kill() しようとすることは致命的エラーです。

=item Can't "last" outside a loop block

=begin original

(F) A "last" statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a current
block.  Note that an "if" or "else" block doesn't count as a "loopish"
block, as doesn't a block given to sort(), map() or grep().  You can
usually double the curlies to get the same effect though, because the
inner curlies will be considered a block that loops once.  See
L<perlfunc/last>.

=end original

(F) 現在のブロックから脱出するために、"last" 文を実行しましたが、
残念なことにブロックの中ではありませんでした。
"if" や "else" のブロックは、sort(), map(), grep() のブロックが違うのと
同様「ループ風」ブロックではないので、注意してください。
ただし、中かっこを二重にすれば、内側の中かっこが、1 度だけループする
ブロックとみなされますから、同じ効果が得られます。
L<perlfunc/last> を参照してください。

=item Can't linearize anonymous symbol table

=begin original

(F) Perl tried to calculate the method resolution order (MRO) of a
package, but failed because the package stash has no name.

=end original

(F) Perl はパッケージのメソッド解決順序 (MRO) を計算しようとしましたが、
パッケージ stash に名前がないので失敗しました。

=item Can't load '%s' for module %s

=begin original

(F) The module you tried to load failed to load a dynamic extension.
This may either mean that you upgraded your version of perl to one
that is incompatible with your old dynamic extensions (which is known
to happen between major versions of perl), or (more likely) that your
dynamic extension was built against an older version of the library
that is installed on your system.  You may need to rebuild your old
dynamic extensions.

=end original

(F) 読み込もうとしたモジュールは、動的拡張モジュールの読み込みに
失敗しました。
これは古い動的拡張モジュールと互換性のない perl にアップグレードしたか
(これは perl のメジャーバージョン間で起きることが知られています)、
(よりあり得るのは)動的拡張モジュールがシステムにインストールされている古い
バージョンのライブラリに対してビルドされているかです。
古い動的拡張モジュールをリビルドする必要があるでしょう。

=item Can't localize lexical variable %s

=begin original

(F) You used local on a variable name that was previously declared as a
lexical variable using "my" or "state".  This is not allowed.  If you
want to localize a package variable of the same name, qualify it with
the package name.

=end original

(F) 以前に "my" や "state" を使ってレキシカル変数として宣言された変数名に
対して local を使いました。
これは認められていません。
同じ名前のパッケージ変数をローカル化したい場合は、
パッケージ名で修飾してください。

=item Can't localize through a reference

=begin original

(F) You said something like C<local $$ref>, which Perl can't currently
handle, because when it goes to restore the old value of whatever $ref
pointed to after the scope of the local() is finished, it can't be sure
that $ref will still be a reference.

=end original

(F) C<local $$ref> のようなことをしましたが、Perl は現在のところこれを
扱えません; なぜなら、local() のスコープが終了した後、$ref が
指しているものの古い値を戻すとき、$ref がまだリファレンスかどうかが
わからないからです。

=item Can't locate %s

=begin original

(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be found.
Perl looks for the file in all the locations mentioned in @INC, unless
the file name included the full path to the file.  Perhaps you need
to set the PERL5LIB or PERL5OPT environment variable to say where the
extra library is, or maybe the script needs to add the library name
to @INC.  Or maybe you just misspelled the name of the file.  See
L<perlfunc/require> and L<lib>.

=end original

(F) ファイルを C<do> (または、C<require>、C<use>) するように
指示されましたが、見つかりませんでした。
Perl は、フルパスで指定されていない場合ファイルを @INC で示される
全ての場所を検索します。
おそらく、追加ライブラリの場所を示すために、
PERL5LIB または PERL5OPT の環境変数を指定する必要があるか、
スクリプトの中で @INC にライブラリ名を追加する必要があります。
ファイル名のスペルミスの可能性もあります。
L<perlfunc/require> と L<lib> を参照してください。

=item Can't locate auto/%s.al in @INC

=begin original

(F) A function (or method) was called in a package which allows
autoload, but there is no function to autoload.  Most probable causes
are a misprint in a function/method name or a failure to C<AutoSplit>
the file, say, by doing C<make install>.

=end original

(F) 関数(またはメソッド)がオートロードを許可しているパッケージで
呼び出されましたが、オートロードする関数がありませんでした。
最も可能性のある原因は関数/メソッド名の誤記か、C<make install> と
することによるファイルの C<AutoSplit> の失敗です。

=item Can't locate loadable object for module %s in @INC

=begin original

(F) The module you loaded is trying to load an external library, like
for example, F<foo.so> or F<bar.dll>, but the L<DynaLoader> module was
unable to locate this library.  See L<DynaLoader>.

=end original

(F) 読み込まれたモジュールは F<foo.so> や F<bar.dll> のような外部
ライブラリを読み込もうとしましたが、L<DynaLoader> モジュールは、この
ライブラリの位置がわかりませんでした。
L<DynaLoader> を参照してください。

=item Can't locate object method "%s" via package "%s"

=begin original

(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't define that particular
method, nor does any of its base classes.  See L<perlobj>.

=end original

(F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケージを
正しく示していますが、そのパッケージにも、基底クラスにも、
該当のメソッドが定義されていません。
L<perlobj> を参照してください。

=item Can't locate object method "%s" via package "%s" (perhaps you forgot
to load "%s"?)

=begin original

(F) You called a method on a class that did not exist, and the method
could not be found in UNIVERSAL.  This often means that a method
requires a package that has not been loaded.

=end original

(F) 存在しないクラスメソッドを呼び出し、メソッドは
UNIVERSAL に見つかりませんでした。
これはしばしばメソッドがまだロードされていないパッケージを
要求していることを意味します。

=item Can't locate package %s for @%s::ISA

=begin original

(W syntax) The @ISA array contained the name of another package that
doesn't seem to exist.

=end original

(W syntax) 配列 @ISA に別のパッケージ名が記されていますが、
存在していないようです。

=item Can't locate PerlIO%s

=begin original

(F) You tried to use in open() a PerlIO layer that does not exist,
e.g. open(FH, ">:nosuchlayer", "somefile").

=end original

(F) 例えば、open(FH, ">:nosuchlayer", "somefile") のように、
open() で 存在しない PerlIO 層を使おうとしました。

=item Can't make list assignment to %ENV on this system

=begin original

(F) List assignment to %ENV is not supported on some systems, notably
VMS.

=end original

(F) %ENV へのリスト代入はいくつかのシステム、特に VMS では
対応していません。

=item Can't make loaded symbols global on this platform while loading %s

=begin original

(S) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request
that symbols from the stated file are made available globally within the
process, but that functionality is not available on this platform.  Whilst
the module likely will still work, this may prevent the perl interpreter
from loading other XS-based extensions which need to link directly to
functions defined in the C or XS code in the stated file.

=end original

(W) モジュールが、プロセスの中でグローバルに利用可能な固定ファイルから
シンボルを読み込むことを要求するために、DynaLoader::dl_load_file() に
0x01 フラグを渡しましたが、この機能はこのプラットフォームでは利用できません。
モジュールはおそらく動作しますが、perl インタプリタによる、固定ファイルの C や
XS コードで定義された関数へ直接リンクする必要のあるその他の XS ベースの
エクステンションの読み込みが妨げられるかもしれません。

=item Can't modify %s in %s

=begin original

(F) You aren't allowed to assign to the item indicated, or otherwise try
to change it, such as with an auto-increment.

=end original

(F) 指定されたものは、代入、インクリメントなど、変更が許されていません。

=item Can't modify nonexistent substring

=begin original

(P) The internal routine that does assignment to a substr() was handed
a NULL.

=end original

(P) substr() への代入を行なう内部ルーティンに NULL が渡されました。

=item Can't modify non-lvalue subroutine call of &%s

=item Can't modify non-lvalue subroutine call of &%s in %s

=begin original

(F) Subroutines meant to be used in lvalue context should be declared as
such.  See L<perlsub/"Lvalue subroutines">.

=end original

(F) 左辺値コンテキストとして使うサブルーチンは、そのように
宣言しなければなりません。
L<perlsub/"Lvalue subroutines"> を参照してください。

=item Can't modify reference to %s in %s assignment

=begin original

(F) Only a limited number of constructs can be used as the argument to a
reference constructor on the left-hand side of an assignment, and what
you used was not one of them.  See L<perlref/Assigning to References>.

=end original

(F) 代入の左側のリファレンスコンストラクタの引数に使える構文は
一部に制限されていて、ここで使ったものはその一つではありません。
L<perlref/Assigning to References> を参照してください。

=item Can't modify reference to localized parenthesized array in list
assignment

=begin original

(F) Assigning to C<\local(@array)> or C<\(local @array)> is not supported, as
it is not clear exactly what it should do.  If you meant to make @array
refer to some other array, use C<\@array = \@other_array>.  If you want to
make the elements of @array aliases of the scalars referenced on the
right-hand side, use C<\(@array) = @scalar_refs>.

=end original

(F) C<\local(@array)> や C<\(local @array)> への代入は対応していません;
正確に何をするべきかが明確ではないからです。
@array が他の配列を参照するようにすることを意味しているなら、
C<\@array = \@other_array> を使ってください。
@array の要素が右側でリファレンスされているスカラへの別名にしたいなら、
C<\(@array) = @scalar_refs> を使ってください。

=item Can't modify reference to parenthesized hash in list assignment

=begin original

(F) Assigning to C<\(%hash)> is not supported.  If you meant to make %hash
refer to some other hash, use C<\%hash = \%other_hash>.  If you want to
make the elements of %hash into aliases of the scalars referenced on the
right-hand side, use a hash slice: C<\@hash{@keys} = @those_scalar_refs>.

=end original

(F) C<\(%hash)> への代入は対応していません。
%hash が他のハッシュを参照するようにすることを意味しているなら、
C<\%hash = \%other_hash> を使ってください。
%hash の要素が右側でリファレンスされているスカラへの別名にしたいなら、
ハッシュスライスを使ってください: C<\@hash{@keys} = @those_scalar_refs>。

=item Can't msgrcv to read-only var

=begin original

(F) The target of a msgrcv must be modifiable to be used as a receive
buffer.

=end original

(F) msgrcv で使用する変数は、受信バッファとして使用しますので、
変更可能なものでなければなりません。

=item Can't "next" outside a loop block

=begin original

(F) A "next" statement was executed to reiterate the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map() or
grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that loops
once.  See L<perlfunc/next>.

=end original

(F) 現在のブロックの繰り返しを進めるために、"next" 文を実行しましたが、
ブロックの中ではありませんでした。
"if" や "else" のブロックは、sort(), map(), grep() のブロックが違うのと
同様「ループ風」ブロックではないので、注意してください。
ただし、中かっこを二重にすれば、内側の中かっこが、1 度だけループする
ブロックとみなされますから、同じ効果が得られます。
L<perlfunc/next> を参照してください。

=item Can't open %s: %s

=begin original

(S inplace) The implicit opening of a file through use of the C<< <> >>
filehandle, either implicitly under the C<-n> or C<-p> command-line
switches, or explicitly, failed for the indicated reason.  Usually
this is because you don't have read permission for a file which
you named on the command line.

=end original

(S inplace) C<< <> >> ファイルハンドルによる暗黙的なファイルオープンまたは
C<-n> か C<-p> コマンドラインスイッチによる暗黙的な、あるいは
明示的なファイルオープンが表示した理由によって失敗しました。
通常、これはコマンドラインで指定したファイルの読み込み権限が無いときに起こります。

=begin original

(F) You tried to call perl with the B<-e> switch, but F</dev/null> (or
your operating system's equivalent) could not be opened.

=end original

(F) B<-e> オプション付きで perl を呼び出そうとしましたが、F</dev/null>
(またはあなたのオペレーティングシステムでの等価物) が開けませんでした。

=item Can't open a reference

=begin original

(W io) You tried to open a scalar reference for reading or writing,
using the 3-arg open() syntax:

=end original

(W io) 3 引数の open() の構文を使ってスカラリファレンスを読み込みまたは
書き込みのために開こうとしました:

    open FH, '>', $ref;

=begin original

but your version of perl is compiled without perlio, and this form of
open is not supported.

=end original

しかしこのバージョンの perl は perlio なしでコンパイルされていて、
この形式の open は対応していません。

=item Can't open bidirectional pipe

=begin original

(W pipe) You tried to say C<open(CMD, "|cmd|")>, which is not supported.
You can try any of several modules in the Perl library to do this, such
as IPC::Open2.  Alternately, direct the pipe's output to a file using
">", and then read it in under a different file handle.

=end original

(W pipe) サポートされていない C<open(CMD, "|cmd|")> を行なおうとしました。
これを行なうためには、Perl ライブラリの IPC::Open2 のようないくつかの
モジュールを使うことができます。
別の方法として、パイプされたものを ">" を使っていったんファイルに出力し、
あとで別のファイルハンドルで読み込みを行なうことも考えられます。

=item Can't open error file %s as stderr

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '2>' or '2>>' on
the command line for writing.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインで書き込みのために '2>' や '2>>' の後に指定された
ファイルを開けませんでした。

=item Can't open input file %s as stdin

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '<' on the
command line for reading.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインで読み込みのために '<' の後に指定された
ファイルを開けませんでした。

=item Can't open output file %s as stdout

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '>' or '>>' on
the command line for writing.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインで書き込みのために '>' や '>>' の後に指定された
ファイルを開けませんでした。

=item Can't open output pipe (name: %s)

=begin original

(P) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the pipe into which to send data destined
for stdout.

=end original

(P) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
標準出力としてデータを送るパイプを開けませんでした。

=item Can't open perl script "%s": %s

=begin original

(F) The script you specified can't be opened for the indicated reason.

=end original

(F) 指定したスクリプトが、表示した理由によってオープンできませんでした。

=begin original

If you're debugging a script that uses #!, and normally relies on the
shell's $PATH search, the -S option causes perl to do that search, so
you don't have to type the path or C<`which $scriptname`>.

=end original

#! を使うスクリプトをデバッグしていて、普通はシェルの $PATH 検索に
頼っている場合は、-S オプションを付けることで perl が検索するようになり、
パスや C<`which $scriptname`> をタイプする必要がなくなります。

=item Can't read CRTL environ

=begin original

(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV
from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not
searched.

=end original

(S) VMS に固有の警告です。
Perl は %ENV の要素を CRTL の内部環境配列から読み込もうとしましたが、
配列がないことを発見しました。
CRTL が環境をどこに間違えて置いたかを探し出すか、F<PERL_ENV_TABLE> を
定義して(L<perlvms> を参照してください)環境を検索しないようにする
必要があります。

=item Can't redeclare "%s" in "%s"

=begin original

(F) A "my", "our" or "state" declaration was found within another declaration,
such as C<my ($x, my($y), $z)> or C<our (my $x)>.

=end original

(F) C<my ($x, my($y), $z)> や C<our (my $x)> のように、
"my", "our", "state" 宣言が他の宣言の中にありました。

=item Can't "redo" outside a loop block

=begin original

(F) A "redo" statement was executed to restart the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/redo>.

=end original

(F) 現在のブロックの繰り返しをもう一度行なうために、
"redo" 文を実行しましたが、ブロックの中ではありませんでした。
"if" や "else" のブロックは、sort(), map(), grep() のブロックが違うのと
同様「ループ風」ブロックではないので、注意してください。
ただし、中かっこを二重にすれば、内側の中かっこが、1 度だけループする
ブロックとみなされますから、同じ効果が得られます。
L<perlfunc/redo> を参照してください。

=item Can't remove %s: %s, skipping file

=begin original

(S inplace) You requested an inplace edit without creating a backup
file.  Perl was unable to remove the original file to replace it with
the modified file.  The file was left unmodified.

=end original

(S inplace) バックアップを作成せずにその場編集することを要求しました。
Perl は変更したファイルで置き換えるために元のファイルを削除することが
できませんでした。
ファイルは変更されずに残されます。

=item Can't rename in-place work file '%s' to '%s': %s

=begin original

(F) When closed implicitly, the temporary file for in-place editing
couldn't be renamed to the original filename.

=end original

(F) その場編集のための一時ファイルが暗黙に閉じられたとき、
元のファイル名にリネームできませんでした。

=item Can't rename %s to %s: %s, skipping file

=begin original

(F) The rename done by the B<-i> switch failed for some reason,
probably because you don't have write permission to the directory.

=end original

(F) B<-i> スイッチで行なわれた rename が何らかの理由によって、
うまく行きませんでした; ディレクトリに書き込み権がないことも考えられます。

=item Can't reopen input pipe (name: %s) in binary mode

=begin original

(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried
to reopen it to accept binary data.  Alas, it failed.

=end original

(P) VMS に固有のエラーです。
Perl は標準入力がパイプであると考えて、バイナリデータを受け入れるために
再オープンしようとしました。
悲しいかな、それは失敗しました。

=item Can't represent character for Ox%X on this platform

=begin original

(F) There is a hard limit to how big a character code point can be due
to the fundamental properties of UTF-8, especially on EBCDIC
platforms.  The given code point exceeds that.  The only work-around is
to not use such a large code point.

=end original

(F) どれだけ大きな文字符号位置が使えるかについては固定値の制限があります;
これは UTF-8 の、特に EBCDIC プラットフォームでの基礎的な特性によるものです。
指定された符号位置はそれを越えています。
唯一の回避策はそのような大きな符号位置を使わないことです。

=item Can't reset %ENV on this system

=begin original

(F) You called C<reset('E')> or similar, which tried to reset
all variables in the current package beginning with "E".  In
the main package, that includes %ENV.  Resetting %ENV is not
supported on some systems, notably VMS.

=end original

(F) C<reset('E')> のようなものを呼び出して、現在のパッケージで "E" で始まる
全ての変数を reset しようとしました。
main パッケージでは、これには %ENV が含まれます。
%ENV の reset は一部のシステム、特に VMS では対応していません。

=item Can't resolve method "%s" overloading "%s" in package "%s"

=begin original

(F)(P) Error resolving overloading specified by a method name (as
opposed to a subroutine reference): no such method callable via the
package.  If the method name is C<???>, this is an internal error.

=end original

(F)(P) (サブルーチンのリファレンスではなく)メソッド名で指定された
オーバーロードの解決でのエラー: そのようなメソッドはパッケージ経由で
呼び出せません。
もしメソッド名が C<???> なら、内部エラーです。

=item Can't return %s from lvalue subroutine

=begin original

(F) Perl detected an attempt to return illegal lvalues (such as
temporary or readonly values) from a subroutine used as an lvalue.  This
is not allowed.

=end original

(F) Perl が、左辺値として使われるサブルーチンから(一時的や
読み込み専用のような)不正な左辺値が返されようとしているのを検出しました。
これは認められていません。

=item Can't return outside a subroutine

=begin original

(F) The return statement was executed in mainline code, that is, where
there was no subroutine call to return out of.  See L<perlsub>.

=end original

(F) return 文が、return で抜けるべきサブルーチンがない、
"main" コードで実行されました。
L<perlsub> を参照してください。

=item Can't return %s to lvalue scalar context

=begin original

(F) You tried to return a complete array or hash from an lvalue
subroutine, but you called the subroutine in a way that made Perl
think you meant to return only one value.  You probably meant to
write parentheses around the call to the subroutine, which tell
Perl that the call should be in list context.

=end original

(F) 左辺値サブルーチンから配列やハッシュ全体を返そうとしましたが、
一つだけの値を返そうとしていると Perl が考えるような方法でサブルーチンを
呼び出しました。
おそらく、Perl にこの呼び出しがリストコンテキストであると伝えるために、
サブルーチン呼び出しの周りにかっこを書いているのでしょう。

=item Can't stat script "%s"

=begin original

(P) For some reason you can't fstat() the script even though you have it
open already.  Bizarre.

=end original

(P) 何らかの理由で、例え既にオープンしていたとしても、fstat() が
行なえません。困ったもんだ。

=item Can't take log of %g

=begin original

(F) For ordinary real numbers, you can't take the logarithm of a
negative number or zero.  There's a Math::Complex package that comes
standard with Perl, though, if you really want to do that for the
negative numbers.

=end original

(F) 実数に対しては、負数や 0 に対する対数を取ることはできません。
しかし、もし本当に負数に対してそのようなことをしたいのなら、
Perl 標準になっている Math::Complex パッケージがあります。

=item Can't take sqrt of %g

=begin original

(F) For ordinary real numbers, you can't take the square root of a
negative number.  There's a Math::Complex package that comes standard
with Perl, though, if you really want to do that.

=end original

(F) 通常の実数では、負数の平方根をとることはできません。
しかし、本当にその計算を行ないたいのであれば、Math::Complex パッケージが
Perl に標準で用意されています。

=item Can't undef active subroutine

=begin original

(F) You can't undefine a routine that's currently running.  You can,
however, redefine it while it's running, and you can even undef the
redefined subroutine while the old routine is running.  Go figure.

=end original

(F) 実行中のルーティンを未定義にすることはできません。
しかし、実行中に再定義することはでき、古いルーティンを実行中に、
再定義したサブルーチンを undef することさえできます。
驚きです。

=item Can't unweaken a nonreference

=begin original

(F) You attempted to unweaken something that was not a reference.  Only
references can be unweakened.

=end original

(F) リファレンスでないものを弱くないようにしようとしました。
リファレンスだけが弱くないようにできます。

=item Can't upgrade %s (%d) to %d

=begin original

(P) The internal sv_upgrade routine adds "members" to an SV, making it
into a more specialized kind of SV.  The top several SV types are so
specialized, however, that they cannot be interconverted.  This message
indicates that such a conversion was attempted.

=end original

(P) 内部の sv_upgrade ルーティンは、SV に「メンバ」を加えて、
より特別な種類の SV にします。　しかし、上位のいくつかの SV 型は、
特殊化され過ぎて、内部変換することができません。
このメッセージは、そのような変更を行なおうとしたことを示しています。

=item Can't use '%c' after -mname

=begin original

(F) You tried to call perl with the B<-m> switch, but you put something
other than "=" after the module name.

=end original

(F) B<-m> オプション付きで perl を呼び出そうとしましたが、モジュール名の後に
"=" 以外のものを置きました。

=item Can't use a hash as a reference

=begin original

(F) You tried to use a hash as a reference, as in
C<< %foo->{"bar"} >> or C<< %$ref->{"hello"} >>.  Versions of perl
<= 5.22.0 used to allow this syntax, but shouldn't
have.  This was deprecated in perl 5.6.1.

=end original

(F) C<< %foo->{"bar"} >> or C<< %$ref->{"hello"} >> のように、
ハッシュをリファレンスとして使おうとしました。
<= 5.22.0 のバージョンの perl ではこの文法が許されていましたが、
そうするべきではありません。
これは perl 5.6.1 から廃止予定です。

=item Can't use an array as a reference

=begin original

(F) You tried to use an array as a reference, as in
C<< @foo->[23] >> or C<< @$ref->[99] >>.  Versions of perl <= 5.22.0
used to allow this syntax, but shouldn't have.  This
was deprecated in perl 5.6.1.

=end original

(F) C<< @foo->[23] >> or C<< @$ref->[99] >> のように、
配列をリファレンスとして使おうとしました。
<= 5.22.0 のバージョンの perl ではこの文法が許されていましたが、
そうするべきではありません。
これは perl 5.6.1 から廃止予定です。

=item Can't use anonymous symbol table for method lookup

=begin original

(F) The internal routine that does method lookup was handed a symbol
table that doesn't have a name.  Symbol tables can become anonymous
for example by undefining stashes: C<undef %Some::Package::>.

=end original

(F) メソッド検索を行う内部ルーチンが、名前のないシンボルテーブルを
扱いました。
シンボルテーブルは、例えば C<undef %Some::Package::> のように未定義の
stash によって無名となります。

=item Can't use an undefined value as %s reference

=begin original

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

=end original

(F) ハードリファレンスやシンボリックリファレンスとして使用する値は、
定義済みの値でなければなりません。
潜伏中のエラーを引きずり出す助けとなります。

=item Can't use bareword ("%s") as %s ref while "strict refs" in use

=begin original

(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.

=end original

(F) "strict refs" によって、ハードリファレンスのみが許可されます。
シンボリックリファレンスは許可されません。
L<perlref> を参照してください。

=item Can't use %! because Errno.pm is not available

=begin original

(F) The first time the C<%!> hash is used, perl automatically loads the
Errno.pm module.  The Errno module is expected to tie the %! hash to
provide symbolic names for C<$!> errno values.

=end original

(F) 最初に C<%!> ハッシュが使われるときに、
perl は自動的に Errno.pm モジュールを読み込みます。
Errno モジュールは C<$!> errno 値のシンボリック名を提供するために
%! ハッシュと tie されることになります。

=item Can't use both '<' and '>' after type '%c' in %s

=begin original

(F) A type cannot be forced to have both big-endian and little-endian
byte-order at the same time, so this combination of modifiers is not
allowed.  See L<perlfunc/pack>.

=end original

(F) 一つの型を同時にビッグエンディアンとリトルエンディアンの両方に
強制することはできないので、この修飾子の組み合わせは許可されません。
L<perlfunc/pack> を参照してください。

=item Can't use 'defined(@array)' (Maybe you should just omit the defined()?)

=begin original

(F) defined() is not useful on arrays because it
checks for an undefined I<scalar> value.  If you want to see if the
array is empty, just use C<if (@array) { # not empty }> for example.

=end original

(F) defined() は未定義の I<スカラ> 値を調べるので、配列に使っても無意味です。
配列が空かどうかを調べたい場合は、例えば単に 
C<if (@array) { # not empty }> としてください。

=item Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)

=begin original

(F) C<defined()> is not usually right on hashes.

=end original

(F) C<defined()> は普通はハッシュの右側ではありません。

=begin original

Although C<defined %hash> is false on a plain not-yet-used hash, it
becomes true in several non-obvious circumstances, including iterators,
weak references, stash names, even remaining true after C<undef %hash>.
These things make C<defined %hash> fairly useless in practice, so it now
generates a fatal error.

=end original

まだ使われていない普通のハッシュに対する C<defined %hash> は偽ですが、
いくつかの明白でない状況では新になります; これには反復し、弱い参照、
stash 名を含み、C<undef %hash> の後でも真になります。
これらにより、実践では C<defined %hash> はほとんど使えないので、
致命的エラーを生成するようになりました。

=begin original

If a check for non-empty is what you wanted then just put it in boolean
context (see L<perldata/Scalar values>):

=end original

空でないことをチェックしたいなら、単にこれを真偽値コンテキストに
置いてください (L<perldata/Scalar values> を参照してください):

    if (%hash) {
       # not empty
    }

=begin original

If you had C<defined %Foo::Bar::QUUX> to check whether such a package
variable exists then that's never really been reliable, and isn't
a good way to enquire about the features of a package, or whether
it's loaded, etc.

=end original

パッケージ変数が存在するかどうかを調べるために
C<defined %Foo::Bar::QUUX> のようなことをしていると、これは決して信頼性が
なく、パッケージの機能や読み込まれているかどうかなどを問い合わせる
良い方法ではありません。

=item Can't use %s for loop variable

=begin original

(P) The parser got confused when trying to parse a C<foreach> loop.

=end original

(P) パーサが C<foreach> ループをパースしようとしたときに混乱しました。

=item Can't use global %s in %s

=begin original

(F) You tried to declare a magical variable as a lexical variable.  This
is not allowed, because the magic can be tied to only one location
(namely the global variable) and it would be incredibly confusing to
have variables in your program that looked like magical variables but
weren't.

=end original

(F) マジカル変数を、字句スコープ変数として宣言しようとしました。
これが許されていないのは、マジカル変数は(グローバル変数という名前の)
1 か所だけに結び付けられているので、マジカル変数のように見えるけれども
そうではない変数がプログラム中にあると、著しく混乱させるからです。

=item Can't use '%c' in a group with different byte-order in %s

=begin original

(F) You attempted to force a different byte-order on a type
that is already inside a group with a byte-order modifier.
For example you cannot force little-endianness on a type that
is inside a big-endian group.

=end original

(F) 既にバイト順修飾子が付けられているグループの内側で異なったバイト順を
強制しようとしました。
例えば、ビッグエンディアングループの中にある型をリトルエンディアンに
強制することはできません。

=item Can't use "my %s" in sort comparison

=begin original

(F) The global variables $a and $b are reserved for sort comparisons.
You mentioned $a or $b in the same line as the <=> or cmp operator,
and the variable had earlier been declared as a lexical variable.
Either qualify the sort variable with the package name, or rename the
lexical variable.

=end original

(F) グローバル変数 $a と $b はソート比較のために予約されています。
$a か $b を <=> か cmp 演算子と同じ行に記述しましたが、その変数は
その前にレキシカル変数として宣言されています。
ソート変数をパッケージ名で修飾するか、レキシカル変数の名前を変えてください。

=item Can't use %s ref as %s ref

=begin original

(F) You've mixed up your reference types.  You have to dereference a
reference of the type needed.  You can use the ref() function to
test the type of the reference, if need be.

=end original

(F) リファレンス型を混同しています。
必要な型のリファレンスを被参照しなければなりません。
必要ならば、リファレンスの型を調べるのに、ref() 関数を使うことができます。

=item Can't use string ("%s") as %s ref while "strict refs" in use

=item Can't use string ("%s"...) as %s ref while "strict refs" in use

=begin original

(F) You've told Perl to dereference a string, something which
C<use strict> blocks to prevent it happening accidentally.  See
L<perlref/"Symbolic references">.  This can be triggered by an C<@> or C<$>
in a double-quoted string immediately before interpolating a variable,
for example in C<"user @$twitter_id">, which says to treat the contents
of C<$twitter_id> as an array reference; use a C<\> to have a literal C<@>
symbol followed by the contents of C<$twitter_id>: C<"user \@$twitter_id">.

=end original

(F) 文字列をデリファレンスするように Perl に指示しましたが、
C<use strict> ブロックがこれが偶然起きることを妨げました。
L<perlref/"Symbolic references"> を参照してください。
これは、ダブルクォート文字列の中の変数展開の直前の C<@> または C<$> で
引き起こされます; 例えば C<"user @$twitter_id"> です; これは C<$twitter_id> の
内容を配列リファレンスとして扱うように指示しています;
リテラルな C<@> の後に C<$twitter_id> の内容が引き続くようにするには
C<\> を使ってください:  C<"user \@$twitter_id">。

=item Can't use subscript on %s

=begin original

(F) The compiler tried to interpret a bracketed expression as a
subscript.  But to the left of the brackets was an expression that
didn't look like a hash or array reference, or anything else subscriptable.

=end original

(F) コンパイラが大かっこで囲われた式を添字として解釈しようとしました。
しかし、大かっこの左側はハッシュか配列のリファレンスやその他の
添字化できるもののようには見えない式です。

=item Can't use \%c to mean $%c in expression

=begin original

(W syntax) In an ordinary expression, backslash is a unary operator that
creates a reference to its argument.  The use of backslash to indicate a
backreference to a matched substring is valid only as part of a regular
expression pattern.  Trying to do this in ordinary Perl code produces a
value that prints out looking like SCALAR(0xdecaf).  Use the $1 form
instead.

=end original

(W syntax) 通常の式では、バックスラッシュは引数へのリファレンスを作る
単項演算子です。
マッチした部分文字列への後方参照を示すためのバックスラッシュの使用は
正規表現パターンの一部の場合にのみ有効です。
通常の Perl コードの中でこれをしようとすると、SCALAR(0xdecaf) のように
表示される値を生成します。
代わりに $1 の形を使ってください。

=item Can't weaken a nonreference

=begin original

(F) You attempted to weaken something that was not a reference.  Only
references can be weakened.

=end original

(F) リファレンスではない何かを弱めようとしました。
リファレンスだけが弱めることができます。

=item Can't "when" outside a topicalizer

=begin original

(F) You have used a when() block that is neither inside a C<foreach>
loop nor a C<given> block.  (Note that this error is issued on exit
from the C<when> block, so you won't get the error if the match fails,
or if you use an explicit C<continue>.)

=end original

(F) C<foreach> ブロックや C<given> ブロックの内側以外で when() ブロックを
使いました。
(このエラーは C<when> ブロックから終了したときに発生するので、マッチングに
失敗したときや、明示的な C<continue> を使った場合はこのエラーは
発生しません。)

=item Can't x= to read-only value

=begin original

(F) You tried to repeat a constant value (often the undefined value)
with an assignment operator, which implies modifying the value itself.
Perhaps you need to copy the value to a temporary, and repeat that.

=end original

(F) 定数値 (未定義値であることが多い) を、自らを書き換えることを意味する、
代入演算子で繰り返しを行なおうとしました。
テンポラリ変数に値を移してから、繰り返すと良いでしょう。

=item Character following "\c" must be printable ASCII

=begin original

(F) In C<\cI<X>>, I<X> must be a printable (non-control) ASCII character.

=end original

(F) C<\cI<X>> において、I<X> は表示可能な ASCII 文字でなければなりません。

=begin original

Note that ASCII characters that don't map to control characters are
discouraged, and will generate the warning (when enabled)
L</""\c%c" is more clearly written simply as "%s"">.

=end original

制御文字にマッピングされない ASCII 文字は非推奨であることに注意してください;
そして (有効になっていれば)
L</""\c%c" is more clearly written simply as "%s""> 警告が出力されます。

=item Character following \%c must be '{' or a single-character Unicode property name in regex; marked by <-- HERE in m/%s/

=begin original

(F) (In the above the C<%c> is replaced by either C<p> or C<P>.)  You
specified something that isn't a legal Unicode property name.  Most
Unicode properties are specified by C<\p{...}>.  But if the name is a
single character one, the braces may be omitted.

=end original

(F) (前述の C<%c> は C<p> か C<P> に置き換えられます。)
正当な Unicode 特性名ではない何かをしていしました。
ほとんどの Unicode 特性は C<\p{...}> として指定されます。
しかし、名前が一文字の場合、中かっこは省略できます。

=item Character in 'C' format wrapped in pack

=begin original

(W pack) You said

=end original

(W pack) 以下のように書きましたが:

    pack("C", $x)

=begin original

where $x is either less than 0 or more than 255; the C<"C"> format is
only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

=end original

$x は 0 より小さいか 255 より大きいです; C<"C"> フォーマットは
ネイティブ OS 文字 (ASCII, EBCDIC など) のエンコーディングだけに
対応していて、Unicode 文字は対応していません;
それで、Perl は以下のように意味しているかのように振舞います:

    pack("C", $x & 255)

=begin original

If you actually want to pack Unicode codepoints, use the C<"U"> format
instead.

=end original

Unicode コードポイントを pack したい場合は、代わりに C<"U"> フォーマットを
使ってください。

=item Character in 'c' format wrapped in pack

=begin original

(W pack) You said

=end original

(W pack) 以下のように書きましたが:

    pack("c", $x)

=begin original

where $x is either less than -128 or more than 127; the C<"c"> format
is only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

=end original

$x は -128 より小さいか 127 より大きいです; C<"c"> フォーマットは
ネイティブ OS 文字 (ASCII, EBCDIC など) のエンコーディングだけに
対応していて、Unicode 文字は対応していません;
それで、Perl は以下のように意味しているかのように振舞います:

    pack("c", $x & 255);

=begin original

If you actually want to pack Unicode codepoints, use the C<"U"> format
instead.

=end original

Unicode コードポイントを pack したい場合は、代わりに C<"U"> フォーマットを
使ってください。

=item Character in '%c' format wrapped in unpack

=begin original

(W unpack) You tried something like

=end original

(W unpack) 以下のようなことをしましたが:

   unpack("H", "\x{2a1}")

=begin original

where the format expects to process a byte (a character with a value
below 256), but a higher value was provided instead.  Perl uses the
value modulus 256 instead, as if you had provided:

=end original

ここでフォーマットはバイト(値が 256 より小さい文字)を想定していますが、
文字の中により大きな値のものがあります。
Perl は、あなたが以下のようにしたかのように、256 で割った余りを文字の
値として使います:

   unpack("H", "\x{a1}")

=item Character in 'W' format wrapped in pack

=begin original

(W pack) You said

=end original

(W pack) 以下のように書きましたが:

    pack("U0W", $x)

=begin original

where $x is either less than 0 or more than 255.  However, C<U0>-mode
expects all values to fall in the interval [0, 255], so Perl behaved
as if you meant:

=end original

$x が 0 より小さいか 255 より大きいです。
しかし、C<U0>-モードは全ての値が [0, 255] の範囲にあることを想定してるので、
Perl は以下のように振る舞います:

    pack("U0W", $x & 255)

=item Character(s) in '%c' format wrapped in pack

=begin original

(W pack) You tried something like

=end original

(W pack) 以下のようなことをしましたが:

   pack("u", "\x{1f3}b")

=begin original

where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value.  Perl
uses the character values modulus 256 instead, as if you had provided:

=end original

ここでフォーマットはバイト(値が 256 より小さい文字)列を想定していますが、
文字の中により大きな値のものがあります。
Perl は、あなたが以下のようにしたかのように、256 で割った余りを文字の
値として使います:

   pack("u", "\x{f3}b")

=item Character(s) in '%c' format wrapped in unpack

=begin original

(W unpack) You tried something like

=end original

(W unpack) 以下のようなことをしましたが:

   unpack("s", "\x{1f3}b")

=begin original

where the format expects to process a sequence of bytes (character with a
value below 256), but some of the characters had a higher value.  Perl
uses the character values modulus 256 instead, as if you had provided:

=end original

ここでフォーマットはバイト(値が 256 より小さい文字)列を想定していますが、
文字の中により大きな値のものがあります。
Perl は、あなたが以下のようにしたかのように、256 で割った余りを文字の
値として使います:

   unpack("s", "\x{f3}b")

=item charnames alias definitions may not contain a sequence of multiple
spaces; marked by S<<-- HERE> in %s

=begin original

(F) You defined a character name which had multiple space characters
in a row.  Change them to single spaces.  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.  See
L<charnames/CUSTOM ALIASES>.

=end original

(F) 連続して複数のスペース文字を持つ文字名を定義しました。
単一のスペースに変更してください。
普通はこれらの名前は C<use charnames> の C<:alias> インポート引数で
定義されますが、C<$^H{charnames}> にインストールされた変換器で
定義されているかも知れません。
L<charnames/CUSTOM ALIASES> を参照してください。

=item charnames alias definitions may not contain trailing white-space;
marked by S<<-- HERE> in %s

=begin original

(F) You defined a character name which ended in a space
character.  Remove the trailing space(s).  Usually these names are
defined in the C<:alias> import argument to C<use charnames>, but they
could be defined by a translator installed into C<$^H{charnames}>.
See L<charnames/CUSTOM ALIASES>.

=end original

(D) スペース文字で終わる文字名を定義しました。
末尾のスペースを取り除いてください。
普通はこれらの名前は C<use charnames> の C<:alias> インポート引数で
定義されますが、C<$^H{charnames}> にインストールされた変換器で
定義されているかも知れません。
L<charnames/CUSTOM ALIASES> を参照してください。

=item chdir() on unopened filehandle %s

=begin original

(W unopened) You tried chdir() on a filehandle that was never opened.

=end original

(W unopened) 開いていないファイルハンドルに対して chdir() しようとしました。

=item "\c%c" is more clearly written simply as "%s"

=begin original

(W syntax) The C<\cI<X>> construct is intended to be a way to specify
non-printable characters.  You used it for a printable one, which
is better written as simply itself, perhaps preceded by a backslash
for non-word characters.  Doing it the way you did is not portable
between ASCII and EBCDIC platforms.

=end original

(W syntax) C<\cI<X>> 構文は非表示文字を指定する方法を意図しています。
これを表示文字に使いました; おそらく(おそらく非単語文字のために
逆スラッシュを前に付けて)単にその文字自身を書くほうがよいです。
この方法ですると ASCII と EBCDIC のプラットフォーム間で移植性がありません。

=item Cloning substitution context is unimplemented

=begin original

(F) Creating a new thread inside the C<s///> operator is not supported.

=end original

(F) C<s///> 演算子の中での新しいスレッドの作成は非対応です。

=item closedir() attempted on invalid dirhandle %s

=begin original

(W io) The dirhandle you tried to close is either closed or not really
a dirhandle.  Check your control flow.

=end original

(W io) 閉じようとしたディレクトリハンドルは既に閉じられているか、実際には
ディレクトリハンドルではありません。
制御フローをチェックしてください。

=item close() on unopened filehandle %s

=begin original

(W unopened) You tried to close a filehandle that was never opened.

=end original

(W unopened) オープンされていないファイルハンドルをクローズしようとしました。

=item Closure prototype called

=begin original

(F) If a closure has attributes, the subroutine passed to an attribute
handler is the prototype that is cloned when a new closure is created.
This subroutine cannot be called.

=end original

(F) クロージャに属性があると、属性ハンドラに渡されるサブルーチンは、新しい
クロージャが作成されたときにクローン化されたプロトタイプです。
このサブルーチンは呼び出すことができません。

=item \C no longer supported in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) The \C character class used to allow a match of single byte
within a multi-byte utf-8 character, but was removed in v5.24 as
it broke encapsulation and its implementation was extremely buggy.
If you really need to process the individual bytes, you probably
want to convert your string to one where each underlying byte is
stored as a character, with utf8::encode().

=end original

(F) \C 文字クラスは、複数バイトの UTF8 文字の単一のバイトに
マッチングできるようにしていましたが、
カプセル化を壊し、その実装が極めてバグっぽいので、v5.24 で削除されました。
本当に個々のバイトを処理する必要があるなら、
おそらくその文字列を、utf8::encode() を使って、
元となっているバイトそれぞれを文字として保持する文字列に変換した方が
良いでしょう。

=item Code missing after '/'

=begin original

(F) You had a (sub-)template that ends with a '/'.  There must be
another template code following the slash.  See L<perlfunc/pack>.

=end original

(F) テンプレートが '/' で終わっています。
スラッシュの後には他のテンプレートコードが必須です。
L<perlfunc/pack> を参照してください。

=item Code point 0x%X is not Unicode, and not portable

=begin original

(S non_unicode portable) You had a code point that has never been in any
standard, so it is likely that languages other than Perl will NOT
understand it.  This code point also will not fit in a 32-bit word on
ASCII platforms and therefore is non-portable between systems.


=end original

(S non_unicode portable) どのような標準でもない符号位置を使いました; 従って
これはおそらく Perl 以外の言語では理解できないでしょう。
この符号位置はまた、ASCII プラットフォームの 32 ビットワードに収まらないので、
システム間で移植性がありません。

=begin original

At one time, it was legal in some standards to have code points up to
0x7FFF_FFFF, but not higher, and this code point is higher.

=end original

一時期、一部の標準では 0x7FFF_FFFF までの符号位置は正当でしたが、
それ以上はそうではありません; そしてこの符号位置はそれ以上です。

=begin original

Acceptance of these code points is a Perl extension, and you should
expect that nothing other than Perl can handle them; Perl itself on
EBCDIC platforms before v5.24 does not handle them.

=end original

このような符号位置を受け付けるのは Perl の拡張で、Perl 以外が
これらを扱えるかについて何も想定するべきではありません;
v5.24 以前の EBCDIC プラットフォームでは Perl 自身もこれらを扱えません。

=begin original

Perl also makes no guarantees that the representation of these code
points won't change at some point in the future, say when machines
become available that have larger than a 64-bit word.  At that time,
files containing any of these, written by an older Perl might require
conversion before being readable by a newer Perl.

=end original

Perl はまた、将来のある時点、例えばマシンが 64 ビットワード以上を
利用可能になったときに、これらの符号位置の表現が変更されないことについて
保証しません。
この時点で、より古い Perl で書かれた、このようなものをファイルは、
より新しい Perl で読み込めるようにする前に変換が必要です。

=item Code point 0x%X is not Unicode, may not be portable

=begin original

(S non_unicode) You had a code point above the Unicode maximum
of U+10FFFF.

=end original

(S non_unicode) Unicode の最大である U+10FFFF を超えた符号位置です。

=begin original

Perl allows strings to contain a superset of Unicode code points, but
these may not be accepted by other languages/systems.  Further, even if
these languages/systems accept these large code points, they may have
chosen a different representation for them than the UTF-8-like one that
Perl has, which would mean files are not exchangeable between them and
Perl.

=end original

Perl は Unicode 符号位置の上位集合を含む文字列を受け入れますが、
これらは他の言語/システムは受け入れないかもしれません。
さらに、たとえこれらの言語/システムがこれらの大きな符号位置を
受け入れたとしても、それらは Perl の UTF-8 風のものと
ことなる表現を選ぶかもしれず、その場合それらと Perl の間でファイルが
交換できないことを意味します。

=begin original

On EBCDIC platforms, code points above 0x3FFF_FFFF have a different
representation in Perl v5.24 than before, so any file containing these
that was written before that version will require conversion before
being readable by a later Perl.

=end original

EBCDIC プラットフォームでは、Perl 5.24 では 0x3FFF_FFFF より上の符号位置は
以前と異なった表現となっているので、このバージョンより前に書かれた
これらを含むファイルは、それ以降の Perl で読み込み可能にする前に
変換が必要です。

=item %s: Command not found

=begin original

(A) You've accidentally run your script through B<csh> or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like

=end original

(A) スクリプトを perl ではなく B<csh> またはその他のシェルで
実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。
ファイルの先頭の #! 行は以下のようにします

  #!/usr/bin/perl

=item %s: command not found

=begin original

(A) You've accidentally run your script through B<bash> or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like

=end original

(A) 誤ってスクリプトを Perl ではなく B<bash> やその他のシェルに渡しました。
#! 行を確認するか、スクリプトを手動で Perl 自身に渡してください。
ファイルの先頭の #! 行は次のような形です:

  #!/usr/bin/perl

=item %s: command not found: %s

=begin original

(A) You've accidentally run your script through B<zsh> or another shell
instead of Perl.  Check the #! line, or manually feed your script into
Perl yourself.  The #! line at the top of your file could look like

=end original

(A) 誤ってスクリプトを Perl ではなく B<zsh> やその他のシェルに渡しました。
#! 行を確認するか、スクリプトを手動で Perl 自身に渡してください。
ファイルの先頭の #! 行は次のような形です:

  #!/usr/bin/perl

=item Compilation failed in require

=begin original

(F) Perl could not compile a file specified in a C<require> statement.
Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.

=end original

(F) Perl は C<require> 文で指定されたファイルをコンパイルできませんでした。
Perl は、コンパイルを直ちに停止させるほど厳しいエラーに遭遇しなかった
ときに、この一般的なメッセージを使います。

=item Complex regular subexpression recursion limit (%d) exceeded

=begin original

(W regexp) The regular expression engine uses recursion in complex
situations where back-tracking is required.  Recursion depth is limited
to 32766, or perhaps less in architectures where the stack cannot grow
arbitrarily.  ("Simple" and "medium" situations are handled without
recursion and are not subject to a limit.)  Try shortening the string
under examination; looping in Perl code (e.g. with C<while>) rather than
in the regular expression engine; or rewriting the regular expression so
that it is simpler or backtracks less.  (See L<perlfaq2> for information
on I<Mastering Regular Expressions>.)

=end original

(W regexp) 正規表現エンジンはバックトラックが要求される複雑な状況では
再帰を使用します。
再帰の深さは 32766、またはスタックを任意に増やせないアーキテクチャでは
おそらくもっと小さい値に制限されています。
(「単純な」または「中くらいの」状況では再帰なしで扱われるので、制限は
ありません。)
調べる文字列を短くしてみてください; 正規表現エンジンではなく
(C<while> などの) Perl コードを使ってループするか、
あるいは正規表現をより単純にしたり、バックトラックが少なくなるように
書き換えてください。
(I<Mastering Regular Expressions> の情報については L<perlfaq2> を
参照してください。)

=item connect() on closed socket %s

=begin original

(W closed) You tried to do a connect on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/connect>.

=end original

(W closed) クローズされたソケットに connent を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/connect> を参照してください。

=item Constant(%s): Call to &{$^H{%s}} did not return a defined value

=begin original

(F) The subroutine registered to handle constant overloading
(see L<overload>) or a custom charnames handler (see
L<charnames/CUSTOM TRANSLATORS>) returned an undefined value.

=end original

(F) 定数オーバーロード (L<overload> 参照) を扱うために登録された
サブルーチンや、カスタム文字名ハンドラ
(L<charnames/CUSTOM TRANSLATORS> 参照) が未定義値を返しました。

=item Constant(%s): $^H{%s} is not defined

=begin original

(F) The parser found inconsistencies while attempting to define an
overloaded constant.  Perhaps you forgot to load the corresponding
L<overload> pragma?

=end original

(F) パーサは、オーバーロード定数を定義しようとしたときに矛盾を発見しました。
おそらく対応する L<overload> プラグマを読み込むのを忘れたのでは?

=item Constant is not %s reference

=begin original

(F) A constant value (perhaps declared using the C<use constant> pragma)
is being dereferenced, but it amounts to the wrong type of reference.
The message indicates the type of reference that was expected.  This
usually indicates a syntax error in dereferencing the constant value.
See L<perlsub/"Constant Functions"> and L<constant>.

=end original

(F) (おそらく C<use constant> プラグマを使って宣言した) 定数値が
デリファレンスされましたが、間違った型のリファレンスになりました。
このメッセージは想定されたリファレンスの型を示しています。
これは普通定数値をデリファレンスするときの文法エラーを示しています。
L<perlsub/"Constant Functions"> と L<constant> を参照してください。

=item Constants from lexical variables potentially modified elsewhere are no longer permitted

=begin original

(F) You wrote something like

=end original

(F) 次のようなものを書きましたが

    my $var;
    $sub = sub () { $var };

=begin original

but $var is referenced elsewhere and could be modified after the C<sub>
expression is evaluated.  Either it is explicitly modified elsewhere
(C<$var = 3>) or it is passed to a subroutine or to an operator like
C<printf> or C<map>, which may or may not modify the variable.

=end original

$var はどこか別の場所へのリファレンスで、
C<sub> 式が評価された後に変更されるかもしれません。
どこかで明示的に変更されたり、(C<$var = 3>) 、
変数を変更するかどうかわからない、
C<printf> や C<map> のようなサブルーチンや演算子に渡されたりします。

=begin original

Traditionally, Perl has captured the value of the variable at that
point and turned the subroutine into a constant eligible for inlining.
In those cases where the variable can be modified elsewhere, this
breaks the behavior of closures, in which the subroutine captures
the variable itself, rather than its value, so future changes to the
variable are reflected in the subroutine's return value.

=end original

伝統的に、Perl はこの時点で変数の値を捕捉して、
サブルーチンをインライン化可能な定数に変換します。
変数が別の場所で変更可能な場合、
これは、サブルーチンが変数の値ではなく変数自体を捕捉しているので
クロージャの振る舞いを壊します。
従って、将来この変数を変更すると、サブルーチンの返り値に反映されます。

=begin original

This usage was deprecated, and as of Perl 5.32 is no longer allowed,
making it possible to change the behavior in the future.

=end original

この使用法は廃止予定になり、Perl 5.32 でもはや許されなくなりました。
これにより将来振る舞いを換えることが可能になります。

=begin original

If you intended for the subroutine to be eligible for inlining, then
make sure the variable is not referenced elsewhere, possibly by
copying it:

=end original

サブルーチンをインライン化可能にするのが目的なら、この変数を、
おそらくコピーすることで、他のどこからも参照されないようにしてください:

    my $var2 = $var;
    $sub = sub () { $var2 };

=begin original

If you do want this subroutine to be a closure that reflects future
changes to the variable that it closes over, add an explicit C<return>:

=end original

このサブルーチンを、これを閉じた後の将来の変数の変更を反映させる
クロージャにしたいなら、明示的な C<return> を追加してください:

    my $var;
    $sub = sub () { return $var };

=item Constant subroutine %s redefined

=begin original

(W redefine)(S) You redefined a subroutine which had previously
been eligible for inlining.  See L<perlsub/"Constant Functions">
for commentary and workarounds.

=end original

(W redefine)(S) 以前にインライン化できる形であったサブルーチンを
再定義しました。
コメントと回避策については L<perlsub/"Constant Functions"> を
参照してください。

=item Constant subroutine %s undefined

=begin original

(W misc) You undefined a subroutine which had previously been eligible
for inlining.  See L<perlsub/"Constant Functions"> for commentary and
workarounds.

=end original

(W misc)以前にインライン化できる形であったサブルーチンを
未定義化しました。
コメントと回避策については L<perlsub/"Constant Functions"> を
参照してください。

=item Constant(%s) unknown

=begin original

(F) The parser found inconsistencies either while attempting
to define an overloaded constant, or when trying to find the
character name specified in the C<\N{...}> escape.  Perhaps you
forgot to load the corresponding L<overload> pragma?

=end original

(F) パーサは、オーバーロードされた定数を定義しようとしたときか、
C<\N{...}> エスケープで指定された文字名の検索中に矛盾を
発見しました。
おそらく対応する L<overload> プラグマを読み込むのを忘れたのでは?

=item :const is experimental

=begin original

(S experimental::const_attr) The "const" attribute is experimental.
If you want to use the feature, disable the warning with C<no warnings
'experimental::const_attr'>, but know that in doing so you are taking
the risk that your code may break in a future Perl version.

=end original

(S experimental::const_attr) "const" 属性は実験的です。
この機能を使いたい場合、
C<no warnings 'experimental::const_attr'> で警告を無効にしてください;
しかし、そうすることであなたのコードが将来の Perl のバージョンで
壊れるリスクを取ることになります。

=item :const is not permitted on named subroutines

=begin original

(F) The "const" attribute causes an anonymous subroutine to be run and
its value captured at the time that it is cloned.  Named subroutines are
not cloned like this, so the attribute does not make sense on them.

=end original

(F) The "const" 属性は、クローンされたときに値を捕捉された
無名サブルーチンになります。
名前付きサブルーチンはこのようにクローンされないので、
属性はこれらに関して意味を持ちません。

=item Copy method did not return a reference

=begin original

(F) The method which overloads "=" is buggy.  See
L<overload/Copy Constructor>.

=end original

(F) "=" をオーバーロードしたメソッドはバグっています。
L<overload/Copy Constructor> を参照してください。

=item &CORE::%s cannot be called directly

=begin original

(F) You tried to call a subroutine in the C<CORE::> namespace
with C<&foo> syntax or through a reference.  Some subroutines
in this package cannot yet be called that way, but must be
called as barewords.  Something like this will work:

=end original

(F) C<CORE::> 名前空間のサブルーチンを C<&foo> 文法またはリファレンス経由で
呼び出そうとしました。
このパッケージの一部のサブルーチンはまだこの方法では呼び出せず、裸の単語で
呼び出さなければなりません。
以下のようなものは動作します:

    BEGIN { *shove = \&CORE::push; }
    shove @array, 1,2,3; # pushes on to @array

=item CORE::%s is not a keyword

=begin original

(F) The CORE:: namespace is reserved for Perl keywords.

=end original

(F) CORE:: 名前空間は Perl キーワードとして予約されています。

=item Corrupted regexp opcode %d > %d

=begin original

(P) This is either an error in Perl, or, if you're using
one, your L<custom regular expression engine|perlreapi>.  If not the
latter, report the problem to L<https://github.com/Perl/perl5/issues>.

=end original

(P) これは Perl か、あるいは、使っているなら
L<カスタム正規表現エンジン|perlreapi> のエラーです。
後者でなければ、L<https://github.com/Perl/perl5/issues> に
問題を報告してください。

=item corrupted regexp pointers

=begin original

(P) The regular expression engine got confused by what the regular
expression compiler gave it.

=end original

(P) 正規表現コンパイラが渡したもので、正規表現エンジンが
処理できなくなりました。

=item corrupted regexp program

=begin original

(P) The regular expression engine got passed a regexp program without a
valid magic number.

=end original

(P) 正規表現エンジンが、有効なマジックナンバーを持たない
regexp プログラムを渡しました。

=item Corrupt malloc ptr 0x%x at 0x%x

=begin original

(P) The malloc package that comes with Perl had an internal failure.

=end original

(P) Perl に付属の malloc ルーティンが内部エラーを起こしました。

=item Count after length/code in unpack

=begin original

(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
L<perlfunc/pack>.

=end original

(F) unpack のテンプレートとしてカウント長文字列を示していますが、
文字列の長さも明示的に指定しています。
L<perlfunc/pack> を参照してください。

=item Declaring references is experimental

=begin original

(S experimental::declared_refs) This warning is emitted if you use
a reference constructor on the right-hand side of C<my>, C<state>, C<our>, or
C<local>.  Simply suppress the warning if you want to use the feature, but
know that in doing so you are taking the risk of using an experimental
feature which may change or be removed in a future Perl version:

=end original

(S experimental::declared_refs) C<my>, C<state>, C<our>, C<local> の右側で
リファレンスコンストラクタを使うとこの警告が出力されます。
この機能を使いたい場合は単にこの警告を抑制してください; ただし
そうすることによってあなたは将来のバージョンの Perl で変更したり
削除されたりするかもしれない実験的な機能を使うというリスクを
取っていると言うことを知っておいてください:

    no warnings "experimental::declared_refs";
    use feature "declared_refs";
    $fooref = my \$foo;

=for comment
The following are used in lib/diagnostics.t for testing two =items that
share the same description.  Changes here need to be propagated to there

=item Deep recursion on anonymous subroutine

=item Deep recursion on subroutine "%s"

=begin original

(W recursion) This subroutine has called itself (directly or indirectly)
100 times more than it has returned.  This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.

=end original

(W recursion) このサブルーチンは、(直接、間接に) 自分自身の呼び出しを、
return より 100 回多く行ないました。
変わったベンチマークプログラムを書いているのでなければ、無限再帰の
可能性があります; ベンチマークを書いている場合には、別のことを示しています。

=begin original

This threshold can be changed from 100, by recompiling the F<perl> binary,
setting the C pre-processor macro C<PERL_SUB_DEPTH_WARN> to the desired value.

=end original

この閾値は、C プリプロセッサマクロ C<PERL_SUB_DEPTH_WARN> を希望の値に
設定して F<perl> バイナリを再コンパイルすることで、100 から変更できます。

=item (?(DEFINE)....) does not allow branches in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) You used something like C<(?(DEFINE)...|..)> which is illegal.  The
most likely cause of this error is that you left out a parenthesis inside
of the C<....> part.

=end original

(F) 不正な形の C<(?(DEFINE)...|..)> のようなものを使いました。
このエラーの、もっともありそうな理由は、C<....> パートの中のかっこを
そのままにしたことです。

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item %s defines neither package nor VERSION--version check failed

=begin original

(F) You said something like "use Module 42" but in the Module file
there are neither package declarations nor a C<$VERSION>.

=end original

(F) "use Module 42" のようなことをしましたが、Module ファイルに
パッケージ定義がないか、C<$VERSION> がありませんでした。

=item delete argument is not a HASH or ARRAY element or slice

=begin original

(F) The argument to C<delete> must be either a hash or array element,
such as:

=end original

(F) C<delete> の引数は以下のようにハッシュか配列の要素であるか:

    $foo{$bar}
    $ref->{"susie"}[12]

=begin original

or a hash or array slice, such as:

=end original

あるいは以下のようにハッシュか配列のスライスか:

    @foo[$bar, $baz, $xyzzy]
    @{$ref->[12]}{"susie", "queue"}

=begin original

or a hash key/value or array index/value slice, such as:

=end original

あるいは以下のようにハッシュのキー/値や配列のインデックス/値で
なければなりません:

    %foo[$bar, $baz, $xyzzy]
    %{$ref->[12]}{"susie", "queue"}

=item Delimiter for here document is too long

=begin original

(F) In a here document construct like C<<<FOO>, the label C<FOO> is too
long for Perl to handle.  You have to be seriously twisted to write code
that triggers this error.

=end original

(F) C<<<FOO> のようなヒアドキュメント構造で、ラベル C<FOO> が
Perl が扱うには長すぎました。
このエラーを起こすようなコードを書くには相当ひねくれている必要があります。

=item Deprecated use of my() in false conditional. This will be a fatal error in Perl 5.30

=begin original

(D deprecated) You used a declaration similar to C<my $x if 0>.  There
has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.  You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg

=end original

(D deprecated) C<my $x if 0> のような定義を行いました。
これは、宣言に偽の条件を含んでいるとスコープから外れた際にレキシカル変数が
クリアされないという、Perl に長い間存在したバグです。
ある種の静的変数を実現するためにこのバグを悪用する人々もいます。
私たちはこのバグを修正するつもりなので、人々がこの振る舞いに依存して
ほしくありません。
関数外の別のブロックで変数を宣言することで似たような静的な効果を
達成できます; 例えば:

    sub f { my $x if 0; return $x++ }

=begin original

becomes

=end original

これは以下のようにします:

    { my $x; sub f { return $x++ } }

=begin original

Beginning with perl 5.10.0, you can also use C<state> variables to have
lexicals that are initialized only once (see L<feature>):

=end original

perl 5.10.0 から、一度だけ初期化されるレキシカルとして C<state> 変数も
使えます (L<feature> を参照してください):

    sub f { state $x; return $x++ }

=begin original

This use of C<my()> in a false conditional has been deprecated since
Perl 5.10, and it will become a fatal error in Perl 5.30.

=end original

偽の条件での C<my()> のこの使用法は Perl 5.10 から廃止予定で、
Perl 5.30 で致命的エラーになる予定です。

=item DESTROY created new reference to dead object '%s'

=begin original

(F) A DESTROY() method created a new reference to the object which is
just being DESTROYed.  Perl is confused, and prefers to abort rather
than to create a dangling reference.

=end original

(F) DESTROY() メソッドが、DESTROY したばかりのオブジェクトへの
新しいリファレンスを作りました。
Perl は混乱して、不明瞭なリファレンスを作るよりは中断することを選びました。

=item Did not produce a valid header

=begin original

See L</500 Server error>.

=end original

L</500 Server error> を参照してください。

=item %s did not return a true value

=begin original

(F) A required (or used) file must return a true value to indicate that
it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a "1;", though any true value would
do.  See L<perlfunc/require>.

=end original

(F) require (や use) されたファイルは、正常にコンパイルされ、
初期化コードを正しく実行したことを示すために、真を返さなければなりません。
こういったファイルは、"1;" で終わるようにするのが習慣ですが、
真となる値であれば、何でもかまいません。
L<perlfunc/require> を参照してください。

=item (Did you mean &%s instead?)

=begin original

(W misc) You probably referred to an imported subroutine &FOO as $FOO or
some such.

=end original

(W misc) おそらく import したサブルーチン &FOO を $FOO として
参照したようなことでしょう。

=item (Did you mean "local" instead of "our"?)

=begin original

(W shadow) Remember that "our" does not localize the declared global
variable.  You have declared it again in the same lexical scope, which
seems superfluous.

=end original

(W shadow) "our" 宣言されたグローバル変数を local 化しないことを
忘れないで下さい。
これをもう一度同じレキシカルスコープで宣言していますが、
不必要でしょう。

=item (Did you mean $ or @ instead of %?)

=begin original

(W) You probably said %hash{$key} when you meant $hash{$key} or
@hash{@keys}.  On the other hand, maybe you just meant %hash and got
carried away.

=end original

(W) おそらく $hash{$key} か @hash{@keys} としたいときに %hash{$key} と
したのでしょう。
あるいは、単に %hash としたくてやりすぎたのでしょう。

=item Died

=begin original

(F) You passed die() an empty string (the equivalent of C<die "">) or
you called it with no args and C<$@> was empty.

=end original

(F) die() に空文字列を渡した(C<die ""> と等価です)か、引数なしで
呼び出して、C<$@> が空でした。

=item Document contains no data

=begin original

See L</500 Server error>.

=end original

L</500 Server error> を参照してください。

=item %s does not define %s::VERSION--version check failed

=begin original

(F) You said something like "use Module 42" but the Module did not
define a C<$VERSION>.

=end original

(F) "use Module 42" のようなことをしましたが、Module は C<$VERSION> を
定義していません。

=item '/' does not take a repeat count

=begin original

(F) You cannot put a repeat count of any kind right after the '/' code.
See L<perlfunc/pack>.

=end original

(F) '/' の直後には繰り返し数を指定できません。
L<perlfunc/pack> を参照してください。

=item do "%s" failed, '.' is no longer in @INC; did you mean do "./%s"?

=begin original

(D deprecated) Previously C< do "somefile"; > would search the current
directory for the specified file.  Since perl v5.26.0, F<.> has been
removed from C<@INC> by default, so this is no longer true.  To search the
current directory (and only the current directory) you can write
C< do "./somefile"; >.

=end original

(D deprecated) 以前は、C< do "somefile"; > は指定されたファイルを
カレントディレクトリから探していました。
perl v5.26.0 から、デフォルトで C<@INC> から F<.> 削除されたので、
これはもはや真ではありません。
カレントディレクトリを(カレントディレクトリだけを)探すためには、
C< do "./somefile"; > と書けます。

=item Don't know how to get file name

=begin original

(P) C<PerlIO_getname>, a perl internal I/O function specific to VMS, was
somehow called on another platform.  This should not happen.

=end original

(P) VMS 固有の perl 内部 I/O 関数である C<PerlIO_getname> がなぜか
他のプラットフォームで呼び出されました。
これは起きないはずです。

=item Don't know how to handle magic of type \%o

=begin original

(P) The internal handling of magical variables has been cursed.

=end original

(P) マジカル変数の内部処理がおかしくなっています。

=item do_study: out of memory

=begin original

(P) This should have been caught by safemalloc() instead.

=end original

(P) これは、本来 safemalloc() で引っ掛かるはずのものです。

=item (Do you need to predeclare %s?)

=begin original

(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
"sub", "package", "require", or "use" statement.  If you're referencing
something that isn't defined yet, you don't actually have to define the
subroutine or package before the current location.  You can use an empty
"sub foo;" or "package FOO;" to enter a "forward" declaration.

=end original

(S syntax) これは "%s found where operator expected" メッセージと共に
表示される教育的な推測です。
これはしばしばサブルーチンやモジュール名がまだ宣言される前に参照されている
ことを意味します。
これはファイル内部での順番のためであったり、"sub", "package", "require",
"use" 文がないためであったりします。
もしまだ定義されていないものを参照したい場合、現在位置より前に実際に
サブルーチンやパッケージを定義する必要はありません。
空の "sub foo;" や "package FOO;" を「前方」宣言として使えます。

=item dump() must be written as CORE::dump() as of Perl 5.30

=begin original

(F) You used the obsolete C<dump()> built-in function.  That was deprecated in
Perl 5.8.0.  As of Perl 5.30 it must be written in fully qualified format:
C<CORE::dump()>.

=end original

(F) 古いものである C<dump()> 組み込み関数を使いました。
これは Perl 5.8.0 から廃止予定でした。
Perl 5.30 から、これは C<CORE::dump()> というように完全修飾形式で
書かなければなりません。

=begin original

See L<perlfunc/dump>.

=end original

L<perlfunc/dump> を参照してください。

=item dump is not supported

=begin original

(F) Your machine doesn't support dump/undump.

=end original

(F) このマシンは dump/undump に対応していません。

=item Duplicate free() ignored

=begin original

(S malloc) An internal routine called free() on something that had
already been freed.

=end original

(S malloc) 既に解放されているものに対して、内部ルーティンが free() を
行なおうとしました。

=item Duplicate modifier '%c' after '%c' in %s

=begin original

(W unpack) You have applied the same modifier more than once after a
type in a pack template.  See L<perlfunc/pack>.

=end original

(W unpack) pack テンプレートで、一つの型の後に同じ修飾子を複数指定しました。
L<perlfunc/pack> を参照してください。

=item elseif should be elsif

=begin original

(S syntax) There is no keyword "elseif" in Perl because Larry thinks
it's ugly.  Your code will be interpreted as an attempt to call a method
named "elseif" for the class returned by the following block.  This is
unlikely to be what you want.

=end original

(S) Larry は "elseif" というのは醜いと考えたので、Perl にはこのキーワードは
ありません。
このコードは引き続くブロックによって返されたクラスの "elseif" メソッドを
呼び出そうとしていると解釈されます。
これは望んでいることではないはずです。

=item Empty \%c in regex; marked by S<<-- HERE> in m/%s/

=item Empty \%c{}

=item Empty \%c{} in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You used something like C<\b{}>, C<\B{}>, C<\o{}>, C<\p>, C<\P>, or
C<\x> without specifying anything for it to operate on.

=end original

(F) 何を操作するかを指定せずに
C<\b{}>, C<\B{}>, C<\o{}>, C<\p>, C<\P>, C<\x> のようなものを使いました。

=begin original

Unfortunately, for backwards compatibility reasons, an empty C<\x> is
legal outside S<C<use re 'strict'>> and expands to a NUL character.

=end original

残念ながら、後方互換性のために、S<C<use re 'strict'>> の外側での空の
C<\x> は正当で、一つの NUL 文字に展開されます。

=item Empty (?) without any modifiers in regex; marked by <-- HERE in m/%s/

=begin original

(W regexp) (only under C<S<use re 'strict'>>)
C<(?)> does nothing, so perhaps this is a typo.

=end original

(W regexp) (C<S<use re 'strict'>> の下のみ)
C<(?)> は何もしません; 従ってこれはおそらくタイプミスです。

=item ${^ENCODING} is no longer supported

=begin original

(F) The special variable C<${^ENCODING}>, formerly used to implement
the C<encoding> pragma, is no longer supported as of Perl 5.26.0.

=end original

(F) 以前は C<encoding> プラグマの実装に使われていた
特殊変数 C<${^ENCODING}> は、Perl 5.26.0 からもはや対応されません。

=begin original

Setting it to anything other than C<undef> is a fatal error as of Perl
5.28.

=end original

これに C<undef> 以外のものを設定すると Perl 5.28 から致命的エラーが出ます。

=item entering effective %s failed

=begin original

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=end original

(F) C<use filetest> プラグマを使っている間に、
実と実効の UID や GID の切り替えに失敗しました。

=item %ENV is aliased to %s

=begin original

(F) You're running under taint mode, and the C<%ENV> variable has been
aliased to another hash, so it doesn't reflect anymore the state of the
program's environment.  This is potentially insecure.

=end original

(F) 汚染モードで動作していて、C<%ENV> 変数が他のハッシュへのエイリアスに
なっているので、これ以上プログラムの環境の状態を反映しません。
これは潜在的にはセキュアではありません。

=item Error converting file specification %s

=begin original

(F) An error peculiar to VMS.  Because Perl may have to deal with file
specifications in either VMS or Unix syntax, it converts them to a
single form when it must operate on them directly.  Either you've passed
an invalid file specification to Perl, or you've found a case the
conversion routines don't handle.  Drat.

=end original

(F) VMS に固有のエラーです。
Perl はファイル仕様を VMS 式か Unix 式かどちらかで扱わなければならないので、
直接操作しなければならない場合は変換します。
不正なファイル仕様を Perl に渡したか、変換ルーチンが扱えないパターンを
発見したかです。
ちぇっ。

=item Eval-group in insecure regular expression

=begin original

(F) Perl detected tainted data when trying to compile a regular
expression that contains the C<(?{ ... })> zero-width assertion, which
is unsafe.  See L<perlre/(?{ code })>, and L<perlsec>.

=end original

C<(?{ ... })> ゼロ幅アサーションを含む正規表現をコンパイルしようと
したときに、Perl は汚染されたデータを検出しました;
これは安全ではありません。
L<perlre/(?{ code })> と L<perlsec> を参照してください。

=item Eval-group not allowed at runtime, use re 'eval' in regex m/%s/

=begin original

(F) Perl tried to compile a regular expression containing the
C<(?{ ... })> zero-width assertion at run time, as it would when the
pattern contains interpolated values.  Since that is a security risk,
it is not allowed.  If you insist, you may still do this by using the
C<re 'eval'> pragma or by explicitly building the pattern from an
interpolated string at run time and using that in an eval().  See
L<perlre/(?{ code })>.

=end original

(F) Perl が実行時に、変数展開された値を含んでいて、
C<(?{ ... })> ゼロ幅アサーションを含む正規表現をコンパイルしようとしました。
これはセキュリティ上の危険があるので、許可されていません。
どうしても実行したい場合は、C<re 'eval'> プラグマを使うか実行時に
変数展開された文字列からパターンを作成して、それを eval() の中で使うことで
実行できます。
L<perlre/(?{ code })> を参照してください。

=item Eval-group not allowed, use re 'eval' in regex m/%s/

=begin original

(F) A regular expression contained the C<(?{ ... })> zero-width
assertion, but that construct is only allowed when the C<use re 'eval'>
pragma is in effect.  See L<perlre/(?{ code })>.

=end original

(F) 正規表現に C<(?{ ... })> ゼロ幅アサーションを含んでいますが、
この構造は C<use re 'eval'> プラグマが有効の場合にのみ許可されます。
L<perlre/(?{ code })> を参照してください。

=item EVAL without pos change exceeded limit in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) You used a pattern that nested too many EVAL calls without consuming
any text.  Restructure the pattern so that text is consumed.

=end original

(F) テキストを一切読み込むことなく、EVAL 呼び出しのネストが多すぎる
パターンを使いました。
テキストを読み込むようにパターンを再構築してください。

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Excessively long <> operator

=begin original

(F) The contents of a <> operator may not exceed the maximum size of a
Perl identifier.  If you're just trying to glob a long list of
filenames, try using the glob() operator, or put the filenames into a
variable and glob that.

=end original

(F) <> 演算子の内容は Perl 識別子の最大サイズを越えることはできません。
単にファイル名の長いリストをグロブしようとしただけなら、glob() 演算子を
使うか、ファイル名を変数に入れて、それをグロブしてください。

=item exec? I'm not *that* kind of operating system

=begin original

(F) The C<exec> function is not implemented on some systems, e.g., Symbian
OS.  See L<perlport>.

=end original

(F) C<exec> 関数は Symbian OS のような一部のシステムには実装されていません。
L<perlport> を参照してください。

=item %sExecution of %s aborted due to compilation errors.

=begin original

(F) The final summary message when a Perl compilation fails.

=end original

(F) Perl のコンパイルが失敗したときの、最後のまとめメッセージです。

=item exists argument is not a HASH or ARRAY element or a subroutine

=begin original

(F) The argument to C<exists> must be a hash or array element or a
subroutine with an ampersand, such as:

=end original

(F) C<exists> の引数は以下のように、ハッシュや配列の要素か、
アンパサンド付きのサブルーチンでなければなりません:

    $foo{$bar}
    $ref->{"susie"}[12]
    &do_something

=item exists argument is not a subroutine name

=begin original

(F) The argument to C<exists> for C<exists &sub> must be a subroutine name,
and not a subroutine call.  C<exists &sub()> will generate this error.

=end original

(F) C<exists &sub> での C<exists> への引数はサブルーチン名でなければならず、
サブルーチン呼び出しではありません。
C<exists &sub()> はこのエラーを生成します。

=item Exiting eval via %s

=begin original

(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.

=end original

(W exiting) goto やループ制御文など、おかしな方法で eval を抜けました。

=item Exiting format via %s

=begin original

(W exiting) You are exiting a format by unconventional means, such as a
goto, or a loop control statement.

=end original

(W exiting) goto やループ制御文といった、異例な形でフォーマットを
終了しました。

=item Exiting pseudo-block via %s

=begin original

(W exiting) You are exiting a rather special block construct (like a
sort block or subroutine) by unconventional means, such as a goto, or a
loop control statement.  See L<perlfunc/sort>.

=end original

(W exiting) (ソートブロックやサブルーチンのような) 特別なブロック構造を、
goto やループ制御文といった異例な方法で終了しました。
L<perlfunc/sort> を参照してください。

=item Exiting subroutine via %s

=begin original

(W exiting) You are exiting a subroutine by unconventional means, such
as a goto, or a loop control statement.

=end original

(W exiting) goto やループ制御文など、おかしな方法でサブルーチンを
抜けました。

=item Exiting substitution via %s

=begin original

(W exiting) You are exiting a substitution by unconventional means, such
as a return, a goto, or a loop control statement.

=end original

(W exit) return や goto やループ制御文など、おかしな方法で置換を
抜けました。

=item Expecting close bracket in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You wrote something like

=end original

(F) 以下のようなものを書きました

 (?13

=begin original

to denote a capturing group of the form
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>,
but omitted the C<")">.

=end original

to denote a capturing group of the form
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)> 形式の
捕捉グループを示していますが C<")"> が省略されています。

=item Expecting interpolated extended charclass in regex; marked by <--
HERE in m/%s/

=begin original

(F) It looked like you were attempting to interpolate an
already-compiled extended character class, like so:

=end original

(F) 次のように、既にコンパイルされている拡張文字クラスを結合しようと
したように見えます:

 my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
 ...
 qr/(?[ \p{Digit} & $thai_or_lao ])/;

=begin original

But the marked code isn't syntactically correct to be such an
interpolated class.

=end original

しかしマークされたコードは、そのような結合されたクラスとして
文法的に正しくありません。

=item Experimental aliasing via reference not enabled

=begin original

(F) To do aliasing via references, you must first enable the feature:

=end original

(F) リファレンスによる別名をするためには、最初にこの機能を
有効にしなければなりません:

    no warnings "experimental::refaliasing";
    use feature "refaliasing";
    \$x = \$y;

=item Experimental %s on scalar is now forbidden

=begin original

(F) An experimental feature added in Perl 5.14 allowed C<each>, C<keys>,
C<push>, C<pop>, C<shift>, C<splice>, C<unshift>, and C<values> to be called with a
scalar argument.  This experiment is considered unsuccessful, and
has been removed.  The C<postderef> feature may meet your needs better.

=end original

(F) Perl 5.14 で追加された実験的機能は、C<each>, C<keys>,
C<push>, C<pop>, C<shift>, C<splice>, C<unshift>, C<values> を
スカラ引数で呼び出すことができました。
この実験は失敗と考えられ、削除されました。
C<postderef> 機能はあなたの要求により良く一致します。

=item Experimental subroutine signatures not enabled

=begin original

(F) To use subroutine signatures, you must first enable them:

=end original

(F) サブルーチンシグネチャを使うためには、まずそれを有効にしなければなりません:

    no warnings "experimental::signatures";
    use feature "signatures";
    sub foo ($left, $right) { ... }

=item Explicit blessing to '' (assuming package main)

=begin original

(W misc) You are blessing a reference to a zero length string.  This has
the effect of blessing the reference into the package main.  This is
usually not what you want.  Consider providing a default target package,
e.g. bless($ref, $p || 'MyPackage');

=end original

(W misc) リファレンスを長さゼロの文字列に bless しました。
これはリファレンスをパッケージ main に bless する効果があります。
これは普通あなたが望んでいることではありません。
(bless($ref, $p || 'MyPackage'); のように) デフォルトターゲット
パッケージを提供することを考慮してください;

=item %s: Expression syntax

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item %s failed--call queue aborted

=begin original

(F) An untrapped exception was raised while executing a UNITCHECK,
CHECK, INIT, or END subroutine.  Processing of the remainder of the
queue of such routines has been prematurely ended.

=end original

(F) UNITCHECK, CHECK, INIT, END サブルーチンを実行中にトラップされていない
例外が発生しました。
このようなルーチンのキューの残りの処理は途中で終了しました。

=item Failed to close in-place work file %s: %s

=begin original

(F) Closing an output file from in-place editing, as with the C<-i>
command-line switch, failed.

=end original

(F) C<-i> コマンドラインオプションによるその場修正で開いたファイルを
閉じるのに失敗しました。

=item False [] range "%s" in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp)(F) A character class range must start and end at a literal
character, not another character class like C<\d> or C<[:alpha:]>.  The "-"
in your false range is interpreted as a literal "-".  In a C<(?[...])>
construct, this is an error, rather than a warning.  Consider quoting
the "-", "\-".  The S<<-- HERE> shows whereabouts in the regular expression
the problem was discovered.  See L<perlre>.

=end original

(W regexp)(F) 文字クラス範囲の先頭とと末尾は、C<\d> や C<[:alpha:]> のような
他の文字クラスではなく、リテラル文字でなければなりません。
間違った範囲の "-" はリテラルの "-" と解釈されます。
C<(?[...])> 構文では、これは警告ではなくエラーです。
"-" を "\-" とクォートすることを考慮してください。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Fatal VMS error (status=%d) at %s, line %d

=begin original

(P) An error peculiar to VMS.  Something untoward happened in a VMS
system service or RTL routine; Perl's exit status should provide more
details.  The filename in "at %s" and the line number in "line %d" tell
you which section of the Perl source code is distressed.

=end original

(P) VMS に固有のエラーです。
何か都合の悪いことが VMS システムサービスか RTL ルーチンで起こりました;
Perl の終了コードに詳細が示されています。
"at %s" のファイル名と "line %d" の行番号は、問題の起こった
Perl ソースコードの位置を示しています。

=item fcntl is not implemented

=begin original

(F) Your machine apparently doesn't implement fcntl().  What is this, a
PDP-11 or something?

=end original

(F) このマシンでは、fcntl() が実装されていないように見えます。
PDP-11 か何かでしょうか。

=item FETCHSIZE returned a negative value

=begin original

(F) A tied array claimed to have a negative number of elements, which
is not possible.

=end original

(F) tie された配列に対して負の番号の要素を要求されました; これは不可能です。

=item Field too wide in 'u' format in pack

=begin original

(W pack) Each line in an uuencoded string starts with a length indicator
which can't encode values above 63.  So there is no point in asking for
a line length bigger than that.  Perl will behave as if you specified
C<u63> as the format.

=end original

(W pack) uuencode された文字列の各行が、63 以上にエンコードできない
長さ識別子から始まっています。
それで、これより長い行の長さを問い合わせるところがありません。
Perl はフォーマットとして C<u63> が指定されたかのように振る舞います。

=item File::Glob::glob() will disappear in perl 5.30. Use File::Glob::bsd_glob() instead.

=begin original

(D deprecated) C<< File::Glob >> has a function called C<< glob >>, which
just calls C<< bsd_glob >>. However, its prototype is different from the
prototype of C<< CORE::glob >>, and hence, C<< File::Glob::glob >> should
not be used.

=end original

(D deprecated) C<< File::Glob >> は C<< glob >> と呼ばれる関数を持っています;
これは単に C<< bsd_glob >> を呼び出します。
しかし、そのプロトタイプは C<< CORE::glob >> のプロトタイプと異なるので、
C<< File::Glob::glob >> は使われるべきではありません。

=begin original

C<< File::Glob::glob() >> was deprecated in perl 5.8.0. A deprecation
message was issued from perl 5.26.0 onwards, and the function will
disappear in perl 5.30.0.

=end original

C<< File::Glob::glob() >> は perl 5.8.0 で廃止予定になりました。
廃止予定メッセージは perl 5.26.0 以降で出力され、
この関数は perl 5.30.0 で削除される予定です。

=begin original

Code using C<< File::Glob::glob() >> should call
C<< File::Glob::bsd_glob() >> instead.

=end original

C<< File::Glob::glob() >> を使っているコードは、代わりに
C<< File::Glob::bsd_glob() >> を使う必要があります。

=item Filehandle %s opened only for input

=begin original

(W io) You tried to write on a read-only filehandle.  If you intended
it to be a read-write filehandle, you needed to open it with "+<" or
"+>" or "+>>" instead of with "<" or nothing.  If you intended only to
write the file, use ">" or ">>".  See L<perlfunc/open>.

=end original

(W io) リードオンリーのファイルハンドルに対して、書込みを行なおうとしました。
読み書き両用ファイルハンドルにしたいのであれば、"<" を付けたり、
何も付けなかったりするのではなく、"+<" や "+>" や "+>>" を付けて
open する必要があります。
ライトオンリーであれば、">" や ">>" を使ってください。
L<perlfunc/open> を参照してください。

=item Filehandle %s opened only for output

=begin original

(W io) You tried to read from a filehandle opened only for writing, If
you intended it to be a read/write filehandle, you needed to open it
with "+<" or "+>" or "+>>" instead of with ">".  If you intended only to
read from the file, use "<".  See L<perlfunc/open>.  Another possibility
is that you attempted to open filedescriptor 0 (also known as STDIN) for
output (maybe you closed STDIN earlier?).

=end original

(W io) 書き込み専用のファイルハンドルから読み込もうとしました;
読み書きできるファイルハンドルにしたい場合は、ファイルのオープン時に
">" ではなく、"+<" か "+>" か "+>>" をつける必要があります。
読み込み専用にしたい場合は、"<" を使ってください。
L<perlfunc/open> を参照してください。
他の可能性としては、ファイル記述子 0 (STDIN としても知られています) を
出力用に開こうとした場合(おそらくその前に STDIN を閉じたのでは?)です。

=item Filehandle %s reopened as %s only for input

=begin original

(W io) You opened for reading a filehandle that got the same filehandle id
as STDOUT or STDERR.  This occurred because you closed STDOUT or STDERR
previously.

=end original

(W io) STDOUT または STDERR として使われていたのと同じファイルハンドル ID の
ファイルハンドルを読み込み用に開こうとしました。
これは、以前 STDOUT または STDERR を閉じたときに起きます。

=item Filehandle STDIN reopened as %s only for output

=begin original

(W io) You opened for writing a filehandle that got the same filehandle id
as STDIN.  This occurred because you closed STDIN previously.

=end original

(W io) STDIN として使われていたのと同じファイルハンドル ID の
ファイルハンドルを書き込み用に開こうとしました。
これは、以前 STDIN を閉じたときに起きます。

=item Final $ should be \$ or $name

=begin original

(F) You must now decide whether the final $ in a string was meant to be
a literal dollar sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.

=end original

(F) 文字列の最後の $ が、リテラルのドル記号なのか、変数名を入れようとして
忘れたのかを、はっきりさせなければなりません。
バックスラッシュを付けるか、名前を入れてください。

=item flock() on closed filehandle %s

=begin original

(W closed) The filehandle you're attempting to flock() got itself closed
some time before now.  Check your control flow.  flock() operates on
filehandles.  Are you attempting to call flock() on a dirhandle by the
same name?

=end original

(W closed) flock() しようとしたファイルハンドルはその前に既に
閉じられています。
制御フローをチェックしてください。
flock() はファイルハンドルを操作します。
同じ名前のディレクトリハンドルに flock() しようとしていませんか?

=item Format not terminated

=begin original

(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.

=end original

(F) フォーマットは、単独のドットだけからなる行で終わらなければなりません。
そのような行が見つからないまま、スクリプトの最後に行き当たってしまいました。

=item Format %s redefined

=begin original

(W redefine) You redefined a format.  To suppress this warning, say

=end original

(W redefine) フォーマットを再定義しました。
この警告を止めるには以下のようにしてください:

    {
	no warnings 'redefine';
	eval "format NAME =...";
    }

=item Found = in conditional, should be ==

=begin original

(W syntax) You said

=end original

(W) 以下のようにしています:

    if ($foo = 123)

=begin original

when you meant

=end original

以下のようにすべきです:

    if ($foo == 123)

=begin original

(or something like that).

=end original

(あるいは似たようなこと)。

=item %s found where operator expected

=begin original

(S syntax) The Perl lexer knows whether to expect a term or an operator.
If it sees what it knows to be a term when it was expecting to see an
operator, it gives you this warning.  Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.

=end original

(S syntax) Perl の字句解析部は、次に項が来るか、演算子が来るかを
知っています。
次に演算子が来ると思っているときに、項であるとわかるものが現れると、
この警告が出ることになります。
通常、演算子かセミコロンのような区切り文字が省略されたことをしめします。

=item gdbm store returned %d, errno %d, key "%s"

=begin original

(S) A warning from the GDBM_File extension that a store failed.

=end original

(S) GDBM_File 拡張モジュールが、値の設定に失敗したという警告です。

=item gethostent not implemented

=begin original

(F) Your C library apparently doesn't implement gethostent(), probably
because if it did, it'd feel morally obligated to return every hostname
on the Internet.

=end original

(F) C ライブラリに gethostent() が実装されていないようです;
おそらく、実装すると Internet 上のすべてのホスト名を
返さなければいけないと思っているのでしょう。

=item get%sname() on closed socket %s

=begin original

(W closed) You tried to get a socket or peer socket name on a closed
socket.  Did you forget to check the return value of your socket() call?

=end original

(W closed) 閉じたソケットに対してソケットやピアソケット名を取得しようと
しました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか?

=item getpwnam returned invalid UIC %#o for user "%s"

=begin original

(S) A warning peculiar to VMS.  The call to C<sys$getuai> underlying the
C<getpwnam> operator returned an invalid UIC.

=end original

(S) VMS に固有の警告です。
C<getpwnam> 演算子の基礎となる C<sys$getuai> 呼び出しで
不正な UIC が返されました。

=item getsockopt() on closed socket %s

=begin original

(W closed) You tried to get a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/getsockopt>.

=end original

(W clockd) クローズされたソケットのソケットオプションを取得しようとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/getsockopt> を参照してください。

=item given is experimental

=begin original

(S experimental::smartmatch) C<given> depends on smartmatch, which
is experimental, so its behavior may change or even be removed
in any future release of perl.  See the explanation under
L<perlsyn/Experimental Details on given and when>.

=end original

(S experimental::smartmatch) C<given> はスマートマッチングのに依存していて、
これは実験的なので、その振る舞いは将来のリリースの perl で変更されたり
削除されたりするかもしれません。
L<perlsyn/Experimental Details on given and when> の説明を参照してください。

=item Global symbol "%s" requires explicit package name (did you forget to
declare "my %s"?)

=begin original

(F) You've said "use strict" or "use strict vars", which indicates 
that all variables must either be lexically scoped (using "my" or "state"), 
declared beforehand using "our", or explicitly qualified to say 
which package the global variable is in (using "::").

=end original

(F) "use strict" か "use strict vars" が指定されていますので、すべての変数は
("my" か "state" を使った) レキシカルスコープの変数か、"our" を使って事前に
宣言するか、グローバル変数がどのパッケージのものかを ("::" を使って)、
明示的に修飾しなくてはなりません。

=item glob failed (%s)

=begin original

(S glob) Something went wrong with the external program(s) used
for C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a C<glob>
pattern that caused the external program to fail and exit with a
nonzero status.  If the message indicates that the abnormal exit
resulted in a coredump, this may also mean that your csh (C shell)
is broken.  If so, you should change all of the csh-related variables
in config.sh:  If you have tcsh, make the variables refer to it as
if it were csh (e.g. C<full_csh='/usr/bin/tcsh'>); otherwise, make them
all empty (except that C<d_csh> should be C<'undef'>) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
C<./Configure -S> and rebuild Perl.

=end original

(S glob) C<glob> や C<< <*.c> >> のために使われる外部プログラムに何か問題が
発生しました。
通常、これは外部プログラムが失敗して非 0 のステータスで終了するような
C<glob> パターンが渡されたことを意味します。
このメッセージがコアダンプを引きおこした異常終了を示している場合、
csh (C シェル) が壊れていることを意味しているかもしれません。
もしそうなら、config.sh の全ての csh 関連の変数を変更するべきです:
もし tcsh があるなら、(C<full_csh='/usr/bin/tcsh'> のように) tcsh を
参照するように変数を設定します;
さもなければ、関連する全ての変数を空にする(例外として C<d_csh> は
C<'undef'> に設定するべきです)ことで、Perl は csh がないものと考えます。
どちらの場合でも、config.sh を修正した後、C<./Configure -S> を実行して
Perl を再ビルドしてください。

=item Glob not terminated

=begin original

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=end original

(F) 項が必要とされるところで、開き山かっこが見つけたため、
対応する閉じ山かっこを探しましたが、見つかりませんでした。
可能性としては、必要なかっこを省いてしまい、本当は、「小なり記号」を
表したかった場合が考えられます。

=item gmtime(%f) failed

=begin original

(W overflow) You called C<gmtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

=end original

(W overflow) 扱えない数値で C<gmtime> を呼び出しました: 大きすぎたり
小さすぎたり NaN だったりです。
返り値は C<undef> です。

=item gmtime(%f) too large

=begin original

(W overflow) You called C<gmtime> with a number that was larger than
it can reliably handle and C<gmtime> probably returned the wrong
date.  This warning is also triggered with NaN (the special
not-a-number value).

=end original

(W overflow) 確実に扱えるよりも大きい数値の引数で C<gmtime> を呼び出して、
おそらく間違った日付が返されました。
この警告は、NaN (特殊な非数) でも引き起こされます。

=item gmtime(%f) too small

=begin original

(W overflow) You called C<gmtime> with a number that was smaller than
it can reliably handle and C<gmtime> probably returned the wrong date.

=end original

(W overflow) 確実に扱えるよりも大きい数値の引数で C<gmtime> を呼び出して、
おそらく間違った日付が返されました。

=item Got an error from DosAllocMem

=begin original

(P) An error peculiar to OS/2.  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.

=end original

(P) OS/2 に固有のエラーです。
もっともありそうなのは廃止されたバージョンの Perl を使っていることで、
どちらにしてもこのエラーは起きないはずです。

=item goto must have label

=begin original

(F) Unlike with "next" or "last", you're not allowed to goto an
unspecified destination.  See L<perlfunc/goto>.

=end original

(F) "next" や "last" とは違って、goto には必ず、飛び先を
指定しなくてはなりません。
L<perlfunc/goto> を参照してください。

=item Goto undefined subroutine%s

=begin original

(F) You tried to call a subroutine with C<goto &sub> syntax, but
the indicated subroutine hasn't been defined, or if it was, it
has since been undefined.

=end original

(F) C<goto &sub> 文法でサブルーチンを呼び出そうとしましたが、示された
サブルーチンは定義されていないか、定義されていましたが未定義化されました。

=item Group name must start with a non-digit word character in regex; marked by 
S<<-- HERE> in m/%s/

=begin original

(F) Group names must follow the rules for perl identifiers, meaning
they must start with a non-digit word character.  A common cause of
this error is using (?&0) instead of (?0).  See L<perlre>.

=end original

(F) グループ名は perl 識別子の規則に従う必要があり、非数値単語文字で
始まらなければなりません。
このエラーのよくある原因は (?0) ではなく (?&0) を使うことです。
L<perlre> を参照してください。

=item ()-group starts with a count

=begin original

(F) A ()-group started with a count.  A count is supposed to follow
something: a template character or a ()-group.  See L<perlfunc/pack>.

=end original

(F) () グループが繰り返し数で始まっています。
繰り返し数は、テンプレート文字か () グループの後に続くことを想定しています。
L<perlfunc/pack> を参照してください。

=item %s had compilation errors.

=begin original

(F) The final summary message when a C<perl -c> fails.

=end original

(F) C<perl -c> が失敗したときの最終まとめメッセージです。

=item Had to create %s unexpectedly

=begin original

(S internal) A routine asked for a symbol from a symbol table that ought
to have existed already, but for some reason it didn't, and had to be
created on an emergency basis to prevent a core dump.

=end original

(S internal) あるルーティンが、既に存在しているはずのシンボルを、
シンボルテーブルで探しましたが、何らかの理由で存在せず、
コアダンプを避けるために、緊急に生成しました。

=item %s has too many errors

=begin original

(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.

=end original

(F) 構文解析部が、プログラム中に 10 個のエラーを見つけたため、
それ以上の解析を諦めました。
それ以上のエラーメッセージは、おそらく意味がないでしょう。

=item Hexadecimal float: exponent overflow

=begin original

(W overflow) The hexadecimal floating point has a larger exponent
than the floating point supports.

=end original

(W overflow) 16 進浮動小数点数は、対応している浮動小数点数よりも大きな
指数を持っています。

=item Hexadecimal float: exponent underflow

=begin original

(W overflow) The hexadecimal floating point has a smaller exponent
than the floating point supports.  With the IEEE 754 floating point,
this may also mean that the subnormals (formerly known as denormals)
are being used, which may or may not be an error.

=end original

(W overflow) 16 進浮動小数点数は、対応している浮動小数点数よりも大きな
指数を持っています。
IEEE 754 浮動小数点では、正規化数が使われたことを意味するかもしれません;
どちらにしろエラーです。

=item Hexadecimal float: internal error (%s)

=begin original

(F) Something went horribly bad in hexadecimal float handling.

=end original

(F) 16 進浮動小数点の扱いにおいて何かが恐ろしくおかしくなりました。

=item Hexadecimal float: mantissa overflow

=begin original

(W overflow) The hexadecimal floating point literal had more bits in
the mantissa (the part between the 0x and the exponent, also known as
the fraction or the significand) than the floating point supports.

=end original

(W overflow) 16 進浮動小数点数リテラルは、仮数部 (0x と指数部の間の部分) に
浮動小数点数が対応しているよりも多いビット数があります。

=item Hexadecimal float: precision loss

=begin original

(W overflow) The hexadecimal floating point had internally more
digits than could be output.  This can be caused by unsupported
long double formats, or by 64-bit integers not being available
(needed to retrieve the digits under some configurations).

=end original

(W overflow) 16 進浮動小数点数リテラルは内部では出力可能なものより
多くの桁数を保持しています。
これは未対応の long double 形式や、(設定によっては受け取る必要のある)
利用できない 64 ビット整数によって引き起こされます。

=item Hexadecimal float: unsupported long double format

=begin original

(F) You have configured Perl to use long doubles but
the internals of the long double format are unknown;
therefore the hexadecimal float output is impossible.

=end original

(F) long double を使うように設定された Perl を使っていますが、
long double の内部形式が不明です; 従って 16 進浮動小数点数出力は
不可能です。

=item Hexadecimal number > 0xffffffff non-portable

=begin original

(W portable) The hexadecimal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=end original

(W portable) 指定した 16 進数が 2**32-1 (4294967295) より大きいので、
システム間で移植性がありません。
移植性に関するさらなる考察については L<perlport> を参照してください。

=item Identifier too long

=begin original

(F) Perl limits identifiers (names for variables, functions, etc.) to
about 250 characters for simple names, and somewhat more for compound
names (like C<$A::B>).  You've exceeded Perl's limits.  Future versions
of Perl are likely to eliminate these arbitrary limitations.

=end original

(F) Perl は識別子(変数名や関数名など)について、単純な名前については
およそ 250 文字に、(C<$A::B> のような)複合名についてはもう少し長い長さに
制限しています。
この Perl の制限を越えました。
将来のバージョンの Perl ではこれらの恣意的な制限はなくなるでしょう。

=item Ignoring zero length \N{} in character class in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) Named Unicode character escapes (C<\N{...}>) may return a
zero-length sequence.  When such an escape is used in a character
class its behavior is not well defined.  Check that the correct
escape has been used, and the correct charname handler is in scope.

=end original

(W regexp) 名前付き Unicode 文字エスケープ (C<\N{...}>) が長さ 0 の
シーケンスを返しました。
文字クラスでこのようなエスケープが使われた場合、振る舞いは未定義です。
正しいエスケープを使っているか、および正しい文字名ハンドラがスコープ内に
あるかをチェックしてください。

=item Illegal %s digit '%c' ignored

=begin original

(W digit) Here C<%s> is one of "binary", "octal", or "hex".
You may have tried to use a digit other than one that is legal for the
given type, such as only 0 and 1 for binary.  For octals, this is raised
only if the illegal character is an '8' or '9'.  For hex, 'A' - 'F' and
'a' - 'f' are legal.
Interpretation of the number stopped just before the offending digit or
character.

=end original

(W digit) ここで C<%s> は "binary", "octal", "hex" のうちの一つです。
one that is legal for the
given type, such as only 0 and 1 for binary.  For octals, this is raised
only if the illegal character is an '8' or '9'.  For hex, 'A' - 'F' and
'a' - 'f' are legal.
を使おうとしたのでしょう。
数の解釈は問題のある数値や文字の直前で停止しました。

=item Illegal binary digit '%c'

=begin original

(F) You used a digit other than 0 or 1 in a binary number.

=end original

(F) 2 進数として 0 と 1 以外の数値を使っています。

=item Illegal character after '_' in prototype for %s : %s

=begin original

(W illegalproto) An illegal character was found in a prototype
declaration.  The '_' in a prototype must be followed by a ';',
indicating the rest of the parameters are optional, or one of '@'
or '%', since those two will accept 0 or more final parameters.

=end original

(W illegalproto) プロトタイプ宣言に無効な文字が見つかりました。
プロトタイプの中の '_' は、残りの引数がオプションであることを示すために
';' が引き続くか、'@' か '%' の一つでなければなりません;
これら二つは 0 以上の末尾の引数を受け付けるからです。

=item Illegal character \%o (carriage return)

=begin original

(F) Perl normally treats carriage returns in the program text as
it would any other whitespace, which means you should never see
this error when Perl was built using standard options.  For some
reason, your version of Perl appears to have been built without
this support.  Talk to your Perl administrator.

=end original

(F) Perl は普通プログラムテキスト中の復帰文字をその他の空白と同様に
扱いますので、Perl を標準のオプションでビルドした場合はこのエラーを
見ることは決してないはずです。
どういうわけか、お使いの Perl はこの機能なしでビルドされているようです。
Perl の管理者に問い合わせてください。

=item Illegal character following sigil in a subroutine signature

=begin original

(F) A parameter in a subroutine signature contained an unexpected character
following the C<$>, C<@> or C<%> sigil character.  Normally the sigil
should be followed by the variable name or C<=> etc.  Perhaps you are
trying use a prototype while in the scope of C<use feature 'signatures'>?
For example:

=end original

(F) サブルーチンシグネチャの引数は、C<$>, C<@>, C<%> 印文字に引き続いて
想定外の文字がありました。
通常は、印には変数名や C<=> などが引き続くはずです。
おそらく C<use feature 'signatures'> のスコープ内で
プロトタイプを使おうとしたのでは?
例えば:

    sub foo ($$) {}            # legal - a prototype

    use feature 'signatures;
    sub foo ($$) {}            # illegal - was expecting a signature
    sub foo ($a, $b)
            :prototype($$) {}  # legal

=item Illegal character in prototype for %s : %s

=begin original

(W illegalproto) An illegal character was found in a prototype declaration.
Legal characters in prototypes are $, @, %, *, ;, [, ], &, \, and +.
Perhaps you were trying to write a subroutine signature but didn't enable
that feature first (C<use feature 'signatures'>), so your signature was
instead interpreted as a bad prototype.

=end original

(W illegalproto) プロトタイプ宣言に無効な文字が見つかりました。
プロトタイプでの有効な文字は、$, @, %, *, ;, [, ], &, \, + です。
おそらくサブルーチンシグネチャを書こうとしたけれども、先にこの機能を有効に
していなかった (C<use feature 'signatures'>) ので、シグネチャが間違った
プロトタイプとして解釈されたのでしょう。

=item Illegal declaration of anonymous subroutine

=begin original

(F) When using the C<sub> keyword to construct an anonymous subroutine,
you must always specify a block of code.  See L<perlsub>.

=end original

(F) 無名サブルーチンを作るために C<sub> を使ったときは、
常にコードのブロックを指定しなければなりません。
L<perlsub> を参照してください。

=item Illegal declaration of subroutine %s

=begin original

(F) A subroutine was not declared correctly.  See L<perlsub>.

=end original

(F) サブルーチンが正しく宣言されていません。
L<perlsub> を参照してください。

=item Illegal division by zero

=begin original

(F) You tried to divide a number by 0.  Either something was wrong in
your logic, or you need to put a conditional in to guard against
meaningless input.

=end original

(F) ゼロで割り算をしようとしました。
ロジックの誤りか、意味の無い入力を防ぐために、条件を付けることが
必要かのどちらかでしょう。

=item Illegal modulus zero

=begin original

(F) You tried to divide a number by 0 to get the remainder.  Most
numbers don't take to this kindly.

=end original

(F) 余りを求めるのに、ゼロで割り算をしようとしました。
これは、ほとんどの数体系で受け入れられません。

=item Illegal number of bits in vec

=begin original

(F) The number of bits in vec() (the third argument) must be a power of
two from 1 to 32 (or 64, if your platform supports that).

=end original

(F) vec() のビット数 (第三引数) は 1 から 32 (プラットフォームが
対応している場合は 64) までの、2 のべき乗でなければなりません。

=item Illegal octal digit '%c'

=begin original

(F) You used an 8 or 9 in an octal number.

=end original

(F) 8 進数で 8 か 9 を使いました。

=item Illegal operator following parameter in a subroutine signature

=begin original

(F) A parameter in a subroutine signature, was followed by something
other than C<=> introducing a default, C<,> or C<)>.

=end original

(F) サブルーチンシグネチャで引数に引き続いて、デフォルトを導入する
C<=>, C<,>, C<)> 以外のものがありました。

    use feature 'signatures';
    sub foo ($=1) {}           # legal
    sub foo ($a = 1) {}        # legal
    sub foo ($a += 1) {}       # illegal
    sub foo ($a == 1) {}       # illegal

=item Illegal pattern in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You wrote something like

=end original

(F) 以下のようなものを書きました

 (?+foo)

=begin original

The C<"+"> is valid only when followed by digits, indicating a
capturing group.  See
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>.

=end original

C<"+"> は捕捉グループを示すために数値が引き続く場合にのみ正当です。
L<C<(?I<PARNO>)>|perlre/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)> を
参照してください。

=item Illegal suidscript

=begin original

(F) The script run under suidperl was somehow illegal.

=end original

(F) suidperl でのスクリプトの実行が何らかの理由で不正でした。

=item Illegal switch in PERL5OPT: -%c

=begin original

(X) The PERL5OPT environment variable may only be used to set the
following switches: B<-[CDIMUdmtw]>.

=end original

(X) PERL5OPT 環境変数で設定できるのは B<-[CDIMUdmtw]> のオプションだけです。

=item Illegal user-defined property name

=begin original

(F) You specified a Unicode-like property name in a regular expression
pattern (using C<\p{}> or C<\P{}>) that Perl knows isn't an official
Unicode property, and was likely meant to be a user-defined property
name, but it can't be one of those, as they must begin with either C<In>
or C<Is>.  Check the spelling.  See also
L</Can't find Unicode property definition "%s">.

=end original

(F) (C<\p{}> や C<\P{}> を使って) 正規表現中に Perl が
公式 Unicode 特性として知らない Unicode 風の特性姪を指定して、
おそらくそれはユーザー定義特性を意味しているのでしょうが、
しかし、それらは C<In> か C<Is> で始まっていなければならないので、
そうなりません。
スペルを確認してください。
L</Can't find Unicode property definition "%s"> も参照してください。

=item Ill-formed CRTL environ value "%s"

=begin original

(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's
internal environ array, and encountered an element without the C<=>
delimiter used to separate keys from values.  The element is ignored.

=end original

(W internal) VMS に固有の警告です。
Perl は CRTL の内部環境配列を読み込もうとしましたが、キーを値と
分離するために使われている C<=> デリミタのない要素に遭遇しました。
この要素は無視しました。

=item Ill-formed message in prime_env_iter: |%s|

=begin original

(W internal) A warning peculiar to VMS.  Perl tried to read a logical
name or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the line was
ignored.

=end original

(W internal) VMS に固有の警告です。
Perl は %ENV を反復する準備したときに論理名や CLI シンボル定義を
読み込もうとしましたが、キーと値の間のデリミタが見つからなかったので、
その行は無視しました。

=item (in cleanup) %s

=begin original

(W misc) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.

=end original

(W misc) この接頭辞は普通、示されている例外が DESTROY() メソッドで
発生したことを示しています。
デストラクタは普通実行中の任意の時点で呼び出され、しばしば大量に
呼び出されるので、この警告は同じメッセージが繰り返されないように、
何回失敗しても一度だけ発生します。

=begin original

Failure of user callbacks dispatched using the C<G_KEEPERR> flag could
also result in this warning.  See L<perlcall/G_KEEPERR>.

=end original

C<G_KEEPERR> フラグを使って発行(dispatch)したユーザーコールバックに失敗した
場合にもこの警告が出ることがあります。
L<perlcall/G_KEEPERR> を参照してください。

=item Incomplete expression within '(?[ ])' in regex; marked by S<<-- HERE>
in m/%s/

=begin original

(F) There was a syntax error within the C<(?[ ])>.  This can happen if the
expression inside the construct was completely empty, or if there are
too many or few operands for the number of operators.  Perl is not smart
enough to give you a more precise indication as to what is wrong.

=end original

(F) これは C<(?[ ])> の中の文法エラーです。
これは、この構文の中の式が完全に空か、演算子の数に対してオペランドが多すぎたり
少なすぎたりする場合に起こります。
Perl は、何が悪いのかをより正確に示せるほど賢くはありませんでした。

=item Inconsistent hierarchy during C3 merge of class '%s': merging failed on 
parent '%s'

=begin original

(F) The method resolution order (MRO) of the given class is not
C3-consistent, and you have enabled the C3 MRO for this class.  See the C3
documentation in L<mro> for more information.

=end original

(F) 与えられたクラスのメソッド解決順序 (MRO) が C3 に矛盾していますが、
このクラスの C3 MRO を有効にしました。
さらなる情報については L<mro> 内の C3 に関する文書を参照してください。

=item Indentation on line %d of here-doc doesn't match delimiter

=begin original

(F) You have an indented here-document where one or more of its lines
have whitespace at the beginning that does not match the closing
delimiter.

=end original

(F) インデントのあるヒヤドキュメントがありますが、
先頭に空白があるけれども閉じ区切り文字にマッチングしない行があります。

=begin original

For example, line 2 below is wrong because it does not have at least
2 spaces, but lines 1 and 3 are fine because they have at least 2:

=end original

例えば、以下の Line 2 は間違っています; これは少なくとも 2 個の
スペースが必要だからです; しかし、Line 1 と Line 3 は正しいです;
少なくとも 2 個あるからです:

    if ($something) {
      print <<~EOF;
        Line 1
       Line 2 not
          Line 3
        EOF
    }

=begin original

Note that tabs and spaces are compared strictly, meaning 1 tab will
not match 8 spaces.

=end original

タブとスペースは厳密に比較されるので、タブ 1 個は スペース 8 個とは
マッチングしないことに注意してください。

=item Infinite recursion in regex

=begin original

(F) You used a pattern that references itself without consuming any input
text.  You should check the pattern to ensure that recursive patterns
either consume text or fail.

=end original

(F) 入力テキストを読み込むことなく自分自身を参照するパターンを使いました。
再帰的なパターンが、テキストを読み込むか失敗するかを確実に行うように、
パターンをチェックするべきです。

=item Infinite recursion via empty pattern

=begin original

(F) You tried to use the empty pattern inside of a regex code block,
for instance C</(?{ s!!! })/>, which resulted in re-executing
the same pattern, which is an infinite loop which is broken by
throwing an exception.

=end original

(F) C</(?{ s!!! })/> のように、正規表現コードブロックの中で
空パターンを使いました;
これは同じパターンを再実行することになり、
例外が投げられることによって壊れる無限ループになります。

=item Initialization of state variables in list currently forbidden

=begin original

(F) C<state> only permits initializing a single variable, specified
without parentheses.  So C<state $a = 42> and C<state @a = qw(a b c)> are
allowed, but not C<state ($a) = 42> or C<(state $a) = 42>.  To initialize
more than one C<state> variable, initialize them one at a time.

=end original

(F) C<state> は、かっこなしで指定された単一の変数の初期化のみが
許されています。
従って C<state $a = 42> と C<state @a = qw(a b c)> は許されますが、
C<state ($a) = 42> や C<(state $a) = 42> は許されません。
To initialize
more than one 
複数の C<state> 変数を初期化するには、一つずつ初期化してください。

=item %%s[%s] in scalar context better written as $%s[%s]

=begin original

(W syntax) In scalar context, you've used an array index/value slice
(indicated by %) to select a single element of an array.  Generally
it's better to ask for a scalar value (indicated by $).  The difference
is that C<$foo[&bar]> always behaves like a scalar, both in the value it
returns and when evaluating its argument, while C<%foo[&bar]> provides
a list context to its subscript, which can do weird things if you're
expecting only one subscript.  When called in list context, it also
returns the index (what C<&bar> returns) in addition to the value.

=end original

(W syntax) スカラコンテキストで、配列の単一の要素を選択するために
(% で示される)配列インデックス/値スライスを使いました。
一般的には($ で示される)スカラ値を取得した方がよいです。
違いは、C<$foo[&bar]> は返り値と引数を評価したときの両方で常にスカラのように
振る舞いますが、C<%foo[&bar]> は添え字にリストコンテキストを提供するので、
一つだけの添え字を想定していた場合、おかしなことになることがあります。
リストコンテキストで呼び出された場合、値に加えてインデックス
(C<&bar> が返すもの) を返します。

=item %%s{%s} in scalar context better written as $%s{%s}

=begin original

(W syntax) In scalar context, you've used a hash key/value slice
(indicated by %) to select a single element of a hash.  Generally it's
better to ask for a scalar value (indicated by $).  The difference
is that C<$foo{&bar}> always behaves like a scalar, both in the value
it returns and when evaluating its argument, while C<@foo{&bar}> and
provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.  When called in list context,
it also returns the key in addition to the value.

=end original

(W syntax) スカラコンテキストで、ハッシュの単一の要素を選択するために
(% で示される)ハッシュキー/値スライスを使いました。
一般的には($ で示される)スカラ値を取得した方がよいです。
違いは、C<$foo[&bar]> は返り値と引数を評価したときの両方で常にスカラのように
振る舞いますが、C<%foo[&bar]> は添え字にリストコンテキストを提供するので、
一つだけの添え字を想定していた場合、おかしなことになることがあります。
リストコンテキストで呼び出された場合、値に加えてインデックスを返します。

=item Insecure dependency in %s

=begin original

(F) You tried to do something that the tainting mechanism didn't like.
The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify B<-T> to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a "dangerous" operation, you get this error.  See
L<perlsec> for more information.

=end original

(F) 何か汚染チェックの機構が、望ましくないと判断することを
行なおうとしました。
setuid や setgid を実行したときや、明示的に B<-T> で指定したときに、
汚染チェック機構が働きます。
汚染チェック機構は、信頼がおけないと仮定されるユーザが直接、間接を問わず、
指定したデータに印を付けます。
そのようなデータを「危険な」操作に用いると、このエラーが発生します。
詳しくは、L<perlsec> を参照してください。

=item Insecure directory in %s

=begin original

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if C<$ENV{PATH}> contains a directory that is writable by
the world.  Also, the PATH must not contain any relative directory.
See L<perlsec>.

=end original

(F) C<$ENV{PATH}> の中に、誰にでも書き込みができるディレクトリが
含まれているとき、system()、exec()、パイプのオープンを
行なうことはできません。
また、PATH には相対早退ディレクトリを含んでいてはいけません。
L<perlsec> を参照してください。

=item Insecure $ENV{%s} while running %s

=begin original

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,
C<$ENV{ENV}>, C<$ENV{BASH_ENV}> or C<$ENV{TERM}> are derived from data
supplied (or potentially supplied) by the user.  The script must set
the path to a known value, using trustworthy data.  See L<perlsec>.

=end original

(F) C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>, C<$ENV{ENV}>,
C<$ENV{BASH_ENV}>, C<$ENV{TERM}> のいずれかがユーザーによって提供された
(あるいは提供された可能性のある)データの場合、setuid や setgid された
スクリプトでは system(), exec(), パイプされる open を
使うことはできません。
スクリプトはパスとして、信頼の置けるデータを使った、既知の値を
セットしなければなりません。
L<perlsec> を参照してください。

=item Insecure user-defined property %s

=begin original

(F) Perl detected tainted data when trying to compile a regular
expression that contains a call to a user-defined character property
function, i.e. C<\p{IsFoo}> or C<\p{InFoo}>.
See L<perlunicode/User-Defined Character Properties> and L<perlsec>.

=end original

(F) Perl は、ユーザー定義文字特性関数 (C<\p{IsFoo}> や C<\p{InFoo}>) の
呼び出しを含む正規表現をコンパイルしようとしたときに汚染されたデータを
検出しました。
L<perlunicode/User-Defined Character Properties> と L<perlsec> を
参照してください。

=item Integer overflow in format string for %s

=begin original

(F) The indexes and widths specified in the format string of C<printf()>
or C<sprintf()> are too large.  The numbers must not overflow the size of
integers for your architecture.

=end original

(F) C<printf()> や C<sprintf()> のフォーマット文字列で指定されたインデックスや
幅が大きすぎます。
数値はあなたのアーキテクチャの整数のサイズをオーバーフローしないように
しなければなりません。

=item Integer overflow in %s number

=begin original

(S overflow) The hexadecimal, octal or binary number you have specified
either as a literal or as an argument to hex() or oct() is too big for
your architecture, and has been converted to a floating point number.
On a 32-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally--subject to loss of precision errors in subsequent
operations.

=end original

(S overflow) リテラルまたは hex() や oct() の引数として指定された 16 進、
8 進、2 進数は実行しているアーキテクチャには大きすぎるので、浮動小数点数に
変換されました。
32 ビットアーキテクチャでは、オーバーフローせずに表現できる 16 進、8 進
2 進数はそれぞれ 0xFFFFFFFF, 037777777777, 
0b11111111111111111111111111111111 です。
Perl は全ての数値を内部では浮動小数点表現に透過的に変換することに
注意してください -- 引き続く操作によって精度が失われることがあります。

=item Integer overflow in srand

=begin original

(S overflow) The number you have passed to srand is too big to fit
in your architecture's integer representation.  The number has been
replaced with the largest integer supported (0xFFFFFFFF on 32-bit
architectures).  This means you may be getting less randomness than
you expect, because different random seeds above the maximum will
return the same sequence of random numbers.

=end original

(S overflow) srand に渡した数値は、現在のアーキテクチャの整数表現に
適合させるには大きすぎます。
数値は対応している最大の整数(32 ビットアーキテクチャでは 0xFFFFFFFF) に
置き換えられました。
これは、最大数よりも大きな異なった乱数の種が同じ乱数の並びを返すので、
想定しているよりもランダム性が低くなることを意味します。

=item Integer overflow in version

=item Integer overflow in version %d

=begin original

(W overflow) Some portion of a version initialization is too large for
the size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use an
element larger than typically 2**32.  This is usually caused by trying
to use some odd mathematical operation as a version, like 100/9.

=end original

(W overflow) バージョン初期化の一部が、アーキテクチャの整数のサイズより
大きすぎます。
バージョンとして典型的には 2**32 を超える要素を使おうとするための合理的な
理由がないので、これは警告ではありません。
これは普通、100/9 のようなおかしな数値演算をバージョンとして
使おうとしたことによります。

=item Internal disaster in regex; marked by S<<-- HERE> in m/%s/

=begin original

(P) Something went badly wrong in the regular expression parser.
The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

(P) 正規表現解析部に何か悪いことが起こりました。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Internal inconsistency in tracking vforks

=begin original

(S) A warning peculiar to VMS.  Perl keeps track of the number of times
you've called C<fork> and C<exec>, to determine whether the current call
to C<exec> should affect the current script or a subprocess (see
L<perlvms/"exec LIST">).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this C<exec> as a request to
terminate the Perl script and execute the specified command.

=end original

(S) VMS に固有の警告です。
Perl は C<fork> と C<exec> を呼び出した回数を数えています;
これは現在の C<exec> 呼び出しが現在のスクリプトかサブプロセスかどちらに
影響を与えるかを決定するためです(L<perlvms/"exec LIST"> を
参照してください)。
どういうわけか、このカウントがおかしくなったので、Perl はこの C<exec> が
Perl スクリプトを終了させて指定されたコマンドを実行する要求であると
仮定して、そのように扱いました。

=item internal %<num>p might conflict with future printf extensions

=begin original

(S internal) Perl's internal routine that handles C<printf> and C<sprintf>
formatting follows a slightly different set of rules when called from
C or XS code.  Specifically, formats consisting of digits followed
by "p" (e.g., "%7p") are reserved for future use.  If you see this
message, then an XS module tried to call that routine with one such
reserved format.

=end original

(S internal) C<printf> と C<sprintf> のフォーマットを扱う Perl の
内部ルーチンは、C や XS コードから呼び出されたときは少し違う規則集合に
従います。
特に、数値に引き続いて "p" のあるフォーマット (例えば "%7p") は将来の
使用のために予約されています。
このメッセージが表示された場合、XS モジュールはこのような予約された
フォーマットを使って呼び出そうとしました。

=item Internal urp in regex; marked by S<<-- HERE> in m/%s/

=begin original

(P) Something went badly awry in the regular expression parser.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

(P) 正規表現解析部に何か間違ったことが起こりました。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item %s (...) interpreted as function

=begin original

(W syntax) You've run afoul of the rule that says that any list operator
followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See
L<perlop/Terms and List Operators (Leftward)>.

=end original

(W syntax) リスト演算子の直後にかっこを置くと、かっこ内にある
リスト演算子引数を持つ関数になる、という規則が適用されました。
L<perlop/Terms and List Operators (Leftward)> を参照してください。

=item In '(?...)', the '(' and '?' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) The two-character sequence C<"(?"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"?">, but you separated them
with whitespace.

=end original

(F)
正規表現中のこのコンテキストでの 2 文字並び C<"(?"> は分割できないトークンで、
C<"("> と C<"?"> の間には何も入らないはずですが、これを空白で分割しました。

=item In '(*...)', the '(' and '*' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) The two-character sequence C<"(*"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"*">, but you separated them.
Fix the pattern and retry.

=end original

(F) 正規表現パターンの中のこの文脈での 2 文字並び C<"(*"> は、
C<"("> と C<"*"> の間に何も入っていない分割されていないトークンである
必要があります; しかしこれが分割されています。
パターンを修正してもう一度試してください。

=item Invalid %s attribute: %s

=begin original

(F) The indicated attribute for a subroutine or variable was not recognized
by Perl or by a user-supplied handler.  See L<attributes>.

=end original

(F) 示されたサブルーチンや変数の属性は Perl やユーザー提供のハンドラで
認識されませんでした。
L<attributes> を参照してください。

=item Invalid %s attributes: %s

=begin original

(F) The indicated attributes for a subroutine or variable were not
recognized by Perl or by a user-supplied handler.  See L<attributes>.

=end original

(F) 示されたサブルーチンや変数の属性は Perl やユーザー提供のハンドラで
認識されませんでした。
L<attributes> を参照してください。

=item Invalid character in charnames alias definition; marked by
S<<-- HERE> in '%s

=begin original

(F) You tried to create a custom alias for a character name, with
the C<:alias> option to C<use charnames> and the specified character in
the indicated name isn't valid.  See L<charnames/CUSTOM ALIASES>.

=end original

(F) C<use charnames> の C<:alias> オプションで文字名へのカスタム別名を
作ろうとしましたが、指定された名前のうち示された文字は正当ではありません。
L<charnames/CUSTOM ALIASES> を参照してください。

=item Invalid \0 character in %s for %s: %s\0%s

=begin original

(W syscalls) Embedded \0 characters in pathnames or other system call
arguments produce a warning as of 5.20.  The parts after the \0 were
formerly ignored by system calls.

=end original

(W syscalls) パス名やその他のシステムコール引数に埋め込まれた \0 文字は
5.20 から警告を出力するようになりました。
以前は \0 の後の部分はシステムコールによって無視されていました。

=item Invalid character in \N{...}; marked by S<<-- HERE> in \N{%s}

=begin original

(F) Only certain characters are valid for character names.  The
indicated one isn't.  See L<charnames/CUSTOM ALIASES>.

=end original

(F) 文字名としては一部の文字のみが正当です。
示されたものは違います。
L<charnames/CUSTOM ALIASES> を参照してください。

=item Invalid conversion in %s: "%s"

=begin original

(W printf) Perl does not understand the given format conversion.  See
L<perlfunc/sprintf>.

=end original

(W printf) Perl は指定されたフォーマット変換が認識できませんでした。
L<perlfunc/sprintf> を参照してください。

=item Invalid escape in the specified encoding in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp)(F) The numeric escape (for example C<\xHH>) of value < 256
didn't correspond to a single character through the conversion
from the encoding specified by the encoding pragma.
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD)
instead, except within S<C<(?[   ])>>, where it is a fatal error.
The S<<-- HERE> shows whereabouts in the regular expression the
escape was discovered.

=end original

(W regexp)(F) (例えば C<\xHH> のような)数値エスケープの 256 より小さい値が、
エンコーディングプラグマで指定した変換によって 一つの文字に対応していません。
エスケープは代わりに REPLACEMENT CHARACTER (U+FFFD) に置き換えられます;
ただし、S<C<(?[   ])>> の内側の場合は致命的エラーになります。
S<<-- HERE> で正規表現のどこにエスケープが発見されたかを示しています。

=item Invalid hexadecimal number in \N{U+...}

=item Invalid hexadecimal number in \N{U+...} in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) The character constant represented by C<...> is not a valid hexadecimal
number.  Either it is empty, or you tried to use a character other than
0 - 9 or A - F, a - f in a hexadecimal number.

=end original

(F) C<...> で表現された文字定数は妥当な 16 進数ではありません。
空か、16 進数の中に 0 - 9, A - F, a - f 以外の文字を使おうとしました。

=item Invalid module name %s with -%c option: contains single ':'

=begin original

(F) The module argument to perl's B<-m> and B<-M> command-line options
cannot contain single colons in the module name, but only in the
arguments after "=".  In other words, B<-MFoo::Bar=:baz> is ok, but
B<-MFoo:Bar=baz> is not.

=end original

(F) perl の B<-m> と B<-M> のコマンドラインオプションでのモジュール引数は、
モジュール名では単一のコロンを含むことが出来ず、"=" の後でのみ含むことが
できます。
言い換えると、B<-MFoo::Bar=:baz> は OK ですが、B<-MFoo:Bar=baz> は
そうではありません。

=item Invalid mro name: '%s'

=begin original

(F) You tried to C<mro::set_mro("classname", "foo")> or C<use mro 'foo'>,
where C<foo> is not a valid method resolution order (MRO).  Currently,
the only valid ones supported are C<dfs> and C<c3>, unless you have loaded
a module that is a MRO plugin.  See L<mro> and L<perlmroapi>.

=end original

(F) C<mro::set_mro("classname", "foo")> または C<use mro 'foo'> を使おうと
しましたが、C<foo> は有効なメソッド解決順序 (MRO) ではありません。
現在のところ、MRO プラグインモジュールを読み込まない限り、対応として
有効なものは C<dfs> と C<c3> だけです。
L<mro> と L<perlmroapi> を参照してください。

=item Invalid negative number (%s) in chr

=begin original

(W utf8) You passed a negative number to C<chr>.  Negative numbers are
not valid character numbers, so it returns the Unicode replacement
character (U+FFFD).

=end original

(W utf8) C<chr> に負数を渡しました。
負数は正当な文字番号ではないので、Unicode 代替文字 (U+FFFD) を返します。

=item Invalid number '%s' for -C option.

=begin original

(F) You supplied a number to the -C option that either has extra leading
zeroes or overflows perl's unsigned integer representation.

=end original

(F) -C オプションに、前に 0 がついていたり、perl の符号なし整数表現を
オーバーフローするといったような数値を指定しました。

=item invalid option -D%c, use -D'' to see choices

=begin original

(S debugging) Perl was called with invalid debugger flags.  Call perl
with the B<-D> option with no flags to see the list of acceptable values.
See also L<perlrun/-Dletters>.

=end original

(F) Perl は不正なデバッガフラグで呼び出されました。
受け付けられる値の一覧を見るには、フラグなしの B<-D> オプションをつけて
perl を呼び出してください。
L<< perlrun/B<-D>I<letters> >> も参照してください。

=item Invalid quantifier in {,} in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) The pattern looks like a {min,max} quantifier, but the min or max
could not be parsed as a valid number - either it has leading zeroes,
or it represents too big a number to cope with.  The S<<-- HERE> shows
where in the regular expression the problem was discovered.  See L<perlre>.

=end original

(F) パターンは {min,max} 量指定子のように見えますが、min または max が
正当な数値としてパースできませんでした - 先頭に 0 が付いているか、
数値として扱うには大きすぎます。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Invalid [] range "%s" in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) The range specified in a character class had a minimum character
greater than the maximum character.  One possibility is that you forgot the
C<{}> from your ending C<\x{}> - C<\x> without the curly braces can go only
up to C<ff>.  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=end original

(F) 文字クラスに指定した範囲の最小値が、最大値よりも大きくなっています。
ひとつの可能性としては、末尾の C<\x{}> から C<{}> を
忘れているということです - 中かっこなしの C<\x> は C<ff> までにしか
なりません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Invalid range "%s" in transliteration operator

=begin original

(F) The range specified in the tr/// or y/// operator had a minimum
character greater than the maximum character.  See L<perlop>.

=end original

(F) tr/// や y/// の演算子での範囲指定で、最大の文字より最小の文字の方が
大きいです。
L<perlop> を参照してください。

=item Invalid reference to group in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) The capture group you specified can't possibly exist because the
number you used is not within the legal range of possible values for
this machine.

=end original

(F) 指定した捕捉グループはおそらく存在できません;
使われている数字がこの機械で可能な値の範囲の中でないからです。

=item Invalid separator character %s in attribute list

=begin original

(F) Something other than a colon or whitespace was seen between the
elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See L<attributes>.

=end original

(F) 属性リストの要素の間にコロンと空白以外のものがあります。
直前の属性がかっこ付きのパラメータリストの場合、おそらくリストが
予定より早く終端されています。
L<attributes> を参照してください。

=item Invalid separator character %s in PerlIO layer specification %s

=begin original

(W layer) When pushing layers onto the Perl I/O system, something other
than a colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.

=end original

(W layer) 層を Perl I/O システムに押し込むときに、層リストの要素の間に
コロンと空白以外のものがありました。
直前の属性がかっこ付きのパラメータリストの場合、おそらくリストが
予定より早く終端されています。

=item Invalid strict version format (%s)

=begin original

(F) A version number did not meet the "strict" criteria for versions.
A "strict" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string with a leading 'v' character and at least three components.
The parenthesized text indicates which criteria were not met.
See the L<version> module for more details on allowed version formats.

=end original

(F) バージョン番号がバージョンの「厳密な」基準に一致しませんでした。
「厳密な」バージョン番号は、指数なしの正の 10 進数 (整数または 10 進小数)か、
さもなければどっと付き 10 進 v-文字列で先頭に 'v' の文字があり、少なくとも
三つの部分からなるものです。
かっこで囲まれたテキストは問題の基準を示しています。
許されるバージョンオブジェクトに関するさらなる詳細については
L<version> モジュールを参照してください。

=item Invalid type '%s' in %s

=begin original

(F) The given character is not a valid pack or unpack type.
See L<perlfunc/pack>.

=end original

(F) 与えられた文字は有効な pack や unpack の型ではありません。
L<perlfunc/pack> を参照してください。

=begin original

(W) The given character is not a valid pack or unpack type but used to be
silently ignored.

=end original

(W) 与えられた文字は有効な pack や unpack の型ではありませんが、暗黙に
無視されました。

=item Invalid version format (%s)

=begin original

(F) A version number did not meet the "lax" criteria for versions.
A "lax" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string.  If the v-string has fewer than three components, it
must have a leading 'v' character.  Otherwise, the leading 'v' is
optional.  Both decimal and dotted-decimal versions may have a
trailing "alpha" component separated by an underscore character
after a fractional or dotted-decimal component.  The parenthesized
text indicates which criteria were not met.  See the L<version> module
for more details on allowed version formats.

=end original

(F) バージョン番号がバージョンの「緩い」基準に一致しませんでした。
「緩い」バージョン番号は指数なしの正の 10 進数(整数または 10 進小数)か、
あるいはどっと付き 10 進 v-文字列です。
v-文字列の要素が三つ未満の場合、先頭に 'v' 文字が必要です。
さもなければ、先頭の 'v' はオプションです。
10 進とドット付き 10 進の両方のバージョンは、小数またはドット付き 10 進
要素の後に下線で区切られた「α」要素が引き続くこともあります。
かっこで囲まれたテキストは問題の基準を示しています。
許されるバージョンオブジェクトに関するさらなる詳細については
L<version> モジュールを参照してください。

=item Invalid version object

=begin original

(F) The internal structure of the version object was invalid.
Perhaps the internals were modified directly in some way or
an arbitrary reference was blessed into the "version" class.

=end original

(F) バージョンオブジェクトの内部構造が不正です。
おそらく何らかの方法で内部が直接変更されたか、任意のリファレンスが
"version" クラスとして bless されました。

=item Inverting a character class which contains a multi-character
sequence is illegal in regex; marked by <-- HERE in m/%s/

=begin original

(F) You wrote something like

=end original

(F) 次のようなものを書きました:

 qr/\P{name=KATAKANA LETTER AINU P}/
 qr/[^\p{name=KATAKANA LETTER AINU P}]/

=begin original

This name actually evaluates to a sequence of two Katakana characters,
not just a single one, and it is illegal to try to take the complement
of a sequence.  (Mathematically it would mean any sequence of characters
from 0 to infinity in length that weren't these two in a row, and that
is likely not of any real use.)

=end original

この名前は実際には一つではなく二つのカタカナ文字の並びに評価され、
並びの反転を取ろうとするのは不正です。
(数学的には、これはこれら二つが並んでいるもの以外の長さ 0 から無限の
任意の文字並びを意味しますが、おそらく実際の用途ではないでしょう。)

=item In '(*VERB...)', the '(' and '*' must be adjacent in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) The two-character sequence C<"(*"> in this context in a regular
expression pattern should be an indivisible token, with nothing
intervening between the C<"("> and the C<"*">, but you separated them.

=end original

(F) 正規表現中のこのコンテキストでの 2 文字並び C<"(*"> は分割できない
トークンで、C<"("> と C<"*"> の間には何も入らないはずですが、これを
分割しました。

=item ioctl is not implemented

=begin original

(F) Your machine apparently doesn't implement ioctl(), which is pretty
strange for a machine that supports C.

=end original

(F) C をサポートしているマシンではおかしなことだと思いますが、
このマシンでは ioctl() が実装されていないようです。

=item ioctl() on unopened %s

=begin original

(W unopened) You tried ioctl() on a filehandle that was never opened.
Check your control flow and number of arguments.

=end original

(W unopened) 開いていないファイルハンドルに ioctl() を使おうとしました。
制御フローと引数の数をチェックしてください。

=item IO layers (like '%s') unavailable

=begin original

(F) Your Perl has not been configured to have PerlIO, and therefore
you cannot use IO layers.  To have PerlIO, Perl must be configured
with 'useperlio'.

=end original

(F) この Perl は PerlIO を使うように設定されていないので、IO 層は使えません。
PerlIO を使うには、'useperlio' 付きで設定する必要があります。

=item IO::Socket::atmark not implemented on this architecture

=begin original

(F) Your machine doesn't implement the sockatmark() functionality,
neither as a system call nor an ioctl call (SIOCATMARK).

=end original

(F) 実行されているマシンでは、システムコールでも
ioctl コール(SIOCATMARK) でも sockatmark() 機能が実装されていません。

=item '%s' is an unknown bound type in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You used C<\b{...}> or C<\B{...}> and the C<...> is not known to
Perl.  The current valid ones are given in
L<perlrebackslash/\b{}, \b, \B{}, \B>.

=end original

(F) あなたは C<\b{...}> または C<\B{...}> を使いましたが C<...> は
Perl が知らないものでした。
現在有効なものは L<perlrebackslash/\b{}, \b, \B{}, \B> にあるものです。

=item %s is forbidden - matches null string many times in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) The pattern you've specified might cause the regular expression to
infinite loop so it is forbidden.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
See L<perlre>.

=end original

(F) 指定されたパターンは、正規表現が無限ループを引き起こすかもしれないので、
禁止されています。
S<<-- HERE> は問題が発見された正規表現の位置を示します。
L<perlre> を参照してください。

=item %s() isn't allowed on :utf8 handles

=begin original

(F) The sysread(), recv(), syswrite() and send() operators are
not allowed on handles that have the C<:utf8> layer, either explicitly, or
implicitly, eg., with the C<:encoding(UTF-16LE)> layer.

=end original

(F) sysread(), recv(), syswrite() and send() 演算子は、
明示的あるいは  C<:encoding(UTF-16LE)> 層のような暗黙的かに関わらず、
C<:utf8> 層を持つハンドルに対しては許されません。

=begin original

Previously sysread() and recv() currently use only the C<:utf8> flag for the stream,
ignoring the actual layers.  Since sysread() and recv() did no UTF-8
validation they can end up creating invalidly encoded scalars.

=end original

以前は、sysread() と recv() は現在の所ストリームに対して
C<:utf8> フラグのみを使い、実際の層は無視します。
sysread() と recv() は UTF-8 の検証を行っていなかったので、
不正にエンコードされたスカラを作ることになる可能性があります。

=begin original

Similarly, syswrite() and send() used only the C<:utf8> flag, otherwise ignoring
any layers.  If the flag is set, both wrote the value UTF-8 encoded, even if
the layer is some different encoding, such as the example above.

=end original

同様に、syswrite() は send() C<:utf8> フラグのみを使い、
それ以外は全ての層を無視していました。
フラグがセットされると、例え層が前述の例のように異なった
エンコーディングでも、UTF-8 エンコードされた値を書き込んでいました。

=begin original

Ideally, all of these operators would completely ignore the C<:utf8> state,
working only with bytes, but this would result in silently breaking existing
code.

=end original

理想的には、これらの演算子全ては完全に C<:utf8> 状態を無視して
バイトに対してのみ動作するべきですが、これは既存のコードを暗黙に
壊すことになります。

=item "%s" is more clearly written simply as "%s" in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

=end original

(W regexp) (C<S<use re 'strict'>> の下か C<(?[...])> の内側のみ)

=begin original

You specified a character that has the given plainer way of writing it, and
which is also portable to platforms running with different character sets.

=end original

それを書くのにより平坦な方法があり、さらに異なる文字集合で実行される
プラットフォーム間で移植性のある文字を指定しました。

=item $* is no longer supported as of Perl 5.30

=begin original

(F) The special variable C<$*>, deprecated in older perls, was removed in
5.10.0, is no longer supported and is a fatal error as of Perl 5.30.  In
previous versions of perl the use of C<$*> enabled or disabled multi-line
matching within a string.

=end original

(F) より古い perl で廃止予定とされ、5.10.0 で削除された特殊変数 C<$*> は、
もはや対応しておらず、Perl 5.30 から致命的エラーになりました。
以前のバージョンの perl では、C<$*> は文字列中の複数行マッチングを有効または
無効にするために使っていました。

=begin original

Instead of using C<$*> you should use the C</m> (and maybe C</s>) regexp
modifiers.  You can enable C</m> for a lexical scope (even a whole file)
with C<use re '/m'>.  (In older versions: when C<$*> was set to a true value
then all regular expressions behaved as if they were written using C</m>.)

=end original

C<$*> を使う代わりに、C</m> (とおそらく C</s>) 正規表現修飾子を
使うべきです。
C<use re '/m'> でレキシカルスコープで (ファイル全体でも) C</m> を
有効にできます。
(より古いバージョンでは: C<$*> を真の値に設定すると全ての正規表現は
C</m> を使って書かれたかのように振る舞っていました。)

=begin original

Use of this variable will be a fatal error in Perl 5.30.

=end original

この変数の使用は Perl 5.30 から致命的エラーになります。

=item $# is no longer supported as of Perl 5.30

=begin original

(F) The special variable C<$#>, deprecated in older perls, was removed as of
5.10.0, is no longer supported and is a fatal error as of Perl 5.30.  You
should use the printf/sprintf functions instead.

=end original

(F) より古い perl で廃止予定とされ、5.10.0 で削除された特殊変数 C<$#> は、
もはや対応しておらず、Perl 5.30 から致命的エラーになりました。

=item '%s' is not a code reference

=begin original

(W overload) The second (fourth, sixth, ...) argument of
overload::constant needs to be a code reference.  Either
an anonymous subroutine, or a reference to a subroutine.

=end original

(W overload) overload::constant の 2 番目 (4 番目、6 番目, ...) の引数は
コードリファレンスである必要があります。
無名サブルーチンか、サブルーチンへのリファレンスです。

=item '%s' is not an overloadable type

=begin original

(W overload) You tried to overload a constant type the overload package is
unaware of.

=end original

(W overload) オーバーロードパッケージが知らない定数型を
オーバーロードしようとしました。

=item isa is experimental

=begin original

(S experimental::isa) This warning is emitted if you use the (C<isa>)
operator. This operator is currently experimental and its behaviour may
change in future releases of Perl.

=end original

(S experimental::isa) この警告は、(C<isa>) 演算子を使うと発生します。
この演算子は現在のところ実験的な機能で、Perl の将来のリリースでは変更される
可能性があります。

=item -i used with no filenames on the command line, reading from STDIN

=begin original

(S inplace) The C<-i> option was passed on the command line, indicating
that the script is intended to edit files in place, but no files were
given.  This is usually a mistake, since editing STDIN in place doesn't
make sense, and can be confusing because it can make perl look like
it is hanging when it is really just trying to read from STDIN.  You
should either pass a filename to edit, or remove C<-i> from the command
line.  See L<perlrun|perlrun/-i[extension]> for more details.

=end original

(S inplace) The C<-i> オプションがコマンドラインで渡されました; これは
スクリプトがファイルをその場で編集することを示していますが、ファイルが
指定されませんでした。
これは普通はミスです; STDIN をその場で編集するというのは無意味ですし、
本当に単に STDIN から読み込もうとしているだけのときに perl が
ハングしているように見えることがあるので混乱を引き起こします。
編集するファイル名を指定するか、コマンドラインから C<-i> を
取り除いてください。
さらなる詳細については L<perlrun|perlrun/-i[extension]> を参照してください。

=item Junk on end of regexp in regex m/%s/

=begin original

(P) The regular expression parser is confused.

=end original

(P) 正規表現の構文解析ができなくなりました。

=item \K not permitted in lookahead/lookbehind in regex; marked by <-- HERE in m/%s/

=begin original

(F) Your regular expression used C<\K> in a lookhead or lookbehind
assertion, which isn't permitted.

=end original

(F) Your regular expression used  in a 
この正規表現は先読みや後読みの言明の中で C<\K> を使っています;
これは許されていません。

=item Label not found for "last %s"

=begin original

(F) You named a loop to break out of, but you're not currently in a loop
of that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=end original

(F) 脱出するループを指定しましたが、その名前のループの中にいません、
たとえ、呼び出された場所がそうであっても、今はそうではありません。
L<perlfunc/last> を参照してください。

=item Label not found for "next %s"

=begin original

(F) You named a loop to continue, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=end original

(F) 次の繰り返しを行なうループを指定しましたが、その名前のループの中に
いません; たとえ、呼び出された場所がそうであっても、今はそうではありません。
L<perlfunc/last> を参照してください。

=item Label not found for "redo %s"

=begin original

(F) You named a loop to restart, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=end original

(F) 繰り返しの再実行を行なうループを指定しましたが、その名前のループの中に
いません; たとえ、呼び出された場所がそうであっても、今はそうではありません。
L<perlfunc/last> を参照してください。

=item leaving effective %s failed

=begin original

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=end original

(F) C<use filetest> プラグマを使っている間に、
実と実効の UID や GID の切り替えに失敗しました。

=item length/code after end of string in unpack

=begin original

(F) While unpacking, the string buffer was already used up when an unpack
length/code combination tried to obtain more data.  This results in
an undefined value for the length.  See L<perlfunc/pack>.

=end original

(F) unpack する間、さらなるデータを取り出すために長さ/コードの組み合わせを
unpack するときに文字列バッファが既に使い切っていました。
これにより、長さが未定義値となります。
L<perlfunc/pack> を参照してください。

=item length() used on %s (did you mean "scalar(%s)"?)

=begin original

(W syntax) You used length() on either an array or a hash when you
probably wanted a count of the items.

=end original

(W syntax) おそらくアイテムの数を知りたいときに配列やハッシュに対して
length() を使いました。

=begin original

Array size can be obtained by doing:

=end original

配列の大きさは以下のようにして得られます:

    scalar(@array);

=begin original

The number of items in a hash can be obtained by doing:

=end original

ハッシュの要素数は以下のようにして得られます:

    scalar(keys %hash);

=item Lexing code attempted to stuff non-Latin-1 character into Latin-1 input

=begin original

(F) An extension is attempting to insert text into the current parse
(using L<lex_stuff_pvn|perlapi/lex_stuff_pvn> or similar), but tried to insert a character that
couldn't be part of the current input.  This is an inherent pitfall
of the stuffing mechanism, and one of the reasons to avoid it.  Where
it is necessary to stuff, stuffing only plain ASCII is recommended.

=end original

(F) エクステンションが(L<lex_stuff_pvn|perlapi/lex_stuff_pvn> や
同様なものを使って)現在のパースにテキストを挿入しようとしましたが、
現在の入力の一部となることができない文字を挿入しようとしました。
これは詰め物機構の生来の落とし穴で、これを避けるための理由の一つです。
詰め物が必要なところでは、プレーン ASCII のみを詰めることを推奨します。

=item Lexing code internal error (%s)

=begin original

(F) Lexing code supplied by an extension violated the lexer's API in a
detectable way.

=end original

(F) エクステンションによって供給された文法解析コードが、検出できる方法で
文法解析器の API に違反しています。

=item listen() on closed socket %s

=begin original

(W closed) You tried to do a listen on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/listen>.

=end original

(W closed) クローズされたソケットに listen を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/listen> を参照してください。

=item List form of piped open not implemented

=begin original

(F) On some platforms, notably Windows, the three-or-more-arguments
form of C<open> does not support pipes, such as C<open($pipe, '|-', @args)>.
Use the two-argument C<open($pipe, '|prog arg1 arg2...')> form instead.

=end original

(F) 一部のプラットフォーム、特に Windows では、
C<open($pipe, '|-', @args)> のような、3 以上の引数の形式の
C<open> ではパイプに対応していません。
代わりに 2 引数 C<open($pipe, '|prog arg1 arg2...')> 形式を使ってください。

=item Literal vertical space in [] is illegal except under /x in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) (only under C<S<use re 'strict'>> or within C<(?[...])>)

=end original

(F) (C<S<use re 'strict'>> の下、または C<(?[...])> の中のみ)

=begin original

Likely you forgot the C</x> modifier or there was a typo in the pattern.
For example, did you really mean to match a form-feed?  If so, all the
ASCII vertical space control characters are representable by escape
sequences which won't present such a jarring appearance as your pattern
does when displayed.

=end original

おそらく C</x> 修飾子を忘れたか、パターンの中にタイプミスがあるのでしょう。
例えば、本当に改ページとマッチングしたかったのですか?
もしそうなら、全ての ASCII の垂直スペース制御文字は、
パターンを表示したときに不愉快な形で表現されることのない、
エスケープシーケンスによって表現できます。

  \r    carriage return
  \f    form feed
  \n    line feed
  \cK   vertical tab

=item %s: loadable library and perl binaries are mismatched (got handshake key %p, needed %p)

=begin original

(P) A dynamic loading library C<.so> or C<.dll> was being loaded into the
process that was built against a different build of perl than the
said library was compiled against.  Reinstalling the XS module will
likely fix this error.

=end original

(P) 動的ロードライブラリ C<.so> が C<.dll> が、ライブラリが
コンパイルされたとするビルドと異なるビルドの perl に対して読み込まれました。
XS モジュールを再インストールすることでおそらくこのエラーは
修正されるでしょう。

=item Locale '%s' contains (at least) the following characters which
have unexpected meanings: %s  The Perl program will use the expected
meanings

=begin original

(W locale) You are using the named UTF-8 locale.  UTF-8 locales are
expected to have very particular behavior, which most do.  This message
arises when perl found some departures from the expectations, and is
notifying you that the expected behavior overrides these differences.
In some cases the differences are caused by the locale definition being
defective, but the most common causes of this warning are when there are
ambiguities and conflicts in following the Standard, and the locale has
chosen an approach that differs from Perl's.

=end original

(W locale) 名前付きの UTF-8 ロケールを使っています。
UTF-8 ロケールは、ほとんどの人がするような、とても特殊な振る舞いをすることが
想定されています。
このメッセージは、perl がこの想定との違いを発見し、その違いを
想定される振る舞いで上書きしたことを通知するときに発生します。
違いはロケール定義に問題があることによる場合もありますが、
この警告のもっとも一般的な原因は、標準に従う際に曖昧さや衝突があり、
ロケールが Perl のものと異なる手法を選んだときです。

=begin original

One of these is because that, contrary to the claims, Unicode is not
completely locale insensitive.  Turkish and some related languages
have two types of C<"I"> characters.  One is dotted in both upper- and
lowercase, and the other is dotless in both cases.  Unicode allows a
locale to use either the Turkish rules, or the rules used in all other
instances, where there is only one type of C<"I">, which is dotless in
the uppercase, and dotted in the lower.  The perl core does not (yet)
handle the Turkish case, and this message warns you of that.  Instead,
the L<Unicode::Casing> module allows you to mostly implement the Turkish
casing rules.

=end original

その一つは、主張に反して、Unicode が完全にロケールに依存しない
訳ではないからです。
トルコ語およびいくつかの関連言語は、2 種類の C<"I"> 文字があります。
一つは大文字と小文字の両方でドットがあり、もう一つは両方ともドットが
ありません。
Unicode はロケールがトルコ語の規則と、その他全ての場合に
使われる規則、つまり一種類の C<"I"> だけで、大文字ではドットがなく、
小文字にはドットがあるもの、のどちらを使うことも許しています。
perl コアは (まだ) トルコ語のケースを扱えず、このメッセージはそれを
警告します。
代わりに、L<Unicode::Casing> モジュールはトルコ語のケース規則をほぼ
実装しています。

=begin original

The other common cause is for the characters

=end original

その他のよくある原因は次の文字です:

 $ + < = > ^ ` | ~

=begin original

These are probematic.  The C standard says that these should be
considered punctuation in the C locale (and the POSIX standard defers to
the C standard), and Unicode is generally considered a superset of
the C locale.  But Unicode has added an extra category, "Symbol", and
classifies these particular characters as being symbols.  Most UTF-8
locales have them treated as punctuation, so that L<ispunct(2)> returns
non-zero for them.  But a few locales have it return 0.   Perl takes
the first approach, not using C<ispunct()> at all (see L<Note [5] in
perlrecharclass|perlrecharclass/[5]>), and this message is raised to notify you that you
are getting Perl's approach, not the locale's.

=end original

これらには問題があります。
C 標準は、これらは C ロケールでは句読点として扱うよう規定されていて
(そして POSIX 標準は C 標準に従います)、Unicode は一般的に C ロケールの
上位集合と考えられています。
しかし Unicode は、"Symbol" というカテゴリが追加され、
これはこれらの文字をシンボルとして分類しています。
ほとんどの UTF-8 ロケールはこれらを句読点として扱うので、
L<ispunct(2)> はこれらに対して非 0 を返します。
しかしいくつかのロケールでは 0 を返します。
Perl は最初の手法をとり、C<ispunct()> を全く使わず ( L<Note [5] in
perlrecharclass|perlrecharclass/[5]> 参照)、 
このメッセージはロケールのものではなく Perl の手法をとったことを
知らせるために発生します。

=item Locale '%s' may not work well.%s

=begin original

(W locale) You are using the named locale, which is a non-UTF-8 one, and
which perl has determined is not fully compatible with what it can
handle.  The second C<%s> gives a reason.

=end original

(W locale) 非 UTF-8 の名前付きロケールを使っていますが、
perl はこれを扱うのに完全な互換性のあるものを決定できませんでした。
2 番目の C<%s> に理由があります。

=begin original

By far the most common reason is that the locale has characters in it
that are represented by more than one byte.  The only such locales that
Perl can handle are the UTF-8 locales.  Most likely the specified locale
is a non-UTF-8 one for an East Asian language such as Chinese or
Japanese.  If the locale is a superset of ASCII, the ASCII portion of it
may work in Perl.

=end original

もっともありそうな理由は、そのロケールが複数バイトで表現される文字を
持っていることです。
Perl が扱えるそのようなロケールで唯一のものは UTF-8 ロケールです。
もっともありそうな指定されたロケールは、中国や日本のような東アジア言語の
非 UTF-8 のものです。
ロケールが ASCII の上位集合の場合、ASCII の部分は Perl で動作するでしょう。

=begin original

Some essentially obsolete locales that aren't supersets of ASCII, mainly
those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have
problems, depending on what portions of the ASCII character set get
changed by the locale and are also used by the program.
The warning message lists the determinable conflicting characters.

=end original

ASCII の上位集合でない、主に ISO 646 のものや、ASMO 449 のような
その他の 7 ビットロケールも問題になり得ます;
ASCII 文字集合のどの部分がロケールによって変更されるか、およびプログラムで
使われるかによります。
警告メッセージは決定できる衝突している文字を一覧表示します。

=begin original

Note that not all incompatibilities are found.

=end original

全ての非互換性が発見されるわけではないことに注意してください。

=begin original

If this happens to you, there's not much you can do except switch to use a
different locale or use L<Encode> to translate from the locale into
UTF-8; if that's impracticable, you have been warned that some things
may break.

=end original

これが起きた場合、異なるロケールを使うように変更するか、
そのロケールから UTF-8 に変換するために L<Encode> を使う以外に
できることはあまりありません; もしそれができないなら、
あなたは何かが壊れるかもしれないことを警告されました。

=begin original

This message is output once each time a bad locale is switched into
within the scope of C<S<use locale>>, or on the first possibly-affected
operation if the C<S<use locale>> inherits a bad one.  It is not raised
for any operations from the L<POSIX> module.

=end original

このメッセージは、C<S<use locale>> のスコープ内で悪いロケールに切り替わった
毎に、あるいは C<S<use locale>> が悪いものを継承している場合は
最初の影響があるかもしれない操作の時点で出力されます。
これは L<POSIX> モジュールの操作では発生しません。

=item localtime(%f) failed

=begin original

(W overflow) You called C<localtime> with a number that it could not handle:
too large, too small, or NaN.  The returned value is C<undef>.

=end original

(W overflow) 扱えない数値で C<localtime> を呼び出しました: 大きすぎたり
小さすぎたり NaN だったりです。
返り値は C<undef> です。

=item localtime(%f) too large

=begin original

(W overflow) You called C<localtime> with a number that was larger
than it can reliably handle and C<localtime> probably returned the
wrong date.  This warning is also triggered with NaN (the special
not-a-number value).

=end original

(W overflow) 信頼して扱えるよりも大きな数値で C<localtime> を呼び出したので
C<localtime> はおそらく間違った日付を返します。
この警告は、NaN (特殊な非数) でも引き起こされます。

=item localtime(%f) too small

=begin original

(W overflow) You called C<localtime> with a number that was smaller
than it can reliably handle and C<localtime> probably returned the
wrong date.

=end original

(W overflow) 信頼して扱えるよりも小さな数値で C<localtime> を呼び出したので
C<localtime> はおそらく間違った日付を返します。

=item Lookbehind longer than %d not implemented in regex m/%s/

=begin original

(F) There is currently a limit on the length of string which lookbehind can
handle.  This restriction may be eased in a future release. 

=end original

(F) 現在のところ前方参照が扱える文字列の長さには制限があります。
この制限は将来のリリースでは緩和されるでしょう。

=item Lost precision when %s %f by 1

=begin original

(W imprecision) The value you attempted to increment or decrement by one
is too large for the underlying floating point representation to store
accurately, hence the target of C<++> or C<--> is unchanged.  Perl issues this
warning because it has already switched from integers to floating point
when values are too large for integers, and now even floating point is
insufficient.  You may wish to switch to using L<Math::BigInt> explicitly.

=end original

(W imprecision) インクリメントまたはデクリメントしようとしている値は、
基礎となっている浮動小数点数表現にとって正確に保管するには大きすぎるので、
C<++> や C<--> のターゲットは変更されません。
Perl は既に値が整数として大きすぎる時には整数から浮動小数点数に
切り替えていて、浮動小数点数でも不十分なときにこの警告を出力します。
明示的に L<Math::BigInt> を使うように切り替えたいかもしれません。

=item lstat() on filehandle%s

=begin original

(W io) You tried to do an lstat on a filehandle.  What did you mean
by that?  lstat() makes sense only on filenames.  (Perl did a fstat()
instead on the filehandle.)

=end original

(W io) ファイルハンドルに lstat を実行しようとしました。
これで何をしようとしたのですか?
lstat() はファイル名に対してのみ意味があります。
(Perl はファイルハンドルには代わりに fstat() を行いました。)

=item lvalue attribute %s already-defined subroutine

=begin original

(W misc) Although L<attributes.pm|attributes> allows this, turning the lvalue
attribute on or off on a Perl subroutine that is already defined
does not always work properly.  It may or may not do what you
want, depending on what code is inside the subroutine, with exact
details subject to change between Perl versions.  Only do this
if you really know what you are doing.

=end original

(W misc) L<attributes.pm|attributes> ではこれは許されていますが、既に
定義されている Perl サブルーチンに対して左辺値属性をオンまたはオフにするのは
常に適切に動作するわけではありません。
あなたの望むことが行われるかもしれませんし行われないかもしれません;
サブルーチンの内側にどんなコードがあるかに依存し、正確な詳細は
Perl バージョン間で変更されることがあります。
自分が何をしているのかが本当に分かっているときにだけこれを行ってください。

=item lvalue attribute ignored after the subroutine has been defined

=begin original

(W misc) Using the C<:lvalue> declarative syntax to make a Perl
subroutine an lvalue subroutine after it has been defined is
not permitted.  To make the subroutine an lvalue subroutine,
add the lvalue attribute to the definition, or put the C<sub
foo :lvalue;> declaration before the definition.

=end original

(W misc) サブルーチンが定義された後、Perl サブルーチンを左辺値サブルーチンに
するために C<:lvalue> 宣言文を使うことはできません。
サブルーチンを左辺値サブルーチンにするには定義時に左辺値属性を追加するか、
定義する前に C<sub foo :lvalue;> 宣言を行います。

=begin original

See also L<attributes.pm|attributes>.

=end original

L<attributes.pm|attributes> も参照してください。

=item Magical list constants are not supported

=begin original

(F) You assigned a magical array to a stash element, and then tried
to use the subroutine from the same slot.  You are asking Perl to do
something it cannot do, details subject to change between Perl versions.

=end original

(F) マジカルな配列をスタッシュ要素に代入し、それから同じスロットから
サブルーチンを使おうとしました。
Perl のバージョンによって詳細が変わるかも知れないような、してはいけないことを
Perl にさせようとしました。

=item Malformed integer in [] in pack

=begin original

(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.

=end original

(F) 中かっこで数値繰り返し数を囲む場合、数値のみが許されます。
L<perlfunc/pack> を参照してください。

=item Malformed integer in [] in unpack

=begin original

(F) Between the brackets enclosing a numeric repeat count only digits
are permitted.  See L<perlfunc/pack>.

=end original

(F) 中かっこで数値繰り返し数を囲む場合、数値のみが許されます。
L<perlfunc/pack> を参照してください。

=item Malformed PERLLIB_PREFIX

=begin original

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

=end original

(F) OS/2 固有のエラーです。
PERLLIB_PREFIX は以下のような形か:

    prefix1;prefix2

=begin original

or
    prefix1 prefix2

=end original

または
    prefix1 prefix2

=begin original

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of
a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in L<perlos2>.

=end original

prefix1 と prefix2 が空でない形である必要があります。
C<prefix1> が組み込みライブラリ検索パスのプレフィックスなら、
prefix2 は置き換えられます。
このエラーは、コンポーネントが見つからないか、長すぎる時に起こります。
L<perlos2> の "PERLLIB_PREFIX" を参照してください。

=item Malformed prototype for %s: %s

=begin original

(F) You tried to use a function with a malformed prototype.  The
syntax of function prototypes is given a brief compile-time check for
obvious errors like invalid characters.  A more rigorous check is run
when the function is called.
Perhaps the function's author was trying to write a subroutine signature
but didn't enable that feature first (C<use feature 'signatures'>),
so the signature was instead interpreted as a bad prototype.

=end original

(F) 不正な形式のプロトタイプをもつ関数を使おうとしました。
関数プロトタイプの構文は、不正な文字のようなありふれたエラーについては
コンパイル時にチェックされます。
より厳密なチェックは、関数が呼び出された時に実行されます。
おそらく関数の作者はサブルーチンシグネチャを書こうとしたけれども、
先にこの機能を有効にしなかった (C<use feature 'signatures'>) ので、
シグネチャは間違ったプロトタイプとして解釈されました。

=item Malformed UTF-8 character%s

=begin original

(S utf8)(F) Perl detected a string that should be UTF-8, but didn't
comply with UTF-8 encoding rules, or represents a code point whose
ordinal integer value doesn't fit into the word size of the current
platform (overflows).  Details as to the exact malformation are given in
the variable, C<%s>, part of the message.

=end original

(S utf8)(F) Perl が、UTF-8 であるべき文字列を検出しましたが、
UTF-8 エンコーディング規則に従わない、
あるいは序数が現在のプラットフォームのワードサイズに収まらない
(オーバーフローする)符号位置を表現する文字列を検出しました。
不正な内容についての詳細は、メッセージの C<%s> の部分に入ります。

=begin original

One possible cause is that you set the UTF8 flag yourself for data that
you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit
data).  To guard against this, you can use C<Encode::decode('UTF-8', ...)>.

=end original

原因の可能性の一つは、UTF-8 だと思っていたけれでもそうではなかったデータ
(例えばレガシーな 8 ビットデータ)にあなた自身で UTF8 フラグをセットした
ことです。
これから守るためには、C<Encode::decode('UTF-8', ...)> を使えます。

=begin original

If you use the C<:encoding(UTF-8)> PerlIO layer for input, invalid byte
sequences are handled gracefully, but if you use C<:utf8>, the flag is set
without validating the data, possibly resulting in this error message.

=end original

入力に C<:encoding(UTF-8)> PerlIO 層を使うと、不正なバイトシーケンスは
寛容に扱われますが、C<:utf8> を使うと、フラグはデータを検証せずに設定され、
おそらく結果としてこのエラーメッセージが出力されます。

=begin original

See also L<Encode/"Handling Malformed Data">.

=end original

L<Encode/"Handling Malformed Data"> も参照してください。

=item Malformed UTF-8 returned by \N{%s} immediately after '%s'

=begin original

(F) The charnames handler returned malformed UTF-8.

=end original

(F) charnames ハンドラが不正な UTF-8 を返しました。

=item Malformed UTF-8 string in "%s"

=begin original

(F) This message indicates a bug either in the Perl core or in XS
code. Such code was trying to find out if a character, allegedly
stored internally encoded as UTF-8, was of a given type, such as
being punctuation or a digit.  But the character was not encoded
in legal UTF-8.  The C<%s> is replaced by a string that can be used
by knowledgeable people to determine what the type being checked
against was.

=end original

(F) このメッセージは、Perl 内部か XS コードのどちらかにバグがあることを
示しています。
そのコードは、UTF-8 として内部でエンコードされて
保管されているということになっているある文字が、
句読点や数字のような指定された型であるかどうかを見つけ出そうとしました。
しかし、この文字は正当な UTF-8 としてエンコードされていません。
C<%s> は、知識がある人々が、どの種類をチェックするべきかを
決めるために使われる文字列で置き換えられます。

=begin original

Passing malformed strings was deprecated in Perl 5.18, and
became fatal in Perl 5.26.

=end original

不正な文字列を渡すことは Perl 5.18 で廃止予定になり、
Perl 5.26 で致命的エラーになりました。

=item Malformed UTF-8 string in '%c' format in unpack

=begin original

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=end original

(F) UTF-8 エンコーディング規則に従わない何かを unpack しようとしたので、
perl はどうやってさらに進捗させればいいかが推測できませんでした。

=item Malformed UTF-8 string in pack

=begin original

(F) You tried to pack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=end original

(F) UTF-8 エンコーディング規則に従わない何かを pack しようとしたので、
perl はどうやってさらに進捗させればいいかが推測できませんでした。

=item Malformed UTF-8 string in unpack

=begin original

(F) You tried to unpack something that didn't comply with UTF-8 encoding
rules and perl was unable to guess how to make more progress.

=end original

(F) UTF-8 エンコーディング規則に従わない何かを unpack しようとしたので、
perl はどうやってさらに進捗させればいいかが推測できませんでした。

=item Malformed UTF-16 surrogate

=begin original

(F) Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.

=end original

(F) Perl は UTF-16 エンコード文字データを読み込んでいると考えましたが、
その間に Perl が不正な Unicode サロゲートに遭遇しました。

=item Mandatory parameter follows optional parameter

=begin original

(F) In a subroutine signature, you wrote something like "$a = undef,
$b", making an earlier parameter optional and a later one mandatory.
Parameters are filled from left to right, so it's impossible for the
caller to omit an earlier one and pass a later one.  If you want to act
as if the parameters are filled from right to left, declare the rightmost
optional and then shuffle the parameters around in the subroutine's body.

=end original

(F) サブルーチンシグネチャで、"$a = undef, $b" のような、先の引数が
オプションで後の引数が必須のようなものを書きました。
引数は左から右に埋められるので、呼び出し側が先のものを省略して後のものに
渡すことは不可能です。
引数が右から左に埋められるかのように振る舞ってほしい場合は、一番右を
オプションと宣言して、引数をサブルーチン本体で入れ替えてください。

=item Matched non-Unicode code point 0x%X against Unicode property; may
not be portable

=begin original

(S non_unicode) Perl allows strings to contain a superset of
Unicode code points; each code point may be as large as what is storable
in a signed integer on your system, but these may not be accepted by
other languages/systems.  This message occurs when you matched a string
containing such a code point against a regular expression pattern, and
the code point was matched against a Unicode property, C<\p{...}> or
C<\P{...}>.  Unicode properties are only defined on Unicode code points,
so the result of this match is undefined by Unicode, but Perl (starting
in v5.20) treats non-Unicode code points as if they were typical
unassigned Unicode ones, and matched this one accordingly.  Whether a
given property matches these code points or not is specified in
L<perluniprops/Properties accessible through \p{} and \P{}>.

=end original

(S non_unicode) Perl は文字列に Unicode 符号位置の上位集合を
含むことができます; それぞれの符号位置はシステムの符号付き整数に
格納できるだけの大きさを指定できますが、これらは他の言語/システムでは
受け付けられないかも知れません。
このメッセージは、このような符号位置を含む文字列をある正規表現パターンで
マッチングし、符号位置が Unicode 特性 C<\p{...}> または C<\P{...}> と
マッチングしたときに発生します。
Unicode 特性は Unicode 符号位置に対してのみ定義されているので、
Unicode によればこのマッチングの結果は未定義ですが、
Perl は (v5.20 から) 非 Unicode 符号位置を、典型的な未割り当て
Unicode 符号位置として扱い、それぞれマッチングします。
指定された特性がこれらの符号位置にマッチングするかどうかは
L<perluniprops/Properties accessible through \p{} and \P{}> で
指定されています。

=begin original

This message is suppressed (unless it has been made fatal) if it is
immaterial to the results of the match if the code point is Unicode or
not.  For example, the property C<\p{ASCII_Hex_Digit}> only can match
the 22 characters C<[0-9A-Fa-f]>, so obviously all other code points,
Unicode or not, won't match it.  (And C<\P{ASCII_Hex_Digit}> will match
every code point except these 22.)

=end original

このメッセージは、符号位置が Unicode かどうかがマッチングの結果に関係ない
場合は、(致命的にしていない限り)抑制されます。
例えば、特性 C<\p{ASCII_Hex_Digit}> は 22 文字 C<[0-9A-Fa-f]> だけに
マッチングするので、明らかに他の符号位置は、Unicode かどうかに関わらず、
マッチングしません。
(そして C<\P{ASCII_Hex_Digit}> はこれら 22 以外の全ての符号位置に
マッチングします。)

=begin original

Getting this message indicates that the outcome of the match arguably
should have been the opposite of what actually happened.  If you think
that is the case, you may wish to make the C<non_unicode> warnings
category fatal; if you agree with Perl's decision, you may wish to turn
off this category.

=end original

このメッセージが出たということは、マッチングの結果はおそらく実際に起きた結果と
逆になっているはずだということを示しています。
これに当てはまっていると考えられる場合は、C<non_unicode> 警告カテゴリを
致命的にした方がよいでしょう; Perl の結果に同意する場合は、このカテゴリを
オフにした方がよいでしょう。

=begin original

See L<perlunicode/Beyond Unicode code points> for more information.

=end original

さらなる情報については L<perlunicode/Beyond Unicode code points> を
参照してください。

=item %s matches null string many times in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
See L<perlre>.

=end original

(W) 指定したパターンは、もし、正規表現エンジンがチェックを
行なっていなければ、無限ループに陥るものです。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Maximal count of pending signals (%u) exceeded

=begin original

(F) Perl aborted due to too high a number of signals pending.  This
usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely.  (See L<perlipc/"Deferred Signals (Safe Signals)">.)

=end original

(F) あまりにも多くのシグナルが保留中になったので Perl は中断しました。
これは普通 OS が速くシグナルを(とても高い優先順位で)配達しようとしすぎて、
perl のプロセスが安全にシグナルを処理できるところに到達するまでに必要な
リソースが不足したことを示しています。
(L<perlipc/"Deferred Signals (Safe Signals)"> を参照してください。)

=item "%s" may clash with future reserved word

=begin original

(W) This warning may be due to running a perl5 script through a perl4
interpreter, especially if the word that is being warned about is
"use" or "my".

=end original

(W) この警告は perl5 のスクリプトを perl4 インタプリタで実行しようとした
ときに起きることが多いです; 特に警告された文字が "use" や "my" の場合は
そうです。

=item '%' may not be used in pack

=begin original

(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other way.
See L<perlfunc/unpack>.

=end original

(F) チェックサムを指定して pack を行なうことはできません;
チェックサム処理では、情報が失われ、どうしようもなくなるからです。
L<perlfunc/unpack> を参照してください。

=item Method for operation %s not found in package %s during blessing

=begin original

(F) An attempt was made to specify an entry in an overloading table that
doesn't resolve to a valid subroutine.  See L<overload>.

=end original

(F) 多重定義テーブルで、有効なサブルーチンに解決できない
エントリを指定しようとしました。
L<overload> を参照してください。

=item Method %s not permitted

=begin original

See L</500 Server error>.

=end original

L</500 Server error> を参照してください。

=item Might be a runaway multi-line %s string starting on line %d

=begin original

(S) An advisory indicating that the previous error may have been caused
by a missing delimiter on a string or pattern, because it eventually
ended earlier on the current line.

=end original

(S) ようやく現在行になって、文字列やパターンの終わりが見つかったことから、
先のエラーが、文字列やパターンのデリミタが、見つからなかったことで
起ったかもしれないことを、補足的に示しています。

=item Misplaced _ in number

=begin original

(W syntax) An underscore (underbar) in a numeric constant did not
separate two digits.

=end original

(W syntax) 数値定数の下線が、二つの値を分離していません。

=item Missing argument for %n in %s

=begin original

(F) A C<%n> was used in a format string with no corresponding argument for
perl to write the current string length to.

=end original

(F) C<%n> がフォーマット文字列で使われましたが、perl が現在の文字列長を
書くための対応する引数がありません。

=item Missing argument in %s

=begin original

(W missing) You called a function with fewer arguments than other
arguments you supplied indicated would be needed.

=end original

(W missing) 他で指定した引数によって必要であると示されているよりも
少ない引数で関数を呼び出しました。

=begin original

Currently only emitted when a printf-type format required more
arguments than were supplied, but might be used in the future for
other cases where we can statically determine that arguments to
functions are missing, e.g. for the L<perlfunc/pack> function.

=end original

現在のところは printf 型式のフォーマットが提供されたよりも多くの引数を
要求した場合にのみ発生しますが、
将来、L<perlfunc/pack> 関数のような、関数の引数を静的に決定できる
その他の場合に使われるかもしれません。

=item Missing argument to -%c

=begin original

(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.

=end original

(F) 示されたコマンドラインスイッチの引数は、
スイッチの直後にスペースを空けないで書く必要があります。

=item Missing braces on \N{}

=item Missing braces on \N{} in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) Wrong syntax of character name literal C<\N{charname}> within
double-quotish context.  This can also happen when there is a space
(or comment) between the C<\N> and the C<{> in a regex with the C</x> modifier.
This modifier does not change the requirement that the brace immediately
follow the C<\N>.

=end original

(F) ダブルクォートされたコンテキストの中で、文字名リテラル C<\N{charname}> の
文法が間違っています。
これはまた、C</x> 修飾子付きの正規表現の C<\N> と C<{> の間に空白(または
コメント)がある場合にも起こります。
この修飾子は、C<\N> の直後に中かっこが必要であるという条件は変更しません。

=item Missing braces on \o{}

=begin original

(F) A C<\o> must be followed immediately by a C<{> in double-quotish context.

=end original

(F) ダブルクォート風コンテキストでは C<\o> は直後に C<{> が
引き続かなければなりません。

=item Missing comma after first argument to %s function

=begin original

(F) While certain functions allow you to specify a filehandle or an
"indirect object" before the argument list, this ain't one of them.

=end original

(F) ある種の関数では、引数リストの前に、ファイルハンドルや
「間接オブジェクト」をおくことができますが、この関数は、
そういったものではありません。

=item Missing command in piped open

=begin original

(W pipe) You used the C<open(FH, "| command")> or
C<open(FH, "command |")> construction, but the command was missing or
blank.

=end original

(W pipe) C<open(FH, "| command")> か C<open(FH, "command |")> の構文を
使っていますが、コマンドが指定されていないか空白です。

=item Missing control char name in \c

=begin original

(F) A double-quoted string ended with "\c", without the required control
character name.

=end original

(F) ダブルクォートされた文字列が "\c" で終わっています; 制御文字名が
必要です。

=item Missing ']' in prototype for %s : %s

=begin original

(W illegalproto) A grouping was started with C<[> but never closed with C<]>.

=end original

(W illegalproto) グループ化は C<[> で始まりましたが C<]> で
閉じられませんでした。

=item Missing name in "%s sub"

=begin original

(F) The syntax for lexically scoped subroutines requires that
they have a name with which they can be found.

=end original

(F) レキシカルスコープのサブルーチンの文法には探すことの出来る名前が必要です。

=item Missing $ on loop variable

=begin original

(F) Apparently you've been programming in B<csh> too much.  Variables
are always mentioned with the $ in Perl, unlike in the shells, where it
can vary from one line to the next.

=end original

(F) B<csh> を使いすぎた症状が現れているようです。
Perl では、変数は常に $ を付けて表わされます; その時によって違う、シェルとは
違っています。

=item (Missing operator before %s?)

=begin original

(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  Often the missing operator is a comma.

=end original

(S syntax) これは "%s found where operator expected" メッセージと共に
表示される教育的な推測です。
しばしば不足している演算子はカンマです。

=item Missing or undefined argument to %s

=begin original

(F) You tried to call require or do with no argument or with an undefined
value as an argument.  Require expects either a package name or a
file-specification as an argument; do expects a filename.  See
L<perlfunc/require EXPR> and L<perlfunc/do EXPR>.

=end original

(F) 引数なし、または未定義値を引数として require や do を
呼び出そうとしました。
require はパッケージ名またはファイル指定を引数として想定します;
do はファイル名を想定します。
L<perlfunc/require EXPR> と L<perlfunc/do EXPR> を参照してください。

=item Missing right brace on \%c{} in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) Missing right brace in C<\x{...}>, C<\p{...}>, C<\P{...}>, or C<\N{...}>.

=end original

(F) C<\x{...}>, C<\p{...}>, C<\P{...}>, C<\N{...}> の右側のかっこが
抜けています。

=item Missing right brace on \N{}

=item Missing right brace on \N{} or unescaped left brace after \N

=begin original

(F) C<\N> has two meanings.

=end original

(F) C<\N> には二つの意味があります。

=begin original

The traditional one has it followed by a name enclosed in braces,
meaning the character (or sequence of characters) given by that
name.  Thus C<\N{ASTERISK}> is another way of writing C<*>, valid in both
double-quoted strings and regular expression patterns.  In patterns,
it doesn't have the meaning an unescaped C<*> does.

=end original

伝統的なものは中かっこで囲まれた名前が引き続き、その名前を持つ文字
(または文字並び)を意味します。
従って C<\N{ASTERISK}> は C<*> を書くためのもう一つの方法であり、
ダブルクォート文字列と正規表現パターンの両方で妥当です。
パターンでは、これはエスケープされない C<*> の持つ意味はありません。

=begin original

Starting in Perl 5.12.0, C<\N> also can have an additional meaning (only)
in patterns, namely to match a non-newline character.  (This is short
for C<[^\n]>, and like C<.> but is not affected by the C</s> regex modifier.)

=end original

Perl 5.12.0 から、C<\N> はパターンでの中(のみ)では追加の意味を持ちます;
非改行文字にマッチングします。
(これは C<[^\n]> の短縮形で、C<.> と似ていますが C</s> 正規表現修飾子によって
影響を受けません。)

=begin original

This can lead to some ambiguities.  When C<\N> is not followed immediately
by a left brace, Perl assumes the C<[^\n]> meaning.  Also, if the braces
form a valid quantifier such as C<\N{3}> or C<\N{5,}>, Perl assumes that this
means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a
C<\N{> and a matching C<}>, Perl assumes that a character name is desired.

=end original

これによりいくつかの曖昧さを引き起こします。
C<\N> の直後に開き中かっこがなければ、Perl は C<[^\n]> の意味を仮定します。
また、中かっこが C<\N{3}> や C<\N{5,}> のような妥当な量指定子の形に
なっているなら、Perl はこれを与えられた量の非改行 (この例では、それぞれ 3 と
5 以上) にマッチングするという意味を仮定します。
それ以外の場合、C<\N{> と対応する C<}> があれば、Perl は文字名が
求められていると仮定します。

=begin original

However, if there is no matching C<}>, Perl doesn't know if it was
mistakenly omitted, or if C<[^\n]{> was desired, and raises this error.
If you meant the former, add the right brace; if you meant the latter,
escape the brace with a backslash, like so: C<\N\{>

=end original

しかし、対応する C<}> がなければ、それが間違って省略されたのか、
C<[^\n]{> が求められているものなのかが分からず、エラーを起こします。
前者を意味しているなら、閉じ中かっこを追加してください; 後者を
意味しているなら、C<\N\{> のように中かっこを逆スラッシュで
エスケープしてください。

=item Missing right curly or square bracket

=begin original

(F) The lexer counted more opening curly or square brackets than closing
ones.  As a general rule, you'll find it's missing near the place you
were last editing.

=end original

(F) 字句解析部が、閉じ中かっこ(または大かっこ)よりも
開き中かっこ(大かっこ)を多く発見しました。
一般的な規則として、最後に修正した場所の近くに間違いがあるといえます。

=item (Missing semicolon on previous line?)

=begin original

(S syntax) This is an educated guess made in conjunction with the message
"%s found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

=end original

(S syntax) これは "%s found where operator expected" メッセージと共に
表示される教育的な推測です。
このメッセージが出たからといって、機械的に前の行にセミコロンを付けることは
しないでください。

=item Modification of a read-only value attempted

=begin original

(F) You tried, directly or indirectly, to change the value of a
constant.  You didn't, of course, try "2 = 1", because the compiler
catches that.  But an easy way to do the same thing is:

=end original

(F) 直接、間接に関らず、定数値を変更しようとしました。
もちろん、コンパイラが発見できる、"2 = 1" などといったことを
したわけではありません。
しかし、同じことは以下のようにしても起こります。

    sub mod { $_[0] = 1 }
    mod(2);

=begin original

Another way is to assign to a substr() that's off the end of the string.

=end original

substr() で、文字列の終わりよりも後ろに代入を行なうことでも起こります。

=begin original

Yet another way is to assign to a C<foreach> loop I<VAR> when I<VAR>
is aliased to a constant in the look I<LIST>:

=end original

もう一つの可能性は、C<foreach> ループにおいて、I<VAR> が I<LIST> の中の
定数のエイリアスであるときに、I<VAR> に代入した時です:

    $x = 1;
    foreach my $n ($x, 2) {
        $n *= 2; # modifies the $x, but fails on attempt to
    }            # modify the 2

=item Modification of non-creatable array value attempted, %s

=begin original

(F) You tried to make an array value spring into existence, and the
subscript was probably negative, even counting from end of the array
backwards.

=end original

(F) 配列値を存在するようにしようとしました; おそらく、添字が負数で、配列の
終わりから逆に数えたとしても、おかしな位置を指しているようです。

=item Modification of non-creatable hash value attempted, %s

=begin original

(P) You tried to make a hash value spring into existence, and it
couldn't be created for some peculiar reason.

=end original

(F) ハッシュ値を存在するようにしようとしましたが、何か特別な理由で、
できませんでした。

=item Module name must be constant

=begin original

(F) Only a bare module name is allowed as the first argument to a "use".

=end original

(F) "use" の最初の引数としてモジュール名を示すのに許されているのは、
裸の単語だけです。

=item Module name required with -%c option

=begin original

(F) The C<-M> or C<-m> options say that Perl should load some module, but
you omitted the name of the module.  Consult
L<perlrun|perlrun/-m[-]module> for full details about C<-M> and C<-m>.

=end original

C<-M> と C<-m> のオプションは Perl にモジュールを読み込ませることを
指示しますが、モジュール名がありませんでした。
C<-M> と C<-m> に関する完全な詳細については
L<perlrun|perlrun/-m[-]module> を参照してください。

=item More than one argument to '%s' open

=begin original

(F) The C<open> function has been asked to open multiple files.  This
can happen if you are trying to open a pipe to a command that takes a
list of arguments, but have forgotten to specify a piped open mode.
See L<perlfunc/open> for details.

=end original

(F) C<open> 関数に、複数のファイルを開くように指定されました。
これは引数のリストを取るコマンドへのパイプを開こうとしたときに、パイプ
オープンモードを指定するのを忘れた時に起きます。
詳細は L<perlfunc/open> を参照してください。

=item mprotect for COW string %p %u failed with %d

=begin original

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see
L<perlguts/"Copy on Write">), but a shared string buffer
could not be made read-only.

=end original

(S) perl を B<-D>PERL_DEBUG_READONLY_COW (L<perlguts/"Copy on Write"> 参照) で
コンパイルしましたが、共有文字列バッファを読み込み専用にできませんでした。

=item mprotect for %p %u failed with %d

=begin original

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see L<perlhacktips>),
but an op tree could not be made read-only.

=end original

(S) perl が B<-D>PERL_DEBUG_READONLY_OPS (L<perlhacktips> 参照) で
コンパイルされましたが、op 木を読み込み専用にできませんでした。

=item mprotect RW for COW string %p %u failed with %d

=begin original

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_COW (see
L<perlguts/"Copy on Write">), but a read-only shared string
buffer could not be made mutable.

=end original

(S) perl を B<-D>PERL_DEBUG_READONLY_COW (L<perlguts/"Copy on Write"> 参照) で
コンパイルしましたが、読み込み専用共有文字列バッファを変更可能に
できませんでした。

=item mprotect RW for %p %u failed with %d

=begin original

(S) You compiled perl with B<-D>PERL_DEBUG_READONLY_OPS (see
L<perlhacktips>), but a read-only op tree could not be made
mutable before freeing the ops.

=end original

(S) perl が B<-D>PERL_DEBUG_READONLY_OPS (L<perlhacktips> 参照) で
コンパイルされましたが、読み込み専用の op 木を、op を解放する前に
ミュータブルにできませんでした。

=item msg%s not implemented

=begin original

(F) You don't have System V message IPC on your system.

=end original

(F) このシステムでは、System V メッセージ IPC は使えません。

=item Multidimensional syntax %s not supported

=begin original

(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.
They're written like C<$foo[1][2][3]>, as in C.

=end original

(W syntax) 多次元配列は、C<$foo[1,2,3]> のようには書けません。
これは、C のように C<$foo[1][2][3]> のように書きます。

=item Multiple slurpy parameters not allowed

=begin original

(F) In subroutine signatures, a slurpy parameter (C<@> or C<%>) must be
the last parameter, and there must not be more than one of them; for
example:

=end original

(F) サブルーチンシグネチャで、吸い込みパラメータ (C<@> または C<%>) は
最後のパラメータでなければならず、複数あってはなりません; 例えば:

    sub foo ($a, @b)    {} # legal
    sub foo ($a, @b, %) {} # invalid

=item '/' must follow a numeric type in unpack

=begin original

(F) You had an unpack template that contained a '/', but this did not
follow some unpack specification producing a numeric value.
See L<perlfunc/pack>.

=end original

(F) '/' を含む unpack テンプレートがありますが、これがなんらかの
数値を生成する unpack 指定に引き続いていません。
L<perlfunc/pack> を参照してください。

=item %s must not be a named sequence in transliteration operator

=begin original

(F) Transliteration (C<tr///> and C<y///>) transliterates individual
characters.  But a named sequence by definition is more than an
individual character, and hence doing this operation on it doesn't make
sense.

=end original

(F) 文字変換 (C<tr///> と C<y///>) は個々の文字を変換します。
しかし、定義による名前付き並びは個々の文字以上のものがあるので、
それに対してこの操作をするのは意味がありません。

=item "my sub" not yet implemented

=begin original

(F) Lexically scoped subroutines are not yet implemented.  Don't try
that yet.

=end original

(F) レキシカルスコープのサブルーチンはまだ実装されていません。
まだ試さないでください。

=item "my" subroutine %s can't be in a package

=begin original

(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.

=end original

(F) レキシカルスコープサブルーチンはパッケージ内にないので、
頭にパッケージ名を付けて宣言することは、無意味です。

=item "my %s" used in sort comparison

=begin original

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

=end original

(W syntax) パッケージ変数 $a と $b はソート比較のために使われます。
$a または $b をソート比較ブロックの中の C<< <=> >> または C<cmp> 演算子の
オペランドとして使いましたが、この変数はその前にレキシカル変数として
宣言されています。
ソート変数をパッケージ名で修飾するか、レキシカル変数の名前を変えてください。

=item "my" variable %s can't be in a package

=begin original

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

=end original

(F) レキシカルスコープサブルーチンはパッケージ内にないので、
頭にパッケージ名を付けて宣言することは、無意味です。
パッケージ変数をローカル化したい場合には、local() を使ってください。

=item Name "%s::%s" used only once: possible typo

=begin original

(W once) Typographical errors often show up as unique variable
names.  If you had a good reason for having a unique name, then
just mention it again somehow to suppress the message.  The C<our>
declaration is also provided for this purpose.

=end original

(W once) しばしばタイプミスによってユニークな変数名として表示されます。
ユニークな名前をを使う理由があるのなら、もう一度どこかで参照することで
このメッセージを抑制できます。
C<our> 宣言もこの目的のために提供されています。

=begin original

NOTE: This warning detects package symbols that have been used
only once.  This means lexical variables will never trigger this
warning.  It also means that all of the package variables $c, @c,
%c, as well as *c, &c, sub c{}, c(), and c (the filehandle or
format) are considered the same; if a program uses $c only once
but also uses any of the others it will not trigger this warning.
Symbols beginning with an underscore and symbols using special
identifiers (q.v. L<perldata>) are exempt from this warning.

=end original

注意: この警告は一度しか使われていないパッケージシンボルを検出します。
つまり、レキシカル変数はこの警告を引き起こさないと言うことです。
また、パッケージ変数 $c, @c, %c および
*c, &c, sub c{}, c(), c (ファイルハンドルまたはフォーマット) は
同じであると考えます; プログラムが $c を一度だけ使っている蹴れどっも
その他のものも使っている場合、この警告は引き起こされません。
下線で始まるシンボルと特殊識別子
(L<perldata> 参照) を使ったシンボルはこの警告を免れます。

=item Need exactly 3 octal digits in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) Within S<C<(?[   ])>>, all constants interpreted as octal need to be
exactly 3 digits long.  This helps catch some ambiguities.  If your
constant is too short, add leading zeros, like

=end original

(F) S<C<(?[   ])>> の中で、8 進数として解釈される全ての定数は正確に 3 桁である
必要があります。
これはある種の曖昧さを捕まえる助けになります。
定数が短い場合は、以下のように先頭に 0 を追加してください

 (?[ [ \078 ] ])     # Syntax error!
 (?[ [ \0078 ] ])    # Works
 (?[ [ \007 8 ] ])   # Clearer

=begin original

The maximum number this construct can express is C<\777>.  If you
need a larger one, you need to use L<\o{}|perlrebackslash/Octal escapes> instead.  If you meant
two separate things, you need to separate them:

=end original

この構文が表現できる最大数は C<\777> です。
より大きな値が必要なときは、代わりに L<\o{}|perlrebackslash/Octal escapes> を
使う必要があります。
二つの別々のものを意味しているなら、分ける必要があります:

 (?[ [ \7776 ] ])        # Syntax error!
 (?[ [ \o{7776} ] ])     # One meaning
 (?[ [ \777 6 ] ])       # Another meaning
 (?[ [ \777 \006 ] ])    # Still another

=item Negative '/' count in unpack

=begin original

(F) The length count obtained from a length/code unpack operation was
negative.  See L<perlfunc/pack>.

=end original

(F) 長さ/コード unpack 操作で得られた長さカウントが負数でした。
L<perlfunc/pack> を参照してください。

=item Negative length

=begin original

(F) You tried to do a read/write/send/recv operation with a buffer
length that is less than 0.  This is difficult to imagine.

=end original

(F) ゼロより短い長さのバッファで、読み込み、書き込み、送信、受信を
行なおうとしました。
これは想像しにくいことです。

=item Negative offset to vec in lvalue context

=begin original

(F) When C<vec> is called in an lvalue context, the second argument must be
greater than or equal to zero.

=end original

(F) 左辺値コンテキストで C<vec> が呼び出されたとき、
二つ目の引数は 0 以上でなければなりません。

=item Negative repeat count does nothing

=begin original

(W numeric) You tried to execute the
L<C<x>|perlop/Multiplicative Operators> repetition operator fewer than 0
times, which doesn't make sense.

=end original

(W numeric) L<C<x>|perlop/Multiplicative Operators> 繰り返し演算子を
0 より小さい回数実行しようとしました; これは無意味です。

=item Nested quantifiers in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You can't quantify a quantifier without intervening parentheses.
So things like ** or +* or ?* are illegal.  The S<<-- HERE> shows
whereabouts in the regular expression the problem was discovered.

=end original

(F) かっこを挟まないで、数量子を数量子で修飾することはできません。
つまり、** や +* や ?* といったものは、正しくありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=begin original

Note that the minimal matching quantifiers, C<*?>, C<+?>, and
C<??> appear to be nested quantifiers, but aren't.  See L<perlre>.

=end original

最短一致数量子の C<*?>、C<+?>、C<??> は、ネストした数量子のように
見えますが、そうではありません。
L<perlre> を参照してください。

=item %s never introduced

=begin original

(S internal) The symbol in question was declared but somehow went out of
scope before it could possibly have been used.

=end original

(S internal) 問題のシンボルは、宣言されましたが、使われる前にスコープから
外れてしまいました。

=item next::method/next::can/maybe::next::method cannot find enclosing method

=begin original

(F) C<next::method> needs to be called within the context of a
real method in a real package, and it could not find such a context.
See L<mro>.

=end original

(F) C<next::method> は実パッケージの実メソッドのコンテキストの中で呼ばれる
必要がありますが、そのようなコンテキストが見つけられませんでした。
L<mro> を参照してください。

=item \N in a character class must be a named character: \N{...} in regex; 
marked by S<<-- HERE> in m/%s/

=begin original

(F) The new (as of Perl 5.12) meaning of C<\N> as C<[^\n]> is not valid in a
bracketed character class, for the same reason that C<.> in a character
class loses its specialness: it matches almost everything, which is
probably not what you want.

=end original

(F) C<[^\n]> という新しい (5.12 からの) C<\N> の意味は大かっこ文字クラスでは
妥当ではありません; 文字クラス内の C<.> がその特殊性を失うのと同じ理由です:
これはほとんど何にでもマッチングし、これはおそらくあなたの求めているものでは
ないでしょう。

=item \N{} here is restricted to one character in regex; marked by <-- HERE in m/%s/

=begin original

(F) Named Unicode character escapes (C<\N{...}>) may return a
multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match the
whole thing correctly, except under certain conditions.  These currently
are

=end original

(F) 名前付き Unicode 文字エスケープ (C<(\N{...})>) は複数文字並びを
返すことがあります。
文字クラスは入力のただ一つの文字にマッチングすることを想定していますが、
perl は全体を正しくマッチングします; 但しいくつかの場合は例外です。
それは今のところ:

=over 4

=item When the class is inverted (C<[^...]>)

(クラスが反転された場合 (C<[^...]>))

=begin original

The mathematically logical behavior for what matches when inverting
is very different from what people expect, so we have decided to
forbid it.

=end original

反転したときに何にマッチングするかに関する厳密に論理的な振る舞いは
人々が想定するものと大きく異なっているので、これは禁止することにしました。

=item The escape is the beginning or final end point of a range

(エスケープが範囲の始点か終点の場合)

=begin original

Similarly unclear is what should be generated when the
C<\N{...}> is used as one of the end points of the range, such as in

=end original

同様に不明確なものは、次のように、範囲の端点として C<\N{...}> が
使われたときに何が生成されるべきかということです:

 [\x{41}-\N{ARABIC SEQUENCE YEH WITH HAMZA ABOVE WITH AE}]

=begin original

What is meant here is unclear, as the C<\N{...}> escape is a sequence
of code points, so this is made an error.

=end original

ここで意味しているものは不明確です; C<\N{...}> エスケープは
符号位置の並びだからです; 従ってこれはエラーを発生させます。

=item In a regex set

(正規表現集合の中の場合)

=begin original

The syntax S<C<(?[   ])>> in a regular expression yields a list of
single code points, none can be a sequence.

=end original

正規表現の中の S<C<(?[   ])>> 構文は単一の符号位置のリストになり、
並びにはなりません。

=back

=item No %s allowed while running setuid

=begin original

(F) Certain operations are deemed to be too insecure for a setuid or
setgid script to even be allowed to attempt.  Generally speaking there
will be another way to do what you want that is, if not secure, at least
securable.  See L<perlsec>.

=end original

(F) ある種の操作は、setuid や setgid スクリプトにとって、
やってみることはできても、とても安全なものとは考えられないものです。
一般に言って、安全ではなくても、安全にしうる、別の方法があるはずです。
L<perlsec> を参照してください。

=item No code specified for -%c

=begin original

(F) Perl's B<-e> and B<-E> command-line options require an argument.  If
you want to run an empty program, pass the empty string as a separate
argument or run a program consisting of a single 0 or 1:

=end original

(F) Perl の B<-e> と B<-E> のコマンドラインオプションは引数が必要です。
空のプログラムを実行したい場合は、空文字列を別の引数として渡すか、単一の
0 または 1 からなるプログラムを実行してください:

    perl -e ""
    perl -e0
    perl -e1

=item No comma allowed after %s

=begin original

(F) A list operator that has a filehandle or "indirect object" is
not allowed to have a comma between that and the following arguments.
Otherwise it'd be just another one of the arguments.

=end original

(F) ファイルハンドルや「間接オブジェクト」を伴うリスト演算子では、
それらとそれ以降の引数の間にコンマを入れることはできません。
そのようにした場合には、引数の一つとなってしまいます。

=begin original

One possible cause for this is that you expected to have imported
a constant to your name space with B<use> or B<import> while no such
importing took place, it may for example be that your operating
system does not support that particular constant.  Hopefully you did
use an explicit import list for the constants you expect to see;
please see L<perlfunc/use> and L<perlfunc/import>.  While an
explicit import list would probably have caught this error earlier
it naturally does not remedy the fact that your operating system
still does not support that constant.  Maybe you have a typo in
the constants of the symbol import list of B<use> or B<import> or in the
constant name at the line where this error was triggered?

=end original

これの原因としてあり得るものの一つは、B<use> や B<import> を使って
名前空間にインポートしたつもりの定数が実際にはインポートされていなかった
場合です;
例えば OS が特定の定数に対応していない場合などです。
できればインポートしたい定数のリストを明示的に使ってください;
L<perlfunc/use> と L<perlfunc/import> を参照して下さい。
明示的なインポートリストでおそらくこのエラーをより早く知ることができますが、
そもそも OS がその定数に対応していないという問題を解決はしません。
おそらく B<use> や B<import> のシンボルインポートリストの定数か、
エラーを引き起こした行の定数名をタイプミスしたのでは?

=item No command into which to pipe on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '|' at the end of the command line, so it
doesn't know where you want to pipe the output from this command.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインの最後にに '|' を発見しましたが、
このコマンドから出力をどこにパイプしたいのかがわかりませんでした。

=item No DB::DB routine defined

=begin original

(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>
module) didn't define a routine to be called at the beginning of each
statement.

=end original

(F) 現在実行中のコードは、B<-d> スイッチを付けてコンパイルされましたが、
何らかの理由により、現在のデバッガ(F<perl5db.pl> か C<Devel::> モジュール)
が各実行文の頭で呼び出すルーティンを定義していません。

=item No dbm on this machine

=begin original

(P) This is counted as an internal error, because every machine should
supply dbm nowadays, because Perl comes with SDBM.  See L<SDBM_File>.

=end original

(P) これは、内部エラーとして扱われます; Perl に SDBM が付いてくるので、
どのマシンでも dbm が使えるはずだからです。
L<SDBM_File> を参照してください。

=item No DB::sub routine defined

=begin original

(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the current debugger (e.g. F<perl5db.pl> or a C<Devel::>
module) didn't define a C<DB::sub> routine to be called at the beginning
of each ordinary subroutine call.

=end original

(F) 現在実行中のコードは、B<-d> スイッチを付けてコンパイルされましたが、
何らかの理由により、現在のデバッガ(F<perl5db.pl> か C<Devel::> モジュール)が
各サブルーチン呼び出しの頭で呼び出す C<DB::sub> ルーティンを
定義していませんでした。

=item No digits found for %s literal

=begin original

(F) No hexadecimal digits were found following C<0x> or no binary digits
were found following C<0b>.

=end original

(F) C<0x> に 16 進数が引き続かなかったり C<0b> に 2 進数が
引き続かなかったりしました。

=item No directory specified for -I

=begin original

(F) The B<-I> command-line switch requires a directory name as part of the
I<same> argument.  Use B<-Ilib>, for instance.  B<-I lib> won't work.

=end original

(F) B<-I> コマンドラインオプションは I<同じ> 引数の一部としてディレクトリ名が
必要です。
例えば、B<-Ilib> としてください。
B<-I lib> は動作しません。

=item No error file after 2> or 2>> on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '2>' or a '2>>' on the command line, but can't
find the name of the file to which to write data destined for stderr.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインに '2>' や '2>>' を発見しましたが、
標準エラーとしてデータを書き込むファイル名が見つかりませんでした。

=item No group ending character '%c' found in template

=begin original

(F) A pack or unpack template has an opening '(' or '[' without its
matching counterpart.  See L<perlfunc/pack>.

=end original

(F) pack や unpack のテンプレートに開きかっこの '(' や '[' がありますが、
対応する閉じかっこがありません。
L<perlfunc/pack> を参照してください。

=item No input file after < on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '<' on the command line, but can't find the
name of the file from which to read data for stdin.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、コマンドラインに
'<' を発見しましたが、標準入力として読み込むためのファイル名が
見つかりませんでした。

=item No next::method '%s' found for %s

=begin original

(F) C<next::method> found no further instances of this method name
in the remaining packages of the MRO of this class.  If you don't want
it throwing an exception, use C<maybe::next::method>
or C<next::can>.  See L<mro>.

=end original

(F) C<next::method> で、このクラスの MRO で残っているパッケージの中で、この
メソッド名のインスタンスがもうありません。
もし例外を投げたくないなら、C<maybe::next::method> か C<next::can> を
使ってください。
L<mro> を参照してください。

=item Non-finite repeat count does nothing

=begin original

(W numeric) You tried to execute the
L<C<x>|perlop/Multiplicative Operators> repetition operator C<Inf> (or
C<-Inf>) or C<NaN> times, which doesn't make sense.

=end original

(W numeric) L<C<x>|perlop/Multiplicative Operators> 繰り返し演算子を
C<Inf> (または C<-Inf>) 回、または C<NaN> 回実行しようとしました;
これは意味がありません。

=item Non-hex character in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) In a regular expression, there was a non-hexadecimal character where
a hex one was expected, like

=end original

(F) 正規表現で、次のように 16 進文字が想定されるところで非 16 進文字がありました

 (?[ [ \xDG ] ])
 (?[ [ \x{DEKA} ] ])

=item Non-hex character '%c' terminates \x early.  Resolved as "%s"

=begin original

(W digit) In parsing a hexadecimal numeric constant, a character was
unexpectedly encountered that isn't hexadecimal.  The resulting value
is as indicated.

=end original

(W digit) 16 進数定数をパースするときに、16 進数でない文字に
想定外に遭遇しました。
結果の値は示しているとおりになりました。

=begin original

Note that, within braces, every character starting with the first
non-hexadecimal up to the ending brace is ignored.

=end original

中かっこの中では、最初に現れた非 16 進数文字から中かっこの終わりまでは
無視されることに注意してください。

=item Non-octal character in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) In a regular expression, there was a non-octal character where
an octal one was expected, like

=end original

(F) 正規表現で、次のように 8 進文字が想定されるところで非 8 進文字がありました

 (?[ [ \o{1278} ] ])

=item Non-octal character '%c' terminates \o early.  Resolved as "%s"

=begin original

(W digit) In parsing an octal numeric constant, a character was
unexpectedly encountered that isn't octal.  The resulting value
is as indicated.

=end original

(W digit) 8 進数定数をパースするときに、8 進数でない文字に遭遇しました。
結果の値は示している通りになります。

=begin original

When not using C<\o{...}>, you wrote something like C<\08>, or C<\179>
in a double-quotish string.  The resolution is as indicated, with all
but the last digit treated as a single character, specified in octal.
The last digit is the next character in the string.  To tell Perl that
this is indeed what you want, you can use the C<\o{ }> syntax, or use
exactly three digits to specify the octal for the character.

=end original

When not using 
C<\o{...}> を使っていないときに、C<\08> のようなものか、
あるいはダブルクォート風文字列の中で C<\179> のようなものを書きました。
結果は示している通りになり、最後以外の数字は 8 進数で指定された
単一の文字として扱われます。
最後の数字は文字列中の次の文字です。
これが確かに望んだものであることを Perl に伝えるには、
C<\o{ }> 構文を使うか、その文字を 8 進数で指定するために
正確に 3 文字の数字を使ってください。

=begin original

Note that, within braces, every character starting with the first
non-octal up to the ending brace is ignored.

=end original

中かっこの中では、最初に現れた非 8 進数文字から中かっこの終わりまでは
無視されることに注意してください。

=item "no" not allowed in expression

=begin original

(F) The "no" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.

=end original

(F) "no" キーワードは、コンパイル時に認識され、実行されるもので、
意味のある値を返しません。
L<perlmod> を参照してください。

=item Non-string passed as bitmask

=begin original

(W misc) A number has been passed as a bitmask argument to select().
Use the vec() function to construct the file descriptor bitmasks for
select.  See L<perlfunc/select>.

=end original

(W misc) select() のビットマスク引数として数値が渡されました。
select のためのファイル記述子のビットマスクを構成するには、
vec() 関数を使ってください。
L<perlfunc/select> を参照してください。

=item No output file after > on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a lone '>' at the end of the command line, so it
doesn't know where you wanted to redirect stdout.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、コマンドラインの
最後に単独の '>' を発見したので、stdout をどこにリダイレクトしたいのかが
わかりませんでした。

=item No output file after > or >> on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '>' or a '>>' on the command line, but can't
find the name of the file to which to write data destined for stdout.

=end original

(F) VMS に固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、コマンドラインに
'>' や '>>' を発見しましたが、stdout を書き込むためのファイル名が
見つかりませんでした。

=item No package name allowed for subroutine %s in "our"

=item No package name allowed for variable %s in "our"

=begin original

(F) Fully qualified subroutine and variable names are not allowed in "our"
declarations, because that doesn't make much sense under existing rules.
Such syntax is reserved for future extensions.

=end original

(F) 完全修飾されたサブルーチン名や変数名は "our" 宣言では使えません;
なぜなら現在の動作ではほとんど意味がないからです。
そのような文法は将来の拡張に予約されています。

=item No Perl script found in input

=begin original

(F) You called C<perl -x>, but no line was found in the file beginning
with #! and containing the word "perl".

=end original

(F) C<perl -x> を呼び出しましたが、そのファイルに #! で始まり、
"perl" という語を含む行が見つかりませんでした。

=item No setregid available

=begin original

(F) Configure didn't find anything resembling the setregid() call for
your system.

=end original

(F) Configure が、システム上に setregid() のような関数を
見つけられませんでした。

=item No setreuid available

=begin original

(F) Configure didn't find anything resembling the setreuid() call for
your system.

=end original

(F) Configure が、システム上に setreuid() のような関数を
見つけられませんでした。

=item No such class %s

=begin original

(F) You provided a class qualifier in a "my", "our" or "state"
declaration, but this class doesn't exist at this point in your program.

=end original

(F) "my", "our", "state" の宣言でクラス修飾子が指定されましたが、指定された
クラスは現時点では存在しません。

=item No such class field "%s" in variable %s of type %s

=begin original

(F) You tried to access a key from a hash through the indicated typed
variable but that key is not allowed by the package of the same type.
The indicated package has restricted the set of allowed keys using the
L<fields> pragma.

=end original

(F) 示されている型の変数を通してハッシュのキーにアクセスしようとしましたが、
そのキーは同じ型のパッケージによって許可されていません。
示されているパッケージは L<fields> プラグマによって許可されるキーの集合が
制限されています。

=item No such hook: %s

=begin original

(F) You specified a signal hook that was not recognized by Perl.
Currently, Perl accepts C<__DIE__> and C<__WARN__> as valid signal hooks.

=end original

(F) Perl が認識できないシグナルフックを指定しました。
現在のところ、Perl は有効なシグナルフックとして
C<__DIE__> と C<__WARN__> を受け付けます。

=item No such pipe open

=begin original

(P) An error peculiar to VMS.  The internal routine my_pclose() tried to
close a pipe which hadn't been opened.  This should have been caught
earlier as an attempt to close an unopened filehandle.

=end original

(P) VMS に固有のエラーです。
内部ルーチンである my_pclose() が、開いていないパイプを閉じようとしました。
これは開いていないファイルハンドルを閉じようとしたとしてもっと早くに
捕捉されるべきものです。

=item No such signal: SIG%s

=begin original

(W signal) You specified a signal name as a subscript to %SIG that was
not recognized.  Say C<kill -l> in your shell to see the valid signal
names on your system.

=end original

(W signal) %SIG の添字として認識できないシグナル名を指定しました。
お使いのシステムで使用可能なシグナル名を調べるには、
シェル上で C<kill -l> などとしてください。

=item No Unicode property value wildcard matches:

=begin original

(W regexp) You specified a wildcard for a Unicode property value, but
there is no property value in the current Unicode release that matches
it.  Check your spelling.

=end original

(W regexp) Unicode 特性値にワイルドカードを指定しましたが、
現在の Unicode リリースにはそれにマッチングする特性値はありません。
スペルを確認してください。

=item Not a CODE reference

=begin original

(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.

=end original

(F) Perl がコード値 (サブルーチン) へのリファレンスを
評価しようとしましたが、別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> も参照してください。

=item Not a GLOB reference

=begin original

(F) Perl was trying to evaluate a reference to a "typeglob" (that is, a
symbol table entry that looks like C<*foo>), but found a reference to
something else instead.  You can use the ref() function to find out what
kind of ref it really was.  See L<perlref>.

=end original

(F) Perl が「型グロブ」(これは、C<*foo> のような
シンボルテーブルエントリです) へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not a HASH reference

=begin original

(F) Perl was trying to evaluate a reference to a hash value, but found a
reference to something else instead.  You can use the ref() function to
find out what kind of ref it really was.  See L<perlref>.

=end original

(F) Perl がハッシュ値へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item '#' not allowed immediately following a sigil in a subroutine signature

=begin original

(F) In a subroutine signature definition, a comment following a sigil
(C<$>, C<@> or C<%>), needs to be separated by whitespace or a comma etc., in
particular to avoid confusion with the C<$#> variable.  For example:

=end original

(F) サブルーチンシグネチャ定義で、印 (C<$>, C<@>, C<%>) に引き続く
コメントは、特に C<$#> 変数との混乱を避けるために、
空白やカンマなどで分ける必要があります;
例えば:

    # bad
    sub f ($# ignore first arg
           , $b) {}
    # good
    sub f ($, # ignore first arg
           $b) {}

=item Not an ARRAY reference

=begin original

(F) Perl was trying to evaluate a reference to an array value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.

=end original

(F) Perl が配列値へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not a SCALAR reference

=begin original

(F) Perl was trying to evaluate a reference to a scalar value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.

=end original

(F) Perl がスカラ値へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not a subroutine reference

=begin original

(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.

=end original

(F) Perl がコード値 (サブルーチン) へのリファレンスを
評価しようとしましたが、別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> も参照してください。

=item Not a subroutine reference in overload table

=begin original

(F) An attempt was made to specify an entry in an overloading table that
doesn't somehow point to a valid subroutine.  See L<overload>.

=end original

(F) 多重定義テーブルで、有効なサブルーチンを指していないエントリを
指定しようとしました。
L<overload> を参照してください。

=item Not enough arguments for %s

=begin original

(F) The function requires more arguments than you specified.

=end original

(F) この関数は、指定したよりも多くの引数を必要とします。

=item Not enough format arguments

=begin original

(W syntax) A format specified more picture fields than the next line
supplied.  See L<perlform>.

=end original

(W syntax) 指定したフォーマットに、次の行で指定したより多くの
ピクチャフィールドがあります。
L<perlform> を参照してください。

=item %s: not found

=begin original

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=end original

(A) スクリプトを perl ではなく Bourne shell で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item no UTC offset information; assuming local time is UTC

=begin original

(S) A warning peculiar to VMS.  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name
F<SYS$TIMEZONE_DIFFERENTIAL> to translate to the number of seconds which
need to be added to UTC to get local time.

=end original

(S) VMS に固有の警告です。
Perl はローカルタイムゾーンオフセットを見つけることができなかったので、
ローカルシステムタイムは UTC と等価であると仮定します。
もし違うなら、論理名 F<SYS$TIMEZONE_DIFFERENTIAL> に、UTC からローカル
時刻を得るために加える必要がある秒数を定義してください。

=item NULL OP IN RUN

=begin original

(S debugging) Some internal routine called run() with a null opcode
pointer.

=end original

(S debugging) 内部ルーティンで、ヌル opcode ポインタで run() を
呼んだものがあります。

=item Null picture in formline

=begin original

(F) The first argument to formline must be a valid format picture
specification.  It was found to be empty, which probably means you
supplied it an uninitialized value.  See L<perlform>.

=end original

(F) formline の第 1 引数は有効なフォーマットピクチャー指定でなければ
なりません。
これが空でした; おそらく初期化していない値を指定したのでしょう。
L<perlform> を参照してください。

=item Null realloc

=begin original

(P) An attempt was made to realloc NULL.

=end original

(P) realloc NULL を行なおうとしました。

=item NULL regexp argument

=begin original

(P) The internal pattern matching routines blew it big time.

=end original

(P) 内部パターンマッチルーティンが、大当たりです。

=item NULL regexp parameter

=begin original

(P) The internal pattern matching routines are out of their gourd.

=end original

(P) 内部パターンマッチルーティンが、狂っています。

=item Number too long

=begin original

(F) Perl limits the representation of decimal numbers in programs to
about 250 characters.  You've exceeded that length.  Future
versions of Perl are likely to eliminate this arbitrary limitation.  In
the meantime, try using scientific notation (e.g. "1e6" instead of
"1_000_000").

=end original

Perl はプログラム中での十進数の表現を 250 文字に制限しています。
この制限を越えました。
Perl の将来のバージョンではこの恣意的な制限は除去されるでしょう。
それまでの間は、科学的な記述法("1_000_000" ではなく "1e6")を
使用してください。

=item Number with no digits

=begin original

(F) Perl was looking for a number but found nothing that looked like
a number.  This happens, for example with C<\o{}>, with no number between
the braces.

=end original

(F) Perl は数字を探していましたが数字に見えないものが見つかりました。
これは、例えば C<\o{}> では、中かっこの中に数字がないときに起こります。

=item Numeric format result too large

=begin original

(F) The length of the result of a numeric format supplied to sprintf()
or printf() would have been too large for the underlying C function to
report.  This limit is typically 2GB.

=end original

(F) sprintf() や printf() に与えられた数値フォーマットの結果の長さは、
報告するための基礎となる C 関数にとって大きすぎました。
この制限は典型的には 2GB です。

=item Numeric variables with more than one digit may not start with '0'

=begin original

(F) The only numeric variable which is allowed to start with a 0 is C<$0>,
and you mentioned a variable that starts with 0 that has more than one
digit. You probably want to remove the leading 0, or if the intent was
to express a variable name in octal you should convert to decimal.

=end original

(F) 0 で始まることが許されている唯一の数値変数は C<$0> で、
0 で始まり複数桁ある変数に言及しました。
おそらく先頭の 0 を削除したいか、変数名を 8 進数で表現したい場合は、
10 進数に変換する必要があります。

=item Octal number > 037777777777 non-portable

=begin original

(W portable) The octal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=end original

(W portable) 指定した 8 進数が 2**32-1 (4294967295) より大きいので、
システム間で移植性がありません。
移植性に関するさらなる考察については L<perlport> を参照してください。

=item Odd name/value argument for subroutine '%s'

=begin original

(F) A subroutine using a slurpy hash parameter in its signature
received an odd number of arguments to populate the hash.  It requires
the arguments to be paired, with the same number of keys as values.
The caller of the subroutine is presumably at fault.

=end original

(F) シグネチャで吸い込みハッシュ引数を使っているサブルーチンが、
ハッシュに展開するために奇数の数の引数を受け取りました。
引数は、同じ数のキーと値のペアになっていることが必要です。
サブルーチンの呼び出しものがおそらく間違えているのでしょう。

=begin original

The message attempts to include the name of the called subroutine. If the
subroutine has been aliased, the subroutine's original name will be shown,
regardless of what name the caller used.

=end original

メッセージには呼び出されたサブルーチンの名前を含めようとします。
サブルーチンに別名がある場合、どの名前で呼び出されたかに関わらず、
元の名前が表示されます。

=item Odd number of arguments for overload::constant

=begin original

(W overload) The call to overload::constant contained an odd number of
arguments.  The arguments should come in pairs.

=end original

(W overload) 奇数の数の引数で overload::constant を呼び出しました。
引数はペアになっている必要があります。

=item Odd number of elements in anonymous hash

=begin original

(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.

=end original

(W misc) ハッシュリストへの要素の数が奇数でした; ハッシュリストは、
key/value のペアで与えられますから、これは奇妙なことです。

=item Odd number of elements in hash assignment

=begin original

(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.

=end original

(W misc) ハッシュリストへの要素の数が奇数でした; ハッシュリストは、
key/value のペアで与えられますから、これは奇妙なことです。

=item Offset outside string

=begin original

(F)(W layer) You tried to do a read/write/send/recv/seek operation
with an offset pointing outside the buffer.  This is difficult to
imagine.  The sole exceptions to this are that zero padding will
take place when going past the end of the string when either
C<sysread()>ing a file, or when seeking past the end of a scalar opened
for I/O (in anticipation of future reads and to imitate the behavior
with real files).

=end original

(F)(W layer) バッファの外を指すオフセットで read/write/send/recv/seek 操作を
しようとしました。
これは想像しにくいことです。
唯一の例外は、ファイルを C<sysread()> するときに 文字列の最後を越えたか、
(将来の読み込みと実際のファイルの振る舞いを模倣することを期待して)
I/O のためにオープンされているスカラの最後を越えてシークしたときに、
0 でパッディングされたときです。

=item Old package separator used in string

=begin original

(W syntax) You used the old package separator, "'", in a variable
named inside a double-quoted string; e.g., C<"In $name's house">.  This
is equivalent to C<"In $name::s house">.  If you meant the former, put
a backslash before the apostrophe (C<"In $name\'s house">).

=end original

(W syntax) ダブルクォートされた文字列の中の変数名で、
C<"In $name's house"> のように、
古いパッケージ区切り文字である "'" を使いました。
これは C<"In $name::s house"> と等価です。
前者の意味なら、アポストロフィの前に逆スラッシュを置いてください
(C<"In $name\'s house">)。

=item %s() on unopened %s

=begin original

(W unopened) An I/O operation was attempted on a filehandle that was
never initialized.  You need to do an open(), a sysopen(), or a socket()
call, or call a constructor from the FileHandle package.

=end original

(W unopened) 初期化していないファイルハンドルに I/O 操作をしようとしました。
open(), sysopen(), socket() を呼び出すか、FileHandle パッケージの
コンストラクタを呼び出す必要があります。

=item -%s on unopened filehandle %s

=begin original

(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your control flow.  See also L<perlfunc/-X>.

=end original

(W unopened) 開いていないファイルハンドルに対してファイルテスト演算子を
使おうとしました。
制御フローをチェックしてください。
L<perlfunc/-X> も参照してください。

=item oops: oopsAV

=begin original

(S internal) An internal warning that the grammar is screwed up.

=end original

(S internal) 文法がおかしくなったことを示す内部警告です。

=item oops: oopsHV

=begin original

(S internal) An internal warning that the grammar is screwed up.

=end original

(S internal) 文法がおかしくなったことを示す内部警告です。

=item Operand with no preceding operator in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) You wrote something like

=end original

(F) 以下のようなものを書きました

 (?[ \p{Digit} \p{Thai} ])

=begin original

There are two operands, but no operator giving how you want to combine
them.

=end original

二つのオペランドがありますが、それをどのように結びつけたいかを指定する
演算子がありません。

=item Operation "%s": no method found, %s

=begin original

(F) An attempt was made to perform an overloaded operation for which no
handler was defined.  While some handlers can be autogenerated in terms
of other handlers, there is no default handler for any operation, unless
the C<fallback> overloading key is specified to be true.  See L<overload>.

=end original

(F) ハンドラが定義されていないオーバーロード操作が行われました。
一部のハンドラは他のハンドラから自動生成されますが、C<fallback>
オーバーロードキーが真に指定されていない限り、どの動作にも
デフォルトのハンドラはありません。
L<overload> を参照してください。

=item Operation "%s" returns its argument for non-Unicode code point 0x%X

=begin original

(S non_unicode) You performed an operation requiring Unicode rules
on a code point that is not in Unicode, so what it should do is not
defined.  Perl has chosen to have it do nothing, and warn you.

=end original

(S non_unicode) Unicode ではない符号位置に対して、Unicode の規則が
必要な操作を実行しました; 何をするべきかは未定義です。
Perl は何もしないことを選択し、警告を出します。

=begin original

If the operation shown is "ToFold", it means that case-insensitive
matching in a regular expression was done on the code point.

=end original

示された操作が "ToFold" なら、正規表現での大文字小文字を無視したマッチングが
その符号位置に対して行われたということです。

=begin original

If you know what you are doing you can turn off this warning by
C<no warnings 'non_unicode';>.

=end original

自分で何をしているのかが分かっているなら、
C<no warnings 'non_unicode';> とすることでこの警告をオフにできます。

=item Operation "%s" returns its argument for UTF-16 surrogate U+%X

=begin original

(S surrogate) You performed an operation requiring Unicode
rules on a Unicode surrogate.  Unicode frowns upon the use
of surrogates for anything but storing strings in UTF-16, but
rules are (reluctantly) defined for the surrogates, and
they are to do nothing for this operation.  Because the use of
surrogates can be dangerous, Perl warns.

=end original

(S surrogate) Unicode サロゲートに対して Unicode の規則が必要な
操作を実行しました。
Unicode は文字列を UTF-16 で保管する以外のことでサロゲートを使うことに
難色を示しますが、規則は(渋々)サロゲートのために定義されていて、それは
この操作に対して何もしないことです。
サロゲートの使用は危険かも知れないので、Perl は警告します。

=begin original

If the operation shown is "ToFold", it means that case-insensitive
matching in a regular expression was done on the code point.

=end original

示された操作が "ToFold" なら、正規表現での大文字小文字を無視したマッチングが
その符号位置に対して行われたということです。

=begin original

If you know what you are doing you can turn off this warning by
C<no warnings 'surrogate';>.

=end original

自分で何をしているのかが分かっているなら、
C<no warnings 'surrogate';> とすることでこの警告をオフにできます。

=item Operator or semicolon missing before %s

=begin original

(S ambiguous) You used a variable or subroutine call where the parser
was expecting an operator.  The parser has assumed you really meant to
use an operator, but this is highly likely to be incorrect.  For
example, if you say "*foo *foo" it will be interpreted as if you said
"*foo * 'foo'".

=end original

(S ambiguous) パーサーが演算子を装置している場所で変数やサブルーチン
呼び出しが使われました。
パーサーはあなたが本当に演算子を使おうとしていると仮定しますが、
これは大抵正しくありません。
例えば、"*foo *foo" とすると、"*foo * 'foo'" としたとして解釈されます。

=item Optional parameter lacks default expression

=begin original

(F) In a subroutine signature, you wrote something like "$a =", making a
named optional parameter without a default value.  A nameless optional
parameter is permitted to have no default value, but a named one must
have a specific default.  You probably want "$a = undef".

=end original

(F) サブルーチンシグネチャで、"$a =" のような、デフォルト値のない名前付き
オプション引数を書きました。
無名オプション引数はデフォルト値を持たないことを許されていますが、
名前付きのものはデフォルトを指定しなければなりません。
おそらく "$a = undef" としたかったのでしょう。

=item "our" variable %s redeclared

=begin original

(W shadow) You seem to have already declared the same global once before
in the current lexical scope.

=end original

(W shadow) 現在のレキシカルスコープで、既に同じ名前のグローバル変数を
宣言しているようです。

=item Out of memory!

=begin original

(X) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  Perl has
no option but to exit immediately.

=end original

(X) 要求を満たすだけの、十分な残メモリ (または、仮想メモリ) が
取得できないことを示す、0 を malloc() 関数が返しました。
Perl は直ちに終了するしかありませんでした。

=begin original

At least in Unix you may be able to get past this by increasing your
process datasize limits: in csh/tcsh use C<limit> and
C<limit datasize n> (where C<n> is the number of kilobytes) to check
the current limits and change them, and in ksh/bash/zsh use C<ulimit -a>
and C<ulimit -d n>, respectively.

=end original

少なくとも Unix ではプロセスのデータサイズ制限を増やすことによって
これを回避することが可能です: 
csh/tcsh では現在の制限を調べるのに C<limit> を、これを変更するには
C<limit datasize n> (ここで C<n> はキロバイト単位) を使ってください;
ksh/bash/zsh ではそれぞれ C<ulimit -a> と C<ulimit -d n> を使ってください。

=item Out of memory during %s extend

=begin original

(X) An attempt was made to extend an array, a list, or a string beyond
the largest possible memory allocation.

=end original

(X) 確保可能な最大メモリを越えて配列、リスト、文字列を拡張しようとしました。

=item Out of memory during "large" request for %s

=begin original

(F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  However,
the request was judged large enough (compile-time default is 64K), so a
possibility to shut down by trapping this error is granted.

=end original

(F) malloc() 関数が 0 を返しました; これは要求を満たすメモリ
(または仮想メモリ)が不十分であることを示しています。
しかし、要求が十分大きい(コンパイル時のデフォルトは 64K)ので、
このエラーをトラップすることでシャットダウンできる可能性があります。

=item Out of memory during request for %s

=begin original

(X)(F) The malloc() function returned 0, indicating there was
insufficient remaining memory (or virtual memory) to satisfy the
request.

=end original

(X)(F) malloc() 関数が 0 を返しました; これは要求を満たすメモリ
(または仮想メモリ)が不十分であることを示しています。

=begin original

The request was judged to be small, so the possibility to trap it
depends on the way perl was compiled.  By default it is not trappable.
However, if compiled for this, Perl may use the contents of C<$^M> as an
emergency pool after die()ing with this message.  In this case the error
is trappable I<once>, and the error message will include the line and file
where the failed request happened.

=end original

要求は小さいものと判定されたので、これをトラップできる確率は perl が
どのようにコンパイルされたかに依存します。
デフォルトではこれはトラップできません。
しかし、もしこのためにコンパイルすると、Perl はこのメッセージと共に
die() した後の非常用エリアとして C<$^M> の内容を使います。
この場合エラーは I<一度だけ> トラップ可能で、エラーメッセージは失敗した
要求が起きたファイルと行番号を含んでいます。

=item Out of memory during ridiculously large request

=begin original

(F) You can't allocate more than 2^31+"small amount" bytes.  This error
is most likely to be caused by a typo in the Perl program. e.g.,
C<$arr[time]> instead of C<$arr[$time]>.

=end original

(F) 2^31+「少量」バイト以上割り当てることはできません。
このエラーはほとんどの場合 Perl プログラムのタイプミスが原因です。
例えば、C<$arr[$time]> の代わりに C<$arr[time]> のような。

=item Out of memory for yacc stack

=begin original

(F) The yacc parser wanted to grow its stack so it could continue
parsing, but realloc() wouldn't give it more memory, virtual or
otherwise.

=end original

(F) yacc パーサーが解析を続けるために、スタックを広げようとしましたが、
realloc() が仮想やその他のメモリを確保できませんでした。

=item '.' outside of string in pack

=begin original

(F) The argument to a '.' in your template tried to move the working
position to before the start of the packed string being built.

=end original

(F) テンプレートでの '.' の引数として、pack された文字列が構築されたよりも
前に作業位置を移動しようとしました。

=item '@' outside of string in unpack

=begin original

(F) You had a template that specified an absolute position outside
the string being unpacked.  See L<perlfunc/pack>.

=end original

(F) unpack される文字列の外に絶対位置指定している、
テンプレートを指定しました。
L<perlfunc/pack> を参照してください。

=item '@' outside of string with malformed UTF-8 in unpack

=begin original

(F) You had a template that specified an absolute position outside
the string being unpacked.  The string being unpacked was also invalid
UTF-8.  See L<perlfunc/pack>.

=end original

(F) unpack される文字列の外に絶対位置指定している、
テンプレートを指定しました。
unpack された文字列は不正な UTF-8 でもあります。
L<perlfunc/pack> を参照してください。

=item overload arg '%s' is invalid

=begin original

(W overload) The L<overload> pragma was passed an argument it did not
recognize.  Did you mistype an operator?

=end original

(W overload) L<overload> プラグマに、認識できない引数が渡されました。
演算子をタイプミスしましたか?

=item Overloaded dereference did not return a reference

=begin original

(F) An object with an overloaded dereference operator was dereferenced,
but the overloaded operation did not return a reference.  See
L<overload>.

=end original

(F) オーバーロードされたデリファレンス演算子のオブジェクトが
デリファレンスされましたが、オーバーロード演算がリファレンスを
返しませんでした。
L<overload> を参照してください。

=item Overloaded qr did not return a REGEXP

=begin original

(F) An object with a C<qr> overload was used as part of a match, but the
overloaded operation didn't return a compiled regexp.  See L<overload>.

=end original

(F) C<qr> をオーバーロードしたオブジェクトがマッチングの一部として
使われましたが、オーバーロード演算がコンパイルされた正規表現を
返しませんでした。
L<overload> を参照してください。

=item %s package attribute may clash with future reserved word: %s

=begin original

(W reserved) A lowercase attribute name was used that had a
package-specific handler.  That name might have a meaning to Perl itself
some day, even though it doesn't yet.  Perhaps you should use a
mixed-case attribute name, instead.  See L<attributes>.

=end original

(W reserved) パッケージ固有のハンドラが、小文字の属性名を使っています。
この名前は、たとえ今は使っていなくても、 Perl 自身がいつか使うかもしれません。
おそらく代わりに大文字小文字の混じった属性名を使うべきでしょう。
L<attributes> を参照してください。

=item pack/unpack repeat count overflow

=begin original

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/pack>.

=end original

(F) 繰り返し回数として符号付き整数をオーバーフローするような
値は指定できません。
L<perlfunc/pack> を参照してください。

=item page overflow

=begin original

(W io) A single call to write() produced more lines than can fit on a
page.  See L<perlform>.

=end original

(W io) write() の 1 度の呼び出しで、1 ページに収まるより多くの行が
できました。
L<perlform> を参照してください。

=item panic: %s

=begin original

(P) An internal error.

=end original

(P) 内部エラーです。

=item panic: attempt to call %s in %s

=begin original

(P) One of the file test operators entered a code branch that calls
an ACL related-function, but that function is not available on this
platform.  Earlier checks mean that it should not be possible to
enter this branch on this platform.

=end original

(P) ファイルテスト演算子の一つが ACL 関連関数を呼び出すコード分岐に
入りましたが、この関数はこのプラットフォームでは利用できません。
より早いチェックは、このプラットフォームのこの分岐に入ることがないように
するべきことを意味します。

=item panic: child pseudo-process was never scheduled

=begin original

(P) A child pseudo-process in the ithreads implementation on Windows
was not scheduled within the time period allowed and therefore was not
able to initialize properly.

=end original

(P) Windowsでのiスレッド実装の子疑似プロセスが許された時間間隔の間に
スケジューリングされなかったので、適切に初期化されなかった可能性があります。

=item panic: ck_grep, type=%u

=begin original

(P) Failed an internal consistency check trying to compile a grep.

=end original

(P) grep をコンパイルしようとして、内部の一貫性チェックに
引っ掛かりました。

=item panic: corrupt saved stack index %ld

=begin original

(P) The savestack was requested to restore more localized values than
there are in the savestack.

=end original

(P) セーブスタックにある以上のローカル化した値を元に戻す
要求がありました。

=item panic: del_backref

=begin original

(P) Failed an internal consistency check while trying to reset a weak
reference.

=end original

(P) 弱いリファレンスをリセットしようとしたときに内部の
一貫性チェックに引っ掛かりました。

=item panic: do_subst

=begin original

(P) The internal pp_subst() routine was called with invalid operational
data.

=end original

(P) 内部の pp_subst() ルーティンが、無効な省略可能データを
付けて呼ばれました。

=item panic: do_trans_%s

=begin original

(P) The internal do_trans routines were called with invalid operational
data.

=end original

(P) 内部の pp_trans ルーティンが、無効な省略可能データを
付けて呼ばれました。

=item panic: fold_constants JMPENV_PUSH returned %d

=begin original

(P) While attempting folding constants an exception other than an C<eval>
failure was caught.

=end original

(P) 定数の畳み込みを実行中に C<eval> 失敗以外の例外が捕捉されました。

=item panic: frexp: %f

=begin original

(P) The library function frexp() failed, making printf("%f") impossible.

=end original

(P) ライブラリ関数 frexp() が失敗したので、printf("%f") ができません。

=item panic: goto, type=%u, ix=%ld

=begin original

(P) We popped the context stack to a context with the specified label,
and then discovered it wasn't a context we know how to do a goto in.

=end original

(P) 指定したラベルを伴うコンテキストへコンテキストスタックを
ポップしたあと、どのように goto するかがわかっている
コンテキストでないことがわかりました。

=item panic: gp_free failed to free glob pointer

=begin original

(P) The internal routine used to clear a typeglob's entries tried
repeatedly, but each time something re-created entries in the glob.
Most likely the glob contains an object with a reference back to
the glob and a destructor that adds a new object to the glob.

=end original

(P) 型グロブのエントリをクリアするために使われる内部ルーチンが複数回
試しましたが、毎回何かがグロブにエントリを再作成しました。
おそらくグロブにそのグロブへのリファレンスと、グロブへの新しいオブジェクトを
追加するデストラクタを持つオブジェクトが含まれています。

=item panic: INTERPCASEMOD, %s

=begin original

(P) The lexer got into a bad state at a case modifier.

=end original

(P) 大文字小文字修飾子のところで、字句解析部がおかしな状態に陥りました。

=item panic: INTERPCONCAT, %s

=begin original

(P) The lexer got into a bad state parsing a string with brackets.

=end original

(P) 中かっこを伴う文字列を解析中に、字句解析部がおかしな状態に陥りました。

=item panic: kid popen errno read

=begin original

(F) A forked child returned an incomprehensible message about its errno.

=end original

(F) fork した子プロセスが errno に関して不完全なメッセージを返しました。

=item panic: last, type=%u

=begin original

(P) We popped the context stack to a block context, and then discovered
it wasn't a block context.

=end original

(P) block コンテキストへコンテキストスタックをポップしたあと、
block コンテキストでないことがわかりました。

=item panic: leave_scope clearsv

=begin original

(P) A writable lexical variable became read-only somehow within the
scope.

=end original

(P) 書き込み可能な字句スコープ変数が、どういうわけか、スコープ内で
リードオンリーになりました。

=item panic: leave_scope inconsistency %u

=begin original

(P) The savestack probably got out of sync.  At least, there was an
invalid enum on the top of it.

=end original

(P) おそらく、セーブスタックの同期がとれていません。
少なくとも、トップに不正な enum がありました。

=item panic: magic_killbackrefs

=begin original

(P) Failed an internal consistency check while trying to reset all weak
references to an object.

=end original

(P) あるオブジェクトへの全ての弱い参照をリセットしようとした時に内部の
一貫性チェックに引っ掛かりました。

=item panic: malloc, %s

=begin original

(P) Something requested a negative number of bytes of malloc.

=end original

(P) malloc に負のバイト数で要求が行なわれました。

=item panic: memory wrap

=begin original

(P) Something tried to allocate either more memory than possible or a
negative amount.

=end original

(P) 何かが、確保可能な量を超える、または負の量のメモリを確保しようとしました。

=item panic: pad_alloc, %p!=%p

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_free curpad, %p!=%p

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_free po

=begin original

(P) A zero scratch pad offset was detected internally.  An attempt was
made to free a target that had not been allocated to begin with.

=end original

(P) スクラッチパッドのオフセット 0 が、内部的に検出されました。
始めるために割り当てられていないターゲットを解放しようとしました。

=item panic: pad_reset curpad, %p!=%p

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_sv po

=begin original

(P) A zero scratch pad offset was detected internally.  Most likely
an operator needed a target but that target had not been allocated
for whatever reason.

=end original

(P) スクラッチパッドのオフセット 0 が、内部的に検出されました。
おそらく演算子がターゲットを必要としたけれどもターゲットが何らかの理由で
割り当てられていません。

=item panic: pad_swipe curpad, %p!=%p

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_swipe po

=begin original

(P) An invalid scratch pad offset was detected internally.

=end original

(P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

=item panic: pp_iter, type=%u

=begin original

(P) The foreach iterator got called in a non-loop context frame.

=end original

(P) foreach の繰返し子が、ループ文脈以外のところで呼ばれました。

=item panic: pp_match%s

=begin original

(P) The internal pp_match() routine was called with invalid operational
data.

=end original

(P) 内部の pp_match() ルーティンが、無効な省略可能データを
付けて呼ばれました。

=item panic: realloc, %s

=begin original

(P) Something requested a negative number of bytes of realloc.

=end original

(P) 何か、realloc に負のバイト数を要求したものがあります。

=item panic: reference miscount on nsv in sv_replace() (%d != 1)

=begin original

(P) The internal sv_replace() function was handed a new SV with a
reference count other than 1.

=end original

(P) 内部の sv_replace() 関数は、参照カウントが 1 でない新しい SV を
扱いました。

=item panic: restartop in %s

=begin original

(P) Some internal routine requested a goto (or something like it), and
didn't supply the destination.

=end original

(P) 内部ルーティンから goto (または、同じようなもの) が
要求されましたが、飛び先が与えれていません。

=item panic: return, type=%u

=begin original

(P) We popped the context stack to a subroutine or eval context, and
then discovered it wasn't a subroutine or eval context.

=end original

(P) サブルーチンコンテキストや eval コンテキストへ、
コンテキストスタックをポップしたあと、サブルーチンコンテキストや
eval コンテキストでないことがわかりました。

=item panic: scan_num, %s

=begin original

(P) scan_num() got called on something that wasn't a number.

=end original

(P) scan_num() が、何か数字でないものに対して呼ばれました。

=item panic: Sequence (?{...}): no code block found in regex m/%s/

=begin original

(P) While compiling a pattern that has embedded (?{}) or (??{}) code
blocks, perl couldn't locate the code block that should have already been
seen and compiled by perl before control passed to the regex compiler.

=end original

(P) 組み込みの (?{}) や (??{}) コードブロックを持つパターンをコンパイル中に、
既に現れていて、正規表現コンパイラに制御を渡す前に perl によって
コンパイルされているコードブロックを発見できませんでした。

=item panic: strxfrm() gets absurd - a => %u, ab => %u

=begin original

(P) The interpreter's sanity check of the C function strxfrm() failed.
In your current locale the returned transformation of the string "ab"
is shorter than that of the string "a", which makes no sense.

=end original

(P) C 関数 strxfrm() のインタプリタの正気度チェックが失敗しました。
現在のロケールでは、文字列 "ab" の変換で返されたものは 文字列 "a" の
変換で返されたものよりも短いので、おかしいです。

=item panic: sv_chop %s

=begin original

(P) The sv_chop() routine was passed a position that is not within the
scalar's string buffer.

=end original

(P) sv_chop() ルーチンは、スカラの文字列バッファ内でない位置を
渡されました。

=item panic: sv_insert, midend=%p, bigend=%p

=begin original

(P) The sv_insert() routine was told to remove more string than there
was string.

=end original

(P) sv_insert() ルーティンが、存在する以上の文字列を削除するように
指示されました。

=item panic: top_env

=begin original

(P) The compiler attempted to do a goto, or something weird like that.

=end original

(P) コンパイラが、goto など妙なことを行なおうとしました。

=item panic: unimplemented op %s (#%d) called

=begin original

(P) The compiler is screwed up and attempted to use an op that isn't
permitted at run time.

=end original

(P) コンパイラがおかしくなって、実行時に許可されていない op を
しようとしました。

=item panic: unknown OA_*: %x

=begin original

(P) The internal routine that handles arguments to C<&CORE::foo()>
subroutine calls was unable to determine what type of arguments
were expected.

=end original

(P) C<&CORE::foo()> サブルーチン呼び出しの引数を扱う内部ルーチンは、
どの種類の引数が想定されているかを決定できませんでした。

=item panic: utf16_to_utf8: odd bytelen

=begin original

(P) Something tried to call utf16_to_utf8 with an odd (as opposed
to even) byte length.

=end original

(P) 何かが(偶数ではなく)奇数のバイト長で utf16_to_utf8 を
呼び出そうとしました。

=item panic: utf16_to_utf8_reversed: odd bytelen

=begin original

(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed
to even) byte length.

=end original

(P) 何かが utf16_to_utf8_reversed を奇数バイト長で呼び出そうとしました。

=item panic: yylex, %s

=begin original

(P) The lexer got into a bad state while processing a case modifier.

=end original

(P) 大文字小文字修飾子を処理中に、字句解析部がおかしな状態に陥りました。

=item Parentheses missing around "%s" list

=begin original

(W parenthesis) You said something like

=end original

(W parenthesis) おそらく以下のようにしたのでしょう:

    my $foo, $bar = @_;

=begin original

when you meant

=end original

以下のようにすべきです:

    my ($foo, $bar) = @_;

=begin original

Remember that "my", "our", "local" and "state" bind tighter than comma.

=end original

"my", "our", "local", "state" は、コンマよりも強く結合することを
忘れないでください。

=item Parsing code internal error (%s)

=begin original

(F) Parsing code supplied by an extension violated the parser's API in
a detectable way.

=end original

(F) エクステンションによって供給されたパースコードが、検出できる形で
パーサの API に違反しています。

=item Pattern subroutine nesting without pos change exceeded limit in regex

=begin original

(F) You used a pattern that uses too many nested subpattern calls without
consuming any text.  Restructure the pattern so text is consumed before
the nesting limit is exceeded.

=end original

(F) テキストを全く消費することなく、あまりに多くネストした副パターンを使う
パターンを使いました。
ネストの制限を越える前にテキストを消費するようにパターンを
再構成してください。

=item C<-p> destination: %s

=begin original

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=end original

(F) C<-p> コマンドラインオプションで起動された
暗黙の出力中にエラーが発生しました。
(この出力は select() でリダイレクトしていない限り STDOUT に出力されます。)

=item Perl API version %s of %s does not match %s

=begin original

(F) The XS module in question was compiled against a different incompatible
version of Perl than the one that has loaded the XS module.

=end original

(F) この XS モジュールは、これを読み込んだ Perl とは互換性のないバージョンの
Perl 用にコンパイルされたものです。

=item Perl folding rules are not up-to-date for 0x%X; please use the perlbug
utility to report; in regex; marked by S<<-- HERE> in m/%s/

=begin original

(S regexp) You used a regular expression with case-insensitive matching,
and there is a bug in Perl in which the built-in regular expression
folding rules are not accurate.  This may lead to incorrect results.
Please report this as a bug to L<https://github.com/Perl/perl5/issues>.

=end original

(S regexp) 大文字小文字を無視するマッチングを行う正規表現を使いました; そして
組み込みの正規表現畳み込み規則が正確でないという Perl のバグがありました。
これは間違った結果を引き起こします。
どうか L<https://github.com/Perl/perl5/issues> に
バグとして報告してください。

=item PerlIO layer ':win32' is experimental

=begin original

(S experimental::win32_perlio) The C<:win32> PerlIO layer is
experimental.  If you want to take the risk of using this layer,
simply disable this warning:

=end original

(S experimental::win32_perlio) C<:win32> PerlIO 層は実験的です。
この層を使うリスクを取りたい場合は、単にこの警告を無効にしてください:

    no warnings "experimental::win32_perlio";

=item Perl_my_%s() not available

=begin original

(F) Your platform has very uncommon byte-order and integer size,
so it was not possible to set up some or all fixed-width byte-order
conversion functions.  This is only a problem when you're using the
'<' or '>' modifiers in (un)pack templates.  See L<perlfunc/pack>.

=end original

(F) あなたのプラットフォームはとても珍しいバイト順と整数サイズを
使っているので、固定長バイト順変換関数の一部または全部を使うことができません。
これは (un)pack テンプレートの中で
'<' か '>' の修飾子を使った場合にのみ問題となります。
L<perlfunc/pack> を参照してください。

=item Perl %s required (did you mean %s?)--this is only %s, stopped

=begin original

(F) The code you are trying to run has asked for a newer version of
Perl than you are running.  Perhaps C<use 5.10> was written instead
of C<use 5.010> or C<use v5.10>.  Without the leading C<v>, the number is
interpreted as a decimal, with every three digits after the
decimal point representing a part of the version number.  So 5.10
is equivalent to v5.100.

=end original

(F) 実行しようとしたコードは、実行している Perl のバージョンよりも高いものを
尋ねました。
おそらく C<use 5.010> or C<use v5.10> ではなく C<use 5.10> と
書かれているのでしょう。
先頭の C<v> がないと、数値は 10 進数で、小数点の後の 3 桁毎にバージョン番号の
部分を表現していると解釈されます。
それで、5.10 は v5.100 と等価です。

=item Perl %s required--this is only %s, stopped

=begin original

(F) The module in question uses features of a version of Perl more
recent than the currently running version.  How long has it been since
you upgraded, anyway?  See L<perlfunc/require>.

=end original

(F) 問題のモジュールは、現在実行中の Perl よりも最近のバージョンの
機能を使っています。
ところで、いつからアップグレードしていないのですか?
L<perlfunc/require> を参照してください。

=item PERL_SH_DIR too long

=begin original

(F) An error peculiar to OS/2.  PERL_SH_DIR is the directory to find the
C<sh>-shell in.  See "PERL_SH_DIR" in L<perlos2>.

=end original

(F) OS/2 固有のエラーです。
PERL_SH_DIR は C<sh>-shell を見つけるためのディレクトリです。
L<perlos2> の "PERL_SH_DIR" を参照してください。

=item PERL_SIGNALS illegal: "%s"

=begin original

(X) See L<perlrun/PERL_SIGNALS> for legal values.

=end original

(X) 有効な値については L<perlrun/PERL_SIGNALS> を参照してください。

=item Perls since %s too modern--this is %s, stopped

=begin original

(F) The code you are trying to run claims it will not run
on the version of Perl you are using because it is too new.
Maybe the code needs to be updated, or maybe it is simply
wrong and the version check should just be removed.

=end original

(F) 実行しようとしているコードは、使っている Perl のバージョンが新しすぎると
主張しています。
コードを更新する必要があるかもしれませんし、単に間違っていて単純に
バージョンチェックを削除するべきかもしれません。

=item perl: warning: Non hex character in '$ENV{PERL_HASH_SEED}', seed only partially set

=begin original

(S) PERL_HASH_SEED should match /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ but it
contained a non hex character.  This could mean you are not using the
hash seed you think you are.

=end original

(S) PERL_HASH_SEED は /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ にマッチングするけれども
非 16 進数文字を含む必要があります。
これは、考えているようなハッシュの種が使われないことを
意味しているかもしれません。

=item perl: warning: Setting locale failed.

=begin original

(S) The whole warning message will look something like:

=end original

(S) 警告全体は以下のような形になります:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

=begin original

Exactly what were the failed locale settings varies.  In the above the
settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your operating
system supplier and/or system administrator have set up the so-called
locale system but Perl could not use those settings.  This was not
dead serious, fortunately: there is a "default locale" called "C" that
Perl can and will use, and the script will be run.  Before you really
fix the problem, however, you will get the same error message each
time you run Perl.  How to really fix the problem can be found in
L<perllocale> section B<LOCALE PROBLEMS>.

=end original

正確にどのロケール設定が失敗したのかは様々です。
上記では設定は LC_ALL は "En_US" で、LANG は空でした。
このエラーは、あなたや OS 供給者やシステム管理者がロケールシステムと呼ばれる
ものをセットアップしましたが、Perl がこれらの設定を使えないことを
検出したことを意味します。
これは幸いにして致命的ではありません; Perl が使用できる "C" と呼ばれる
「デフォルトロケール」が存在するので、スクリプトは実行されます。
しかし、本当にこの問題を解決するまでは、Perl を実行する毎に同じエラー
メッセージが表示されます。
本当にこの問題を修正する方法は L<perllocale> の B<LOCALE PROBLEMS> の
章にあります。

=item perl: warning: strange setting in '$ENV{PERL_PERTURB_KEYS}': '%s'

=begin original

(S) Perl was run with the environment variable PERL_PERTURB_KEYS defined
but containing an unexpected value.  The legal values of this setting
are as follows.

=end original

(S) 環境変数 PERL_PERTURB_KEYS が定義されている環境で Perl が実行されましたが
想定外の値でした。
この設定の正当な値は以下のものです。

  Numeric | String        | Result
  --------+---------------+-----------------------------------------
  0       | NO            | Disables key traversal randomization
  1       | RANDOM        | Enables full key traversal randomization
  2       | DETERMINISTIC | Enables repeatable key traversal
          |               | randomization

=begin original

Both numeric and string values are accepted, but note that string values are
case sensitive.  The default for this setting is "RANDOM" or 1.

=end original

数値と文字列の値の両方が受け入れられますが、文字列の値は大文字小文字を
区別することに注意してください。
この設定のデフォルトは "RANDOM"、つまり 1 です。

=item pid %x not a child

=begin original

(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.

=end original

(W exec) VMS に固有の警告です。
現在のプロセスのサブプロセスでないプロセスに Waitpid() を使いました。
これは VMS の観点からは問題ありませんが、おそらくあなたの望んでいることでは
ないでしょう。

=item 'P' must have an explicit size in unpack

=begin original

(F) The unpack format P must have an explicit size, not "*".

=end original

(F) unpack フォーマット P は "*" ではなく、明示的なサイズを
指定しなければなりません。

=item POSIX class [:%s:] unknown in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) The class in the character class [: :] syntax is unknown.  The S<<-- HERE>
shows whereabouts in the regular expression the problem was discovered.
Note that the POSIX character classes do B<not> have the C<is> prefix
the corresponding C interfaces have: in other words, it's C<[[:print:]]>,
not C<isprint>.  See L<perlre>.

=end original

(F) 文字クラス [: :] 文法の中のクラスは不明です。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
POSIX 文字クラスは、対応する C インターフェースが持っている C<is> 接頭辞が
B<付かない> ことに注意してください: 言い換えると、C<[[:print:]]> であり、
C<isprint> ではありません。
L<perlre> を参照してください。

=item POSIX getpgrp can't take an argument

=begin original

(F) Your system has POSIX getpgrp(), which takes no argument, unlike
the BSD version, which takes a pid.

=end original

(F) お使いのシステムは、引数に pid をとる BSD バージョンの
getpgrp() と違って、引数をとらない POSIX のものを使っています。

=item POSIX syntax [%c %c] belongs inside character classes%s in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) Perl thinks that you intended to write a POSIX character
class, but didn't use enough brackets.  These POSIX class constructs [:
:], [= =], and [. .]  go I<inside> character classes, the [] are part of
the construct, for example: C<qr/[012[:alpha:]345]/>.  What the regular
expression pattern compiled to is probably not what you were intending.
For example, C<qr/[:alpha:]/> compiles to a regular bracketed character
class consisting of the four characters C<":">,  C<"a">,  C<"l">,
C<"h">, and C<"p">.  To specify the POSIX class, it should have been
written C<qr/[[:alpha:]]/>.

=end original

(W regexp) Perl は、あなたが POSIX 文字クラスを書くことを意図していると
考えましたが、大かっこが足りませんでした。
例えば C<qr/[012[:alpha:]345]/> のように、POSIX クラス構造
[: :], [= =], [. .] が文字クラスの I<内側> にあり、[] は構文の一部です。
コンパイルされた正規表現パターンはおそらくあなたが意図したものでは
ないでしょう。
例えば、C<qr/[:alpha:]/> は、C<":">, C<"a">, C<"l">, C<"h">, C<"p"> の
四つの文字からなる 正規表現大かっこ文字クラスにコンパイルされます。
POSIX クラスを指定するには、C<qr/[[:alpha:]]/> と書く必要があります。

=begin original

Note that [= =] and [. .] are not currently
implemented; they are simply placeholders for future extensions and
will cause fatal errors.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.

=end original

[= =] と [. .] は現在のところ実装されていないことに注意してください;
これらは単に将来の拡張のためのプレースホルダであり、致命的エラーを
生成します。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=begin original

If the specification of the class was not completely valid, the message
indicates that.

=end original

このクラスの仕様が完全に正当出ない場合、このメッセージはそれを示しています。

=item POSIX syntax [. .] is reserved for future extensions in regex; marked by 
S<<-- HERE> in m/%s/

=begin original

(F) Within regular expression character classes ([]) the syntax beginning
with "[." and ending with ".]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[."
and ".\]".  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=end original

(F) 正規表現文字クラス ([]) の中では、"[." で始まる文法と ".]" で
終わる文法は将来の拡張のために予約されます。
正規表現文字クラスの中でこのような文字シーケンスを表現する必要がある
場合には、"\[." と ".\]" のように、大かっこをバックスラッシュで
クォートしてください。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item POSIX syntax [= =] is reserved for future extensions in regex; marked by 
S<<-- HERE> in m/%s/

=begin original

(F) Within regular expression character classes ([]) the syntax beginning
with "[=" and ending with "=]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[="
and "=\]".  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=end original

(F) 正規表現文字クラス ([]) の中では、"[=" で始まる文法と "=]" で
終わる文法は将来の拡張のために予約されます。
正規表現文字クラスの中でこのような文字シーケンスを表現する必要がある
場合には、"\[=" と "=\]" のように、大かっこをバックスラッシュで
クォートしてください。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Possible attempt to put comments in qw() list

=begin original

(W qw) qw() lists contain items separated by whitespace; as with literal
strings, comment characters are not ignored, but are instead treated as
literal data.  (You may have used different delimiters than the
parentheses shown here; braces are also frequently used.)

=end original

(W qw) qw() リストは空白で分割されたアイテムを含んでいます;
リテラル文字列では、コメント文字無視されず、リテラルデータとして扱われます。
(ここで使われているのと違うデリミタを用いているかもしれません;
大かっこもよく使われます。)

=begin original

You probably wrote something like this:

=end original

おそらく以下のように書いたのでしょう:

    @list = qw(
	a # a comment
        b # another comment
    );

=begin original

when you should have written this:

=end original

以下のように書くべきです:

    @list = qw(
	a
        b
    );

=begin original

If you really want comments, build your list the
old-fashioned way, with quotes and commas:

=end original

本当にコメントをつけたいのなら、
リストを昔のクォートとカンマの形で書いてください。

    @list = (
        'a',    # a comment
        'b',    # another comment
    );

=item Possible attempt to separate words with commas

=begin original

(W qw) qw() lists contain items separated by whitespace; therefore
commas aren't needed to separate the items.  (You may have used
different delimiters than the parentheses shown here; braces are also
frequently used.)

=end original

(W qw) qw() リストに空白で分割された項目があります;
そのため、カンマは項目を分割する必要がありません。
(ここで使われているのと違うデリミタを用いているかもしれません;
大かっこもよく使われます。)

=begin original

You probably wrote something like this:

=end original

おそらく以下のように書いたのでしょう:

    qw! a, b, c !;

=begin original

which puts literal commas into some of the list items.  Write it without
commas if you don't want them to appear in your data:

=end original

リスト要素の中にリテラルのカンマを書いています。
データの中にカンマを出したくないなら、カンマなしで書きます:

    qw! a b c !;

=item Possible memory corruption: %s overflowed 3rd argument

=begin original

(F) An ioctl() or fcntl() returned more than Perl was bargaining for.
Perl guesses a reasonable buffer size, but puts a sentinel byte at the
end of the buffer just in case.  This sentinel byte got clobbered, and
Perl assumes that memory is now corrupted.  See L<perlfunc/ioctl>.

=end original

(F) ioctl() や fcntl() が、Perl が求めていた以上のものを返してきました。
Perl は、適量のバッファサイズを見積もりますが、念のためにバッファの
最後に目印を付けています。
この目印が壊されたため、Perl はメモリの破壊が起こったと判断しました。
L<perlfunc/ioctl> を参照してください。

=item Possible precedence issue with control flow operator

=begin original

(W syntax) There is a possible problem with the mixing of a control
flow operator (e.g. C<return>) and a low-precedence operator like
C<or>.  Consider:

=end original

(W syntax) フロー制御演算子 (例えば C<return>) と、C<or> のような
低優先順位演算子を混ぜると問題が起きることがあります。
次を考えると:

    sub { return $a or $b; }

=begin original

This is parsed as:

=end original

これは次のようにパースされます:

    sub { (return $a) or $b; }

=begin original

Which is effectively just:

=end original

これは事実上次のものです:

    sub { return $a; }

=begin original

Either use parentheses or the high-precedence variant of the operator.

=end original

かっこか、高優先順位版の演算子を使ってください。

=begin original

Note this may be also triggered for constructs like:

=end original

これは次のような構文でも引き起こされることに注意してください:

    sub { 1 if die; }

=item Possible precedence problem on bitwise %s operator

=begin original

(W precedence) Your program uses a bitwise logical operator in conjunction
with a numeric comparison operator, like this :

=end original

(W precedence) 以下のように、ビット単位の論理演算子を数値比較演算子と
結合して使用しています:

    if ($x & $y == 0) { ... }

=begin original

This expression is actually equivalent to C<$x & ($y == 0)>, due to the
higher precedence of C<==>.  This is probably not what you want.  (If you
really meant to write this, disable the warning, or, better, put the
parentheses explicitly and write C<$x & ($y == 0)>).

=end original

この式は、C<==> の優先順位の方が高いので、C<$x & ($y == 0)> と
等価になります。
これはおそらく望んでいるものではないでしょう。
(もし本当にこのように書きたいのなら、警告を無効にするか、あるいは
よりよいのはかっこを明示的に使って C<$x & ($y == 0)> と書きます)。

=item Possible unintended interpolation of $\ in regex

=begin original

(W ambiguous) You said something like C<m/$\/> in a regex.
The regex C<m/foo$\s+bar/m> translates to: match the word 'foo', the output
record separator (see L<perlvar/$\>) and the letter 's' (one time or more)
followed by the word 'bar'.

=end original

(W ambiguous) 正規表現で C<m/$\/> のようなことをしました。
正規表現 C<m/foo$\s+bar/m> は以下のように翻訳されます: 単語 'foo'、出力
レコードセパレータ (L<perlvar/$\> 参照)、文字 's' (1 回以上)、単語
'bar' にマッチングします。

=begin original

If this is what you intended then you can silence the warning by using 
C<m/${\}/> (for example: C<m/foo${\}s+bar/>).

=end original

これがあなたのしたいことなら、C<m/${\}/> を使うことで警告を抑制できます
(例えば: C<m/foo${\}s+bar/>)。

=begin original

If instead you intended to match the word 'foo' at the end of the line
followed by whitespace and the word 'bar' on the next line then you can use
C<m/$(?)\/> (for example: C<m/foo$(?)\s+bar/>).

=end original

そうではなく、行末の単語 'foo' に引き続いて、次の行で空白と単語 'bar' に
マッチングしたいなら、C<m/$(?)\/> を使ってください (例えば:
C<m/foo$(?)\s+bar/>)。

=item Possible unintended interpolation of %s in string

=begin original

(W ambiguous) You said something like '@foo' in a double-quoted string
but there was no array C<@foo> in scope at the time.  If you wanted a
literal @foo, then write it as \@foo; otherwise find out what happened
to the array you apparently lost track of.

=end original

(W ambiguous) 「@foo」のようなものをダブルクォート文字列の中に書きましたが、
現在のスコープ内に C<@foo> という配列はありません。
リテラルな @foo を指定したい場合は、\@foo と書いてください;
そうでなければ、どうやら見失ってしまったらしい配列に何が起こったを
調べてください。

=item Precedence problem: open %s should be open(%s)

=begin original

(S precedence) The old irregular construct

=end original

(S precedence) 古い変則的な構文

    open FOO || die;

=begin original

is now misinterpreted as

=end original

は現在は、Perl 5 の文法の厳しい正規化の結果、単項演算子か
リスト演算子と解釈されますので、

    open(FOO || die);

=begin original

because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old open was a little of both.)  You must put
parentheses around the filehandle, or use the new "or" operator instead
of "||".

=end original

という風に誤った解釈がなされます。
(古い open は、単項演算子とリスト演算子の中間のようなものでした。)
ファイルハンドルの前後をかっこで囲むか、"||" 演算子の代わりに
"or" 演算子を使わなくてはなりません。

=item Premature end of script headers

=begin original

See L</500 Server error>.

=end original

L</500 Server error> を参照してください。

=item printf() on closed filehandle %s

=begin original

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.

=end original

(W closed) 書き込みを行なおうとしたファイルハンドルは、既に閉じられています。
制御フローをチェックしてください。

=item print() on closed filehandle %s

=begin original

(W closed) The filehandle you're printing on got itself closed sometime
before now.  Check your control flow.

=end original

(W closed) print を行なおうとしたファイルハンドルは、既に閉じられています。
制御フローをチェックしてください。

=item Process terminated by SIG%s

=begin original

(W) This is a standard message issued by OS/2 applications, while *nix
applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
L<perlipc/"Signals">.  See also "Process terminated by SIGTERM/SIGINT"
in L<perlos2>.

=end original

(W) *nix アプリケーションは何も出力せずに終了しますが、
OS/2 アプリケーションはこれを標準メッセージとして出力します。
これは OS/2 版の仕様とみなされています。
適切なシグナルハンドラによって簡単に無効にできます;
L<perlipc/"Signals"> を参照してください。
L<perlos2> の "Process terminated by SIGTERM/SIGINT" も参照してください。

=item Prototype after '%c' for %s : %s

=begin original

(W illegalproto) A character follows % or @ in a prototype.  This is
useless, since % and @ gobble the rest of the subroutine arguments.

=end original

(W illegalproto) プロトタイプで % または @ に文字が引き続いています。
これは無意味です; % と @ は残りのサブルーチン引数を全て飲み込むからです。

=item Prototype mismatch: %s vs %s

=begin original

(S prototype) The subroutine being declared or defined had previously been
declared or defined with a different function prototype.

=end original

(S prototype) 以前異なる関数プロトタイプで宣言または定義された
サブルーチンが宣言または定義されました。

=item Prototype not terminated

=begin original

(F) You've omitted the closing parenthesis in a function prototype
definition.

=end original

(F) 関数プロトタイプ宣言で、閉じかっこがありませんでした。

=item Prototype '%s' overridden by attribute 'prototype(%s)' in %s

=begin original

(W prototype) A prototype was declared in both the parentheses after
the sub name and via the prototype attribute.  The prototype in
parentheses is useless, since it will be replaced by the prototype
from the attribute before it's ever used.

=end original

(W prototype) サブルーチン名の後のかっことプロトタイプ属性の両方で
プロトタイプが宣言されました。
先に宣言されていたプロトタイプは属性で置き換えられるので、かっこ内の
プロトタイプは無駄です。

=item Quantifier follows nothing in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You started a regular expression with a quantifier.  Backslash it if
you meant it literally.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.

=end original

(F) 正規表現を量指定子で開始しています。
もしそれをリテラルに使いたいなら、バックスラッシュでクォートしてください。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Quantifier in {,} bigger than %d in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) There is currently a limit to the size of the min and max values of
the {min,max} construct.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.  See L<perlre>.

=end original

現在のところ、{min,max} 構造の最大値と最小値には制限があります。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Quantifier {n,m} with n > m can't match in regex

=item Quantifier {n,m} with n > m can't match in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) Minima should be less than or equal to maxima.  If you really
want your regexp to match something 0 times, just put {0}.

=end original

(W regexp) 最小値は最大値以下である必要があります。
本当に 0 回マッチングする正規表現がほしいなら、単に {0} を指定してください。

=item Quantifier unexpected on zero-length expression in regex m/%s/

=begin original

(W regexp) You applied a regular expression quantifier in a place where
it makes no sense, such as on a zero-width assertion.  Try putting the
quantifier inside the assertion instead.  For example, the way to match
"abc" provided that it is followed by three repetitions of "xyz" is
C</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.

=end original

(W regexp) 正規表現量指定子をゼロ幅アサーションのような意味のない場所に
適用しました。
代わりにアサーションの中に量指定子を置いてください。
例えば、"xyz" を 3 回繰り返した後の "abc" にマッチングさせるには、
C</abc(?=xyz){3}/> ではなく C</abc(?=(?:xyz){3})/> としてください。

=item Range iterator outside integer range

=begin original

(F) One (or both) of the numeric arguments to the range operator ".."
are outside the range which can be represented by integers internally.
One possible workaround is to force Perl to use magical string increment
by prepending "0" to your numbers.

=end original

(F) 範囲演算子 ".." の一つ(または両方)の数値引数が、内部で整数として
表現できる範囲を越えています。
回避方法のひとつとしては、数値の頭に "0" を付けることで Perl に
マジカル文字列インクリメントの使用を強制させることです。

=item Ranges of ASCII printables should be some subset of "0-9", "A-Z", or
"a-z" in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

=end original

(W regexp) (C<S<use re 'strict'>> の下か C<(?[...])> の内側のみ)

=begin original

Stricter rules help to find typos and other errors.  Perhaps you didn't
even intend a range here, if the C<"-"> was meant to be some other
character, or should have been escaped (like C<"\-">).  If you did
intend a range, the one that was used is not portable between ASCII and
EBCDIC platforms, and doesn't have an obvious meaning to a casual
reader.

=end original

より厳密な規則はタイプミスやその他のエラーを見つける助けになります。
おそらくそもそもここで範囲を意図していないか、C<"-"> が他の文字の
つもりだったか、(C<"\-"> のように)エスケープされるべきだったのでしょう。
範囲を意図していたのなら、使われているものは ASCII と EBCDIC 
プラットフォームの間で移植性がなく、カジュアルな読者には不明確な
意味になります。

 [3-7]    # OK; Obvious and portable
 [d-g]    # OK; Obvious and portable
 [A-Y]    # OK; Obvious and portable
 [A-z]    # WRONG; Not portable; not clear what is meant
 [a-Z]    # WRONG; Not portable; not clear what is meant
 [%-.]    # WRONG; Not portable; not clear what is meant
 [\x41-Z] # WRONG; Not portable; not obvious to non-geek

=begin original

(You can force portability by specifying a Unicode range, which means that
the endpoints are specified by
L<C<\N{...}>|perlrecharclass/Character Ranges>, but the meaning may
still not be obvious.)
The stricter rules require that ranges that start or stop with an ASCII
character that is not a control have all their endpoints be the literal
character, and not some escape sequence (like C<"\x41">), and the ranges
must be all digits, or all uppercase letters, or all lowercase letters.

=end original

(Unicode の範囲を指定することで移植性を共生することができます;
これは端点を L<C<\N{...}>|perlrecharclass/Character Ranges> で
指定するということですが、意味はやはり明確ではないかもしれません。)
より厳密な規則は、制御文字でなく、全てリテラルな文字で、
(C<"\x41"> のような)一部のエスケープシーケンスでない
ASCII 文字で開始および終了することを要求し、
範囲は全て数字か、全て大文字か、全て小文字でなければなりません。

=item Ranges of digits should be from the same group in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) (only under C<S<use re 'strict'>> or within C<(?[...])>)

=end original

(W regexp) (C<S<use re 'strict'>> の基か C<(?[...])> の内側のみ)

=begin original

Stricter rules help to find typos and other errors.  You included a
range, and at least one of the end points is a decimal digit.  Under the
stricter rules, when this happens, both end points should be digits in
the same group of 10 consecutive digits.

=end original

より厳密な規則はタイプミスやその他のエラーを見つける助けになります。
範囲を含んでいて、少なくとも片方の端は数字です。
より厳密な規則では、これが起きたときは、両端が 10 連続した数字の同じ
グループに属する符号位置である必要があります。

=item readdir() attempted on invalid dirhandle %s

=begin original

(W io) The dirhandle you're reading from is either closed or not really
a dirhandle.  Check your control flow.

=end original

(W io) 読み込もうとしたディレクトリハンドルは既に閉じられているか、
実際にはディレクトリハンドルではありません。
制御フローをチェックしてください。

=item readline() on closed filehandle %s

=begin original

(W closed) The filehandle you're reading from got itself closed sometime
before now.  Check your control flow.

=end original

(W closed) 読み込もうとしたファイルハンドルは、既に閉じられています。
制御フローをチェックしてください。

=item read() on closed filehandle %s

=begin original

(W closed) You tried to read from a closed filehandle.

=end original

(W closed) 閉じたファイルハンドルから読み込もうとしました。

=item read() on unopened filehandle %s

=begin original

(W unopened) You tried to read from a filehandle that was never opened.

=end original

(W unopened) 開いていないファイルハンドルから読み込もうとしました。

=item Reallocation too large: %x

=begin original

(F) You can't allocate more than 64K on an MS-DOS machine.

=end original

(F) MS-DOS マシンでは、64K を越えるメモリを割り当てることはできません。

=item realloc() of freed memory ignored

=begin original

(S malloc) An internal routine called realloc() on something that had
already been freed.

=end original

内部ルーチンが、何か既に解放されているものに対して realloc() を
呼び出しました。

=item Recompile perl with B<-D>DEBUGGING to use B<-D> switch

=begin original

(S debugging) You can't use the B<-D> option unless the code to produce
the desired output is compiled into Perl, which entails some overhead,
which is why it's currently left out of your copy.

=end original

(S debugging) Perl のコンパイル時に、適切な出力ルーティンが
組み込まれていなければ、B<-D> スイッチを使うことはできません;
これは、多少のオーバヘッドがかかるもので、それが現在使っている
Perl に組み込んでない理由でしょう。

=item Recursive call to Perl_load_module in PerlIO_find_layer

=begin original

(P) It is currently not permitted to load modules when creating
a filehandle inside an %INC hook.  This can happen with C<open my
$fh, '<', \$scalar>, which implicitly loads PerlIO::scalar.  Try
loading PerlIO::scalar explicitly first.

=end original

(P) %INC フックの内側でファイルハンドルを作る時にモジュールを読み込むのは
現在のところ許されていません。
これは、C<open my $fh, '<', \$scalar> で暗黙に PerlIO::scalar を読み込むときに
起こることがあります。
最初に PerlIO::scalar を明示的に読み込むことを試してください。

=item Recursive inheritance detected in package '%s'

=begin original

(F) While calculating the method resolution order (MRO) of a package, Perl
believes it found an infinite loop in the C<@ISA> hierarchy.  This is a
crude check that bails out after 100 levels of C<@ISA> depth.

=end original

(F) パッケージのメソッド解決順序 (MRO) の計算中に、C<@ISA> 構造に
無限ループがあると判断しました。
これは、C<@ISA> を 100 階層探索した後に起きる荒いチェックです。

=item Redundant argument in %s

=begin original

(W redundant) You called a function with more arguments than other
arguments you supplied indicated would be needed.  Currently only
emitted when a printf-type format required fewer arguments than were
supplied, but might be used in the future for e.g. L<perlfunc/pack>.

=end original

(W redundant) 関数を呼び出すときに、ある引数が示している必要数より
多くの引数を指定しました。
現在のところ、printf 型のフォーマットが指定されたものより少ない数の
引数しか必要としていない場合にのみ発生しますが、将来は
例えば L<perlfunc/pack> で使われるかもしれません。

=item refcnt_dec: fd %d%s

=item refcnt: fd %d%s

=item refcnt_inc: fd %d%s

=begin original

(P) Perl's I/O implementation failed an internal consistency check.  If
you see this message, something is very wrong.

=end original

(P) Perl の I/O 実装は内部の一貫性チェックに失敗しました。
このメッセージを見たなら、何かがすごく悪いです。

=item Reference found where even-sized list expected

=begin original

(W misc) You gave a single reference where Perl was expecting a list
with an even number of elements (for assignment to a hash).  This
usually means that you used the anon hash constructor when you meant
to use parens.  In any case, a hash requires key/value B<pairs>.

=end original

(W misc) Perl が(ハッシュへの代入のために)偶数の数の要素のリストを
想定しているところに 一つのリファレンスを渡しました。
これは普通かっこを使うべきところで無名ハッシュコンストラクタを使ったことを
意味します。
とにかく、ハッシュはキー/値の B<組> を要求します。

    %hash = { one => 1, two => 2, };	# WRONG
    %hash = [ qw/ an anon array / ];	# WRONG
    %hash = ( one => 1, two => 2, );	# right
    %hash = qw( one 1 two 2 );			# also fine

=item Reference is already weak

=begin original

(W misc) You have attempted to weaken a reference that is already weak.
Doing so has no effect.

=end original

(W misc) 既に弱いリファレンスを弱めようとしました。
そうしても何の効果もありません。

=item Reference is not weak

=begin original

(W misc) You have attempted to unweaken a reference that is not weak.
Doing so has no effect.

=end original

(W misc) 現在弱くないリファレンスを弱くないリファレンスにしようとしました。
そうしても何の効果もありません。

=item Reference to invalid group 0 in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You used C<\g0> or similar in a regular expression.  You may refer
to capturing parentheses only with strictly positive integers
(normal backreferences) or with strictly negative integers (relative
backreferences).  Using 0 does not make sense.

=end original

(F) 正規表現で C<\g0> のようなものを使いました。
捕捉用のかっこへの参照は、正数(通常の後方参照)か、負数(相対後方参照)
のみです。
0 は意味を成しません。

=item Reference to nonexistent group in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) You used something like C<\7> in your regular expression, but there are
not at least seven sets of capturing parentheses in the expression.  If
you wanted to have the character with ordinal 7 inserted into the regular
expression, prepend zeroes to make it three digits long: C<\007>

=end original

正規表現の中で C<\7> のような記述がありますが、
正規表現の中に値を捕らえるかっこが 7 つありません。
正規表現の中に値 7 を持つ文字を挿入したい場合、
ゼロをつけて最低 3 桁の数値にする必要があります: C<\007>

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Reference to nonexistent named group in regex; marked by S<<-- HERE>
in m/%s/

=begin original

(F) You used something like C<\k'NAME'> or C<< \k<NAME> >> in your regular
expression, but there is no corresponding named capturing parentheses
such as C<(?'NAME'...)> or C<< (?<NAME>...) >>.  Check if the name has been
spelled correctly both in the backreference and the declaration.

=end original

(F) 正規表現中に C<\k'NAME'> や C<< \k<NAME> >> のようなものを使いましたが、
C<(?'NAME'...)> や C<< (?<NAME>...) >> のような、対応する名前付き捕捉かっこが
ありません。
前方参照と定義の両方において、名前のスペルが正しいかどうか
チェックしてください。

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Reference to nonexistent or unclosed group in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) You used something like C<\g{-7}> in your regular expression, but there
are not at least seven sets of closed capturing parentheses in the
expression before where the C<\g{-7}> was located.

=end original

(F) 正規表現で C<\g{-7}> のようなものを使いましたが、式中で C<\g{-7}> の
位置より前に少なくとも 7 組の捕捉用のかっこの組がありません。

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item regexp memory corruption

=begin original

(P) The regular expression engine got confused by what the regular
expression compiler gave it.

=end original

(P) 正規表現コンパイラが渡したもので、正規表現エンジンが
処理できなくなりました。

=item Regexp modifier "/%c" may appear a maximum of twice

=item Regexp modifier "%c" may appear a maximum of twice in regex; marked
by S<<-- HERE> in m/%s/

=begin original

(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.

=end original

(F) 正規表現パターンに指定された修飾子が多すぎます。
余分なものを削除してください。

=item Regexp modifier "%c" may not appear after the "-" in regex; marked by <-- 
HERE in m/%s/

=begin original

(F) Turning off the given modifier has the side effect of turning on
another one.  Perl currently doesn't allow this.  Reword the regular
expression to use the modifier you want to turn on (and place it before
the minus), instead of the one you want to turn off.

=end original

(F regexp) 指定された修飾子をオフにするのは他の修飾子をオンにするという
副作用があります。
Perl は現在のところこれを受け入れません。
オフにしたいものではなく、オンにしたい修飾子を使う(そしてマイナスの
前に置く)ように正規表現を書き直してください。

=item Regexp modifier "/%c" may not appear twice

=item Regexp modifier "%c" may not appear twice in regex; marked by <--
HERE in m/%s/

=begin original

(F) The regular expression pattern had too many occurrences
of the specified modifier.  Remove the extraneous ones.

=end original

(F) 正規表現パターンに指定された修飾子が多すぎます。
余分なものを削除してください。

=item Regexp modifiers "/%c" and "/%c" are mutually exclusive

=item Regexp modifiers "%c" and "%c" are mutually exclusive in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) The regular expression pattern had more than one of these
mutually exclusive modifiers.  Retain only the modifier that is
supposed to be there.

=end original

(F) 正規表現パターンに相互に排他的な修飾子が複数あります。
ここで使うであろう修飾子のみを保持します。

=item Regexp out of space in regex m/%s/

=begin original

(P) A "can't happen" error, because safemalloc() should have caught it
earlier.

=end original

(P) safemalloc() が見つけるはずなので、「起こるはずのない」エラーです。

=item Repeated format line will never terminate (~~ and @#)

=begin original

(F) Your format contains the ~~ repeat-until-blank sequence and a
numeric field that will never go blank so that the repetition never
terminates.  You might use ^# instead.  See L<perlform>.

=end original

(F) フォーマットに ~~ (空白まで繰り返し)シーケンスと決して空白にならない
スウチフィールドが含まれているので、無限ループになります。
代わりに ^# を使うべきでしょう。
L<perlform> を参照してください。

=item Replacement list is longer than search list

=begin original

(W misc) You have used a replacement list that is longer than the
search list.  So the additional elements in the replacement list
are meaningless.

=end original

(W misc) 検索リストよりも長い置換リストを使いました。
長い分の置換リストは無意味です。

=item '(*%s' requires a terminating ':' in regex; marked by <-- HERE in m/%s/

=begin original

(F) You used a construct that needs a colon and pattern argument.
Supply these or check that you are using the right construct.

=end original

(F) コロンとパターン引数を必要とする構文を使いました。
これらを補うか、正しい構文を使っているか確認してください。

=item '%s' resolved to '\o{%s}%d'

=begin original

As of Perl 5.32, this message is no longer generated.  Instead, see
L</Non-octal character '%c' terminates \o early.  Resolved as "%s">.
(W misc, regexp)  You wrote something like C<\08>, or C<\179> in a
double-quotish string.  All but the last digit is treated as a single
character, specified in octal.  The last digit is the next character in
the string.  To tell Perl that this is indeed what you want, you can use
the C<\o{ }> syntax, or use exactly three digits to specify the octal
for the character.

=end original

Perl 5.32 から、もはやこのメッセージは出力されません。
代わりに、
L</Non-octal character '%c' terminates \o early.  Resolved as "%s">
を見てください。
(W misc, regexp) ダブルクォート風の文字列の中で C<\08> や C<\179> のような
ものを書きました。
最後以外の数字は、8 進数で指定された単一の文字として扱われます。
最後の数字は文字列中の次の文字です。
これがまさしく望んでいるものであることを Perl に伝えるには、
C<\o{ }> 構文を使うか、文字を 8 進数で指定するために正確に 3 桁を
使ってください。

=item Reversed %s= operator

=begin original

(W syntax) You wrote your assignment operator backwards.  The = must
always come last, to avoid ambiguity with subsequent unary operators.

=end original

(W syntax) 代入演算子を逆順に書いています。
等号の後に単項演算子が続くときに、曖昧になるのを避けるため、
代入演算子では、等号 = が、最後にこないといけません。

=item rewinddir() attempted on invalid dirhandle %s

=begin original

(W io) The dirhandle you tried to do a rewinddir() on is either closed
or not really a dirhandle.  Check your control flow.

=end original

(W io) rewinddir() しようとしたディレクトリハンドルは既に閉じられているか、
実際にはディレクトリハンドルではありません。
制御フローをチェックしてください。

=item Scalars leaked: %d

=begin original

(S internal) Something went wrong in Perl's internal bookkeeping
of scalars: not all scalar variables were deallocated by the time
Perl exited.  What this usually indicates is a memory leak, which
is of course bad, especially if the Perl program is intended to be
long-running.

=end original

(P) Perl 内部のスカラ管理で何かがおかしくなりました:
Perl 終了時に全てのスカラ変数が解放されませんでした。
これは普通メモリリークを示していて、これはもちろん悪いことですが、
Perl プログラムが長い間動作する場合には特にそうです。

=item Scalar value @%s[%s] better written as $%s[%s]

=begin original

(W syntax) You've used an array slice (indicated by @) to select a
single element of an array.  Generally it's better to ask for a scalar
value (indicated by $).  The difference is that C<$foo[&bar]> always
behaves like a scalar, both when assigning to it and when evaluating its
argument, while C<@foo[&bar]> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

=end original

(W syntax) 配列の一つの要素を選ぶのに、(@ で示される) 配列
スライスを用いました。
一般には、($ で示される) スカラ値を使った方が良いと思われます。
違いは、C<$foo[&bar]> とした場合、代入の対象としたときにも、
添字を評価するときにも、常にスカラとして振る舞うのに対し、
C<@foo[&bar]> の場合には、代入の対象としてもリストとして振る舞い、
添字にもリストコンテキストを与えることになります;
これは、一つの添字だけを期待するときには、おかしなこととなるでしょう。

=begin original

On the other hand, if you were actually hoping to treat the array
element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
L<perlref>.

=end original

一方、もし本当に配列要素をリストとして扱いたい場合、リファレンスが
どのように働くかについて詳しく知る必要があります; なぜなら
Perl はスカラとリストを自動的に変換したりはしないからです。
L<perlref> を参照してください。

=item Scalar value @%s{%s} better written as $%s{%s}

=begin original

(W syntax) You've used a hash slice (indicated by @) to select a single
element of a hash.  Generally it's better to ask for a scalar value
(indicated by $).  The difference is that C<$foo{&bar}> always behaves
like a scalar, both when assigning to it and when evaluating its
argument, while C<@foo{&bar}> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

=end original

(W syntax) ハッシュの一つの要素を選ぶのに、(@ で示される) ハッシュ
スライスを用いました。
一般には、($ で示される) スカラ値を使った方が良いと思われます。
違いは、C<$foo{&bar}> とした場合、代入の対象としたときにも、
添字を評価するときにも、常にスカラとして振る舞うのに対し、
C<@foo{&bar}> の場合には、代入の対象としてもリストとして振る舞い、
添字にもリストコンテキストを与えることになります;
これは、一つの添字だけを期待するときには、おかしなこととなるでしょう。

=begin original

On the other hand, if you were actually hoping to treat the hash element
as a list, you need to look into how references work, because Perl will
not magically convert between scalars and lists for you.  See
L<perlref>.

=end original

一方、もし本当にハッシュ要素をリストとして扱いたい場合、リファレンスが
どのように働くかについて詳しく知る必要があります; なぜなら
Perl はスカラとリストを自動的に変換したりはしないからです。
L<perlref> を参照してください。

=item Search pattern not terminated

=begin original

(F) The lexer couldn't find the final delimiter of a // or m{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from a variable C<$m> may cause this error.

=end original

(F) // もしくは m{} 構文の最後の区切り文字が見つかりませんでした。
かっこ類の区切り文字では、ネストを数えることを忘れないでください。
C<$m> 変数の前に C<$> をつけるのを忘れるとこのエラーが出ることがあります。

=begin original

Note that since Perl 5.10.0 a // can also be the I<defined-or>
construct, not just the empty search pattern.  Therefore code written
in Perl 5.10.0 or later that uses the // as the I<defined-or> can be
misparsed by pre-5.10.0 Perls as a non-terminated search pattern.

=end original

Perl 5.10.0 から、// は I<defined-or> 構文として扱われ、単なる
空検索パターンではありません。
従って、Perl 5.10.0 以降で書かれた、// を I<defined-or> として使っている
コードは、5.10.0 以前の Perl では、終端していない検索パターンとして
誤パースされるかもしれません。

=item seekdir() attempted on invalid dirhandle %s

=begin original

(W io) The dirhandle you are doing a seekdir() on is either closed or not
really a dirhandle.  Check your control flow.

=end original

(W io) seekdir() しようとしたディレクトリハンドルは閉じられているか、
実際にはディレクトリハンドルではありません。
制御フローをチェックしてください。

=item %sseek() on unopened filehandle

=begin original

(W unopened) You tried to use the seek() or sysseek() function on a
filehandle that was either never opened or has since been closed.

=end original

(W unopened) オープンされていないファイルハンドルか、既にクローズされた
ファイルハンドルに対して、seek() 関数や sysseek() 関数を使おうとしました。

=item select not implemented

=begin original

(F) This machine doesn't implement the select() system call.

=end original

(F) このマシンでは、select() システムコールは実装されていません。

=item Self-ties of arrays and hashes are not supported

=begin original

(F) Self-ties are of arrays and hashes are not supported in
the current implementation.

=end original

(F) 配列やハッシュの自己 tie は現在の実装では対応していません。

=item Semicolon seems to be missing

=begin original

(W semicolon) A nearby syntax error was probably caused by a missing
semicolon, or possibly some other missing operator, such as a comma.

=end original

(W semicolon) この付近の構文エラーは、おそらくセミコロンか、コンマなどの
演算子がなかったために起こったものと考えられます。

=item semi-panic: attempt to dup freed string

=begin original

(S internal) The internal newSVsv() routine was called to duplicate a
scalar that had previously been marked as free.

=end original

(S internal) 既に解放と印を付けたスカラを複製するために、内部の
newSVsv() ルーティンが呼ばれました。

=item sem%s not implemented

=begin original

(F) You don't have System V semaphore IPC on your system.

=end original

(F) このシステムでは、System V セマフォ IPC は使えません。

=item send() on closed socket %s

=begin original

(W closed) The socket you're sending to got itself closed sometime
before now.  Check your control flow.

=end original

(W closed) 送信を行なおうとしたソケットは、既に閉じられています。
制御フローをチェックしてください。

=item Sequence "\c{" invalid

=begin original

(F) These three characters may not appear in sequence in a
double-quotish context.  This message is raised only on non-ASCII
platforms (a different error message is output on ASCII ones).  If you
were intending to specify a control character with this sequence, you'll
have to use a different way to specify it.

=end original

(F) これら三つの文字の並びはダブルクォート風のコンテキストでは
使えません。
このメッセージは非 ASCII プラットフォームでのみ発生します
(ASCII では異なったえらメッセージが出力されます)。
この並びの制御文字を指定することを意図している場合は、指定するために
異なる方法を使う必要があります。

=item Sequence (? incomplete in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) A regular expression ended with an incomplete extension (?.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=end original

(F) 正規表現が不完全な拡張 (? で終わっています。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Sequence (?%c...) not implemented in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) A proposed regular expression extension has the character reserved
but has not yet been written.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.  See L<perlre>.

=end original

(F) 使おうとした正規表現の拡張は、予約された文字ですが、
まだ実装されていません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Sequence (?%s...) not recognized in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) You used a regular expression extension that doesn't make sense.
The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  This may happen when using the C<(?^...)> construct to tell
Perl to use the default regular expression modifiers, and you
redundantly specify a default modifier.  For other
causes, see L<perlre>.

=end original

(F) お使いになった正規表現の拡張は、意味をなしません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
これは、 Perl にデフォルトの正規表現修飾子を使うように知らせるために
C<(?^...)> 構文を使ったときや、デフォルトの演算子を冗長に指定しています。
その他の理由については、L<perlre> を参照してください。

=item Sequence (?#... not terminated in regex m/%s/

=begin original

(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  See
L<perlre>.

=end original

(F) 正規表現のコメントは閉じかっこで終わらなければなりません。
組み込みのかっこは許可されません。
L<perlre> を参照してください。

=item Sequence (?&... not terminated in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) A named reference of the form C<(?&...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=end original

(F) C<(?&...)> の形式の名前付きリファレンスで、名前の後の最後の閉じかっこが
ありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence (?%c... not terminated in regex; marked by S<<-- HERE>
in m/%s/

=begin original

(F) A named group of the form C<(?'...')> or C<< (?<...>) >> was missing the final
closing quote or angle bracket.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.

=end original

(F) C<(?'...')> または C<< (?<...>) >> の形式の名前付きグループで、名前の後の
最後の閉じクォートまたは山かっこがありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence (?(%c... not terminated in regex; marked by S<<-- HERE>
in m/%s/

=begin original

(F) A named reference of the form C<(?('...')...)> or C<< (?(<...>)...) >> was
missing the final closing quote or angle bracket after the name.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

(F) C<(?('...')...)> または C<< (?(<...>)...) >> の形式の名前付き
リファレンスで、名前の後の最後の閉じクォートまたは山かっこがありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence (?... not terminated in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) There was no matching closing parenthesis for the '('.  The
S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.

=end original

(F) '(' に対応する閉じかっこがありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence \%s... not terminated in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) The regular expression expects a mandatory argument following the escape
sequence and this has been omitted or incorrectly written.

=end original

(F) 正規表現でエスケープシーケンスの後に必須の引き数を想定しましたが、
それが省略されているか適切に書かれていません。

=item Sequence (?{...}) not terminated with ')'

=begin original

(F) The end of the perl code contained within the {...} must be
followed immediately by a ')'.

=end original

(F) {} の中に含まれている perl コードの末尾は直後に ')' が
引き続かなければなりません。

=item Sequence (?PE<gt>... not terminated in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) A named reference of the form C<(?PE<gt>...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=end original

(F) C<(?PE<gt>...)> 形式の名前付き参照で、名前の後の最後の閉じかっこが
ありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence (?PE<lt>... not terminated in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) A named group of the form C<(?PE<lt>...E<gt>')> was missing the final
closing angle bracket.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.

=end original

(F) C<(?PE<lt>...E<gt>')> 形式の名前付きグループで、
最後の閉じ山かっこがありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence ?P=... not terminated in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) A named reference of the form C<(?P=...)> was missing the final
closing parenthesis after the name.  The S<<-- HERE> shows whereabouts
in the regular expression the problem was discovered.

=end original

(F) C<(?P=...)> の形式の名前付きリファレンスで、名前の後の最後の
閉じかっこがありません。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=item Sequence (?R) not terminated in regex m/%s/

=begin original

(F) An C<(?R)> or C<(?0)> sequence in a regular expression was missing the
final parenthesis.

=end original

(F) 正規表現中の C<(?R)> または C<(?0)> で最後のかっこがありません。

=item Z<>500 Server error

=begin original

(A) This is the error message generally seen in a browser window
when trying to run a CGI program (including SSI) over the web.  The
actual error text varies widely from server to server.  The most
frequently-seen variants are "500 Server error", "Method (something)
not permitted", "Document contains no data", "Premature end of script
headers", and "Did not produce a valid header".

=end original

(A) これは、一般的には CGI (SSI を含みます)プログラムを WWW 越しに
実行しようとしたときにブラウザのウィンドウに表示されるメッセージです。
実際のエラーテキストはサーバーによって大きく異なります。
もっともよく見られるものとしては、"500 Server error",
"Method (something) not permitted", "Document contains no data",
"Premature end of script headers", "Did not produce a valid header" が
あります。

=begin original

B<This is a CGI error, not a Perl error>.

=end original

B<これは CGI のエラーであり、Perl のエラーではありません>.

=begin original

You need to make sure your script is executable, is accessible by
the user CGI is running the script under (which is probably not the
user account you tested it under), does not rely on any environment
variables (like PATH) from the user it isn't running under, and isn't
in a location where the CGI server can't find it, basically, more or
less.  Please see the following for more information:

=end original

まずはあなたのスクリプトが実行可能か、CGI を実行するユーザー(これはおそらく
あなたがテストしたユーザーではありません)で読み込み可能か、実行しているのとは
異なるユーザーの環境変数(PATH など)に依存していないか、CGI サーバーが
見つけられない場所に置いていないか、といったことを確認する必要があるでしょう。
さらなる情報については以下を参照してください。

	https://www.perl.org/CGI_MetaFAQ.html
	http://www.htmlhelp.org/faq/cgifaq.html
	http://www.w3.org/Security/Faq/

=begin original

You should also look at L<perlfaq9>.

=end original

L<perlfaq9> も見るべきでしょう。

=item setegid() not implemented

=begin original

(F) You tried to assign to C<$)>, and your operating system doesn't
support the setegid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<$)> へ代入を行なおうとしましたが、この OS では、setegid()
システムコール (または、同等のもの) がサポートされていません;
少なくとも Configure では、そう判断されました。

=item seteuid() not implemented

=begin original

(F) You tried to assign to C<< $> >>, and your operating system doesn't
support the seteuid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<< $> >> へ代入を行なおうとしましたが、この OS では、seteuid()
システムコール (または、同等のもの) がサポートされていません;
少なくとも Configure では、そう判断されました。

=item setpgrp can't take arguments

=begin original

(F) Your system has the setpgrp() from BSD 4.2, which takes no
arguments, unlike POSIX setpgid(), which takes a process ID and process
group ID.

=end original

(F) このシステムの setpgrp() は BSD 4.2 由来のもので、引数がありません;
POSIX setpgid() はプロセス ID とプロセスグループ ID を引数にとります。

=item setrgid() not implemented

=begin original

(F) You tried to assign to C<$(>, and your operating system doesn't
support the setrgid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<$(> へ代入を行なおうとしましたが、この OS では、setrgid()
システムコール (または、同等のもの) がサポートされていません;
少なくとも Configure では、そう判断されました。

=item setruid() not implemented

=begin original

(F) You tried to assign to C<$<>, and your operating system doesn't
support the setruid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<$<> へ代入を行なおうとしましたが、この OS では、setruid()
システムコール (または、同等のもの) がサポートされていません;
少なくとも Configure では、そう判断されました。

=item setsockopt() on closed socket %s

=begin original

(W closed) You tried to set a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/setsockopt>.

=end original

(W closed) 閉じているソケットにソケットオプションを設定しようとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか?
L<perlfunc/setsockopt> を参照してください。

=item Setting $/ to a reference to %s is forbidden

=begin original

(F) You assigned a reference to a scalar to C<$/> where the referenced item is
not a positive integer.  In older perls this B<appeared> to work the same as
setting it to C<undef> but was in fact internally different, less efficient
and with very bad luck could have resulted in your file being split by a
stringified form of the reference.

=end original

(F) リファレンス先のアイテムが正の整数でないときに、
C<$/> にスカラへの整数を代入しました。
以前の perl ではこれは C<undef> を設定するのと同じように B<見えました> が、
内部的には異なっていて、より非効率で、とても運が悪い場合はファイルが
このリファレンスの文字列化形式で split されることになっていました。

=begin original

In Perl 5.20.0 this was changed so that it would be B<exactly> the same as
setting C<$/> to undef, with the exception that this warning would be thrown.

=end original

Perl 5.20.0 でこれは変更され、これはこの警告が投げられることを除いては
C<$/> に undef を設定するのと B<正確に> 同じになりました。

=begin original

You are recommended to change your code to set C<$/> to C<undef> explicitly if
you wish to slurp the file.  As of Perl 5.28 assigning C<$/> to a reference
to an integer which isn't positive is a fatal error.

=end original

ファイル全体を読み込みたい場合は、明示的に C<$/> に C<undef> を
設定するようにコードを変更することを勧めます。
Perl 5.28 から、C<$/> への正でない整数へのリファレンスの代入は
致命的エラーです。

=item Setting $/ to %s reference is forbidden

=begin original

(F) You tried to assign a reference to a non integer to C<$/>.  In older
Perls this would have behaved similarly to setting it to a reference to
a positive integer, where the integer was the address of the reference.
As of Perl 5.20.0 this is a fatal error, to allow future versions of Perl
to use non-integer refs for more interesting purposes.

=end original

(F) 非整数へのリファレンスを C<$/> に代入しようとしました。
以前の Perl ではこれは正の整数(リファレンスのアドレス)へのリファレンスを
設定するのと似たように振る舞っていました。
将来のバージョンの Perl で非整数リファレンスをより興味深い目的に使えるように
Perl 5.20.0 から、これは致命的エラーになりました。

=item shm%s not implemented

=begin original

(F) You don't have System V shared memory IPC on your system.

=end original

(F) このシステムでは、System V 共有メモリ IPC は使えません。

=item !=~ should be !~

=begin original

(W syntax) The non-matching operator is !~, not !=~.  !=~ will be
interpreted as the != (numeric not equal) and ~ (1's complement)
operators: probably not what you intended.

=end original

(W syntax) 非マッチ演算子は !=~ ではなく !~ です。
!=~ は != (数値の不一致) と ~ (1 の補数) 演算子と解釈されます:
おそらくあなたの意図していることではないでしょう。

=item /%s/ should probably be written as "%s"

=begin original

(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to C<join>.  Perl will treat the true or false
result of matching the pattern against $_ as the string, which is
probably not what you had in mind.

=end original

(W syntax) C<join> の最初の引数として、Perl が文字列を想定しているところに
パターンを使いました。
Perl は $_ をパターンマッチングした結果の真か偽の値を文字列として
扱いますが、これはおそらく望んでいることではないでしょう。

=item shutdown() on closed socket %s

=begin original

(W closed) You tried to do a shutdown on a closed socket.  Seems a bit
superfluous.

=end original

(W closed) クローズされたソケットに shutdown を行なおうとしました。
多少、無駄のように思われます。

=item SIG%s handler "%s" not defined

=begin original

(W signal) The signal handler named in %SIG doesn't, in fact, exist.
Perhaps you put it into the wrong package?

=end original

(W signal) %SIG 内で指定したシグナルハンドラが、存在しません。
間違ったパッケージで、設定を行なっているのかもしれません。

=item Slab leaked from cv %p

=begin original

(S) If you see this message, then something is seriously wrong with the
internal bookkeeping of op trees.  An op tree needed to be freed after
a compilation error, but could not be found, so it was leaked instead.

=end original

(S) このメッセージが出た場合、構文木の内部管理で何かひどく
悪いことになっています。
ある構文木がコンパイルエラーの後で解放される必要がありますが、
見つからないので、リークしています。

=item sleep(%u) too large

=begin original

(W overflow) You called C<sleep> with a number that was larger than
it can reliably handle and C<sleep> probably slept for less time than
requested.

=end original

(W overflow) 確実に扱えるよりも大きな値で C<sleep> を呼び出したので、
C<sleep> はおそらく指定されたより短い時間だけスリープします。

=item Slurpy parameter not last

=begin original

(F) In a subroutine signature, you put something after a slurpy (array or
hash) parameter.  The slurpy parameter takes all the available arguments,
so there can't be any left to fill later parameters.

=end original

(F) サブルーチンシグネチャの中で、吸い込み(配列またはハッシュ)パラメータの後に
何かを起きました。
吸い込みパラメータは利用可能な全ての引数を取るので、その後のパラメータに
対応するものを残しません。

=item Smart matching a non-overloaded object breaks encapsulation

=begin original

(F) You should not use the C<~~> operator on an object that does not
overload it: Perl refuses to use the object's underlying structure
for the smart match.

=end original

(F) オーバーロードしていないオブジェクトに対して C<~~> 演算子を
使うべきではありません: Perl はスマートマッチング時にオブジェクトの
基礎となる構造を使うことを拒否します。

=item Smartmatch is experimental

=begin original

(S experimental::smartmatch) This warning is emitted if you
use the smartmatch (C<~~>) operator.  This is currently an experimental
feature, and its details are subject to change in future releases of
Perl.  Particularly, its current behavior is noticed for being
unnecessarily complex and unintuitive, and is very likely to be
overhauled.

=end original

(S experimental::smartmatch) この警告は、スマートマッチング (C<~~>) 演算子を
使ったときに出力されます。
これは現在のところ実験的な機能で、Perl の将来のリリースでは変更される
可能性があります。
特に、現在の実装は不必要に複雑かつ直感的でないとされており、ほぼ確実に
見直されます。

=item Sorry, hash keys must be smaller than 2**31 bytes

=begin original

(F) You tried to create a hash containing a very large key, where "very
large" means that it needs at least 2 gigabytes to store. Unfortunately,
Perl doesn't yet handle such large hash keys. You should
reconsider your design to avoid hashing such a long string directly.

=end original

(F) とても大きなキーを含むハッシュを作ろうとしました;
ここで「とても大きな」とは、保管に最低 2 ギガバイト必要なものです。
残念ながら、Perl はまだそのような大きなハッシュキーを扱えません。
そのような長い文字列で直接ハッシュを作るのを避けるように、
設計を再考する必要があります。

=item sort is now a reserved word

=begin original

(F) An ancient error message that almost nobody ever runs into anymore.
But before sort was a keyword, people sometimes used it as a filehandle.

=end original

(F) もはや、誰もお目にかかることのない、旧世代のエラーメッセージです。
ただ、sort がキーワードとなる前には、これをファイルハンドルとして
使う方がいました。

=item Source filters apply only to byte streams

=begin original

(F) You tried to activate a source filter (usually by loading a
source filter module) within a string passed to C<eval>.  This is
not permitted under the C<unicode_eval> feature.  Consider using
C<evalbytes> instead.  See L<feature>.

=end original

(F) C<eval> に渡された文字列の中で(通常はソースフィルタモジュールを
読み込むことで)ソースフィルタを有効にしようとしました。
これは C<unicode_eval> 機能が有効の場合は許されていません。
代わりに C<evalbytes> を使うことを検討してください。
L<feature> を参照してください。

=item splice() offset past end of array

=begin original

(W misc) You attempted to specify an offset that was past the end of
the array passed to splice().  Splicing will instead commence at the
end of the array, rather than past it.  If this isn't what you want,
try explicitly pre-extending the array by assigning $#array = $offset.
See L<perlfunc/splice>.

=end original

(W misc) splice() で渡された配列の末尾より後ろのオフセットを指定しました。
splice は配列の末尾ではなく、配列の最後の位置に対して実行されます。
これが望んでいることではないなら、$#array = $offset と代入することで
明示的に事前に配列を拡張してください。
L<perlfunc/splice> を参照してください。

=item Split loop

=begin original

(P) The split was looping infinitely.  (Obviously, a split shouldn't
iterate more times than there are characters of input, which is what
happened.)  See L<perlfunc/split>.

=end original

(P) split が無限ループに陥りました。
(明らかに、split は、入力文字数以上にはできないはずですが、
そうなってしまいました。)　
L<perlfunc/split> を参照してください。

=item Statement unlikely to be reached

=begin original

(W exec) You did an exec() with some statement after it other than a
die().  This is almost always an error, because exec() never returns
unless there was a failure.  You probably wanted to use system()
instead, which does return.  To suppress this warning, put the exec() in
a block by itself.

=end original

(W exec) exec() の後に、die() 以外の実行文があります。
失敗したとき以外は、exec() から戻ってくることはありませんから、
ほとんどの場合には誤りでしょう。
戻ってくるsystem() に置き換える必要があるかもしれません。
この警告を止めるには、ブロック内に exec() だけを記述してください。

=item "state" subroutine %s can't be in a package

=begin original

(F) Lexically scoped subroutines aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.

=end original

(F) レキシカルスコープサブルーチンはパッケージ内にないので、
頭にパッケージ名を付けて宣言することは、無意味です。

=item "state %s" used in sort comparison

=begin original

(W syntax) The package variables $a and $b are used for sort comparisons.
You used $a or $b in as an operand to the C<< <=> >> or C<cmp> operator inside a
sort comparison block, and the variable had earlier been declared as a
lexical variable.  Either qualify the sort variable with the package
name, or rename the lexical variable.

=end original

(W syntax) パッケージ変数 $a と $b はソート比較のために使われます。
$a または $b をソート比較ブロックの中の C<< <=> >> または C<cmp> 演算子の
オペランドとして使いましたが、この変数はその前にレキシカル変数として
宣言されています。
ソート変数をパッケージ名で修飾するか、レキシカル変数の名前を変えてください。

=item "state" variable %s can't be in a package

=begin original

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

=end original

(F) レキシカルスコープサブルーチンはパッケージ内にないので、
頭にパッケージ名を付けて宣言することは、無意味です。
パッケージ変数をローカル化したい場合には、local() を使ってください。

=item stat() on unopened filehandle %s

=begin original

(W unopened) You tried to use the stat() function on a filehandle that
was either never opened or has since been closed.

=end original

(W unopened) オープンされていないファイルハンドルか、既にクローズされた
ファイルハンドルに対して、stat() 関数を使おうとしました。

=item Strings with code points over 0xFF may not be mapped into in-memory file handles

=begin original

(W utf8) You tried to open a reference to a scalar for read or append
where the scalar contained code points over 0xFF.  In-memory files
model on-disk files and can only contain bytes.

=end original

(W utf8) 0xFF を超える符号位置を含むスカラに対して、読み込みや追加で
スカラへのリファレンスを開こうとしました。
インメモリファイルはディスクのファイルをモデル化していて、バイトのみが
使えます。

=item Stub found while resolving method "%s" overloading "%s" in package "%s"

=begin original

(P) Overloading resolution over @ISA tree may be broken by importation
stubs.  Stubs should never be implicitly created, but explicit calls to
C<can> may break this.

=end original

(P) @ISA ツリーでのオーバーロードの解決がインポートのスタブで壊されました。
スタブは暗黙に作られることはありませんが、明示的に C<can> を呼び出すと
これを破壊することがあります。

=item Subroutine attributes must come before the signature

=begin original

(F) When subroutine signatures are enabled, any subroutine attributes must
come before the signature. Note that this order was the opposite in
versions 5.22..5.26. So:

=end original

(F) サブルーチンシグネチャが有効の場合、サブルーチン属性は
シグネチャの前に来なければなりません。
この順序はバージョン 5.22 .. 5.26 と反対であることに注意してください。
従って:

    sub foo :lvalue ($a, $b) { ... }  # 5.20 and 5.28 +
    sub foo ($a, $b) :lvalue { ... }  # 5.22 .. 5.26

=item Subroutine "&%s" is not available

=begin original

(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical subroutine that is not currently
available.  This can happen for one of two reasons.  First, the lexical
subroutine may be declared in an outer anonymous subroutine that has
not yet been created.  (Remember that named subs are created at compile
time, while anonymous subs are created at run-time.)  For example,

=end original

(W closure) コンパイル時に、内部の名前付きサブルーチンや eval が、現在
利用できない外側のレキシカルサブルーチンを捕捉しようとしました。
これは二つの理由で起こります。
まず、レキシカルサブルーチンが、まだ作成されていない外側の無名サブルーチンで
宣言されたときです。
(名前付きサブルーチンはコンパイル時に作成されますが、無名サブルーチンは
実行時に作成されることを思い出してください。)
例えば、

    sub { my sub a {...} sub f { \&a } }

=begin original

At the time that f is created, it can't capture the current "a" sub,
since the anonymous subroutine hasn't been created yet.  Conversely, the
following won't give a warning since the anonymous subroutine has by now
been created and is live:

=end original

f が作成された時点で、現在の "a" サブルーチンは捕捉できません; なぜなら
無名サブルーチンはまだ作成されていないからです。
逆に、以下のものは警告されません; 無名サブルーチンはこの時点で作成されていて
生きているからです:

    sub { my sub a {...} eval 'sub f { \&a }' }->();

=begin original

The second situation is caused by an eval accessing a lexical subroutine
that has gone out of scope, for example,

=end original

2 番目の状況は eval がスコープ外となったレキシカルサブルーチンに
アクセスすることで起こります; 例えば:

    sub f {
	my sub a {...}
	sub { eval '\&a' }
    }
    f()->();

=begin original

Here, when the '\&a' in the eval is being compiled, f() is not currently
being executed, so its &a is not available for capture.

=end original

ここで、eval の中の '\&a' がコンパイルされるとき、f() はこの時点では
実行されていないので、&a は捕捉として利用できません。

=item "%s" subroutine &%s masks earlier declaration in same %s

=begin original

(W shadow) A "my" or "state" subroutine has been redeclared in the
current scope or statement, effectively eliminating all access to
the previous instance.  This is almost always a typographical error.
Note that the earlier subroutine will still exist until the end of
the scope or until all closure references to it are destroyed.

=end original

(W shadow) "my" または "state" サブルーチンは現在のスコープまたは文で
再定義されたため、事実上以前の実体への全てのアクセスが取り除かれます。
これはほとんど常にタイプミスです。
最初のサブルーチンはスコープの末尾に到達するか、これを参照している
全てのクロージャが破壊されるまで存在したままであることに注意してください。

=item Subroutine %s redefined

=begin original

(W redefine) You redefined a subroutine.  To suppress this warning, say

=end original

(W redefine) サブルーチンを再定義しました。
この警告を止めるには以下のようにしてください:

    {
	no warnings 'redefine';
	eval "sub name { ... }";
    }

=item Subroutine "%s" will not stay shared

=begin original

(W closure) An inner (nested) I<named> subroutine is referencing a "my"
subroutine defined in an outer named subroutine.

=end original

(W closure) 内側の (ネストした) I<名前付き> サブルーチンが、
外側の名前付きサブルーチンで定義された "my" サブルーチンを参照しています。

=begin original

When the inner subroutine is called, it will see the value of the outer
subroutine's lexical subroutine as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the lexical subroutine.  In other words,
it will no longer be shared.  This will especially make a difference
if the lexical subroutines accesses lexical variables declared in its
surrounding scope.

=end original

内側のサブルーチンが呼び出されるとき、
外側のサブルーチンのレキシカルサブルーチンの値は、
外側のサブルーチンの「最初の」呼び出し前と呼び出し中のものになります;
この場合、外側のサブルーチンへの最初の呼び出しが終了した後、
内側と外側のサブルーチンはもはやレキシカルサブルーチンについて
共通の値を共有しません。
言い換えると、これはもはや共有されません。
これは特に、レキシカルサブルーチンがその周りのスコープで宣言された
レキシカル変数にアクセスしたときに違いがあります。

=begin original

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference lexical subroutines in outer subroutines are created, they
are automatically rebound to the current values of such lexical subs.

=end original

この問題は普通、C<sub {}> 構文を使って内側のサブルーチンを無名にすることで
解決します。
外側のサブルーチンのレキシカルサブルーチンを参照する内側の
無名サブルーチンが作成されたとき、そのレキシカルサブルーチンの現在の値に
自動的に回復します。

=item Substitution loop

=begin original

(P) The substitution was looping infinitely.  (Obviously, a substitution
shouldn't iterate more times than there are characters of input, which
is what happened.)  See the discussion of substitution in
L<perlop/"Regexp Quote-Like Operators">.

=end original

(P) 置換が無限ループに陥りました。
(明らかに、置換は入力文字数以上には起こらないはずですが、
それが起こってしまいました。)
L<perlop/"Quote and Quote-Like Operators"> を参照してください。

=item Substitution pattern not terminated

=begin original

(F) The lexer couldn't find the interior delimiter of an s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from variable C<$s> may cause this error.

=end original

(F) s/// もしくは s{}{} 構文の真ん中の区切り文字が見つかりませんでした。
かっこ類の区切り文字では、ネストを数えることを忘れないでください。
C<$s> 変数の前に C<$> をつけるのを忘れるとこのエラーが出ることがあります。

=item Substitution replacement not terminated

=begin original

(F) The lexer couldn't find the final delimiter of an s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from variable C<$s> may cause this error.

=end original

(F) s/// もしくは s{}{} 構文の最後の区切り文字が見つかりませんでした。
かっこ類の区切り文字では、ネストを数えることを忘れないでください。
C<$s> 変数の前に C<$> をつけるのを忘れるとこのエラーが出ることがあります。

=item substr outside of string

=begin original

(W substr)(F) You tried to reference a substr() that pointed outside of
a string.  That is, the absolute value of the offset was larger than the
length of the string.  See L<perlfunc/substr>.  This warning is fatal if
substr is used in an lvalue context (as the left hand side of an
assignment or as a subroutine argument for example).

=end original

(W substr)(F) 文字列の外を指す substr() を参照しようとしました。
つまり、オフセットの絶対値が、文字列の長さより大きくなっています。
L<perlfunc/substr> を参照してください。
この警告は、substr が(代入の左側やサブルーチンの引数といった)
左辺値として使われた場合は致命的となります。

=item sv_upgrade from type %d down to type %d

=begin original

(P) Perl tried to force the upgrade of an SV to a type which was actually
inferior to its current type.

=end original

(P) Perl は SV を、実際には現在の型より下位の型への昇格を
強制しようとしました。

=item Switch (?(condition)... contains too many branches in regex; marked by 
S<<-- HERE> in m/%s/

=begin original

(F) A (?(condition)if-clause|else-clause) construct can have at most
two branches (the if-clause and the else-clause).  If you want one or
both to contain alternation, such as using C<this|that|other>, enclose
it in clustering parentheses:

=end original

(F) (?(condition)if-clause|else-clause) 構造は最大で二つの分岐
(if-clause と else-clause) を持つことができます。
片方、または両方に選択肢を含めたいときは、それをかっこで囲んでください:

    (?(condition)(?:this|that|other)|else-clause)

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem
was discovered.  See L<perlre>.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Switch condition not recognized in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) The condition part of a (?(condition)if-clause|else-clause) construct
is not known.  The condition must be one of the following:

=end original

(?(...)if-clause|else-clause) 構造の条件部が不明です。
条件は以下のいずれかでなければなりません。

 (1) (2) ...        true if 1st, 2nd, etc., capture matched
 (<NAME>) ('NAME')  true if named capture matched
 (?=...) (?<=...)   true if subpattern matches
 (?!...) (?<!...)   true if subpattern fails to match
 (?{ CODE })        true if code returns a true value
 (R)                true if evaluating inside recursion
 (R1) (R2) ...      true if directly inside capture group 1, 2, etc.
 (R&NAME)           true if directly inside named capture
 (DEFINE)           always false; for defining named subpatterns

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Switch (?(condition)... not terminated in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) You omitted to close a (?(condition)...) block somewhere
in the pattern.  Add a closing parenthesis in the appropriate
position.  See L<perlre>.

=end original

(F) パターン中のどこかで (?(condition)...) ブロックを閉じるのを省略しました。
適切な位置に閉じかっこを追加してください。
L<perlre> を参照してください。

=item switching effective %s is not implemented

=begin original

(F) While under the C<use filetest> pragma, we cannot switch the real
and effective uids or gids.

=end original

(F) C<use filetest> プラグマを使っている間に、
実と実効の UID や GID の切り替えに失敗しました。

=item syntax error

=begin original

(F) Probably means you had a syntax error.  Common reasons include:

=end original

(F) おそらく、構文エラーが起こっています。
よくある原因としては以下のことが考えられます:

=begin original

    A keyword is misspelled.
    A semicolon is missing.
    A comma is missing.
    An opening or closing parenthesis is missing.
    An opening or closing brace is missing.
    A closing quote is missing.

=end original

    キーワードのスペルミス。
    セミコロンを忘れた。
    コンマを忘れた。
    開きかっこ、閉じかっこを忘れた。
    開き中かっこ、閉じ中かっこを忘れた。
    クォートの閉じ忘れ。

=begin original

Often there will be another error message associated with the syntax
error giving more information.  (Sometimes it helps to turn on B<-w>.)
The error message itself often tells you where it was in the line when
it decided to give up.  Sometimes the actual error is several tokens
before this, because Perl is good at understanding random input.
Occasionally the line number may be misleading, and once in a blue moon
the only way to figure out what's triggering the error is to call
C<perl -c> repeatedly, chopping away half the program each time to see
if the error went away.  Sort of the cybernetic version of S<20 questions>.

=end original

多くの場合、構文エラーと一緒に、別のエラーメッセージが出て、
情報を与えてくれます。(-w を付けることが、助けになることもあります。)
エラーメッセージ自身には、何行目まで行って、諦めたのかということも
含まれています。
Perl はでたらめな入力を理解するのが得意なので、実際のエラーはもう少し前に
在ることもあります。
ときには、行番号が全く役に立たないこともあり、はまってしまったなら、
エラーのきっかけが何かを見つける唯一の手段は、プログラムを寸断して、
エラーがなくなるまで、perl -c を繰り返すしかありません。
S<頭の体操 20 問>だと思ってください。

=item syntax error at line %d: '%s' unexpected

=begin original

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=end original

(A) スクリプトを perl ではなく Bourne shell で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item syntax error in file %s at line %d, next 2 tokens "%s"

=begin original

(F) This error is likely to occur if you run a perl5 script through
a perl4 interpreter, especially if the next 2 tokens are "use strict"
or "my $var" or "our $var".

=end original

(F) このエラーは、perl5 のスクリプトを perl4 インタプリタで実行したときに
おきそうなものです; 特に次の二つのトークンが "use strict" か
"my $var" か "our $var" の場合はそうです。

=item Syntax error in (?[...]) in regex; marked by <-- HERE in m/%s/

=begin original

(F) Perl could not figure out what you meant inside this construct; this
notifies you that it is giving up trying.

=end original

(F) Perl はこの構文の中で何を意味しようとしているのかが分かりませんでした;
これは試すのを諦めたことを知らせます。

=item %s syntax OK

=begin original

(F) The final summary message when a C<perl -c> succeeds.

=end original

(F) C<perl -c> が成功したときの最終まとめメッセージです。

=item sysread() on closed filehandle %s

=begin original

(W closed) You tried to read from a closed filehandle.

=end original

(W closed) 閉じたファイルハンドルから読み込もうとしました。

=item sysread() on unopened filehandle %s

=begin original

(W unopened) You tried to read from a filehandle that was never opened.

=end original

(W unopened) 開いていないファイルハンドルから読み込もうとしました。

=item System V %s is not implemented on this machine

=begin original

(F) You tried to do something with a function beginning with "sem",
"shm", or "msg" but that System V IPC is not implemented in your
machine.  In some machines the functionality can exist but be
unconfigured.  Consult your system support.

=end original

(F) 何か、名前が "sem"、"shm"、"msg" で始まる関数を実行しようとしましたが、
あなたのマシンには System V IPC が実装されていません。
機能はあっても設定されていない場合もあります。
システムサポートに相談してください。

=item syswrite() on closed filehandle %s

=begin original

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.

=end original

(W closed) 書き込みを行なおうとしたファイルハンドルは、既に閉じられています。
制御フローをチェックしてください。

=item C<-T> and C<-B> not implemented on filehandles

=begin original

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.

=end original

(F) Perl が、お使いの stdio のことをよく知らないとき、
ファイルハンドルの stdio バッファを覗くことはできません。
代わりにファイル名を使わなければなりません。

=item Target of goto is too deeply nested

=begin original

(F) You tried to use C<goto> to reach a label that was too deeply nested
for Perl to reach.  Perl is doing you a favor by refusing.

=end original

(F) C<goto> で、Perl が届かないほど深くネストしたラベルに移動しようとしました。
Perl は親切にもこれを拒否します。

=item telldir() attempted on invalid dirhandle %s

=begin original

(W io) The dirhandle you tried to telldir() is either closed or not really
a dirhandle.  Check your control flow.

=end original

(W io) telldir() しようとしたディレクトリハンドルは既に閉じられているか、
実際にはディレクトリハンドルではありません。
制御フローをチェックしてください。

=item tell() on unopened filehandle

=begin original

(W unopened) You tried to use the tell() function on a filehandle that
was either never opened or has since been closed.

=end original

(W unopened) オープンされていないファイルハンドルか、既にクローズされた
ファイルハンドルに対して、tell() 関数を使おうとしました。

=item The crypt() function is unimplemented due to excessive paranoia.

=begin original

(F) Configure couldn't find the crypt() function on your machine,
probably because your vendor didn't supply it, probably because they
think the U.S. Government thinks it's a secret, or at least that they
will continue to pretend that it is.  And if you quote me on that, I
will deny it.

=end original

(F) Configure は、マシン上で crypt() 関数を見つけられませんでした;
おそらく、ベンダからの供給がなかったからで、おそらく、ベンダは
アメリカ政府がそれを秘密だとしていると思っているか、
少なくとも思っているというふりをしているのでしょう。
私を引き合いに出したところで、それは否定されることでしょう。

=item The experimental declared_refs feature is not enabled

=begin original

(F) To declare references to variables, as in C<my \%x>, you must first enable
the feature:

=end original

(F) C<my \%x> のように、変数へのリファレンスを定義するには、
最初にこの機能を有効にしなければなりません:

    no warnings "experimental::declared_refs";
    use feature "declared_refs";

=item The %s function is unimplemented

=begin original

(F) The function indicated isn't implemented on this architecture,
according to the probings of Configure.

=end original

(F) この関数は、Configure の調査によると、このアーキテクチャでは、
実装されていないようです。

=item The private_use feature is experimental

=begin original

(S experimental::private_use) This feature is actually a hook for future
use.

=end original

(S experimental::private_use) この機能は実際には将来の使用のための
フックです。

=item The regex_sets feature is experimental

=begin original

(S experimental::regex_sets) This warning is emitted if you
use the syntax S<C<(?[   ])>> in a regular expression.
The details of this feature are subject to change.
If you want to use it, but know that in doing so you
are taking the risk of using an experimental feature which may
change in a future Perl version, you can do this to silence the
warning:

=end original

(S experimental::regex_sets) この警告は、正規表現で S<C<(?[   ])>> 構文を
使うと出力されます。
この機能の詳細は変更されることがあります。
この機能を使いたいけれども、そうすることで将来の Perl バージョンで
変更されるかもしれない実験的機能を使うリスクを取ることを分かっている場合は、
以下のようにして警告を黙らせられます:

    no warnings "experimental::regex_sets";

=item The signatures feature is experimental

=begin original

(S experimental::signatures) This warning is emitted if you unwrap a
subroutine's arguments using a signature.  Simply suppress the warning
if you want to use the feature, but know that in doing so you are taking
the risk of using an experimental feature which may change or be removed
in a future Perl version:

=end original

(S experimental::signatures) この警告は、シグネチャを使ったサブルーチンの
引数を展開するときに出力されます。
この機能を使いたいけれども、そうすることで将来の Perl バージョンで
変更されるかもしれない実験的機能を使うリスクを取ることを分かっている場合は、
単に警告を抑制してください:

    no warnings "experimental::signatures";
    use feature "signatures";
    sub foo ($left, $right) { ... }

=item The stat preceding %s wasn't an lstat

=begin original

(F) It makes no sense to test the current stat buffer for symbolic
linkhood if the last stat that wrote to the stat buffer already went
past the symlink to get to the real file.  Use an actual filename
instead.

=end original

(F) 過去の stat がシンボリックリンクを通り過ぎた、実際のファイルの
情報を取って、stat バッファに入れているときに、シンボリックタイプの
stat をカレント stat バッファに対して行なっても意味がありません。
実際のファイル名を使ってください。

=item The Unicode property wildcards feature is experimental

=begin original

(S experimental::uniprop_wildcards) This feature is experimental
and its behavior may in any future release of perl.  See
L<perlunicode/Wildcards in Property Values>.

=end original

(S experimental::uniprop_wildcards) この機能は実験的で、
その振る舞いは将来のリリースの perl で変わるかもしれません。
L<perlunicode/Wildcards in Property Values> を参照してください。

=item The 'unique' attribute may only be applied to 'our' variables

=begin original

(F) This attribute was never supported on C<my> or C<sub> declarations.

=end original

(F) この属性は C<my> や C<sub> の宣言では対応していません。

=item This Perl can't reset CRTL environ elements (%s)

=item This Perl can't set CRTL environ elements (%s=%s)

=begin original

(W internal) Warnings peculiar to VMS.  You tried to change or delete an
element of the CRTL's internal environ array, but your copy of Perl
wasn't built with a CRTL that contained the setenv() function.  You'll
need to rebuild Perl with a CRTL that does, or redefine
F<PERL_ENV_TABLES> (see L<perlvms>) so that the environ array isn't the
target of the change to
%ENV which produced the warning.

=end original

(W internal) VMS に固有の警告です。
CRTL の内部環境配列を変更または削除しようとしましたが、この Perl は
setenv() 関数を含んだ CRTL でビルドされていません。
これを含む CRTL を使って Perl を再ビルドするか、環境配列がこの警告を
出力している %ENV を変更するターゲットとならないように 
F<PERL_ENV_TABLES> (L<perlvms> を参照してください) を再定義してください。

=item This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().

=begin original

(F) Something has attempted to use an internal API call which
depends on Perl being compiled with the default support for randomized hash
key traversal, but this Perl has been compiled without it.  You should
report this warning to the relevant upstream party, or recompile perl
with default options.

=end original

(F) 何かが、Perl がデフォルトで対応しているランダム化されたハッシュキー検索に
依存した 内部 API 呼び出しを使おうとしましたが、この Perl はそれなしで
コンパイルされていました。
この警告を関係する上流グループに報告するか、デフォルトオプションで perl を
再コンパイルしてください。

=item This use of my() in false conditional is no longer allowed

=begin original

(F) You used a declaration similar to C<my $x if 0>.  There
has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional.  Some people have exploited this bug to achieve a kind of
static variable.  Since we intend to fix this bug, we don't want people
relying on this behavior.  You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg

=end original

(F) C<my $x if 0> のような千眼を使いました。
宣言が偽の条件のとき、スコープを抜けてもレキシカル変数がクリアされないという
長年のバグが Perl にはありました。
一部の人々は、ある種の静的変数を実現するためにこのバグを悪用してきました。
私たちはこのバグを修正したいので、人々にこの振る舞いに
依存してほしくありません。
関数の外側の独立したブロックで変数を宣言することで、同様の静的な効果を
得られます; 例えば:

    sub f { my $x if 0; return $x++ }

=begin original

becomes

=end original

これは次のようになります:

    { my $x; sub f { return $x++ } }

=begin original

Beginning with perl 5.10.0, you can also use C<state> variables to have
lexicals that are initialized only once (see L<feature>):

=end original

perl 5.10.0 から、一度だけ初期化されるレキシカル変数のために
C<state> 変数を使うこともできます (L<feature> を参照してください):

    sub f { state $x; return $x++ }

=begin original

This use of C<my()> in a false conditional was deprecated beginning in
Perl 5.10 and became a fatal error in Perl 5.30.

=end original

偽の条件での C<my()> のこの使用法は Perl 5.10 から廃止予定になり、
Perl 5.30 で致命的エラーになりました。

=item times not implemented

=begin original

(F) Your version of the C library apparently doesn't do times().  I
suspect you're not running on Unix.

=end original

(F) お使いの C ライブラリでは、times() を行わないようです。
UNIX ではない環境でしょうか。

=item "-T" is on the #! line, it must also be used on the command line

=begin original

(X) The #! line (or local equivalent) in a Perl script contains
the B<-T> option (or the B<-t> option), but Perl was not invoked with
B<-T> in its command line.  This is an error because, by the time
Perl discovers a B<-T> in a script, it's too late to properly taint
everything from the environment.  So Perl gives up.

=end original

(X) Perl スクリプトの #! 行(あるいはローカルで等価なもの)に B<-T>
オプション (または B<-t> オプション) が含まれていますが、Perl は
コマンドラインで B<-T> 付きで起動されていません。
Perl がスクリプトの中で B<-T> を発見した時点では、環境からの全てを
汚染チェックするには遅すぎるので、これはエラーになります。
それで Perl は諦めます。

=begin original

If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be
fixed by editing the #! line so that the B<-%c> option is a part of
Perl's first argument: e.g. change C<perl -n -%c> to C<perl -%c -n>.

=end original

perl スクリプトが #! 機構(またはローカルな等価な機構)を使ってコマンドとして
実行される場合、このエラーは普通 B<-%c> オプションを Perl の最初の引数に
変更する(C<perl -n -%c> を C<perl -%c -n> に変更する)ことで修正されます。

=begin original

If the Perl script is being executed as C<perl scriptname>, then the
B<-%c> option must appear on the command line: C<perl -%c scriptname>.

=end original

Perl スクリプトが C<perl scriptname> として起動される場合、B<-T> オプションは
コマンドラインに書かなければなりません: C<perl -%c scriptname>

=item To%s: illegal mapping '%s'

=begin original

(F) You tried to define a customized To-mapping for lc(), lcfirst,
uc(), or ucfirst() (or their string-inlined versions), but you
specified an illegal mapping.
See L<perlunicode/"User-Defined Character Properties">.

=end original

(F) lc(), lcfirst, uc(), or ucfirst() (またはこれらの文字列組み込み版)の
ためのカスタマイズされた変換先マッピングを定義しようとしましたが、
不正なマッピングを指定しました。
L<perlunicode/"User-Defined Character Properties"> を参照してください。

=item Too deeply nested ()-groups

=begin original

(F) Your template contains ()-groups with a ridiculously deep nesting level.

=end original

(F) テンプレートに、おかしいぐらいネストした () グループがあります。

=item Too few args to syscall

=begin original

(F) There has to be at least one argument to syscall() to specify the
system call to call, silly dilly.

=end original

(F) syscall() には、最低限でも呼び出すシステムコールを示す、
引数が一つ必要です。

=item Too few arguments for subroutine '%s'

=begin original

(F) A subroutine using a signature fewer arguments than required by the
signature.  The caller of the subroutine is presumably at fault.

=end original

(F) シグネチャを使っているサブルーチンが、シグネチャが要求しているよりも
少ない引数を受け取りました。
おそらくサブルーチンの呼び出し元が間違っています。

=begin original

The message attempts to include the name of the called subroutine.  If
the subroutine has been aliased, the subroutine's original name will be
shown, regardless of what name the caller used.

=end original

このメッセージは呼び出されたサブルーチン名を含めようとします。
サブルーチンが別名化されている場合、どの名前で呼びされたかにかかわらず
サブルーチンの元の名前が表示されます。

=item Too late for "-%s" option

=begin original

(X) The #! line (or local equivalent) in a Perl script contains the
B<-M>, B<-m> or B<-C> option.

=end original

(X) Perl スクリプトの #! 行(またはローカルな等価な機構)に B<-M>, B<-m>,
B<-C> オプションが含まれています。

=begin original

In the case of B<-M> and B<-m>, this is an error because those options
are not intended for use inside scripts.  Use the C<use> pragma instead.

=end original

B<-M> と B<-m> に関しては、スクリプト内部で使うためのものではないので、
これはエラーになります。
代わりに C<use> プラグマを使ってください。

=begin original

The B<-C> option only works if it is specified on the command line as
well (with the same sequence of letters or numbers following).  Either
specify this option on the command line, or, if your system supports
it, make your script executable and run it directly instead of passing
it to perl.

=end original

B<-C> オプションは、コマンドラインも (以下と同じ文字と数値の並びで)
指定されたときにのみ動作します。
このオプションをコマンドラインで指定するか、もしシステムが対応しているなら、
スクリプトを perl に渡すのではなく、スクリプトを実行可能にして
直接実行してください。

=item Too late to run %s block

=begin original

(W void) A CHECK or INIT block is being defined during run time proper,
when the opportunity to run them has already passed.  Perhaps you are
loading a file with C<require> or C<do> when you should be using C<use>
instead.  Or perhaps you should put the C<require> or C<do> inside a
BEGIN block.

=end original

(W void) CHECK か INIT のブロックが、それが実行される機会が過ぎてから
実行時に定義されました。
おそらく C<use> を使うべきときに C<require> か C<do> を使ってファイルを
読み込んでいます。
あるいはおそらく BEGIN ブロックの中に C<require> か C<do> を
書いたのでしょう。

=item Too many args to syscall

=begin original

(F) Perl supports a maximum of only 14 args to syscall().

=end original

(F) Perl では、syscall() に最大 14 までしか、引数を渡すことができません。

=item Too many arguments for %s

=begin original

(F) The function requires fewer arguments than you specified.

=end original

(F) 関数が要求する以上の引数を指定しました。

=item Too many arguments for subroutine '%s'

=begin original

(F) A subroutine using a signature received more arguments than permitted
by the signature.  The caller of the subroutine is presumably at fault.

=end original

(F) シグネチャを使っているサブルーチンが、シグネチャで許されているよりも
多い引数を受け取りました。
おそらくサブルーチンの呼び出し元が間違っています。

=begin original

The message attempts to include the name of the called subroutine. If the
subroutine has been aliased, the subroutine's original name will be shown,
regardless of what name the caller used.

=end original

メッセージには呼び出されたサブルーチンの名前を含めようとします。
サブルーチンに別名がある場合、どの名前で呼び出されたかに関わらず、
元の名前が表示されます。

=item Too many nested open parens in regex; marked by <-- HERE in m/%s/

=begin original

(F) You have exceeded the number of open C<"("> parentheses that haven't
been matched by corresponding closing ones.  This limit prevents eating
up too much memory.  It is initially set to 1000, but may be changed by
setting C<${^RE_COMPILE_RECURSION_LIMIT}> to some other value.  This may
need to be done in a BEGIN block before the regular expression pattern
is compiled.

=end original

(F) 対応する閉じかっこのない開き C<"("> かっこの数が制限を超えました。
この制限は、あまりに多くのメモリを食べ尽くすことを防ぎます。
これは 1000 に初期化されていますが、
C<${^RE_COMPILE_RECURSION_LIMIT}> に他の値を設定することで変更されます。
これは正規表現パターンがコンパイルされる前に BEGIN ブロックの中で
行われる必要があります。

=item Too many )'s

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Too many ('s

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Trailing \ in regex m/%s/

=begin original

(F) The regular expression ends with an unbackslashed backslash.
Backslash it.   See L<perlre>.

=end original

(F) 正規表現が、バックスラッシュを付けていないバックスラッシュで
終了しました。バックスラッシュを付けてください。
L<perlre> を参照してください。

=item Transliteration pattern not terminated

=begin original

(F) The lexer couldn't find the interior delimiter of a tr/// or tr[][]
or y/// or y[][] construct.  Missing the leading C<$> from variables
C<$tr> or C<$y> may cause this error.

=end original

(F) tr///, tr[][], y///, y[][] 構文の真ん中の区切り文字が
見つかりませんでした。
C<$tr> 変数 や C<$y> 変数の前に C<$> をつけるのを忘れると
このエラーが出ることがあります。

=item Transliteration replacement not terminated

=begin original

(F) The lexer couldn't find the final delimiter of a tr///, tr[][],
y/// or y[][] construct.

=end original

(F) tr///, tr[][], y///, y[][] 構文の最後の区切り文字が
見つかりませんでした。

=item '%s' trapped by operation mask

=begin original

(F) You tried to use an operator from a Safe compartment in which it's
disallowed.  See L<Safe>.

=end original

(F) Safe 区画の中で、許されていない演算子を使おうとしました。
L<Safe> を参照してください。

=item truncate not implemented

=begin original

(F) Your machine doesn't implement a file truncation mechanism that
Configure knows about.

=end original

(F) このマシンでは、Configure が知りうる、ファイルの切り詰めの機能が
実装されていません。

=item Type of arg %d to &CORE::%s must be %s

=begin original

(F) The subroutine in question in the CORE package requires its argument
to be a hard reference to data of the specified type.  Overloading is
ignored, so a reference to an object that is not the specified type, but
nonetheless has overloading to handle it, will still not be accepted.

=end original

(F) CORE パッケージにある問題のサブルーチンは、引数に特定の型のデータへの
ハードリファレンスを要求しています。
オーバーロードは無視されるので、指定された型ではないけれども、それを
扱えるようにオーバーロードされたオブジェクトへのリファレンスでも
受け付けられません。

=item Type of arg %d to %s must be %s (not %s)

=begin original

(F) This function requires the argument in that position to be of a
certain type.  Arrays must be @NAME or C<@{EXPR}>.  Hashes must be
%NAME or C<%{EXPR}>.  No implicit dereferencing is allowed--use the
{EXPR} forms as an explicit dereference.  See L<perlref>.

=end original

(F) この関数は、その位置に決まった型の引数を必要とします。
配列は、@NAME もしくは C<@{EXPR}> でなりません。
ハッシュは、%NAME もしくは C<%{EXPR}> でなければなりません。
暗黙の被参照は許されませんので、明示的な被参照として、
{EXPR} 形式を使ってください。
L<perlref> を参照してください。

=item umask not implemented

=begin original

(F) Your machine doesn't implement the umask function and you tried to
use it to restrict permissions for yourself (EXPR & 0700).

=end original

(F) umask 関数が実装されていないマシンで、自分自身の権限を制限する
(EXPR & 0700) ためにこれを使おうとしました。

=item Unbalanced context: %d more PUSHes than POPs

=begin original

(S internal) The exit code detected an internal inconsistency in how
many execution contexts were entered and left.

=end original

(S internal) いくつの実行コンテキストに入って、出たかということの
内部矛盾が exit コードで発見されました。

=item Unbalanced saves: %d more saves than restores

=begin original

(S internal) The exit code detected an internal inconsistency in how
many values were temporarily localized.

=end original

(S internal) いくつの値が、一時的にローカル化されたかということの
内部矛盾が exit コードで発見されました。

=item Unbalanced scopes: %d more ENTERs than LEAVEs

=begin original

(S internal) The exit code detected an internal inconsistency in how
many blocks were entered and left.

=end original

(S internal) いくつのブロックに入って、出たかということの
内部矛盾が exit コードで発見されました。

=item Unbalanced string table refcount: (%d) for "%s"

=begin original

(S internal) On exit, Perl found some strings remaining in the shared
string table used for copy on write and for hash keys.  The entries
should have been freed, so this indicates a bug somewhere.

=end original

(S internal) 終了時に、ハッシュキーのためのコピーオンライトのための
共有文字列テーブルに文字列が残っていることを Perl が発見しました。
エントリは開放されている必要があるので、これはどこかにバグがあることを
示しています。

=item Unbalanced tmps: %d more allocs than frees

=begin original

(S internal) The exit code detected an internal inconsistency in how
many mortal scalars were allocated and freed.

=end original

(S internal) いくつの揮発性スカラの割り当てを行ない、解放したかと
いうことの内部矛盾が exit コードで発見されました。

=item Undefined format "%s" called

=begin original

(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See L<perlform>.

=end original

(F) 示されたフォーマットが存在しないようです。
おそらく本当は他のパッケージにあるのでは?
L<perlform> を参照してください。

=item Undefined sort subroutine "%s" called

=begin original

(F) The sort comparison routine specified doesn't seem to exist.
Perhaps it's in a different package?  See L<perlfunc/sort>.

=end original

(F) 指定された sort の比較ルーティンは存在していないように思われます。
おそらく、別のパッケージに存在するのではないでしょうか。
L<perlfunc/sort> を参照してください。

=item Undefined subroutine &%s called

=begin original

(F) The subroutine indicated hasn't been defined, or if it was, it has
since been undefined.

=end original

(F) 指定されたサブルーチンが定義されていません; 定義されていたとしても、
既に未定義になっています。

=item Undefined subroutine called

=begin original

(F) The anonymous subroutine you're trying to call hasn't been defined,
or if it was, it has since been undefined.

=end original

(F) 呼びだそうとしている無名のサブルーチンは、定義されていません;
定義されていたとしても、既に未定義になっています。

=item Undefined subroutine in sort

=begin original

(F) The sort comparison routine specified is declared but doesn't seem
to have been defined yet.  See L<perlfunc/sort>.

=end original

(F) 指定された sort の比較ルーティンは宣言されましたが、
定義されていないようです。
L<perlfunc/sort> を参照してください。

=item Undefined top format "%s" called

=begin original

(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See L<perlform>.

=end original

(F) 示されたフォーマットが存在しないようです。
おそらく本当は他のパッケージにあるのでは?
L<perlform> を参照してください。

=item Undefined value assigned to typeglob

=begin original

(W misc) An undefined value was assigned to a typeglob, a la
C<*foo = undef>.  This does nothing.  It's possible that you really mean
C<undef *foo>.

=end original

(W misc) C<*foo = undef> のように、未定義値を型グロブに代入しました。
これは何もしません。
本当は C<undef *foo> としたかったのかもしれません。

=item %s: Undefined variable

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Unescaped left brace in regex is illegal here in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) The simple rule to remember, if you want to
match a literal C<"{"> character (U+007B C<LEFT CURLY BRACKET>) in a
regular expression pattern, is to escape each literal instance of it in
some way.  Generally easiest is to precede it with a backslash, like
C<"\{"> or enclose it in square brackets (C<"[{]">).  If the pattern
delimiters are also braces, any matching right brace (C<"}">) should
also be escaped to avoid confusing the parser, for example,

=end original

(F) 正規表現中で
リテラルな C<"{"> 文字 (U+007B C<LEFT CURLY BRACKET>) にマッチングしたいときに
覚えておくべき単純な規則は、何らかの方法で
それぞれのリテラルな実体をエスケープすることです。
一般的に一番簡単なのは、C<"\{"> のように逆スラッシュを前置するか、
かっこでかこむ (C<"[{]">) ことです。. 
パターン区切り文字も中かっこの場合、マッチングする右中かっこ
(C<"}">) も、パーサーの混乱を避けるためにエスケープするべきです; 例えば:

 qr{abc\{def\}ghi}

=begin original

Forcing literal C<"{"> characters to be escaped enables the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use there of C<"{"> as a literal.  Those that are
not potentially ambiguous do not warn; those that are do raise a
non-deprecation warning.

=end original

リテラルな C<"{"> 文字にエスケープを強制することにより、
将来のリリースで様々な方法で Perl 言語を拡張できるようになります。
既存のコードを不必要に壊すことを避けるために、
拡張が C<"{"> をリテラルとして使うことと競合しそうにない文脈では
制限は強制されません。
潜在的にあいまいでないものは警告されません; あいまいなものは
廃止予定でない警告が発生します。

=begin original

The contexts where no warnings or errors are raised are:

=end original

警告やエラーが出ない文脈は:

=over 4

=item *

=begin original

as the first character in a pattern, or following C<"^"> indicating to
anchor the match to the beginning of a line.

=end original

パターンの最初の文字、あるいは行頭にマッチングすることを示す
C<"^"> に引き続いている場合。

=item *

=begin original

as the first character following a C<"|"> indicating alternation.

=end original

代替を示す C<"|"> に引き続く最初の文字の場合。

=item *

=begin original

as the first character in a parenthesized grouping like

=end original

次のようなかっこ付きグループの最初の文字の場合:

 /foo({bar)/
 /foo(?:{bar)/

=item *

=begin original

as the first character following a quantifier

=end original

量指定子に引き続く最初の文字の場合

 /\s*{/

=back

=for comment
The text of the message above is mostly duplicated below (with changes)
to allow splain (and 'use diagnostics') to work.  Since one is fatal,
and one not, they can't be combined as one message.  Perhaps perldiag
could be enhanced to handle this case.

=item Unescaped left brace in regex is passed through in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp)  The simple rule to remember, if you want to
match a literal C<"{"> character (U+007B C<LEFT CURLY BRACKET>) in a
regular expression pattern, is to escape each literal instance of it in
some way.  Generally easiest is to precede it with a backslash, like
C<"\{"> or enclose it in square brackets (C<"[{]">).  If the pattern
delimiters are also braces, any matching right brace (C<"}">) should
also be escaped to avoid confusing the parser, for example,

=end original

(W regexp) 正規表現中で
リテラルな C<"{"> 文字 (U+007B C<LEFT CURLY BRACKET>) にマッチングしたいときに
覚えておくべき単純な規則は、何らかの方法で
それぞれのリテラルな実体をエスケープすることです。
一般的に一番簡単なのは、C<"\{"> のように逆スラッシュを前置するか、
かっこでかこむ (C<"[{]">) ことです。. 
パターン区切り文字も中かっこの場合、マッチングする右中かっこ
(C<"}">) も、パーサーの混乱を避けるためにエスケープするべきです; 例えば:

 qr{abc\{def\}ghi}

=begin original

Forcing literal C<"{"> characters to be escaped enables the Perl
language to be extended in various ways in future releases.  To avoid
needlessly breaking existing code, the restriction is not enforced in
contexts where there are unlikely to ever be extensions that could
conflict with the use there of C<"{"> as a literal.  Those that are
not potentially ambiguous do not warn; those that are raise this
warning.  This makes sure that an inadvertent typo doesn't silently
cause the pattern to compile to something unintended.

=end original

リテラルな C<"{"> 文字にエスケープを強制することにより、
将来のリリースで様々な方法で Perl 言語を拡張できるようになります。
既存のコードを不必要に壊すことを避けるために、
拡張が C<"{"> をリテラルとして使うことと競合しそうにない文脈では
制限は強制されません。
潜在的にあいまいでないものは警告されません; あいまいなものは
この警告が発生します。
これは、不注意によるタイプミスによって、パターンが何か想定外のものに
黙ってコンパイルされないことを確実にします。

=begin original

The contexts where no warnings or errors are raised are:

=end original

警告やエラーが出ない文脈は:

=over 4

=item *

=begin original

as the first character in a pattern, or following C<"^"> indicating to
anchor the match to the beginning of a line.

=end original

パターンの最初の文字、あるいは行頭にマッチングすることを示す
C<"^"> に引き続いている場合。

=item *

=begin original

as the first character following a C<"|"> indicating alternation.

=end original

代替を示す C<"|"> に引き続く最初の文字の場合。

=item *

=begin original

as the first character in a parenthesized grouping like

=end original

次のようなかっこ付きグループの最初の文字の場合:

 /foo({bar)/
 /foo(?:{bar)/

=item *

=begin original

as the first character following a quantifier

=end original

量指定子に引き続く最初の文字の場合

 /\s*{/

=back

=item Unescaped literal '%c' in regex; marked by <-- HERE in m/%s/

=begin original

(W regexp) (only under C<S<use re 'strict'>>)

=end original

(W regexp) (C<S<use re 'strict'>> の下のみ)

=begin original

Within the scope of C<S<use re 'strict'>> in a regular expression
pattern, you included an unescaped C<}> or C<]> which was interpreted
literally.  These two characters are sometimes metacharacters, and
sometimes literals, depending on what precedes them in the
pattern.  This is unlike the similar C<)> which is always a
metacharacter unless escaped.

=end original

C<S<use re 'strict'>> スコープでの正規表現パターンの中で、
リテラルとして解釈される、エスケープされない C<}> や C<]> を置きました。
これらの二つの文字は時にはメタ文字で、ときにはリテラルです;
パターン中で何が前に置かれるかによります。
これは、エスケープされない限り常にメタ文字である C<)> に似ていますが
異なります。

=begin original

This action at a distance, perhaps a large distance, can lead to Perl
silently misinterpreting what you meant, so when you specify that you
want extra checking by C<S<use re 'strict'>>, this warning is generated.
If you meant the character as a literal, simply confirm that to Perl by
preceding the character with a backslash, or make it into a bracketed
character class (like C<[}]>).  If you meant it as closing a
corresponding C<[> or C<{>, you'll need to look back through the pattern
to find out why that isn't happening.

=end original

遠くで、おそらくはとても遠くでこの動作をすると、Perl は暗黙のままで
あなたの意図を間違って解釈するかもしれないので、
C<S<use re 'strict'>> で追加のチェックを求めるように指定すると、
この警告が出力されます。
この文字がリテラルであるなら、文字の前に逆スラッシュを置くか、
(C<[}]> のように)大かっこ文字クラスの中に入れることで、Perl に
はっきりさせてください。
これが対応する C<[> や C<{> を閉じるものなら、
なぜそれが起きないかを見つけるためにパターン全体を見直してください。

=item unexec of %s into %s failed!

=begin original

(F) The unexec() routine failed for some reason.  See your local FSF
representative, who probably put it there in the first place.

=end original

(F) unexec() ルーティンが何らかの理由によって失敗しました。
最初にインストールしたであろう、サイトの FSF 代表者にたずねてみてください。

=item Unexpected binary operator '%c' with no preceding operand in regex;
marked by S<<-- HERE> in m/%s/

=begin original

(F) You had something like this:

=end original

(F) 以下のようなものを書きました:

 (?[ | \p{Digit} ])

=begin original

where the C<"|"> is a binary operator with an operand on the right, but
no operand on the left.

=end original

ここで C<"|"> は右側にはオペランドがありますが、左側にはオペランドがない
2 項演算子です。

=item Unexpected character in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You had something like this:

=end original

(F) 以下のようなものを書きました:

 (?[ z ])

=begin original

Within C<(?[ ])>, no literal characters are allowed unless they are
within an inner pair of square brackets, like

=end original

C<(?[ ])> の中では、次のようにさらに内側の大かっこの内側でない限り
リテラル文字は許されません

 (?[ [ z ] ])

=begin original

Another possibility is that you forgot a backslash.  Perl isn't smart
enough to figure out what you really meant.

=end original

もう一つの可能性は、逆スラッシュを忘れたことです。
Perl はあなたが何を意味しているのかを見つけ出せるほど賢くはありませんでした。

=item Unexpected constant lvalue entersub entry via type/targ %d:%d

=begin original

(P) When compiling a subroutine call in lvalue context, Perl failed an
internal consistency check.  It encountered a malformed op tree.

=end original

(P) 左辺値コンテキストでのサブルーチン呼び出しをコンパイルするときに、Perl は
内部一貫性チェックに失敗しました。
不正な構文木に遭遇しました。

=item Unexpected exit %u

=begin original

(S) exit() was called or the script otherwise finished gracefully when
C<PERL_EXIT_WARN> was set in C<PL_exit_flags>.

=end original

(S) C<PL_exit_flags> に C<PERL_EXIT_WARN> が設定されているときに exit() が
呼び出されたりその他の理由で通常終了しました。

=item Unexpected exit failure %d

=begin original

(S) An uncaught die() was called when C<PERL_EXIT_WARN> was set in
C<PL_exit_flags>.

=end original

(S) C<PL_exit_flags> に C<PERL_EXIT_WARN> が設定されているときに
捕らえられていない die() が呼び出されました。

=item Unexpected ')' in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You had something like this:

=end original

(F) 以下のようなものを書きました:

 (?[ ( \p{Digit} + ) ])

=begin original

The C<")"> is out-of-place.  Something apparently was supposed to
be combined with the digits, or the C<"+"> shouldn't be there, or
something like that.  Perl can't figure out what was intended.

=end original

C<")"> の場所がおかしいです。
何かを数値と結合しようとしていたのか、C<"+"> があるべきでないのか、あるいは
似たような何かです。
Perl は何を意図しているのかが分かりませんでした。

=item Unexpected ']' with no following ')' in (?[... in regex; marked by
<-- HERE in m/%s/

=begin original

(F) While parsing an extended character class a ']' character was
encountered at a point in the definition where the only legal use of
']' is to close the character class definition as part of a '])', you
may have forgotten the close paren, or otherwise confused the parser.

=end original

(F) 拡張文字クラスのパース中、'])' の一部として文字クラス定義を
閉じることが唯一の有効な ']' の使い方である位置で ']' に遭遇しました;
閉じかっこを忘れているか、さもなければパーサが混乱しています。

=item Unexpected '(' with no preceding operator in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) You had something like this:

=end original

(F) 以下のようなものを書きました:

 (?[ \p{Digit} ( \p{Lao} + \p{Thai} ) ])

=begin original

There should be an operator before the C<"(">, as there's
no indication as to how the digits are to be combined
with the characters in the Lao and Thai scripts.

=end original

これらは C<"("> の前の演算子であるべきです; ラオ語やタイ語で数字とこれらの
文字がどのように結びつくかの指示がないからです。

=item Unicode non-character U+%X is not recommended for open interchange

=begin original

(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are
defined by the Unicode standard to be non-characters.  Those
are legal codepoints, but are reserved for internal use; so,
applications shouldn't attempt to exchange them.  An application
may not be expecting any of these characters at all, and receiving
them may lead to bugs.  If you know what you are doing you can
turn off this warning by C<no warnings 'nonchar';>.

=end original

(S nonchar) U+FFFE や U+FFFF のようないくつかの符号位置は
Unicode 標準によって非文字として指定されています。
これらは有効な符号位置ですが、内部使用のために予約されています; 従って、
アプリケーションはこれを交換しようとするべきではありません。
アプリケーションは、これらの文字を想定するべきではなく、これらを
受け取るとバグを引き起こすことがあります。
もし自分が何をしているかを理解しているなら、C<no warnings 'nonchar';> で
警告を無効にできます。

=begin original

This is not really a "severe" error, but it is supposed to be
raised by default even if warnings are not enabled, and currently
the only way to do that in Perl is to mark it as serious.

=end original

これは実際には「重大な」エラーではありませんが、例え警告が有効でなくても
デフォルトで発生させることになっていて、今のところ Perl で出来る唯一のことは
これを重大なものとして扱うことです。

=item Unicode property wildcard not terminated

=begin original

(F) A Unicode property wildcard looks like a delimited regular
expression pattern (all within the braces of the enclosing C<\p{...}>.
The closing delimtter to match the opening one was not found.  If the
opening one is escaped by preceding it with a backslash, the closing one
must also be so escaped.

=end original

(F) Unicode 特性ワイルドカードは区切られた正規表現パターン
(C<\p{...}> を囲む中かっこの中に全てがある) のように見えます。
開き区切り文字に対応する閉じ区切り文字が見つかりませんでした。
前に逆スラッシュを置くことで開き文字がエスケープされている場合、
閉じ文字もエスケープされていなければなりません。

=item Unicode string properties are not implemented in (?[...]) in
regex; marked by <-- HERE in m/%s/

=begin original

(F) A Unicode string property is one which expands to a sequence of
multiple characters.  An example is C<\p{name=KATAKANA LETTER AINU P}>,
which is comprised of the sequence C<\N{KATAKANA LETTER SMALL H}>
followed by C<\N{COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK}>.
Extended character classes, C<(?[...])> currently cannot handle these.

=end original

(F) A Unicode 文字列特性は、複数の文字の並びに拡張するものです。
例は C<\p{name=KATAKANA LETTER AINU P}> で、これは
C<\N{KATAKANA LETTER SMALL H}> に
C<\N{COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK}> が引き続く
並びからなります。
拡張文字クラス C<(?[...])> は現在の所これらを扱えません。

=item Unicode surrogate U+%X is illegal in UTF-8

=begin original

(S surrogate) You had a UTF-16 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by C<no warnings 'surrogate';>.

=end original

(S surrogate) 受け付けられないと考えられる場所に UTF-16 サロゲートを
使いました。
これらの符号位置、U+D800 から U+DFFF (両端含む) は UTF-16 のためだけに
Unicode によって使われます。
しかし Perl は、サロゲートを含む、内部で全ての符号なし整数の符号位置(最大値は
プラットフォームで利用可能なサイズ上限)を受け付けます。
しかし、これらは入力や出力になるときに問題を引き起こします;  それは
おそらくこのメッセージが出た場所です。
自分で何をしているのかが本当に本当に分かっているなら、
C<no warnings 'surrogate';> とすることでこの警告をオフにできます。

=item Unknown charname '%s'

=begin original

(F) The name you used inside C<\N{}> is unknown to Perl.  Check the
spelling.  You can say C<use charnames ":loose"> to not have to be
so precise about spaces, hyphens, and capitalization on standard Unicode
names.  (Any custom aliases that have been created must be specified
exactly, regardless of whether C<:loose> is used or not.)  This error may
also happen if the C<\N{}> is not in the scope of the corresponding
C<S<use charnames>>.

=end original

(F) C<\N{}> の内側で使った名前は Perl が知らないものでした。
綴りをチェックしてください。
C<use charnames ":loose"> と指定することで、標準 Unicode 名の空白、ハイフン、
大文字小文字についてはそれほど正確でなくてもいいようになります。
(作成されたカスタム別名は、C<:loose> のありなしに関わらず正確に
指定されなければなりません。)
このエラーは、C<\N{}> が、対応する C<S<use charnames>> のスコープ内に
ないときにも起こることがあります。

=item Unknown '(*...)' construct '%s' in regex; marked by <-- HERE in m/%s/

=begin original

(F) The C<(*> was followed by something that the regular expression
compiler does not recognize.  Check your spelling.

=end original

(F) C<(*> に、何か正規表現コンパイラが理解できないものが
引き続いていました。
綴りをチェックしてください。

=item Unknown error

=begin original

(P) Perl was about to print an error message in C<$@>, but the C<$@> variable
did not exist, even after an attempt to create it.

=end original

(P) Perl は C<$@> のエラーメッセージを表示しようとしましたが、C<$@> 変数が
(たとえ作ろうとした後でも) 存在しませんでした。

=item Unknown locale category %d; can't set it to %s

=begin original

(W locale) You used a locale category that perl doesn't recognize, so it
cannot carry out your request.  Check that you are using a valid
category.  If so, see L<perllocale/Multi-threaded> for advice on
reporting this as a bug, and for modifying perl locally to accommodate
your needs.

=end original

(W locale) perl が認識できないロケールカテゴリを使ったので、
要求を実行することができません。
正しいカテゴリを使っているかチェックしてください。
もしそうなら、これをバグとして報告する助言や、必要性に対応するために
perl をローカルで修正する方法について L<perllocale/Multi-threaded> を
参照してください。

=item Unknown open() mode '%s'

=begin original

(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>.

=end original

(F) 3 引数 open() の 第 2 引数が以下の有効なモードの
どれでもありませんでした:
C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->, C<< <& >>, C<< >& >>

=item Unknown PerlIO layer "%s"

=begin original

(W layer) An attempt was made to push an unknown layer onto the Perl I/O
system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as C<mmap>,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.

=end original

(W layer) 不明な層をPerl I/O システムに追加しようとしました。
(層はデータの外部表現と内部表現の変換を扱います。)
C<mmap> のような層は、全ての環境で対応しているわけではないことに
注意してください。
明示的に失敗する操作を要求していないのであれば、これは環境変数 PERLIO の
値が原因かもしれません。

=item Unknown process %x sent message to prime_env_iter: %s

=begin original

(P) An error peculiar to VMS.  Perl was reading values for %ENV before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.

=end original

(P) VMS に固有のエラーです。
Perl は %ENV を反復する前に %ENV から値を読み込み、Perl が想定している
データストリームの中に誰かがメッセージを差し込みました。
誰かはとても混乱しているか、邪悪な目的のために %ENV の Perl の集団を
滅亡させようとしています。

=item Unknown regexp modifier "/%s"

=begin original

(F) Alphanumerics immediately following the closing delimiter
of a regular expression pattern are interpreted by Perl as modifier
flags for the regex.  One of the ones you specified is invalid.  One way
this can happen is if you didn't put in white space between the end of
the regex and a following alphanumeric operator:

=end original

(F) 正規表現で、閉じデリミタの直後の英数字は Perl によって正規表現への
修飾子フラグと解釈されます。
その一つが不正でした。
これが起きる一つの可能性は、正規表現の終わりと引き続く英数字演算子の間に
空白を置いていない場合です:

 if ($a =~ /foo/and $bar == 3) { ... }

=begin original

The C<"a"> is a valid modifier flag, but the C<"n"> is not, and raises
this error.  Likely what was meant instead was:

=end original

C<"a"> は正当な修飾子フラグですが、C<"n"> は違うので、このエラーが起こります。
おそらくしたかったのは以下のようなことでしょう:

 if ($a =~ /foo/ and $bar == 3) { ... }

=item Unknown "re" subpragma '%s' (known ones are: %s)

=begin original

(W) You tried to use an unknown subpragma of the "re" pragma.

=end original

(W) "re" プラグマの、不明なサブプラグマを使おうとしました。

=item Unknown switch condition (?(...)) in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) The condition part of a (?(condition)if-clause|else-clause) construct
is not known.  The condition must be one of the following:

=end original

(?(...)if-clause|else-clause) 構造の条件部が不明です。
条件は以下のいずれかでなければなりません。

 (1) (2) ...            true if 1st, 2nd, etc., capture matched
 (<NAME>) ('NAME')      true if named capture matched
 (?=...) (?<=...)       true if subpattern matches
 (*pla:...) (*plb:...)  true if subpattern matches; also
                             (*positive_lookahead:...)
                             (*positive_lookbehind:...)
 (*nla:...) (*nlb:...)  true if subpattern fails to match; also
                             (*negative_lookahead:...)
                             (*negative_lookbehind:...)
 (?{ CODE })            true if code returns a true value
 (R)                    true if evaluating inside recursion
 (R1) (R2) ...          true if directly inside capture group 1, 2,
                             etc.
 (R&NAME)               true if directly inside named capture
 (DEFINE)               always false; for defining named subpatterns

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Unknown Unicode option letter '%c'

=begin original

(F) You specified an unknown Unicode option.  See
L<perlrun|perlrun/-C [numberE<sol>list]> documentation of the C<-C> switch
for the list of known options.

=end original

(F) 不明な Unicode オプションを指定しました。
オプションの一覧については、L<perlrun|perlrun/-C [numberE<sol>list]> 文書の
C<-C> オプションを参照してください。

=item Unknown Unicode option value %d

=begin original

(F) You specified an unknown Unicode option.  See
L<perlrun|perlrun/-C [numberE<sol>list]> documentation of the C<-C> switch
for the list of known options.

=end original

(F) 不明な Unicode オプションを指定しました。
オプションの一覧については、L<perlrun|perlrun/-C [numberE<sol>list]> 文書の
C<-C> オプションを参照してください。

=item Unknown verb pattern '%s' in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You either made a typo or have incorrectly put a C<*> quantifier
after an open brace in your pattern.  Check the pattern and review
L<perlre> for details on legal verb patterns.

=end original

(F) タイプミスをしたか、間違ってパターン中の開き大かっこの後に
C<*> 量指定子を書いたかどちらかです。
パターンをチェックして、有効な動詞パターンの詳細については
L<perlre> を再チェックしてください。

=item Unknown warnings category '%s'

=begin original

(F) An error issued by the C<warnings> pragma.  You specified a warnings
category that is unknown to perl at this point.

=end original

(F) C<warnings> プラグマによるエラーです。
現在のところ perl が知らない警告カテゴリを指定しました。

=begin original

Note that if you want to enable a warnings category registered by a
module (e.g. C<use warnings 'File::Find'>), you must have loaded this
module first.

=end original

(C<use warnings 'File::Find'> のように)モジュールによって登録される
警告カテゴリを有効にしたい場合、このモジュールを先に読み込む必要が
あることに注意してください。

=item Unmatched [ in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) The brackets around a character class must match.  If you wish to
include a closing bracket in a character class, backslash it or put it
first.  The S<<-- HERE> shows whereabouts in the regular expression the
problem was discovered.  See L<perlre>.

=end original

(F) 文字クラスの周りの大かっこが一致していません。
文字クラスに閉じ大かっこを含めたい場合は、バックスラッシュをつけるか
先頭に置いてください。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Unmatched ( in regex; marked by S<<-- HERE> in m/%s/

=item Unmatched ) in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) Unbackslashed parentheses must always be balanced in regular
expressions.  If you're a vi user, the % key is valuable for finding
the matching parenthesis.  The S<<-- HERE> shows whereabouts in the
regular expression the problem was discovered.  See L<perlre>.

=end original

(F) 正規表現の中ではバックスラッシュのついていないかっこは常に
対応していなければなりません。
vi ユーザーであれば、% キーが対応するかっこの発見に有用です。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Unmatched right %s bracket

=begin original

(F) The lexer counted more closing curly or square brackets than opening
ones, so you're probably missing a matching opening bracket.  As a
general rule, you'll find the missing one (so to speak) near the place
you were last editing.

=end original

(F) 文法解析器が、閉じ中かっこや大かっこが開きかっこよりも多いことを
見つけました; おそらく対応する開きかっこを忘れたのでしょう。
一般的な規則として、忘れたかっこ(そう呼ぶなら)はあなたが最後に編集した
場所の近くにあります。

=item Unquoted string "%s" may clash with future reserved word

=begin original

(W reserved) You used a bareword that might someday be claimed as a
reserved word.  It's best to put such a word in quotes, or capitalize it
somehow, or insert an underbar into it.  You might also declare it as a
subroutine.

=end original

(W) いつの日にか、予約語とかち合うかもしれない、裸の単語を使用しています。
そのような単語は、クォートするか、大文字を入れるか、アンダーバー (_) を
いれるかしてください。
その裸の単語は、サブルーチンとして宣言することも可能です。

=item Unrecognized character %s; marked by S<<-- HERE> after %s near column
%d

=begin original

(F) The Perl parser has no idea what to do with the specified character
in your Perl script (or eval) near the specified column.  Perhaps you
tried  to run a compressed script, a binary program, or a directory as
a Perl program.

=end original

(F) Perl パーサーは、Perl スクリプト(または eval) で指定された桁数あたりに
出てきた文字に対してどうすればよいか分かりませんでした。
おそらく圧縮したスクリプト、バイナリプログラム、ディレクトリといったものを
Perl プログラムとして実行しようとしたのでしょう。

=item Unrecognized escape \%c in character class in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) You used a backslash-character combination which is not
recognized by Perl inside character classes.  This is a fatal
error when the character class is used within C<(?[ ])>.

=end original

(F) Perl の内部文字クラスとして認識されない逆スラッシュ文字並びを使いました。
これは文字クラスが C<(?[ ])> の中で使われた時は致命的エラーです。

=item Unrecognized escape \%c in character class passed through in regex; 
marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) You used a backslash-character combination which is not
recognized by Perl inside character classes.  The character was
understood literally, but this may change in a future version of Perl.
The S<<-- HERE> shows whereabouts in the regular expression the
escape was discovered.

=end original

(W regexp) Perl 内部文字クラスで認識できない、バックスラッシュ-文字の
組み合わせを使いました。
文字はリテラルに処理されますが、将来のバージョンの Perl では
変更されるかもしれません。
S<<-- HERE> で正規表現のどこにエスケープが発見されたかを示しています。

=item Unrecognized escape \%c passed through

=begin original

(W misc) You used a backslash-character combination which is not
recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.

=end original

(W misc) Perl が理解できないバックスラッシュ-文字の組み合わせが
使われています。
文字はリテラルに処理されますが、将来のバージョンの Perl では
変更されるかもしれません。

=item Unrecognized escape \%s passed through in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) You used a backslash-character combination which is not
recognized by Perl.  The character(s) were understood literally, but
this may change in a future version of Perl.  The S<<-- HERE> shows
whereabouts in the regular expression the escape was discovered.

=end original

(W regexp) Perl が認識できない、バックスラッシュ-文字の組み合わせが
使われています。
文字はリテラルに処理されますが、将来のバージョンの Perl では
変更されるかもしれません。
S<<-- HERE> で正規表現のどこにエスケープが発見されたかを示しています。

=item Unrecognized signal name "%s"

=begin original

(F) You specified a signal name to the kill() function that was not
recognized.  Say C<kill -l> in your shell to see the valid signal names
on your system.

=end original

(F) kill() 関数に、認識できないシグナル名を指定しました。
お使いのシステムで使用可能なシグナル名を調べるには、
シェル上で C<kill -l> などとしてください。

=item Unrecognized switch: -%s  (-h will show valid options)

=begin original

(F) You specified an illegal option to Perl.  Don't do that.  (If you
think you didn't do that, check the #! line to see if it's supplying the
bad switch on your behalf.)

=end original

(F) Perl に間違ったオプションを指定しました。
これを行なってはいけません。
(指定したつもりがないのであれば、#! 行に間違ったオプションが
スイッチが指定されていないかをチェックしてください。)

=item Unsuccessful %s on filename containing newline

=begin original

(W newline) A file operation was attempted on a filename, and that
operation failed, PROBABLY because the filename contained a newline,
PROBABLY because you forgot to chomp() it off.  See L<perlfunc/chomp>.

=end original

(W newline) あるファイル名に対して、ファイル操作を行ないましたが、
失敗しました; 「おそらく」ファイル名に改行文字がついていたからで、
「おそらく」 chomp() するのを忘れたのでしょう。　
L<perlfunc/chomp> を参照してください。

=item Unsupported directory function "%s" called

=begin original

(F) Your machine doesn't support opendir() and readdir().

=end original

(F) このマシンでは、opendir() や readdir() がサポートされていません。

=item Unsupported function %s

=begin original

(F) This machine doesn't implement the indicated function, apparently.
At least, Configure doesn't think so.

=end original

(F) このマシンでは、表示した関数は実装されていません。
少なくとも、Configure はそう判断しました。

=item Unsupported function fork

=begin original

(F) Your version of executable does not support forking.

=end original

(F) この実行ファイルは fork に対応していません。

=begin original

Note that under some systems, like OS/2, there may be different flavors
of Perl executables, some of which may support fork, some not.  Try
changing the name you call Perl by to C<perl_>, C<perl__>, and so on.

=end original

OS/2 のようなシステムには、Perl 実行ファイルにいくつかの種類があり、
fork に対応しているものとしていないものがあります。
Perl を呼び出す時の名前を C<perl_>, C<perl__> のように
変えてみてください。

=item Unsupported script encoding %s

=begin original

(F) Your program file begins with a Unicode Byte Order Mark (BOM) which
declares it to be in a Unicode encoding that Perl cannot read.

=end original

(F) プログラムファイルが、Perl が読み込めない Unicode エンコーディングを
宣言する Unicode Byte Order Mark (BOM) で始まっています。

=item Unsupported socket function "%s" called

=begin original

(F) Your machine doesn't support the Berkeley socket mechanism, or at
least that's what Configure thought.

=end original

(F) このマシンでは、Berkeley ソケット機構がサポートされていないか、
少なくとも Configure がそう判断しました。

=item Unterminated '(*...' argument in regex; marked by <-- HERE in m/%s/

=begin original

(F) You used a pattern of the form C<(*...:...)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=end original

(F) C<(*...:...)> 形式のパターンを使いましたが、パターンが
C<)> で終端されていません。
パターンを修正して再挑戦してください。

=item Unterminated attribute list

=begin original

(F) The lexer found something other than a simple identifier at the
start of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous
attribute too soon.  See L<attributes>.

=end original

(F) 字句解析器が、属性の先頭として単純な識別子やセミコロンやブロックの
開始でないものを発見しました。
おそらく以前の属性のパラメータリストを早く終端しすぎたのでしょう。
L<attributes> を参照してください。

=item Unterminated attribute parameter in attribute list

=begin original

(F) The lexer saw an opening (left) parenthesis character while parsing
an attribute list, but the matching closing (right) parenthesis
character was not found.  You may need to add (or remove) a backslash
character to get your parentheses to balance.  See L<attributes>.

=end original

(F) 字句解析器が、属性リストをパースしているときに開き(左)かっこを
発見しましたが、対応する閉じ(右)かっこが見つかりませんでした。
かっこのバランスを取るために、バックスラッシュを追加(または削除)する
必要があるでしょう。
L<attributes> を参照してください。

=item Unterminated compressed integer

=begin original

(F) An argument to unpack("w",...) was incompatible with the BER
compressed integer format and could not be converted to an integer.
See L<perlfunc/pack>.

=end original

(F) unpack("w",...) の引数が BER 圧縮整数フォーマットと互換性がなく、
整数に変換できませんでした。
L<perlfunc/pack> を参照してください。

=item Unterminated '(*...' construct in regex; marked by <-- HERE in m/%s/

=begin original

(F) You used a pattern of the form C<(*...)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=end original

(F) C<(*...)> 形式のパターンを使いましたが、パターンが
C<)> で終端されていません。
パターンを修正して再挑戦してください。

=item Unterminated delimiter for here document

=begin original

(F) This message occurs when a here document label has an initial
quotation mark but the final quotation mark is missing.  Perhaps
you wrote:

=end original

(F) このメッセージは、ヒヤドキュメントのラベルがクォートで始まっているけれども
末尾のクォートがありません。
おそらく以下のように書いたのでしょう:

    <<"foo

=begin original

instead of:

=end original

次のように書いてください:

    <<"foo"

=item Unterminated \g... pattern in regex; marked by S<<-- HERE> in m/%s/

=item Unterminated \g{...} pattern in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) In a regular expression, you had a C<\g> that wasn't followed by a
proper group reference.  In the case of C<\g{>, the closing brace is
missing; otherwise the C<\g> must be followed by an integer.  Fix the
pattern and retry.

=end original

(F) 正規表現の中で、適切なグループ参照が引き続かない C<\g> を使いました。
C<\g{> の場合、閉じ中かっこがありません; さもなければ、C<\g> には整数が
引き続かなければ鳴りません。
パターンを修正して再挑戦してください。

=item Unterminated <> operator

=begin original

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=end original

(F) 項が必要とされるところで、開き山かっこが見つけたため、
対応する閉じ山かっこを探しましたが、見つかりませんでした。
可能性としては、必要なかっこを省いてしまい、本当は、「小なり記号」を
表したかった場合が考えられます。

=item Unterminated verb pattern argument in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(F) You used a pattern of the form C<(*VERB:ARG)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=end original

(F) C<(*VERB:ARG)> の形のパターンを使いましたが、パターンが C<)> で
終わっていません。
パターンを修正して再挑戦してください。

=item Unterminated verb pattern in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You used a pattern of the form C<(*VERB)> but did not terminate
the pattern with a C<)>.  Fix the pattern and retry.

=end original

(F) C<(*VERB)> の形のパターンを使いましたが、パターンが C<)> で
終わっていません。
パターンを修正して再挑戦してください。

=item untie attempted while %d inner references still exist

=begin original

(W untie) A copy of the object returned from C<tie> (or C<tied>) was
still valid when C<untie> was called.

=end original

(W untie) C<tie> (または C<tied>) から返されたオブジェクトが、
C<untie> が呼び出されたときにまだ有効でした。

=item Usage: POSIX::%s(%s)

=begin original

(F) You called a POSIX function with incorrect arguments.
See L<POSIX/FUNCTIONS> for more information.

=end original

(F) POSIX 関数を間違った引数で呼び出しました。
さらなる情報については L<POSIX/FUNCTIONS> を参照してください。

=item Usage: Win32::%s(%s)

=begin original

(F) You called a Win32 function with incorrect arguments.
See L<Win32> for more information.

=end original

(F) Win32 関数を間違った引数で呼び出しました。
更なる情報については L<Win32> を参照してください。

=item $[ used in %s (did you mean $] ?)

=begin original

(W syntax) You used C<$[> in a comparison, such as:

=end original

(W syntax) 以下のように、比較で C<$[> を使いました:

    if ($[ > 5.006) {
	...
    }

=begin original

You probably meant to use C<$]> instead.  C<$[> is the base for indexing
arrays.  C<$]> is the Perl version number in decimal.

=end original

おそらく C<$]> を使いたかったのでしょう。
C<$[> は配列の基数です。
C<$]> は Perl のバージョン番号の 10 進数です。

=item Use "%s" instead of "%s"

=begin original

(F) The second listed construct is no longer legal.  Use the first one
instead.

=end original

(F) 2 番目に挙げられた構文はもはや有効ではありません。
代わりに 1 番目のものを使ってください。

=item Useless assignment to a temporary

=begin original

(W misc) You assigned to an lvalue subroutine, but what
the subroutine returned was a temporary scalar about to
be discarded, so the assignment had no effect.

=end original

(W misc) 左辺値サブルーチンに代入しましたが、サブルーチンが返したものは
捨てられようとする一時的なスカラなので、代入は向こうです。

=item Useless (?-%s) - don't use /%s modifier in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(W regexp) You have used an internal modifier such as (?-o) that has no
meaning unless removed from the entire regexp:

=end original

(W regexp) (?-o) のような内部修飾子は、正規表現全体から除去されなければ
意味がありません:

    if ($string =~ /(?-o)$pattern/o) { ... }

=begin original

must be written as

=end original

これは以下のように書かなければなりません:

    if ($string =~ /$pattern/) { ... }

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Useless localization of %s

=begin original

(W syntax) The localization of lvalues such as C<local($x=10)> is legal,
but in fact the local() currently has no effect.  This may change at
some point in the future, but in the meantime such code is discouraged.

=end original

(W syntax) C<local($x=10)> のような左辺値のローカル化は有効ですが、
実際のところ local() は現在のところ何の効果もありません。
これは将来変更されるかもしれませんが、今のところはこのようなコードは
勧められません。

=item Useless (?%s) - use /%s modifier in regex; marked by S<<-- HERE> in
m/%s/

=begin original

(W regexp) You have used an internal modifier such as (?o) that has no
meaning unless applied to the entire regexp:

=end original

(W regexp) (?o) のような内部修飾子は、正規表現全体に適用されなければ
意味がありません:

    if ($string =~ /(?o)$pattern/) { ... }

=begin original

must be written as

=end original

これは以下のように書かなければなりません:

    if ($string =~ /$pattern/o) { ... }

=begin original

The S<<-- HERE> shows whereabouts in the regular expression the problem was
discovered.  See L<perlre>.

=end original

S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Useless use of attribute "const"

=begin original

(W misc) The C<const> attribute has no effect except
on anonymous closure prototypes.  You applied it to
a subroutine via L<attributes.pm|attributes>.  This is only useful
inside an attribute handler for an anonymous subroutine.

=end original

(W misc) C<const> 属性は、無名クロージャプロトタイプ以外では効果がありません。
あなたはこれを L<attributes.pm|attributes> 経由でサブルーチンに適用しました。
これは無名サブルーチンのための属性ハンドラの中でしか有用ではありません。

=item Useless use of /d modifier in transliteration operator

=begin original

(W misc) You have used the /d modifier where the searchlist has the
same length as the replacelist.  See L<perlop> for more information
about the /d modifier.

=end original

(W misc) 検索リストが置換リストと同じ長さの時に /d 修飾子を使いました。
/d 修飾子に関するさらなる情報については L<perlop> を参照してください。

=item Useless use of \E

=begin original

(W misc) You have a \E in a double-quotish string without a C<\U>,
C<\L> or C<\Q> preceding it.

=end original

(W misc) ダブルクォート風文字列の中で C<\U>, C<\L>, C<\Q> を前置することなく
\E を書きました。

=item Useless use of greediness modifier '%c' in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) You specified something like these:

=end original

(W regexp) 次のようなものを指定しました:

 qr/a{3}?/
 qr/b{1,1}+/

=begin original

The C<"?"> and C<"+"> don't have any effect, as they modify whether to
match more or fewer when there is a choice, and by specifying to match
exactly a given numer, there is no room left for a choice.

=end original

C<"?"> と C<"+"> は何の効果もありません; これはマッチングする数に幅がある時に
より多くまたは少なく変更します。
そして指定された数に正確にマッチングすることを指定されているので、
選択の余地はありません。

=item Useless use of %s in void context

=begin original

(W void) You did something without a side effect in a context that does
nothing with the return value, such as a statement that doesn't return a
value from a block, or the left side of a scalar comma operator.  Very
often this points not to stupidity on your part, but a failure of Perl
to parse your program the way you thought it would.  For example, you'd
get this if you mixed up your C precedence with Python precedence and
said

=end original

(W void) ブロックの値を返さない文や、スカラのコンマ演算子の左側のように
返却値の無い文脈で、副作用のないことを行ないました。
多くは、みなさんの間違いを指摘するものではなく、Perl がみなさんの
意向を汲み取った解釈ができないことで起こります。
たとえば、みなさんが C の優先順位を Python の優先順位と混同して
以下のようにした場合です:

    $one, $two = 1, 2;

=begin original

when you meant to say

=end original

以下のようにするべきです。

    ($one, $two) = (1, 2);

=begin original

Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say

=end original

その他の良くあるエラーとしては、リストを作るのに中かっこや大かっこを
使うべきところで普通のかっこを使うことです; 例えば、以下のように書いた
場合です:

    $array = (1,2);

=begin original

when you should have said

=end original

以下のように書くべきです:

    $array = [1,2];

=begin original

The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
L<perlref> for more on this.

=end original

角かっこはリスト値を明示的にスカラ値に変換しますが、かっこは変換しません。
そのため、かっこで括られたリストをスカラコンテキストで評価すると、
カンマは C のカンマ演算子のように扱われ、左側の引数は捨てられます;
これは望んでいることではないでしょう。
これに関するさらなる情報については L<perlref> を参照してください。

=begin original

This warning will not be issued for numerical constants equal to 0 or 1
since they are often used in statements like

=end original

この警告は、0 か 1 と等しい数値定数では起きません; なぜなら、
しばしば以下のような文で使われるからです:

    1 while sub_with_side_effects();

=begin original

String constants that would normally evaluate to 0 or 1 are warned
about.

=end original

通常 0 か 1 に評価される文字列定数は警告されます。

=item Useless use of (?-p) in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) The C<p> modifier cannot be turned off once set.  Trying to do
so is futile.

=end original

(W regexp)
C<p> 修飾子は、一度設定したものをオフにはできません。
そうしようとしても無効です。

=item Useless use of "re" pragma

=begin original

(W) You did C<use re;> without any arguments.  That isn't very useful.

=end original

(W) C<use re;> プラグマを引数なしで指定しました。これは無意味です。

=item Useless use of sort in scalar context

=begin original

(W void) You used sort in scalar context, as in :

=end original

(W void) こんな風に、ソートをスカラコンテキストで使いました:

    my $x = sort @y;

=begin original

This is not very useful, and perl currently optimizes this away.

=end original

これは全く便利ではないので、perl は現在のところ最適化して取り除きます。

=item Useless use of %s with no values

=begin original

(W syntax) You used the push() or unshift() function with no arguments
apart from the array, like C<push(@x)> or C<unshift(@foo)>.  That won't
usually have any effect on the array, so is completely useless.  It's
possible in principle that push(@tied_array) could have some effect
if the array is tied to a class which implements a PUSH method.  If so,
you can write it as C<push(@tied_array,())> to avoid this warning.

=end original

(W syntax) C<push(@x)> や C<unshift(@foo)> のようにして、push() 関数や
unshift() 関数を、配列以外の引数なしで使いました。
これは普通は配列に何の影響も与えないので、完全に無意味です。
理論的には、配列が tie されているクラスの PUSH メソッドの実装によっては
push(@tied_array) が何らかの効果を持つ可能性はあります。
もしそうなら、これを C<push(@tied_array,())> のように書くことで警告を
回避できます。

=item "use" not allowed in expression

=begin original

(F) The "use" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.

=end original

(F) "use" キーワードは、コンパイル時に認識され、実行されるもので、
意味のある値を返しません。
L<perlmod> を参照してください。

=item Use of bare << to mean <<"" is forbidden

=begin original

(F) You are now required to use the explicitly quoted form if you wish
to use an empty line as the terminator of the here-document.

=end original

(F) ヒアドキュメントの終端子として空行を使いたいときには、明示的に
クォートされた形を使うことが必要になりました。

=begin original

Use of a bare terminator was deprecated in Perl 5.000, and is a fatal
error as of Perl 5.28.

=end original

裸の終端子は Perl 5.000 で廃止予定になっていて、
Perl 5.28 から致命的エラーです。

=item Use of /c modifier is meaningless in s///

=begin original

(W regexp) You used the /c modifier in a substitution.  The /c
modifier is not presently meaningful in substitutions.

=end original

(W regexp) 置換で /c 修飾子を使いました。
/c は置換では現在のところ無意味です。

=item Use of /c modifier is meaningless without /g

=begin original

(W regexp) You used the /c modifier with a regex operand, but didn't
use the /g modifier.  Currently, /c is meaningful only when /g is
used.  (This may change in the future.)

=end original

(W regexp) 正規表現オペランドに /c 修飾子を使いましたが、/g 修飾子は
使いませんでした。
現在のところ、/c は /g が使われたときにのみ有効です。
(これは将来変更されるかもしれません。)

=item Use of code point 0x%s is not allowed; the permissible max is 0x%X

=item Use of code point 0x%s is not allowed; the permissible max is 0x%X
in regex; marked by <-- HERE in m/%s/

=begin original

(F) You used a code point that is not allowed, because it is too large.
Unicode only allows code points up to 0x10FFFF, but Perl allows much
larger ones. Earlier versions of Perl allowed code points above IV_MAX
(0x7FFFFFF on 32-bit platforms, 0x7FFFFFFFFFFFFFFF on 64-bit platforms),
however, this could possibly break the perl interpreter in some constructs,
including causing it to hang in a few cases.

=end original

(F) 大きすぎるので許されない符号位置を使いました。
Unicode は 0x10FFFF までだけの符号位置を許していますが、
Perl は遙かに大きいものを許します。
以前のバージョンの Perl は
IV_MAX (32 ビットシステムでは 0x7FFFFFF、64 ビットシステムでは
0x7FFFFFFFFFFFFFFF) を超えた符号位置を許していましたが、
これは一部の構文で perl インタプリタを壊すことがあり、
場合によってはハングアップすることがありました。

=begin original

If your code is to run on various platforms, keep in mind that the upper
limit depends on the platform.  It is much larger on 64-bit word sizes
than 32-bit ones.

=end original

コードが様々なプラットフォームで実行するためのものなら、
上限がプラットフォームに依存していることを心に留めておいてください。
64 ビットワードサイズは 32 ビットよりも遙かに大きいです。

=begin original

The use of out of range code points was deprecated in Perl 5.24, and
became a fatal error in Perl 5.28.

=end original

範囲外の符号位置の使用は Perl 5.24 で廃止予定になり、
Perl 5.28 で致命的エラーになりました。

=item Use of each() on hash after insertion without resetting hash iterator results in undefined behavior

=begin original

(S internal) The behavior of C<each()> after insertion is undefined;
it may skip items, or visit items more than once.  Consider using
C<keys()> instead of C<each()>.

=end original

(S internal) 挿入の後の C<each()> の振る舞いは未定義です; アイテムを
読み飛ばしたり、複数回読んだりします。
C<each()> の代わりに C<keys()> を使うことを検討してください。

=item Use of := for an empty attribute list is not allowed

=begin original

(F) The construction C<my $x := 42> used to parse as equivalent to
C<my $x : = 42> (applying an empty attribute list to C<$x>).
This construct was deprecated in 5.12.0, and has now been made a syntax
error, so C<:=> can be reclaimed as a new operator in the future.

=end original

(F) 構文 C<my $x := 42> は C<my $x : = 42> と等価にパースされていました
(C<$x> に空の属性リストを適用する)。
この構文は 5.12.0 に廃止予定となり、今回文法エラーとなったので、
C<:=> は将来新しい演算子として再利用できます。

=begin original

If you need an empty attribute list, for example in a code generator, add
a space before the C<=>.

=end original

例えばコードジェネレータのために、空属性リストが必要なら、C<=> の前に
スペースを加えてください。

=item Use of %s for non-UTF-8 locale is wrong.  Assuming a UTF-8 locale

=begin original

(W locale)  You are matching a regular expression using locale rules,
and the specified construct was encountered.  This construct is only
valid for UTF-8 locales, which the current locale isn't.  This doesn't
make sense.  Perl will continue, assuming a Unicode (UTF-8) locale, but
the results are likely to be wrong.

=end original

(W locale)  ロケールの規則を使って正規表現のマッチングを行い、
指定した構文が出現しました。
この構文は UTF-8 ロケールでのみ有効ですが、現在のロケールは異なります。
これは意味がありません。
Perl は Unicode (UTF-8) ロケールを仮定して動作を続けますが、
結果はおそらく間違ったものです。

=item Use of freed value in iteration

=begin original

(F) Perhaps you modified the iterated array within the loop?
This error is typically caused by code like the following:

=end original

(F) おそらくループの中で反復される配列を変更したのでは?
このエラーは典型的には以下のようなコードで発生します:

    @a = (3,4);
    @a = () for (1,2,@a);

=begin original

You are not supposed to modify arrays while they are being iterated over.
For speed and efficiency reasons, Perl internally does not do full
reference-counting of iterated items, hence deleting such an item in the
middle of an iteration causes Perl to see a freed value.

=end original

反復中の配列は変更してはいけないことになっています。
速度と効率上の理由から、Perl 内部では反復されたアイテムの参照カウントを
完全には数えていません; 従って反復中のアイテムのを削除すると Perl は
解放された値を見ることになります。

=item Use of /g modifier is meaningless in split

=begin original

(W regexp) You used the /g modifier on the pattern for a C<split>
operator.  Since C<split> always tries to match the pattern
repeatedly, the C</g> has no effect.

=end original

(W regexp) C<split> 演算子のパターンで /g 修飾子を使いました。
C<split> は常にパターンを繰り返しマッチングしようとするので、
C</g> は効果がありません。

=item Use of "goto" to jump into a construct is deprecated

=begin original

(D deprecated) Using C<goto> to jump from an outer scope into an inner
scope is deprecated and should be avoided.

=end original

(D deprecated) 外側のスコープから内側のスコープに飛び込むために C<goto> を
使うことは廃止予定であり、避けるべきです。

=begin original

This was deprecated in Perl 5.12.

=end original

これは Perl 5.12 で廃止予定になりました。

=item Use of '%s' in \p{} or \P{} is deprecated because: %s

=begin original

(D deprecated) Certain properties are deprecated by Unicode, and may
eventually be removed from the Standard, at which time Perl will follow
along.  In the meantime, this message is raised to notify you.

=end original

(D deprecated) 一部の特性は Unicode によって廃止予定とされており、
最終的に標準から削除されるかもしれません; その時点で Perl も追随します。
今のところは、通知のためにこのメッセージが発生します。

=item Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed

=begin original

(F) As an accidental feature, C<AUTOLOAD> subroutines were looked up as
methods (using the C<@ISA> hierarchy), even when the subroutines to be
autoloaded were called as plain functions (e.g. C<Foo::bar()>), not as
methods (e.g. C<< Foo->bar() >> or C<< $obj->bar() >>).

=end original

(F) 偶発的な仕様によって、C<AUTOLOAD> サブルーチンは、
autoload されるサブルーチンがメソッド (C<< Foo->bar() >> や
C<< $obj->bar() >>) ではなく、普通の関数 (C<Foo::bar()>) として
呼び出された場合にも、(C<@ISA> 階層を使って) メソッドとして検索していました。

=begin original

This was deprecated in Perl 5.004, and was made fatal in Perl 5.28.

=end original

この機能は Perl 5.004 で廃止予定になり、Perl 5.28 で致命的エラーになりました。

=item Use of %s in printf format not supported

=begin original

(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.

=end original

(F) C でのみアクセス可能な printf の機能を使おうとしました。
これは普通 Perl で行うより良い方法があります。

=item Use of %s is not allowed in Unicode property wildcard
subpatterns in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) You were using a wildcard subpattern a Unicode property value, and
the subpattern contained something that is illegal.  Not all regular
expression capabilities are legal in such subpatterns, and this is one.
Rewrite your subppattern to not use the offending construct.
See L<perlunicode/Wildcards in Property Values>.

=end original

(F) Unicode 特性値にワイルドカード部分パターンを使い、その部分パターンには何か
不正なものが含まれていました。
このような部分パターンでは全ての正規表現機能が正当というわけではなく、
これはその一つです。
問題となっている構文を使わないように部分パターンを書き換えてください。
L<perlunicode/Wildcards in Property Values> を参照してください。

=item Use of -l on filehandle%s

=begin original

(W io) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
The operation returned C<undef>.  Use a filename instead.

=end original

(F) ファイルはオープンされたファイルを表わすものであり、
ファイルをオープンしたときには、探しているシンボリックリンクは、
既に通り過ぎた後です。
この操作は C<undef> を返します。
代わりにファイル名を使ってください。

=item Use of reference "%s" as array index

=begin original

(W misc) You tried to use a reference as an array index; this probably
isn't what you mean, because references in numerical context tend
to be huge numbers, and so usually indicates programmer error.

=end original

(W misc) リファレンスを配列の添え字として使おうとしました; これはおそらく
望んでいることではないでしょう; なぜなら数値コンテキストでの
リファレンスはとても大きな数になることが多いので、普通はプログラマの
ミスを意味しています。

=begin original

If you really do mean it, explicitly numify your reference, like so:
C<$array[0+$ref]>.  This warning is not given for overloaded objects,
however, because you can overload the numification and stringification
operators and then you presumably know what you are doing.

=end original

本当にそうしたい場合は、C<$array[0+$ref]> のように、リファレンスを明示的に
数値化してください。
しかし、この警告はオーバーロードされたオブジェクトでは発生しません;
数値化と文字列化の演算子をオーバーロードして、何をしているかをわかっていると
仮定できるからです。

=item Use of strings with code points over 0xFF as arguments to %s
operator is not allowed

=begin original

(F) You tried to use one of the string bitwise operators (C<&> or C<|> or C<^> or
C<~>) on a string containing a code point over 0xFF.  The string bitwise
operators treat their operands as strings of bytes, and values beyond
0xFF are nonsensical in this context.

=end original

(F) 文字列ビット単位演算子 (C<&> や C<|> や C<^> や C<~>) の一つを
0xFF を超える符号位置を含む文字列に使おうとしました。
ビット単位文字列演算子はオペランドをバイト文字列として扱い、
0xFF を超える値はこの文脈では無意味です。

=begin original

Certain instances became fatal in Perl 5.28; others in perl 5.32.

=end original

一部は Perl 5.28 で致命的エラーになりました; 残りは perl 5.32 です。

=item Use of strings with code points over 0xFF as arguments to vec is forbidden

=begin original

(F) You tried to use L<C<vec>|perlfunc/vec EXPR,OFFSET,BITS>
on a string containing a code point over 0xFF, which is nonsensical here.

=end original

(F) 0xFF を超える符号位置を含む文字列に対して
L<C<vec>|perlfunc/vec EXPR,OFFSET,BITS> を使おうとしました;
これはここでは意味がありません。

=begin original

This became fatal in Perl 5.32.

=end original

これは Perl 5.32 で致命的エラーになりました。

=item Use of tainted arguments in %s is deprecated

=begin original

(W taint, deprecated) You have supplied C<system()> or C<exec()> with multiple
arguments and at least one of them is tainted.  This used to be allowed
but will become a fatal error in a future version of perl.  Untaint your
arguments.  See L<perlsec>.

=end original

(W taint, deprecated) C<system()> や C<exec()> に複数の引数を与えましたが、
そのうち少なくとも一つが汚染されています。
これは許されていましたが、将来のバージョンの perl では致命的エラーに
なるでしょう。
引数を浄化してください。
L<perlsec> を参照してください。

=item Use of unassigned code point or non-standalone grapheme for a
delimiter is not allowed

=begin original

(F)
A grapheme is what appears to a native-speaker of a language to be a
character.  In Unicode (and hence Perl) a grapheme may actually be
several adjacent characters that together form a complete grapheme.  For
example, there can be a base character, like "R" and an accent, like a
circumflex "^", that appear when displayed to be a single character with
the circumflex hovering over the "R".  Perl currently allows things like
that circumflex to be delimiters of strings, patterns, I<etc>.  When
displayed, the circumflex would look like it belongs to the character
just to the left of it.  In order to move the language to be able to
accept graphemes as delimiters, we cannot allow the use of
delimiters which aren't graphemes by themselves.  Also, a delimiter must
already be assigned (or known to be never going to be assigned) to try
to future-proof code, for otherwise code that works today would fail to
compile if the currently unassigned delimiter ends up being something
that isn't a stand-alone grapheme.  Because Unicode is never going to
assign
L<non-character code points|perlunicode/Noncharacter code points>, nor
L<code points that are above the legal Unicode maximum|
perlunicode/Beyond Unicode code points>, those can be delimiters, and
their use is legal.

=end original

(F)
書記素は言語のネイティブスピーカーにとって文字のように見えるものです。
Unicode (従って Perl) では、
書記素は実際には互いに完全な書記素を形成するいくつかの隣接する
文字かもしれません。
例えば、"R" のような基底文字と曲折アクセント "^" のような
アクセントかもしれません; これは表示されるときには
"R" の上に曲折アクセントがある単一の文字となります。
Perl は現在の所曲折アクセントのようなものを文字列、パターンなどの
区切り文字にすることを許しています。
表示されるとき、曲折アクセントは、
そのすぐ左にある文字に付属するかのように見えます。
言語が書記素を区切り文字として受けいられられるようにするために、
それ自体が書記素でない区切り文字の使用は認められません。
また、区切り文字は将来も動作するコードであり続けるために、
既に割り当てられている(または決して割り当てられないと分かっている)
ものでなければなりません;
さもなければ、もし現在割り当てられていない書記素が単体の書記素でないものに
なった場合、今日動作しているコードがコンパイルに失敗することになります。
Unicode は決して
L<非文字符号位置|perlunicode/Noncharacter code points> や
L<正当な Unicode の最大値より大きな符号位置|
perlunicode/Beyond Unicode code points> を割り当てないので、
これらは区切り文字になることができ、これらの使用は正当です。

=item Use of uninitialized value%s

=begin original

(W uninitialized) An undefined value was used as if it were already
defined.  It was interpreted as a "" or a 0, but maybe it was a mistake.
To suppress this warning assign a defined value to your variables.

=end original

(W uninitialized) 未定義値を、あたかも既に定義されているかのように
使用しました。
これは、"" か 0 と解釈されますが、間違いの可能性があります。
この警告を止めるには、変数に定義された値を代入してください。

=begin original

To help you figure out what was undefined, perl will try to tell you
the name of the variable (if any) that was undefined.  In some cases
it cannot do this, so it also tells you what operation you used the
undefined value in.  Note, however, that perl optimizes your program
and the operation displayed in the warning may not necessarily appear
literally in your program.  For example, C<"that $foo"> is usually
optimized into C<"that " . $foo>, and the warning will refer to the
C<concatenation (.)> operator, even though there is no C<.> in
your program.

=end original

何が未定義なのかを見つけ出す助けにするために、perl は(あれば)未定義である
変数名を示します。
それができないような場合では、未定義値を使った操作を示します。
しかし、perl がプログラムを最適化するので、文字通りにはプログラム中に
現れない操作についての警告が表示されるかもしれないことに注意してください。
例えば、C<"that $foo"> は C<"that " . $foo> に最適化されるので、
たとえプログラム中に C<連結 (.)> 演算子がなくても C<.> に関する警告が
出ます。

=item "use re 'strict'" is experimental

=begin original

(S experimental::re_strict) The things that are different when a regular
expression pattern is compiled under C<'strict'> are subject to change
in future Perl releases in incompatible ways.  This means that a pattern
that compiles today may not in a future Perl release.  This warning is
to alert you to that risk.

=end original

(S experimental::re_strict) 正規表現が C<'strict'> の基で
コンパイルされたときに何が異なるかは、
将来の Perl のリリースで互換性のない形で変更される予定です。
つまり、今日コンパイルしたパターンは将来の Perl リリースのものとは
違うかもしれません。
この警告はそのリスクを知らせるためのものです。

=item Use \x{...} for more than two hex characters in regex; marked by
S<<-- HERE> in m/%s/

=begin original

(F) In a regular expression, you said something like

=end original

(F) 正規表現で、以下のようなことをしました

 (?[ [ \xBEEF ] ])

=begin original

Perl isn't sure if you meant this

=end original

Perl は、これが以下のものを意味しているのか

 (?[ [ \x{BEEF} ] ])

=begin original

or if you meant this

=end original

それとも次のものかがわかりません。

 (?[ [ \x{BE} E F ] ])

=begin original

You need to add either braces or blanks to disambiguate.

=end original

明確にするために大かっこか空白を追加する必要があります。

=item Using just the first character returned by \N{} in character class in 
regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) Named Unicode character escapes C<(\N{...})> may return
a multi-character sequence.  Even though a character class is
supposed to match just one character of input, perl will match
the whole thing correctly, except when the class is inverted
(C<[^...]>), or the escape is the beginning or final end point of
a range.  For these, what should happen isn't clear at all.  In
these circumstances, Perl discards all but the first character
of the returned sequence, which is not likely what you want.

=end original

(W regexp) 名前付き Unicode 文字エスケープ C<(\N{...})> は
複数文字並びを返すことがあります。
文字クラスは入力のただ一つの文字にマッチングすることを想定していますが、
perl は全体を正しくマッチングします; 但し例外は、
クラスが反転された場合 (C<[^...]>) と、
エスケープが範囲の始点か終点の場合です。
これらの場合、何をするべきかは全く明らかではありません。
このため、Perl は返された並びの最初以外の文字を捨てます;
おそらくこれはあなたが求めているものではないでしょう。

=item Using just the single character results returned by \p{} in
(?[...]) in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) Extended character classes currently cannot handle operands
that evaluate to more than one character.  These are removed from the
results of the expansion of the C<\p{}>.

=end original

(W regexp) 拡張文字クラスは、現在の所、複数の文字に評価されるオペランドを
扱うことは出来ません。
これらは C<\p{}> の拡張の結果から取り除かれました。

=begin original

This situation can happen, for example, in

=end original

この状況は、例えば次の場合に起こります:

 (?[ \p{name=/KATAKANA/} ])

=begin original

"KATAKANA LETTER AINU P" is a legal Unicode name (technically a "named
sequence"), but it is actually two characters.  The above expression
with match only the Unicode names containing KATAKANA that represent
single characters.

=end original

"KATAKANA LETTER AINU P" は正当な Unicode 名 (技術的には「名前付き並び」)ですが、
実際には二つの文字です。
前述の式は、単一の文字を表現する KATAKANA を含む Unicode 名のみに
マッチングします。

=item Using /u for '%s' instead of /%s in regex; marked by S<<-- HERE> in m/%s/

=begin original

(W regexp) You used a Unicode boundary (C<\b{...}> or C<\B{...}>) in a
portion of a regular expression where the character set modifiers C</a>
or C</aa> are in effect.  These two modifiers indicate an ASCII
interpretation, and this doesn't make sense for a Unicode definition.
The generated regular expression will compile so that the boundary uses
all of Unicode.  No other portion of the regular expression is affected.

=end original

(W regexp) 文字集合修飾子 C</a> または C</aa> が有効の場合に正規表現の一部で
Unicode 境界 (C<\b{...}> または C<\B{...}>) を使いました。
これら二つの修飾子は ASCII での解釈を示していて、これは
Unicode の定義では意味がありません。
生成された正規表現は、境界は全て Unicode としてコンパイルします。
正規表現のその他の部分は影響を受けません。

=item Using !~ with %s doesn't make sense

=begin original

(F) Using the C<!~> operator with C<s///r>, C<tr///r> or C<y///r> is
currently reserved for future use, as the exact behavior has not
been decided.  (Simply returning the boolean opposite of the
modified string is usually not particularly useful.)

=end original

(F) C<s///r>, C<tr///r>, C<y///r> での C<!~> 演算子の使用は、正確な振る舞いが
まだ決定されていないので、将来の使用のために予約されています。
(単に修正された文字列の真偽値としての逆を返すのは普通特に
有用ではありません。)

=item UTF-16 surrogate U+%X

=begin original

(S surrogate) You had a UTF-16 surrogate in a context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by C<no warnings 'surrogate';>.

=end original

(S surrogate) 受け付けられないと考えられる場所に UTF-16 サロゲートを
使いました。
これらの符号位置、U+D800 から U+DFFF (両端含む) は UTF-16 のためだけに
Unicode によって使われます。
しかし Perl は、サロゲートを含む、内部で全ての符号なし整数の符号位置(最大値は
プラットフォームで利用可能なサイズ上限)を受け付けます。
しかし、これらは入力や出力になるときに問題を引き起こします;  それは
おそらくこのメッセージが出た場所です。
自分で何をしているのかが本当に本当に分かっているなら、
C<no warnings 'surrogate';> とすることでこの警告をオフにできます。

=item Value of %s can be "0"; test with defined()

=begin original

(W misc) In a conditional expression, you used <HANDLE>, <*> (glob),
C<each()>, or C<readdir()> as a boolean value.  Each of these constructs
can return a value of "0"; that would make the conditional expression
false, which is probably not what you intended.  When using these
constructs in conditional expressions, test their values with the
C<defined> operator.

=end original

(W misc) 条件式の中で、<HANDLE>, <*> (グロブ), C<each()>, C<readdir()> を
真偽値として使いました。
これらの構文は値 "0" を返すことがあります; これは条件式では偽を示しますが、
これはおそらく望んでいることではないでしょう。
これらの構文を条件式の中で使うときは、その値を C<defined> 演算子で
テストしてください。

=item Value of CLI symbol "%s" too long

=begin original

(W misc) A warning peculiar to VMS.  Perl tried to read the value of an
%ENV element from a CLI symbol table, and found a resultant string
longer than 1024 characters.  The return value has been truncated to
1024 characters.

=end original

(W misc) VMS に固有の警告です。
Perl は CLI シンボルテーブルから %ENV 要素の値を読み込もうとしましたが、
結果の文字列が 1024 文字を越えました。
返り値は 1024 文字に切り詰められます。

=item Variable "%s" is not available

=begin original

(W closure) During compilation, an inner named subroutine or eval is
attempting to capture an outer lexical that is not currently available.
This can happen for one of two reasons.  First, the outer lexical may be
declared in an outer anonymous subroutine that has not yet been created.
(Remember that named subs are created at compile time, while anonymous
subs are created at run-time.)  For example,

=end original

(W closure) コンパイル中に、内側の名前付きサブルーチンや eval が
まだ利用可能でない外側のレキシカルを捕捉しようとしました。
これは二つの理由で起こります。
まず、外側のレキシカルが、まだ作成されていない外側の無名サブルーチンで
定義されている場合です。
(名前付きサブルーチンはコンパイル時に作成されますが、無名サブルーチンは
実行時に作成されることを思い出してください。)
例えば、

    sub { my $a; sub f { $a } }

=begin original

At the time that f is created, it can't capture the current value of $a,
since the anonymous subroutine hasn't been created yet.  Conversely,
the following won't give a warning since the anonymous subroutine has by
now been created and is live:

=end original

f が作成された時点で、$a の現在の値を捕捉できません;
なぜなら無名サブルーチンはまだ作成されていないからです。
逆に、以下のものは警告されません; 無名サブルーチンはこの時点で作成されていて
生きているからです:

    sub { my $a; eval 'sub f { $a }' }->();

=begin original

The second situation is caused by an eval accessing a variable that has
gone out of scope, for example,

=end original

2 番目の状況は eval がスコープ外となった変数にアクセスすることで起こります;
例えば:

    sub f {
	my $a;
	sub { eval '$a' }
    }
    f()->();

=begin original

Here, when the '$a' in the eval is being compiled, f() is not currently
being executed, so its $a is not available for capture.

=end original

ここで、eval の中の '$a' がコンパイルされるとき、f() はまだ
実行されていないので、この $a は捕捉出来ません。

=item Variable "%s" is not imported%s

=begin original

(S misc) With "use strict" in effect, you referred to a global variable
that you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported by
that module.  It usually means you put the wrong funny character on the
front of your variable.

=end original

(S misc) "use strict" が有効のときに、見たところ他のモジュールから
インポートされたとあなたが考えたグローバル変数を参照しました;
なぜなら同じ名前の何か他のもの(通常はサブルーチン)がそのモジュールから
エクスポートされています。
これは普通は変数の前に間違ったおかしな文字を置いたことを意味します。

=item Variable length lookbehind not implemented in regex m/%s/

=begin original

(F) B<This message no longer should be raised as of Perl 5.30.>  It is
retained in this document as a convenience for people using an earlier
Perl version.

=end original

(F) B<このメッセージは Perl 5.30 からもはや発生しません。>
これはより古いバージョンの Perl を使っている人々が便利なように
この文書に残しています。

=begin original

In Perl 5.30 and earlier, lookbehind is allowed
only for subexpressions whose length is fixed and
known at compile time.  For positive lookbehind, you can use the C<\K>
regex construct as a way to get the equivalent functionality.  See
L<(?<=pattern) and \K in perlre|perlre/\K>.

=end original

Perl 5.30 以前では、後方参照は長さが固定で、
コンパイル時に確定している副式に対してのみ可能です。
正の後方参照では、等価な機能を得るために C<\K> 正規表現構文が使えます。
L<(?<=pattern) and \K in perlre|perlre/\K> を参照してください。

=begin original

Starting in Perl 5.18, there are non-obvious Unicode rules under C</i>
that can match variably, but which you might not think could.  For
example, the substring C<"ss"> can match the single character LATIN
SMALL LETTER SHARP S.  Here's a complete list of the current ones
affecting ASCII characters:

=end original

Perl 5.18 から、C</i> の下では、おそらくあなたが考えていないような
種類のものにマッチングするという、明確でない Unicode の規則があります。
例えば、部分文字列 C<"ss"> は単一文字 LATIN SMALL LETTER SHARP S に
マッチングします。
以下は ASCII 文字に影響を与える現在のものの完全な一覧です:

   ASCII
  sequence      Matches single letter under /i
    FF          U+FB00 LATIN SMALL LIGATURE FF
    FFI         U+FB03 LATIN SMALL LIGATURE FFI
    FFL         U+FB04 LATIN SMALL LIGATURE FFL
    FI          U+FB01 LATIN SMALL LIGATURE FI
    FL          U+FB02 LATIN SMALL LIGATURE FL
    SS          U+00DF LATIN SMALL LETTER SHARP S
                U+1E9E LATIN CAPITAL LETTER SHARP S
    ST          U+FB06 LATIN SMALL LIGATURE ST
                U+FB05 LATIN SMALL LIGATURE LONG S T

=begin original

This list is subject to change, but is quite unlikely to.
Each ASCII sequence can be any combination of upper- and lowercase.

=end original

この一覧は変更されるかもしれませんが、かなり起こりにくいです。
それぞれの ASCII 並びは大文字と小文字が組み合わさっている場合もあります。

=begin original

You can avoid this by using a bracketed character class in the
lookbehind assertion, like

=end original

次のように、後読み言明で大かっこ文字クラスを使うことでこれを防げます:

 (?<![sS]t)
 (?<![fF]f[iI])

=begin original

This fools Perl into not matching the ligatures.

=end original

これは合字にマッチングしないように Perl を騙します。

=begin original

Another option for Perls starting with 5.16, if you only care about
ASCII matches, is to add the C</aa> modifier to the regex.  This will
exclude all these non-obvious matches, thus getting rid of this message.
You can also say

=end original

Perl v5.16 からのもう一つの選択肢として、
もし ASCII のマッチングにだけ関心があるのなら、
正規表現に C</aa> を追加することでこれらの明確でないマッチングを全て
除くことができるので、このメッセージを避けられます。
また、次のようにすることで:

 use if $] ge 5.016, re => '/aa';

=begin original

to apply C</aa> to all regular expressions compiled within its scope.
See L<re>.

=end original

スコープ内でコンパイルされた全ての正規表現に対して C</aa> を適用します。
L<re> を参照してください。

=item "%s" variable %s masks earlier declaration in same %s

=begin original

(W shadow) A "my", "our" or "state" variable has been redeclared in the
current scope or statement, effectively eliminating all access to the
previous instance.  This is almost always a typographical error.  Note
that the earlier variable will still exist until the end of the scope
or until all closure references to it are destroyed.

=end original

(W shadow) 現在のスコープや文で "my", "our", "state" 変数が再宣言されたので、
以前の実体への全てのアクセスができなくなりました。
これはほとんど常にタイプミスです。
以前の変数は、スコープが終わるか、それを参照している全てのクロージャが
破壊されるまでは存在し続けることに注意してください。

=item Variable syntax

=begin original

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Variable "%s" will not stay shared

=begin original

(W closure) An inner (nested) I<named> subroutine is referencing a
lexical variable defined in an outer named subroutine.

=end original

(W closure) 内部の(ネストした) I<名前付き> サブルーチンが、
外側の名前付きサブルーチンで定義したレキシカル変数を参照しています。

=begin original

When the inner subroutine is called, it will see the value of
the outer subroutine's variable as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the variable.  In other words, the
variable will no longer be shared.

=end original

内側のサブルーチンが呼び出されるとき、
外側のサブルーチンの変数の値は、
「最初の」外側のサブルーチンへの呼び出し前および呼び出し中のものになります;
この場合、外側のサブルーチンへの最初の呼び出しが終了した後、
内側と外側のサブルーチンはこの変数に関して同じ値を共有しなくなります。
言い換えると、この変数はもはや共有されません。

=begin original

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference variables in outer subroutines are created, they
are automatically rebound to the current values of such variables.

=end original

この問題は普通、C<sub {}> 構文を使って内側のサブルーチンを無名にすることで
解決します。
外側のサブルーチンの変数を参照している内側の無名サブルーチンが
作成されたとき、これらはそのような変数の現在の値に自動的に回復します。

=item vector argument not supported with alpha versions

=begin original

(S printf) The %vd (s)printf format does not support version objects
with alpha parts.

=end original

(S printf) %vd (s)printf フォーマットはアルファ部分のある
バージョンオブジェクトに対応していません。

=item Verb pattern '%s' has a mandatory argument in regex; marked by
S<<-- HERE> in m/%s/ 

=begin original

(F) You used a verb pattern that requires an argument.  Supply an
argument or check that you are using the right verb.

=end original

(F) 引き数が必要な動詞パターンを使いました。
引き数を追加するか、正しい動詞を使ってください。

=item Verb pattern '%s' may not have an argument in regex; marked by
S<<-- HERE> in m/%s/ 

=begin original

(F) You used a verb pattern that is not allowed an argument.  Remove the 
argument or check that you are using the right verb.

=end original

(F) 引き数が認められていない動詞パターンを使いました。
引き数を削除するか、正しい動詞を使ってください。

=item Version control conflict marker

=begin original

(F) The parser found a line starting with C<E<lt><<<<<<>,
C<E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>>, or C<=======>.  These may be left by a
version control system to mark conflicts after a failed merge operation.

=end original

(F) パーサは C<E<lt><<<<<<>,
C<E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>E<gt>>, C<=======> で始まる行を発見しました。
これらはマージ操作に失敗したあと衝突を記録するために
バージョン制御システムによって残されたものかもしれません。

=item Version number must be a constant number

=begin original

(P) The attempt to translate a C<use Module n.n LIST> statement into
its equivalent C<BEGIN> block found an internal inconsistency with
the version number.

=end original

(P) C<use Module n.n LIST> 文を等価な C<BEGIN> ブロックに変換しようと
したときに、バージョン番号について内部の不整合を発見しました。

=item Version string '%s' contains invalid data; ignoring: '%s'

=begin original

(W misc) The version string contains invalid characters at the end, which
are being ignored.

=end original

(W misc) バージョン文字列の末尾に不正な文字が含まれていたので、その文字は
無視されます。

=item Warning: something's wrong

=begin original

(W) You passed warn() an empty string (the equivalent of C<warn "">) or
you called it with no args and C<$@> was empty.

=end original

(W) warn() に空文字列を渡した (C<warn ""> と透過です) か、
引数なしで呼び出され、C<$@> も空でした。

=item Warning: unable to close filehandle %s properly

=begin original

(S) The implicit close() done by an open() got an error indication on
the close().  This usually indicates your file system ran out of disk
space.

=end original

(S) open() によって暗黙のうちに行なわれる close() が、
close() のエラーとなりました。
通常、ファイルシステムがいっぱいであることを示します。

=item Warning: unable to close filehandle properly: %s

=item Warning: unable to close filehandle %s properly: %s

=begin original

(S io) There were errors during the implicit close() done on a filehandle
when its reference count reached zero while it was still open, e.g.:

=end original

(S io) まだ開いているけれども参照カウントがゼロになったときに
ファイルハンドルに対して行われる暗黙の close() 中にエラーが起きました;
例えば:

    {
        open my $fh, '>', $file  or die "open: '$file': $!\n";
        print $fh $data or die "print: $!";
    } # implicit close here

=begin original

Because various errors may only be detected by close() (e.g. buffering could
allow the C<print> in this example to return true even when the disk is full),
it is dangerous to ignore its result.  So when it happens implicitly, perl
will signal errors by warning.

=end original

様々なエラーは close() によってのみ検出される
(バッファリングによって、この例の C<print> はディスクフルの場合でも
真を返すことが可能です)ので、
その結果を無視するのは危険です。
従って、それが暗黙に起きたとき、perl は警告によってエラーを知らせます。

=begin original

B<Prior to version 5.22.0, perl ignored such errors>, so the common idiom shown
above was liable to cause B<silent data loss>.

=end original

B<バージョン 5.22.0 より前では、perl はこのようなエラーを無視していました>;
従って、前述のような一般的な慣用句は
B<暗黙なデータの損失> を引き起こすことがありました。

=item Warning: Use of "%s" without parentheses is ambiguous

=begin original

(S ambiguous) You wrote a unary operator followed by something that
looks like a binary operator that could also have been interpreted as a
term or unary operator.  For instance, if you know that the rand
function has a default argument of 1.0, and you write

=end original

(S ambiguous) 単項演算子の後に、何か項にも単項演算子にも解釈できる、
二項演算子のようなものが置かれました。
たとえば、rand 関数がデフォルトの引数として、1.0 をとることを知って
いれば、以下のように書いて:

    rand + 5;

=begin original

you may THINK you wrote the same thing as

=end original

以下の同じことと思うかもしれませんが:

    rand() + 5;

=begin original

but in actual fact, you got

=end original

実際には以下のようになります:

    rand(+5);

=begin original

So put in parentheses to say what you really mean.

=end original

したがって、思うように解釈させるには、かっこが必要になります。

=item when is experimental

=begin original

(S experimental::smartmatch) C<when> depends on smartmatch, which is
experimental.  Additionally, it has several special cases that may
not be immediately obvious, and their behavior may change or
even be removed in any future release of perl.  See the explanation
under L<perlsyn/Experimental Details on given and when>.

=end original

(S experimental::smartmatch) C<when> は、実験的であるスマートマッチングに
依存しています。
さらに、完全に明らかとは言えないいくつかの特殊なケースがあるので、その
振る舞いは将来のリリースの perl で変更されたり削除されたりするかもしれません。
L<perlsyn/Experimental Details on given and when> の説明を参照してください。

=item Wide character in %s

=begin original

(S utf8) Perl met a wide character (ordinal >255) when it wasn't
expecting one.  This warning is by default on for I/O (like print).

=end original

(S utf8) Perl が(想定していないところで)ワイド文字(値が >255)に遭遇しました。
この警告は、(print のような) I/O に対してはデフォルトでオンです。

=begin original

If this warning does come from I/O, the easiest
way to quiet it is simply to add the C<:utf8> layer, I<e.g.>,
S<C<binmode STDOUT, ':utf8'>>.  Another way to turn off the warning is
to add S<C<no warnings 'utf8';>> but that is often closer to
cheating.  In general, you are supposed to explicitly mark the
filehandle with an encoding, see L<open> and L<perlfunc/binmode>.

=end original

この警告が I/O からのものなら、これを黙らせる最も簡単な方法は、
S<C<binmode STDOUT, ':utf8'>> のように
出力に単に C<:utf8> 層を追加することです。
もう一つの方法は S<C<no warnings 'utf8';>> を追加することですが、これは
しばしばいかさまに近い方法です。
一般的に、ファイルハンドルにはエンコーディングを明示的に指定することに
なっています; L<open> と L<perlfunc/binmode> を参照してください。

=begin original

If the warning comes from other than I/O, this diagnostic probably
indicates that incorrect results are being obtained.  You should examine
your code to determine how a wide character is getting to an operation
that doesn't handle them.

=end original

この警告が I/O 以外からのものなら、この診断メッセージは
おそらく正しくない結果が得られたことを意味しています。
どのようにしてワイド文字が、それを扱えない操作に渡されたのかを
決定するために、ソースコードを調べる必要があります。

=item Wide character (U+%X) in %s

=begin original

(W locale) While in a single-byte locale (I<i.e.>, a non-UTF-8
one), a multi-byte character was encountered.   Perl considers this
character to be the specified Unicode code point.  Combining non-UTF-8
locales and Unicode is dangerous.  Almost certainly some characters
will have two different representations.  For example, in the ISO 8859-7
(Greek) locale, the code point 0xC3 represents a Capital Gamma.  But so
also does 0x393.  This will make string comparisons unreliable.

=end original

(W locale) 単一バイトロケール (つまり非 UTF-8 のもの)で、
複数バイト文字に遭遇しました。
Perl はこの文字を指定された Unicode 符号位置として扱います。
非 UTF-8 ロケールと Unicode を結合するのは危険です。
ほとんど確実に一部の文字は複数の異なる表現を持ちます。
例えば、ISO 8859-7 (ギリシャ語) ロケールでは、
符号位置 0xC3 は Capital Gamma を表現します。
しかし 0x393 も同じです。
これは文字列比較を信頼できないものにします。

=begin original

You likely need to figure out how this multi-byte character got mixed up
with your single-byte locale (or perhaps you thought you had a UTF-8
locale, but Perl disagrees).

=end original

おそらくどうしてこのマルチバイト文字が単一バイトロケールで混ざったかを
見つける必要があるでしょう(あるいはおそらくあなたは UTF-8 ロケールを
使っていると考えているけれども Perl は同意していないのでしょう)。

=item Within []-length '%c' not allowed

=begin original

(F) The count in the (un)pack template may be replaced by C<[TEMPLATE]>
only if C<TEMPLATE> always matches the same amount of packed bytes that
can be determined from the template alone.  This is not possible if
it contains any of the codes @, /, U, u, w or a *-length.  Redesign
the template.

=end original

(F) (un)pack テンプレートの繰り返し数は、C<TEMPLATE> が常に
テンプレートだけから決定される同じサイズの pack されたバイト列と一致する
場合にのみ C<[TEMPLATE]> によって置き換えられます。
これは、コード @, /, U, u, w や、長さ * が含まれていると不可能です。
テンプレートを再設計してください。

=item While trying to resolve method call %s->%s() can not locate package "%s" yet it is mentioned in @%s::ISA (perhaps you forgot to load "%s"?)

=begin original

(W syntax) It is possible that the C<@ISA> contains a misspelled or never loaded
package name, which can result in perl choosing an unexpected parent
class's method to resolve the method call. If this is deliberate you
can do something like

=end original

(W syntax) C<@ISA> にタイプミスか読み込まれていないパッケージ名があり、
結果として perl がメソッド呼び出しの解決に想定外の親クラスのメソッドを
選んだ可能性があります。
これが意図的な場合は、次のようにして:

  @Missing::Package::ISA = ();

=begin original

to silence the warnings, otherwise you should correct the package name, or
ensure that the package is loaded prior to the method call.

=end original

この警告を黙らせられます; さもなければパッケージ名を修正するか、
パッケージがメソッド呼び出しの前に読み込まれるようにする必要があります。

=item %s() with negative argument

=begin original

(S misc) Certain operations make no sense with negative arguments.
Warning is given and the operation is not done.

=end original

(S misc) 一部の操作は負の引数は意味がありません。
警告が出力され、操作は行われません。

=item write() on closed filehandle %s

=begin original

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your control flow.

=end original

(W closed) 書き込みを行なおうとしたファイルハンドルは、既に閉じられています。
制御フローをチェックしてください。

=item %s "\x%X" does not map to Unicode

=begin original

(S utf8) When reading in different encodings, Perl tries to
map everything into Unicode characters.  The bytes you read
in are not legal in this encoding.  For example

=end original

(S utf8) 異なったエンコーディングを読み込むとき、Perl は全てを Unicode 文字に
マッピングしようとします。
読み込んだバイトはこのエンコーディングでは不正でした。
例えば:

    utf8 "\xE4" does not map to Unicode

=begin original

if you try to read in the a-diaereses Latin-1 as UTF-8.

=end original

というのは、Latin-1 の a 分節を UTF-8 として読み込もうとした場合です。

=item 'X' outside of string

=begin original

(F) You had a (un)pack template that specified a relative position before
the beginning of the string being (un)packed.  See L<perlfunc/pack>.

=end original

(F) (un)pack している文字列の最後より後の相対位置を示している
(un)pack テンプレートを指定しました。
L<perlfunc/pack> を参照してください。

=item 'x' outside of string in unpack

=begin original

(F) You had a pack template that specified a relative position after
the end of the string being unpacked.  See L<perlfunc/pack>.

=end original

(F) unpack している文字列の最後より後の相対位置を示している
pack テンプレートを指定しました。
L<perlfunc/pack> を参照してください。

=item YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!

=begin original

(F) And you probably never will, because you probably don't have the
sources to your kernel, and your vendor probably doesn't give a rip
about what you want.  There is a vulnerability anywhere that you have a
set-id script, and to close it you need to remove the set-id bit from
the script that you're attempting to run.  To actually run the script
set-id, your best bet is to put a set-id C wrapper around your script.

=end original

(F) そして、そうすることはできないでしょう; カーネルのソースは
お持ちではないでしょうし、ベンダも欲しいものを提供しては
くれないでしょうから。
set-id スクリプトのあちこちには脆弱性があり、
それを閉じるためには実行しようとしているスクリプトから
set-id ビットを削除する必要があります。
実際にスクリプトを set-id で実行するために
もっとも良いのは、スクリプトに set-id C ラッパーを被せることです。

=item You need to quote "%s"

=begin original

(W syntax) You assigned a bareword as a signal handler name.
Unfortunately, you already have a subroutine of that name declared,
which means that Perl 5 will try to call the subroutine when the
assignment is executed, which is probably not what you want.  (If it IS
what you want, put an & in front.)

=end original

(W syntax) シグナルハンドラ名に、裸の単語を代入しました。
残念ながら、そのサブルーチンは既に宣言されていて、Perl 5 では、
おそらく思惑とは違って、代入の実行時にサブルーチンの呼び出しが起こります。
(もし、本当にそうしたいのであれば、サブルーチン名に & を付けてください。)

=item Your random numbers are not that random

=begin original

(F) When trying to initialize the random seed for hashes, Perl could
not get any randomness out of your system.  This usually indicates
Something Very Wrong.

=end original

(F) ハッシュのための乱数の種を初期化しようとしたとき、Perl はシステムから
何の乱数性も得られませんでした。
これは普通「何かとても具合が悪い」ことを示しています。

=item Zero length \N{} in regex; marked by S<<-- HERE> in m/%s/

=begin original

(F) Named Unicode character escapes (C<\N{...}>) may return a zero-length
sequence.  Such an escape was used in an extended character class, i.e.
C<(?[...])>, or under C<use re 'strict'>, which is not permitted.  Check
that the correct escape has been used, and the correct charnames handler
is in scope.  The S<<-- HERE> shows whereabouts in the regular
expression the problem was discovered.

=end original

(F) 名前付き Unicode 文字エスケープ (C<(\N{...})>) はゼロ幅並びを
返すことがあります。
このようなエスケープが拡張文字クラス、つまり C<(?[...])> の中、
あるいは C<use re 'strict'> の基で使われました;
これは認められていません。
正しいエスケープを使っているか、および正しい文字名ハンドラがスコープ内に
あるかをチェックしてください。
S<<-- HERE> で正規表現のどこに問題が発見されたかを示しています。

=back

=head1 SEE ALSO

L<warnings>, L<diagnostics>.

=cut

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp> (5.000)
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.6.1-)
Status: in progress

=end meta

