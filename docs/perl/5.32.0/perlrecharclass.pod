
=encoding euc-jp

=head1 NAME
X<character class>

=begin original

perlrecharclass - Perl Regular Expression Character Classes

=end original

perlrecharclass - Perl 正規表現文字クラス

=head1 DESCRIPTION

=begin original

The top level documentation about Perl regular expressions
is found in L<perlre>.

=end original

Perl 正規表現に関する最上位文書は L<perlre> です。

=begin original

This manual page discusses the syntax and use of character
classes in Perl regular expressions.

=end original

このマニュアルページは Perl 正規表現の文字クラスの文法と使用法について
議論します。

=begin original

A character class is a way of denoting a set of characters
in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)

=end original

文字クラスは、集合の中の一文字がマッチングするというような方法で、
文字の集合を指定するための方法です。
次のことを覚えておくことは重要です: 文字集合はソース文字列の中から正確に
一文字だけを消費します。
(ソース文字列とは正規表現がマッチングしようとしている文字列です。)

=begin original

There are three types of character classes in Perl regular
expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term "character class" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.

=end original

Perl 正規表現には 3 種類の文字クラスがあります: ドット、
逆スラッシュシーケンス、大かっこで囲まれた形式です。
しかし、「文字クラス」という用語はしばしば大かっこ形式だけを意味するために
使われることに注意してください。
確かに、ほとんどの Perl 文書ではそうなっています。

=head2 The dot

(ドット)

=begin original

The dot (or period), C<.> is probably the most used, and certainly
the most well-known character class. By default, a dot matches any
character, except for the newline. That default can be changed to
add matching the newline by using the I<single line> modifier:
for the entire regular expression with the C</s> modifier, or
locally with C<(?s)>  (and even globally within the scope of
L<C<use re '/s'>|re/'E<sol>flags' mode>).  (The C<L</\N>> backslash
sequence, described
below, matches any character except newline without regard to the
I<single line> modifier.)

=end original

ドット (またはピリオド) C<.> はおそらくもっともよく使われ、そして確実に
もっともよく知られている文字クラスです。
デフォルトでは、ドットは改行を除く任意の文字にマッチングします。
このデフォルトは I<単一行> 修飾子を使うことで改行にもマッチングするように
変更されます: 正規表現全体に対して C</s> 修飾子を使うか、ローカルには
C<(?s)> を使います
(そしてグローバルに L<C<use re '/s'>|re/'E<sol>flags' mode> の
スコープ内の場合でもそうです)。
(後述する C<L</\N>> 逆スラッシュシーケンスでは、I<単一行> 修飾子に
関わりなく改行以外の任意の文字にマッチングします。)

=begin original

Here are some examples:

=end original

以下は例です:

=begin original

 "a"  =~  /./       # Match
 "."  =~  /./       # Match
 ""   =~  /./       # No match (dot has to match a character)
 "\n" =~  /./       # No match (dot does not match a newline)
 "\n" =~  /./s      # Match (global 'single line' modifier)
 "\n" =~  /(?s:.)/  # Match (local 'single line' modifier)
 "ab" =~  /^.$/     # No match (dot matches one character)

=end original

 "a"  =~  /./       # マッチングする
 "."  =~  /./       # マッチングする
 ""   =~  /./       # マッチングしない (ドットは文字にマッチングする必要がある)
 "\n" =~  /./       # マッチングしない (ドットは改行にはマッチングしない)
 "\n" =~  /./s      # マッチングする (グローバル「単一行」修飾子)
 "\n" =~  /(?s:.)/  # マッチングする (ローカル「単一行」修飾子)
 "ab" =~  /^.$/     # マッチングしない (ドットは一文字にマッチングする)

=head2 Backslash sequences
X<\w> X<\W> X<\s> X<\S> X<\d> X<\D> X<\p> X<\P>
X<\N> X<\v> X<\V> X<\h> X<\H>
X<word> X<whitespace>

(逆スラッシュシーケンス)

=begin original

A backslash sequence is a sequence of characters, the first one of which is a
backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.

=end original

逆スラッシュシーケンスは、最初がバックスラッシュの文字並びです。
Perl はそのような並びの多くに特別な意味を持たせていて、
その一部は文字クラスです。
つまり、それらはそれぞれ並びによって定義されている特定の文字の集合に
帰属する一文字にマッチングします。

=begin original

Here's a list of the backslash sequences that are character classes.  They
are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see L<perlrebackslash>.)

=end original

以下は文字クラスの逆スラッシュシーケンスの一覧です。
以下でさらに詳細に議論します。
(文字クラスではない逆スラッシュシーケンスについては、L<perlrebackslash> を
参照してください。)

=begin original

 \d             Match a decimal digit character.
 \D             Match a non-decimal-digit character.
 \w             Match a "word" character.
 \W             Match a non-"word" character.
 \s             Match a whitespace character.
 \S             Match a non-whitespace character.
 \h             Match a horizontal whitespace character.
 \H             Match a character that isn't horizontal whitespace.
 \v             Match a vertical whitespace character.
 \V             Match a character that isn't vertical whitespace.
 \N             Match a character that isn't a newline.
 \pP, \p{Prop}  Match a character that has the given Unicode property.
 \PP, \P{Prop}  Match a character that doesn't have the Unicode property

=end original

 \d             10 進数字にマッチング。
 \D             非 10 進数字にマッチング。
 \w             「単語」文字にマッチング。
 \W             非「単語」文字にマッチング。
 \s             空白文字にマッチング。
 \S             非空白文字にマッチング。
 \h             水平空白文字にマッチング。
 \H             水平空白でない文字にマッチング。
 \v             垂直空白文字にマッチング。
 \V             垂直空白でない文字にマッチング。
 \N             改行以外の文字にマッチング。
 \pP, \p{Prop}  指定された Unicode 特性を持つ文字にマッチング。
 \PP, \P{Prop}  指定された Unicode 特性を持たない文字にマッチング。

=head3 \N

=begin original

C<\N>, available starting in v5.12, like the dot, matches any
character that is not a newline. The difference is that C<\N> is not influenced
by the I<single line> regular expression modifier (see L</The dot> above).  Note
that the form C<\N{...}> may mean something completely different.  When the
C<{...}> is a L<quantifier|perlre/Quantifiers>, it means to match a non-newline
character that many times.  For example, C<\N{3}> means to match 3
non-newlines; C<\N{5,}> means to match 5 or more non-newlines.  But if C<{...}>
is not a legal quantifier, it is presumed to be a named character.  See
L<charnames> for those.  For example, none of C<\N{COLON}>, C<\N{4F}>, and
C<\N{F4}> contain legal quantifiers, so Perl will try to find characters whose
names are respectively C<COLON>, C<4F>, and C<F4>.

=end original

v5.12 から利用可能な C<\N> は、ドットのように、
改行以外の任意の文字にマッチングします。
違いは、C<\N> は I<単一行> 正規表現修飾子の影響を受けないことです
(上述の L</The dot> 参照)。
C<\N{...}> 型式は何か全く違うものを意味するかも知れないことに
注意してください。
C<{...}> が L<量指定子|perlre/Quantifiers> なら、これは指定された回数の
非改行文字にマッチングします。
例えば、C<\N{3}> は三つの非改行にマッチングします;
C<\N{5,}> は五つ以上の非改行にマッチングします。
しかし、C<{...}> が有効な量指定子でない場合、これは名前付き文字と
推定されます。
これについては L<charnames> を参照してください。
例えば、C<\N{COLON}>, C<\N{4F}>, C<\N{F4}> はどれも有効な
量指定子ではないので、Perl はそれぞれ C<COLON>, C<4F>, C<F4> という名前の
文字を探そうとします。

=head3 Digits

(数字)

=begin original

C<\d> matches a single character considered to be a decimal I<digit>.
If the C</a> regular expression modifier is in effect, it matches [0-9].
Otherwise, it
matches anything that is matched by C<\p{Digit}>, which includes [0-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have C<[0-9]> matched by C<\d>, and/or might match
other characters whose code point is less than 256.  The only such locale
definitions that are legal would be to match C<[0-9]> plus another set of
10 consecutive digit characters;  anything else would be in violation of
the C language standard, but Perl doesn't currently assume anything in
regard to this.)

=end original

C<\d> は 10 進 I<数字> と考えられる単一の文字にマッチングします。
C</a> 正規表現修飾子が有効の場合、これは [0-9] にマッチングします。
さもなければ、これは C<[0-9]> を含む、C<\p{Digit}> にマッチングするものに
マッチングします。
(ありそうもない例外はロケールマッチングの下で、現在のロケールが
C<\d> にマッチングする [0-9] がないか、
符号位置が 256 未満の他の文字にマッチングすることです。
唯一正当なロケール定義は、C<[0-9]> に加えてもう一つの 10 の連続した
数字の集合にマッチングするもので、
それ以外は C 言語標準に違反していますが、
Perl は今のところこれに関して何も仮定しません。)

=begin original

What this means is that unless the C</a> modifier is in effect C<\d> not
only matches the digits '0' - '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.

=end original

これが意味することは、C</a> 修飾子が有効でない限り、C<\d> は数字
'0' - '9' だけでなく、アラビア文字、デバナーガリ文字、およびその他の言語の
数字もマッチングします。
これは混乱やセキュリティ問題を引き起こすことがあります。

=begin original

Some digits that C<\d> matches look like some of the [0-9] ones, but
have different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks
very much like an ASCII DIGIT EIGHT (U+0038), and LEPCHA DIGIT SIX
(U+1C46) looks very much like an ASCII DIGIT FIVE (U+0035).  An
application that
is expecting only the ASCII digits might be misled, or if the match is
C<\d+>, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do.  L<Unicode::UCD/num()> can
be used to safely
calculate the value, returning C<undef> if the input string contains
such a mixture.  Otherwise, for example, a displayed price might be
deliberately different than it appears.

=end original

C<\d> にマッチングする数字には、[0-9] のように見えるけれども、
異なる値を持つものもあります。
例えば、 C<BENGALI DIGIT FOUR> (U+09EA) は C<ASCII DIGIT EIGHT> (U+0038) に
とてもよく似ていて、
C<LEPCHA DIGIT SIX> (U+1C46) は C<ASCII DIGIT FIVE> (U+0035) に
とてもよく似ています。
ASCII 数字のみを想定しているアプリケーションはミスリードされるかも知れず、
マッチングが C<\d+> の場合、
マッチングした文字列は、実際と異なる値を示しているように見える、
異なった書記体系からの数字が混ざったものかもしれません。
L<Unicode::UCD/num()> は値を安全に計算するのに使えます;
入力文字列がこのような混合を含んでいる場合は C<undef> を返します。
さもなければ、例えば、表示された価格は見た目と意図的に違うものに
なるかもしれません。

=begin original

What C<\p{Digit}> means (and hence C<\d> except under the C</a>
modifier) is C<\p{General_Category=Decimal_Number}>, or synonymously,
C<\p{General_Category=Digit}>.  Starting with Unicode version 4.1, this
is the same set of characters matched by C<\p{Numeric_Type=Decimal}>.
But Unicode also has a different property with a similar name,
C<\p{Numeric_Type=Digit}>, which matches a completely different set of
characters.  These characters are things such as C<CIRCLED DIGIT ONE>
or subscripts, or are from writing systems that lack all ten digits.

=end original

C<\p{Digit}> が意味するもの(つまり、C</a> 修飾子の下でない C<\d>)は、
C<\p{General_Category=Decimal_Number}>、または同義語として
C<\p{General_Category=Digit}> です。
Unicode バージョン 4.1 以降では、これは C<\p{Numeric_Type=Decimal}> に
マッチングする文字集合と同じです。
ただし、Unicode には、C<\p{Numeric_Type=Digit}> という類似した名前を持つ
別の特性もあります; これは完全に異なる文字集合とマッチングします。
これらの文字は、C<CIRCLEED DIGIT ONE> や添字のようなものであるか、
10 の数字すべてが揃っていない書記体系からのものです。

=begin original

The design intent is for C<\d> to exactly match the set of characters
that can safely be used with "normal" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of "digit",
C<\p{Numeric_Type=Digit}>, and so C<\d> doesn't match them.

=end original

設計意図は、C<\d> が「通常の」ビッグエンディアンの
位置 10 進構文 (例えば、123 は一つの「100」に二つの「10」と三つの「1」を
加えたものを意味する) で安全に使用できる文字集合と
正確にマッチングするようにすることです;
この位置表記は、他のタイプの「digit」である C<\p{Numeric_Type=Digit}> に
マッチングする文字には必ずしも適用されないため、
C<\d> はこれらの文字にマッチングしません。

=begin original

The Tamil digits (U+0BE6 - U+0BEF) can also legally be
used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean "times 10", "times 100",
etc.  (See L<https://www.unicode.org/notes/tn21>.)

=end original

タミル語の数字(U+0BE6-U+0BEF)は、古い様式のタミル語の
数字でも合法的に使用することができます;
この数字は、「×10」や「×100」などを意味する文字で区切られて、
1 回に一度にしか現れません。
(L<https://www.unicode.org/notes/tn21>を参照してください)。

=begin original

Any character not matched by C<\d> is matched by C<\D>.

=end original

C<\d> にマッチングしない任意の文字は C<\D> にマッチングします。

=head3 Word characters

(単語文字)

=begin original

A C<\w> matches a single alphanumeric character (an alphabetic character, or a
decimal digit); or a connecting punctuation character, such as an
underscore ("_"); or a "mark" character (like some sort of accent) that
attaches to one of those.  It does not match a whole word.  To match a
whole word, use C<\w+>.  This isn't the same thing as matching an
English word, but in the ASCII range it is the same as a string of
Perl-identifier characters.

=end original

C<\w> は単語全体ではなく、単一の英数字(つまり英字または数字)または
下線(C<_>) のような接続句読点
またはこれらの一つに付いている(ある種のアクセントのような)「マーク」文字に
マッチングします。
これは単語全体にはマッチングしません。
単語全体にマッチングするには、C<\w+> を使ってください。
これは英語の単語にマッチングするのと同じことではありませんが、
ASCII の範囲では、Perl の識別子文字の文字列と同じです。

=over

=item If the C</a> modifier is in effect ...

(C</a> 修飾子が有効なら ...)

=begin original

C<\w> matches the 63 characters [a-zA-Z0-9_].

=end original

C<\w> は 63 文字 [a-zA-Z0-9_] にマッチングします。

=item otherwise ...

(さもなければ ...)

=over

=item For code points above 255 ...

(256 以上の符号位置では ...)

=begin original

C<\w> matches the same as C<\p{Word}> matches in this range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a C<COMBINING TILDE> and the modifier letters, which
are generally used to add auxiliary markings to letters.

=end original

C<\w> はこの範囲で C<\p{Word}> がマッチングするものと同じものに
マッチングします。
つまり、タイ文字、ギリシャ文字などです。
これには(下線のような)二つの単語を繋ぐ接続句読点、
C<COMBINING TILDE> や一般的に文字に追加のマークを付けるために
使われる修飾字のようなダイアクリティカルマークが含まれます。

=item For code points below 256 ...

(255 以下の符号位置では ...)

=over

=item if locale rules are in effect ...

(ロケール規則が有効なら ...)

=begin original

C<\w> matches the platform's native underscore character plus whatever
the locale considers to be alphanumeric.

=end original

C<\w> は、プラットフォームのネイティブな下線に加えてロケールが英数字と
考えるものにマッチングします。

=item if, instead, Unicode rules are in effect ...

(そうではなく、Unicode 規則が有効なら ...)

=begin original

C<\w> matches exactly what C<\p{Word}> matches.

=end original

C<\w> は C<\p{Word}> がマッチングするものと同じものにマッチングします。

=item otherwise ...

(さもなければ ...)

=begin original

C<\w> matches [a-zA-Z0-9_].

=end original

C<\w> は [a-zA-Z0-9_] にマッチングします。

=back

=back

=back

=begin original

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

=end original

どの規則を適用するかは L<perlre/Which character set modifier is in effect?> で
記述されている方法で決定されます。

=begin original

There are a number of security issues with the full Unicode list of word
characters.  See L<http://unicode.org/reports/tr36>.

=end original

完全な Unicode の単語文字の一覧には多くのセキュリティ問題があります。
L<http://unicode.org/reports/tr36> を参照してください。

=begin original

Also, for a somewhat finer-grained set of characters that are in programming
language identifiers beyond the ASCII range, you may wish to instead use the
more customized L</Unicode Properties>, C<\p{ID_Start}>,
C<\p{ID_Continue}>, C<\p{XID_Start}>, and C<\p{XID_Continue}>.  See
L<http://unicode.org/reports/tr31>.

=end original

また、ASCII の範囲を超えたプログラミング言語識別子のための
より高精度の文字集合のためには、代わりによりカスタマイズされた
L<Unicode 特性|/Unicode Properties>である
 C<\p{ID_Start}>,
C<\p{ID_Continue}>, C<\p{XID_Start}>, and C<\p{XID_Continue}> を
使った方がよいでしょう。
L<http://unicode.org/reports/tr31> を参照してください。

=begin original

Any character not matched by C<\w> is matched by C<\W>.

=end original

C<\w> にマッチングしない任意の文字は C<\W> にマッチングします。

=head3 Whitespace

(空白)

=begin original

C<\s> matches any single character considered whitespace.

=end original

C<\s> は空白と考えられる単一の文字にマッチングします。

=over

=item If the C</a> modifier is in effect ...

(C</a> 修飾子が有効なら ...)

=begin original

In all Perl versions, C<\s> matches the 5 characters [\t\n\f\r ]; that
is, the horizontal tab,
the newline, the form feed, the carriage return, and the space.
Starting in Perl v5.18, it also matches the vertical tab, C<\cK>.
See note C<[1]> below for a discussion of this.

=end original

全ての Perl バージョンで、C<\s> は [\t\n\f\r ] の 5 文字にマッチングします;
つまり、水平タブ、改行、改頁、復帰、スペースです。
Perl 5.18 から、垂直タブ C<\cK> にもマッチングします。
ここでの議論については後述する C<[1]> を参照してください。

=item otherwise ...

(さもなければ ...)

=over

=item For code points above 255 ...

(256 以上の符号位置では ...)

=begin original

C<\s> matches exactly the code points above 255 shown with an "s" column
in the table below.

=end original

C<\s> は、後述する表の "s" の列で示されている、
255 を超える符号位置に正確にマッチングします。

=item For code points below 256 ...

(255 以下の符号位置では ...)

=over

=item if locale rules are in effect ...

(ロケール規則が有効なら ...)

=begin original

C<\s> matches whatever the locale considers to be whitespace.

=end original

C<\s> はロケールが空白だと考えるものにマッチングします。

=item if, instead, Unicode rules are in effect ...

(そうではなく、Unicode 規則が有効なら ...)

=begin original

C<\s> matches exactly the characters shown with an "s" column in the
table below.

=end original

C<\s> は正確に以下の表で "s" の列にある文字にマッチングします。

=item otherwise ...

(さもなければ ...)

=begin original

C<\s> matches [\t\n\f\r ] and, starting in Perl
v5.18, the vertical tab, C<\cK>.
(See note C<[1]> below for a discussion of this.)
Note that this list doesn't include the non-breaking space.

=end original

C<\s> は [\t\n\f\r ] にマッチングし、Perl v5.18 から、
垂直タブ C<\cK> にもマッチングします。
(これの議論については後述する C<[1]> を参照してください。)
この一覧にはノーブレークスペースが含まれていないことに注意してください。

=back

=back

=back

=begin original

Which rules apply are determined as described in L<perlre/Which character set modifier is in effect?>.

=end original

どの規則を適用するかは L<perlre/Which character set modifier is in effect?> で
記述されている方法で決定されます。

=begin original

Any character not matched by C<\s> is matched by C<\S>.

=end original

C<\s> にマッチングしない任意の文字は C<\S> にマッチングします。

=begin original

C<\h> matches any character considered horizontal whitespace;
this includes the platform's space and tab characters and several others
listed in the table below.  C<\H> matches any character
not considered horizontal whitespace.  They use the platform's native
character set, and do not consider any locale that may otherwise be in
use.

=end original

C<\h> は水平空白と考えられる任意の文字にマッチングします; これは
プラットフォームのスペースとタブ文字および以下の表に上げられている
いくつかのその他の文字です。
C<\H> は水平空白と考えられない文字にマッチングします。
これらはプラットフォームのネイティブな文字集合を使い、
他の場所では有効なロケールを考慮しません。

=begin original

C<\v> matches any character considered vertical whitespace;
this includes the platform's carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
C<\V> matches any character not considered vertical whitespace.
They use the platform's native character set, and do not consider any
locale that may otherwise be in use.

=end original

C<\v> は垂直空白と考えられる任意の文字にマッチングします; これは
プラットフォームの復帰と行送り(改行)文字に加えていくつかのその他の文字です;
全ては以下の表に挙げられています。
C<\V> は垂直空白と考えられない任意の文字にマッチングします。
これらはプラットフォームのネイティブな文字集合を使い、
他の場所では有効なロケールを考慮しません。

=begin original

C<\R> matches anything that can be considered a newline under Unicode
rules. It can match a multi-character sequence. It cannot be used inside
a bracketed character class; use C<\v> instead (vertical whitespace).
It uses the platform's
native character set, and does not consider any locale that may
otherwise be in use.
Details are discussed in L<perlrebackslash>.

=end original

C<\R> は Unicode の規則で改行と考えられるものにマッチングします。
複数文字の並びにマッチングすることもあります。
従って、大かっこ文字クラスの中では使えません; 代わりに C<\v> (垂直空白) を
使ってください。
これらはプラットフォームのネイティブな文字集合を使い、
他の場所では有効なロケールを考慮しません。
詳細は L<perlrebackslash> で議論しています。

=begin original

Note that unlike C<\s> (and C<\d> and C<\w>), C<\h> and C<\v> always match
the same characters, without regard to other factors, such as the active
locale or whether the source string is in UTF-8 format.

=end original

C<\s> (および C<\d> と C<\w>) と違って、C<\h> および C<\v> は、現在の
ロケールやソース文字列が UTF-8 形式かどうかといった他の要素に関わらず
同じ文字にマッチングします。

=begin original

One might think that C<\s> is equivalent to C<[\h\v]>. This is indeed true
starting in Perl v5.18, but prior to that, the sole difference was that the
vertical tab (C<"\cK">) was not matched by C<\s>.

=end original

C<\s> が C<[\h\v]> と等価と考える人がいるかもしれません。
Perl 5.18 からはもちろん正しいです; しかしそれより前では、
唯一の違いは、垂直タブ (C<"\xcK">) は C<\s> にマッチングしないということです。

=begin original

The following table is a complete listing of characters matched by
C<\s>, C<\h> and C<\v> as of Unicode 6.3.

=end original

以下の表は Unicode 6.3 現在で C<\s>, C<\h>, C<\v> にマッチングする文字の
完全な一覧です。

=begin original

The first column gives the Unicode code point of the character (in hex format),
the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale is in
effect that changes the C<\s> matching).

=end original

最初の列は文字の Unicode 符号位置(16 進形式)、2 番目の列は (Unicode の)
名前です。
3 番目の列はどのクラスにマッチングするかを示しています
(C<\s> のマッチングを変更するようなロケールが
有効でないことを仮定しています)。

 0x0009        CHARACTER TABULATION   h s
 0x000a              LINE FEED (LF)    vs
 0x000b             LINE TABULATION    vs  [1]
 0x000c              FORM FEED (FF)    vs
 0x000d        CARRIAGE RETURN (CR)    vs
 0x0020                       SPACE   h s
 0x0085             NEXT LINE (NEL)    vs  [2]
 0x00a0              NO-BREAK SPACE   h s  [2]
 0x1680            OGHAM SPACE MARK   h s
 0x2000                     EN QUAD   h s
 0x2001                     EM QUAD   h s
 0x2002                    EN SPACE   h s
 0x2003                    EM SPACE   h s
 0x2004          THREE-PER-EM SPACE   h s
 0x2005           FOUR-PER-EM SPACE   h s
 0x2006            SIX-PER-EM SPACE   h s
 0x2007                FIGURE SPACE   h s
 0x2008           PUNCTUATION SPACE   h s
 0x2009                  THIN SPACE   h s
 0x200a                  HAIR SPACE   h s
 0x2028              LINE SEPARATOR    vs
 0x2029         PARAGRAPH SEPARATOR    vs
 0x202f       NARROW NO-BREAK SPACE   h s
 0x205f   MEDIUM MATHEMATICAL SPACE   h s
 0x3000           IDEOGRAPHIC SPACE   h s

=over 4

=item [1]

=begin original

Prior to Perl v5.18, C<\s> did not match the vertical tab.
C<[^\S\cK]> (obscurely) matches what C<\s> traditionally did.

=end original

Perl v5.18 より前では、C<\s> は垂直タブにマッチングしませんでした。
C<[^\S\cK]> は(ひっそりと)C<\s> が伝統的に
マッチングしていたものにマッチングします。

=item [2]

=begin original

NEXT LINE and NO-BREAK SPACE may or may not match C<\s> depending
on the rules in effect.  See
L<the beginning of this section|/Whitespace>.

=end original

NEXT LINE と NO-BREAK SPACE はどの規則が有効かによって C<\s> に
マッチングしたりマッチングしなかったりします。
L<the beginning of this section|/Whitespace> を参照してください。

=back

=head3 Unicode Properties

(Unicode 特性)

=begin original

C<\pP> and C<\p{Prop}> are character classes to match characters that fit given
Unicode properties.  One letter property names can be used in the C<\pP> form,
with the property name following the C<\p>, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like C<\p{name=value}>,
which means to match if the property "name" for the character has that particular
"value".
For instance, a match for a number can be written as C</\pN/> or as
C</\p{Number}/>, or as C</\p{Number=True}/>.
Lowercase letters are matched by the property I<Lowercase_Letter> which
has the short form I<Ll>. They need the braces, so are written as C</\p{Ll}/> or
C</\p{Lowercase_Letter}/>, or C</\p{General_Category=Lowercase_Letter}/>
(the underscores are optional).
C</\pLl/> is valid, but means something different.
It matches a two character string: a letter (Unicode property C<\pL>),
followed by a lowercase C<l>.

=end original

C<\pP> と C<\p{Prop}> は指定された Unicode 特性に一致する文字に
マッチングする文字クラスです。
一文字特性は C<\pP> 形式で、C<\p> に引き続いて特性名です; さもなければ
中かっこが必要です。
中かっこを使うとき、単に特性名を中かっこで囲んだ単一形式と、
C<\p{name=value}> のような形で、文字の特性 "name" が特定の "value" を
持つものにマッチングすることになる複合形式があります。
例えば、数字にマッチングするものは C</\pN/> または C</\p{Number}/> または
C</\p{Number=True}/> と書けます。
小文字は I<LowercaseLetter> 特性にマッチングします; これには
I<Ll> と言う短縮形式があります。
中かっこが必要なので、C</\p{Ll}/> または C</\p{Lowercase_Letter}/> または
C</\p{General_Category=Lowercase_Letter}/> と書きます(下線はオプションです)。
C</\pLl/> も妥当ですが、違う意味になります。
これは 2 文字にマッチングします: 英字 (Unicode 特性 C<\pL>)に引き続いて
小文字の C<l> です。

=begin original

What a Unicode property matches is never subject to locale rules, and
if locale rules are not otherwise in effect, the use of a Unicode
property will force the regular expression into using Unicode rules, if
it isn't already.

=end original

Unicode 特性が何にマッチングするかは決してロケールの規則に影響されず、
ロケール規則が有効でない場合、Unicode 特性を使うと
正規表現に (まだそうでなければ) Unicode 規則を使うように強制します。

=begin original

Note that almost all properties are immune to case-insensitive matching.
That is, adding a C</i> regular expression modifier does not change what
they match.  But there are two sets that are affected.  The first set is
C<Uppercase_Letter>,
C<Lowercase_Letter>,
and C<Titlecase_Letter>,
all of which match C<Cased_Letter> under C</i> matching.
The second set is
C<Uppercase>,
C<Lowercase>,
and C<Titlecase>,
all of which match C<Cased> under C</i> matching.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case, so they are C<Cased>, but
aren't considered to be letters, so they aren't C<Cased_Letter>s. They're
actually C<Letter_Number>s.)
This set also includes its subsets C<PosixUpper> and C<PosixLower>, both
of which under C</i> match C<PosixAlpha>.

=end original

ほとんど全ての特性は大文字小文字を無視したマッチングから免除されることに
注意してください。
つまり、C</i> 正規表現修飾子はこれらがマッチングするものに影響を
与えないということです。
しかし、影響を与える二つの集合があります。
一つ目の集合は
C<Uppercase_Letter>,
C<Lowercase_Letter>,
C<Titlecase_Letter> で、全て C</i> マッチングの下で
C<Cased_Letter> にマッチングします。
二つ目の集合は
C<Uppercase>,
C<Lowercase>,
C<Titlecase> で、全てC</i> マッチングの下で
C<Cased> にマッチングします。
(これらの集合の違いは、ローマ数字のような一部のものは、
大文字と小文字があるので C<Cased> ですが、
文字とは扱われないので C<Cased_Letter> ではありません。
これらは実際には C<Letter_Number> です。)
この集合はその部分集合である C<PosixUpper> と C<PosixLower> を含みます;
これら両方は C</i> マッチングの下では C<PosixAlpha> にマッチングします。

=begin original

For more details on Unicode properties, see L<perlunicode/Unicode
Character Properties>; for a
complete list of possible properties, see
L<perluniprops/Properties accessible through \p{} and \P{}>,
which notes all forms that have C</i> differences.
It is also possible to define your own properties. This is discussed in
L<perlunicode/User-Defined Character Properties>.

=end original

Unicode 特性に関するさらなる詳細については、
L<perlunicode/Unicode Character Properties> を参照してください; 特性の完全な
一覧については、C</i> に違いのある全ての形式について記されている
L<perluniprops/Properties accessible through \p{} and \P{}> を参照して
ください。
独自の特性を定義することも可能です。
これは L<perlunicode/User-Defined Character Properties> で
議論されています。

=begin original

Unicode properties are defined (surprise!) only on Unicode code points.
Starting in v5.20, when matching against C<\p> and C<\P>, Perl treats
non-Unicode code points (those above the legal Unicode maximum of
0x10FFFF) as if they were typical unassigned Unicode code points.

=end original

Unicode 特性は (驚くべきことに!) Unicode 符号位置に対してのみ
定義されています。
v5.20 から、C<\p> と C<\P> に対してマッチングするとき、
Perl は
非 Unicode 符号位置 (正当な Unicode の上限の 0x10FFFF を超えるもの) を、
典型的な未割り当て Unicode 符号位置であるかのように扱います。

=begin original

Prior to v5.20, Perl raised a warning and made all matches fail on
non-Unicode code points.  This could be somewhat surprising:

=end original

v5.20 より前では、非 Unicode 符号位置に対しては全てのマッチングは失敗して、
Perl は警告を出していました。
これは驚かされるものだったかもしれません。

 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}     # Fails on Perls < v5.20.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}    # Also fails on Perls
                                               # < v5.20

=begin original

Even though these two matches might be thought of as complements, until
v5.20 they were so only on Unicode code points.

=end original

これら二つのマッチングは補集合と考えるかもしれませんが、
v5.20 まで、これらは Unicode 符号位置だけでした。

=begin original

Starting in perl v5.30, wildcards are allowed in Unicode property
values.  See L<perlunicode/Wildcards in Property Values>.

=end original

perl v5.30 から、Unicode 特性にワイルドカードを使えます。
L<perlunicode/Wildcards in Property Values> を参照してください。

=head4 Examples

(例)

=begin original

 "a"  =~  /\w/      # Match, "a" is a 'word' character.
 "7"  =~  /\w/      # Match, "7" is a 'word' character as well.
 "a"  =~  /\d/      # No match, "a" isn't a digit.
 "7"  =~  /\d/      # Match, "7" is a digit.
 " "  =~  /\s/      # Match, a space is whitespace.
 "a"  =~  /\D/      # Match, "a" is a non-digit.
 "7"  =~  /\D/      # No match, "7" is not a non-digit.
 " "  =~  /\S/      # No match, a space is not non-whitespace.

=end original

 "a"  =~  /\w/      # マッチング; "a" は「単語」文字。
 "7"  =~  /\w/      # マッチング; "7" も「単語」文字。
 "a"  =~  /\d/      # マッチングしない; "a" は数字ではない。
 "7"  =~  /\d/      # マッチング; "7" は数字。
 " "  =~  /\s/      # マッチング; スペースは空白。
 "a"  =~  /\D/      # マッチング; "a" は非数字。
 "7"  =~  /\D/      # マッチングしない; "7" は非数字ではない。
 " "  =~  /\S/      # マッチングしない; スペースは非空白ではない。

=begin original

 " "  =~  /\h/      # Match, space is horizontal whitespace.
 " "  =~  /\v/      # No match, space is not vertical whitespace.
 "\r" =~  /\v/      # Match, a return is vertical whitespace.

=end original

 " "  =~  /\h/      # マッチング; スペースは水平空白。
 " "  =~  /\v/      # マッチングしない; スペースは垂直空白ではない。
 "\r" =~  /\v/      # マッチング; 復帰は垂直空白。

=begin original

 "a"  =~  /\pL/     # Match, "a" is a letter.
 "a"  =~  /\p{Lu}/  # No match, /\p{Lu}/ matches upper case letters.

=end original

 "a"  =~  /\pL/     # マッチング; "a" は英字。
 "a"  =~  /\p{Lu}/  # マッチングしない; /\p{Lu}/ は大文字にマッチングする。

=begin original

 "\x{0e0b}" =~ /\p{Thai}/  # Match, \x{0e0b} is the character
                           # 'THAI CHARACTER SO SO', and that's in
                           # Thai Unicode class.
 "a"  =~  /\P{Lao}/ # Match, as "a" is not a Laotian character.

=end original

 "\x{0e0b}" =~ /\p{Thai}/  # マッチング; \x{0e0b} は文字
                           # 'THAI CHARACTER SO SO' で、これは
                           # Thai Unicode クラスにある。
 "a"  =~  /\P{Lao}/ # マッチング; "a" はラオス文字ではない。

=begin original

It is worth emphasizing that C<\d>, C<\w>, etc, match single characters, not
complete numbers or words. To match a number (that consists of digits),
use C<\d+>; to match a word, use C<\w+>.  But be aware of the security
considerations in doing so, as mentioned above.

=end original

C<\d>, C<\w> などは数値や単語全体ではなく、1 文字にマッチングすることは
強調する価値があります。
(数字で構成される) 数値 にマッチングするには C<\d+> を使います;
単語にマッチングするには C<\w+> を使います。
しかし前述したように、そうする場合のセキュリティ問題について
注意してください。

=head2 Bracketed Character Classes

(かっこ付き文字クラス)

=begin original

The third form of character class you can use in Perl regular expressions
is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: C<[aeiou]>.
This matches one of C<a>, C<e>, C<i>, C<o> or C<u>.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a L<quantifier|perlre/Quantifiers>.  For
instance, C<[aeiou]+> matches one or more lowercase English vowels.

=end original

Perl 正規表現で使える文字クラスの第 3 の形式は大かっこ文字クラスです。
もっとも単純な形式では、以下のように大かっこの中にマッチングする文字を
リストします: C<[aeiou]>.
これは C<a>, C<e>, C<i>, C<o>, C<u> のどれかにマッチングします。
他の文字クラスと同様、正確に一つの文字にマッチングします。
文字クラスで言及した文字で構成されるより長い文字列にマッチングするには、
文字クラスに L<量指定子|perlre/Quantifiers> を付けます。
例えば、C<[aeiou]+> は一つまたはそれ以上の小文字英語母音に
マッチングします。

=begin original

Repeating a character in a character class has no
effect; it's considered to be in the set only once.

=end original

文字クラスの中で文字を繰り返しても効果はありません; 一度だけ現れたものと
考えられます。

=begin original

Examples:

=end original

例:

=begin original

 "e"  =~  /[aeiou]/        # Match, as "e" is listed in the class.
 "p"  =~  /[aeiou]/        # No match, "p" is not listed in the class.
 "ae" =~  /^[aeiou]$/      # No match, a character class only matches
                           # a single character.
 "ae" =~  /^[aeiou]+$/     # Match, due to the quantifier.

=end original

 "e"  =~  /[aeiou]/        # マッチング; "e" はクラスにある。
 "p"  =~  /[aeiou]/        # マッチングしない; "p" はクラスにない。
 "ae" =~  /^[aeiou]$/      # マッチングしない; 一つの文字クラスは
                           # 一文字だけにマッチングする。
 "ae" =~  /^[aeiou]+$/     # マッチング; 量指定子により。

 -------

=begin original

* There are two exceptions to a bracketed character class matching a
single character only.  Each requires special handling by Perl to make
things work:

=end original

* 大かっこ文字クラスは単一の文字にのみマッチングするということには
二つの例外があります。
それぞれは Perl がうまく動くために特別な扱いが必要です:

=over

=item *

=begin original

When the class is to match caselessly under C</i> matching rules, and a
character that is explicitly mentioned inside the class matches a
multiple-character sequence caselessly under Unicode rules, the class
will also match that sequence.  For example, Unicode says that the
letter C<LATIN SMALL LETTER SHARP S> should match the sequence C<ss>
under C</i> rules.  Thus,

=end original

クラスが C</i> マッチング規則の下で大文字小文字を無視したマッチングを
して、クラスの中で明示的に記述された文字が Unicode の規則の下で複数文字並びに
大文字小文字を無視してマッチングするとき、
そのクラスはその並びにもマッチングします。
例えば、Unicode は文字 C<LATIN SMALL LETTER SHARP S> は C</i> 規則の下では
並び C<ss> にマッチングするとしています。
従って:

 'ss' =~ /\A\N{LATIN SMALL LETTER SHARP S}\z/i             # Matches
 'ss' =~ /\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i    # Matches

=begin original

For this to happen, the class must not be inverted (see L</Negation>)
and the character must be explicitly specified, and not be part of a
multi-character range (not even as one of its endpoints).  (L</Character
Ranges> will be explained shortly.) Therefore,

=end original

これが起きるためには、
そのクラスは否定 (L</Negation> 参照) ではなく、
その文字は明示的に指定され、複数文字範囲の一部
(たとえその端でも)でない必要があります。
(L</Character Ranges> は短く説明されています。)
従って:

 'ss' =~ /\A[\0-\x{ff}]\z/ui       # Doesn't match
 'ss' =~ /\A[\0-\N{LATIN SMALL LETTER SHARP S}]\z/ui   # No match
 'ss' =~ /\A[\xDF-\xDF]\z/ui   # Matches on ASCII platforms, since
                               # \xDF is LATIN SMALL LETTER SHARP S,
                               # and the range is just a single
                               # element

=begin original

Note that it isn't a good idea to specify these types of ranges anyway.

=end original

どちらにしろこれらの種類の範囲を指定するのは良い考えではありません。

=item *

=begin original

Some names known to C<\N{...}> refer to a sequence of multiple characters,
instead of the usual single character.  When one of these is included in
the class, the entire sequence is matched.  For example,

=end original

Some names known to 
C<\N{...}> で知られているいくつかの名前は、通常の単一の文字ではなく、
複数の文字の並びを参照します。
その一つがこのクラスに含まれている場合、並び全体がマッチングします。
例えば:

  "\N{TAMIL LETTER KA}\N{TAMIL VOWEL SIGN AU}"
                              =~ / ^ [\N{TAMIL SYLLABLE KAU}]  $ /x;

=begin original

matches, because C<\N{TAMIL SYLLABLE KAU}> is a named sequence
consisting of the two characters matched against.  Like the other
instance where a bracketed class can match multiple characters, and for
similar reasons, the class must not be inverted, and the named sequence
may not appear in a range, even one where it is both endpoints.  If
these happen, it is a fatal error if the character class is within the
scope of L<C<use re 'strict>|re/'strict' mode>, or within an extended
L<C<(?[...])>|/Extended Bracketed Character Classes> class; otherwise
only the first code point is used (with a C<regexp>-type warning
raised).

=end original

これはマッチングします; なぜなら C<\N{TAMIL SYLLABLE KAU}> は
マッチングする二つの文字からなる名前付き並びだからです。
大かっこクラスが複数の文字にマッチングするその他の例と同じように、
そして同様の理由で、クラスは否定できず、
たとえ両端の間であっても名前付き並びは範囲の中には現れません。
これらが起きたとき、文字クラスが
L<C<use re 'strict>|re/'strict' mode> のスコープ内か、
拡張された L<C<(?[...])>|/Extended Bracketed Character Classes> クラスの
中の場合には致命的エラーになります;
さもなければ、最初の符号位置のみが使われます
(そして C<regexp> 系の警告が発生します)。

=back

=head3 Special Characters Inside a Bracketed Character Class

(かっこ付き文字クラスの中の特殊文字)

=begin original

Most characters that are meta characters in regular expressions (that
is, characters that carry a special meaning like C<.>, C<*>, or C<(>) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, C<[()]> matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.  Be aware that, unless the pattern is
evaluated in single-quotish context, variable interpolation will take
place before the bracketed class is parsed:

=end original

正規表現内でメタ文字(つまり、C<.>, C<*>, C<(> のように特別な意味を持つ
文字)となるほとんどの文字は文字クラス内ではエスケープしなくても特別な意味を
失うので、エスケープする必要はありません。
例えば、C<[()]> は開きかっこまたは閉じかっこにマッチングし、文字クラスの中の
かっこはグループや捕捉にはなりません。
パターンがシングルクォート風コンテキストの中で評価されない限り、
変数展開は大かっこクラスがパースされる前に行われることに注意してください:

 $, = "\t| ";
 $a =~ m'[$,]';        # single-quotish: matches '$' or ','
 $a =~ q{[$,]}'        # same
 $a =~ m/[$,]/;        # double-quotish: matches "\t", "|", or " "

=begin original

Characters that may carry a special meaning inside a character class are:
C<\>, C<^>, C<->, C<[> and C<]>, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.

=end original

文字クラスの中でも特別な意味を持つ文字は:
C<\>, C<^>, C<->, C<[>, C<]> で、以下で議論します。
これらは逆スラッシュでエスケープできますが、不要な場合もあり、そのような
場合では逆スラッシュは省略できます。

=begin original

The sequence C<\b> is special inside a bracketed character class. While
outside the character class, C<\b> is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, C<\b> matches a
backspace character.

=end original

シーケンス C<\b> は大かっこ文字クラスの内側では特別です。
文字クラスの外側では C<\b> 二つの単語文字か二つの非単語文字のどちらかではない
位置を示す表明ですが、大かっこ文字クラスの内側では C<\b> は後退文字に
マッチングします。

=begin original

The sequences
C<\a>,
C<\c>,
C<\e>,
C<\f>,
C<\n>,
C<\N{I<NAME>}>,
C<\N{U+I<hex char>}>,
C<\r>,
C<\t>,
and
C<\x>
are also special and have the same meanings as they do outside a
bracketed character class.

=end original

並び
C<\a>,
C<\c>,
C<\e>,
C<\f>,
C<\n>,
C<\N{I<NAME>}>,
C<\N{U+I<hex char>}>,
C<\r>,
C<\t>,
C<\x>
も特別で、大かっこ文字クラスの外側と同じ意味を持ちます。

=begin original

Also, a backslash followed by two or three octal digits is considered an octal
number.

=end original

また、逆スラッシュに引き続いて 2 または 3 桁の 8 進数字があると 8 進数として
扱われます。

=begin original

A C<[> is not special inside a character class, unless it's the start of a
POSIX character class (see L</POSIX Character Classes> below). It normally does
not need escaping.

=end original

C<[> は、POSIX 文字クラス(後述の L</POSIX Character Classes> 参照)の
開始でない限りは文字クラスの中では特別ではありません。
これは普通エスケープは不要です。

=begin original

A C<]> is normally either the end of a POSIX character class (see
L</POSIX Character Classes> below), or it signals the end of the bracketed
character class.  If you want to include a C<]> in the set of characters, you
must generally escape it.

=end original

A C<]> は普通は POSIX 文字クラス(後述の L</POSIX Character Classes> 参照)の
終わりか、大かっこ文字クラスの終了を示すかどちらかです。
文字集合に C<]> を含める必要がある場合、一般的には
エスケープしなければなりません。

=begin original

However, if the C<]> is the I<first> (or the second if the first
character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.

=end original

しかし、C<]> が大かっこ文字クラスの I<最初> (または最初の文字がキャレットなら
2 番目) の文字の場合、(空クラスを作ることはできないので)これはクラスの
終了を意味せず、エスケープなしでマッチングできる文字の集合の一部と
考えられます。

=begin original

Examples:

=end original

例:

=begin original

 "+"   =~ /[+?*]/     #  Match, "+" in a character class is not special.
 "\cH" =~ /[\b]/      #  Match, \b inside in a character class
                      #  is equivalent to a backspace.
 "]"   =~ /[][]/      #  Match, as the character class contains
                      #  both [ and ].
 "[]"  =~ /[[]]/      #  Match, the pattern contains a character class
                      #  containing just [, and the character class is
                      #  followed by a ].

=end original

 "+"   =~ /[+?*]/     #  マッチング; 文字クラス内の "+" は特別ではない。
 "\cH" =~ /[\b]/      #  マッチング; 文字クラスの内側の \b は後退と
                      #  等価。
 "]"   =~ /[][]/      #  マッチング; 文字クラスに [ と ] の両方を
                      #  含んでいる。
 "[]"  =~ /[[]]/      #  マッチング; パターンは [ だけを含んでいる
                      #  文字クラスと、それに引き続く
                      #  ] からなる。

=head3 Bracketed Character Classes and the C</xx> pattern modifier

=begin original

Normally SPACE and TAB characters have no special meaning inside a
bracketed character class; they are just added to the list of characters
matched by the class.  But if the L<C</xx>|perlre/E<sol>x and E<sol>xx>
pattern modifier is in effect, they are generally ignored and can be
added to improve readability.  They can't be added in the middle of a
single construct:

=end original

通常、大かっこ文字クラスの内側では SPACE と TAB の文字は
特別な意味はありません; これらは単にクラスによってマッチングされる文字の
リストに加えられます。
しかし、L<C</xx>|perlre/E<sol>x and E<sol>xx> パターン修飾子が有効の場合、
これらは一般的に無視されるので、可読性を向上させるために追加できます。
これらは単一の構文の中には追加できません:

 / [ \x{10 FFFF} ] /xx  # WRONG!

=begin original

The SPACE in the middle of the hex constant is illegal.

=end original

16 進定数の中の SPACE は不正です。

=begin original

To specify a literal SPACE character, you can escape it with a
backslash, like:

=end original

リテラルな SPACE 文字を指定するには、次のように逆スラッシュで
エスケープします:

 /[ a e i o u \  ]/xx

=begin original

This matches the English vowels plus the SPACE character.

=end original

これは英語の母音と SPACE 文字に一致します。

=begin original

For clarity, you should already have been using C<\t> to specify a
literal tab, and C<\t> is unaffected by C</xx>.

=end original

確認すると、リテラルなタブのためには既に C<\t> を使っているべきで、
C<\t> は C</xx> の影響を受けません。

=head3 Character Ranges

(文字範囲)

=begin original

It is not uncommon to want to match a range of characters. Luckily, instead
of listing all characters in the range, one may use the hyphen (C<->).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, C<[0-9]> matches any ASCII digit, and C<[a-m]>
matches any lowercase letter from the first half of the ASCII alphabet.

=end original

文字のある範囲にマッチングしたいというのは珍しくありません。
幸運なことに、その範囲の文字を全て一覧に書く代わりに、ハイフン (C<->) を
使えます。
大かっこ文字クラスの内側で二つの文字がハイフンで区切られていると、
二つの文字の間の全ての文字がクラスに書かれているかのように扱われます。
例えば、C<[0-9]> は任意の ASCII 数字にマッチングし、C<[a-m]> は
ASCII アルファベットの前半分の小文字にマッチングします。

=begin original

Note that the two characters on either side of the hyphen are not
necessarily both letters or both digits. Any character is possible,
although not advisable.  C<['-?]> contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as EBCDIC.

=end original

ハイフンのそれぞれの側の二つの文字は両方とも英字であったり両方とも
数字であったりする必要はないことに注意してください。
任意の文字が可能ですが、勧められません。
C<['-?]> は文字の範囲を含みますが、ほとんどの人はどの文字が含まれるか
分かりません。
さらに、このような範囲は、コードが EBCDIC のような異なった文字集合を使う
プラットフォームで実行されると移植性の問題を引き起こします。

=begin original

If a hyphen in a character class cannot syntactically be part of a range, for
instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.

=end original

例えば文字クラスの最初または最後であったり、範囲の直後のために、文字クラスの
中のハイフンが文法的に範囲の一部となれない場合、ハイフンは特別ではなく、
リテラルにマッチングするべき文字として扱われます。
マッチングする文字の集合にハイフンを入れたいけれどもその位置が範囲の
一部として考えられる場合はハイフンを逆スラッシュで
エスケープしなければなりません。

=begin original

Examples:

=end original

例:

=begin original

 [a-z]       #  Matches a character that is a lower case ASCII letter.
 [a-fz]      #  Matches any letter between 'a' and 'f' (inclusive) or
             #  the letter 'z'.
 [-z]        #  Matches either a hyphen ('-') or the letter 'z'.
 [a-f-m]     #  Matches any letter between 'a' and 'f' (inclusive), the
             #  hyphen ('-'), or the letter 'm'.
 ['-?]       #  Matches any of the characters  '()*+,-./0123456789:;<=>?
             #  (But not on an EBCDIC platform).
 [\N{APOSTROPHE}-\N{QUESTION MARK}]
             #  Matches any of the characters  '()*+,-./0123456789:;<=>?
             #  even on an EBCDIC platform.
 [\N{U+27}-\N{U+3F}] # Same. (U+27 is "'", and U+3F is "?")

=end original

 [a-z]       #  小文字 ASCII 英字にマッチング。
 [a-fz]      #  'a' から 'f' の英字およびと 'z' の英字に
             #  マッチング。
 [-z]        #  ハイフン ('-') または英字 'z' にマッチング。
 [a-f-m]     #  'a' から 'f' の英字、ハイフン ('-')、英字 'm' に
             #  マッチング。
 ['-?]       #  文字 '()*+,-./0123456789:;<=>? のどれかにマッチング
             #  (しかし EBCDIC プラットフォームでは異なります)。
 [\N{APOSTROPHE}-\N{QUESTION MARK}]
             #  たとえ EBCDIC プラットフォームでも '()*+,-./0123456789:;<=>?
             #  のいずれかの文字にマッチング。
 [\N{U+27}-\N{U+3F}] # 同じ。 (U+27 は "'", U+3F は "?")

=begin original

As the final two examples above show, you can achieve portability to
non-ASCII platforms by using the C<\N{...}> form for the range
endpoints.  These indicate that the specified range is to be interpreted
using Unicode values, so C<[\N{U+27}-\N{U+3F}]> means to match
C<\N{U+27}>, C<\N{U+28}>, C<\N{U+29}>, ..., C<\N{U+3D}>, C<\N{U+3E}>,
and C<\N{U+3F}>, whatever the native code point versions for those are.
These are called "Unicode" ranges.  If either end is of the C<\N{...}>
form, the range is considered Unicode.  A C<regexp> warning is raised
under C<S<"use re 'strict'">> if the other endpoint is specified
non-portably:

=end original

前述の最後の二つの例が示すように、範囲の端点に
C<\N{...}> 形式を使用することで、非 ASCII プラットフォームへの
移植性を実現できます。
これらは、指定された範囲が Unicode 値を使用して解釈されることを示しています;
したがって、C<[\N{U+27}-\N{U+3F}]>は、C<\N{U+27}>、C<\N{U+28}>、
C<\N{U+29}>、...、C<\N{U+3D}>、C<\N{U+3E}>、C<\N{U+3F}> に
マッチングすることを意味します;
これらのネイティブ符号位置のバージョンが何であっても一致します。
これらは "Unicode" 範囲と呼ばれます。
いずれかの端点が C<\N{...}> 形式の場合、範囲は Unicode と見なされます。
もう一方の端点が移植性がない形で指定されている場合、
C<S<"use re 'strict'">> の下で C<regexp> 警告が発生します:

 [\N{U+00}-\x09]    # Warning under re 'strict'; \x09 is non-portable
 [\N{U+00}-\t]      # No warning;

=begin original

Both of the above match the characters C<\N{U+00}> C<\N{U+01}>, ...
C<\N{U+08}>, C<\N{U+09}>, but the C<\x09> looks like it could be a
mistake so the warning is raised (under C<re 'strict'>) for it.

=end original

前述の両方とも文字 C<\N{U+00}> C<\N{U+01}>, ...
C<\N{U+08}>, C<\N{U+09}> にマッチングしますが、
C<\x09> は誤りのように見えるので、
(C<re 'strict'> の下で) 警告が発生します。

=begin original

Perl also guarantees that the ranges C<A-Z>, C<a-z>, C<0-9>, and any
subranges of these match what an English-only speaker would expect them
to match on any platform.  That is, C<[A-Z]> matches the 26 ASCII
uppercase letters;
C<[a-z]> matches the 26 lowercase letters; and C<[0-9]> matches the 10
digits.  Subranges, like C<[h-k]>, match correspondingly, in this case
just the four letters C<"h">, C<"i">, C<"j">, and C<"k">.  This is the
natural behavior on ASCII platforms where the code points (ordinal
values) for C<"h"> through C<"k"> are consecutive integers (0x68 through
0x6B).  But special handling to achieve this may be needed on platforms
with a non-ASCII native character set.  For example, on EBCDIC
platforms, the code point for C<"h"> is 0x88, C<"i"> is 0x89, C<"j"> is
0x91, and C<"k"> is 0x92.   Perl specially treats C<[h-k]> to exclude the
seven code points in the gap: 0x8A through 0x90.  This special handling is
only invoked when the range is a subrange of one of the ASCII uppercase,
lowercase, and digit ranges, AND each end of the range is expressed
either as a literal, like C<"A">, or as a named character (C<\N{...}>,
including the C<\N{U+...> form).

=end original

Perl はまた、範囲 C<A-Z>、C<a-z>、C<0-9>、およびこれらの部分範囲が、
英語のみの話者が一致すると予想する範囲とどのプラットフォームでも
一致することを保証します。
つまり、C<[A-Z]> はASCII の大文字 26 文字と一致します;
C<[a-z]> は小文字 26 文字と一致します;
C<[0-9]>は 10 の数字と一致します。
C<[h-k]> のような部分範囲もこれに対応して一致します;
この場合、4 文字 C<"h">、C<"i">、C<"j">、C<"k"> だけが一致します。
これは、C<"h"> から C<"k"> までの符号位置(序数値)が連続した
整数(0x68 から 0x6B)である ASCII プラットフォームでの自然な動作です。
しかし、非 ASCII ネイティブ文字集合を持つプラットフォームでは、
これを実現するための特別な処理が必要になるかもしれません。
たとえば、EBCDIC プラットフォームでは、C<"h"> のコードポイントは
0x88、C<"i"> は 0x89、C<"j"> は 0x91、C<"k"> は 0x92 です。
Perl は C<[h-k]> を特別に扱い、隙間にある七つの符号位置
(0x8A から 0x90)を除外します。
この特殊処理は、範囲が ASCII の大文字、小文字、数字の範囲の
いずれかの部分範囲であり、範囲の両端が C<"A"> のようなリテラル
または名前付き文字(C<\N{...}>(C<\N{U+...> 形式を含む))として表現されている
場合にのみ呼び出されます。

=begin original

EBCDIC Examples:

=end original

EBCDIC の例:

 [i-j]               #  Matches either "i" or "j"
 [i-\N{LATIN SMALL LETTER J}]  # Same
 [i-\N{U+6A}]        #  Same
 [\N{U+69}-\N{U+6A}] #  Same
 [\x{89}-\x{91}]     #  Matches 0x89 ("i"), 0x8A .. 0x90, 0x91 ("j")
 [i-\x{91}]          #  Same
 [\x{89}-j]          #  Same
 [i-J]               #  Matches, 0x89 ("i") .. 0xC1 ("J"); special
                     #  handling doesn't apply because range is mixed
                     #  case

=head3 Negation

(否定)

=begin original

It is also possible to instead list the characters you do not want to
match. You can do so by using a caret (C<^>) as the first character in the
character class. For instance, C<[^a-z]> matches any character that is not a
lowercase ASCII letter, which therefore includes more than a million
Unicode code points.  The class is said to be "negated" or "inverted".

=end original

代わりにマッチングしたくない文字の一覧を指定することも可能です。
文字クラスの先頭の文字としてキャレット (C<^>) を使うことで実現します。
例えば、C<[^a-z]> 小文字の ASCII 英字以外の文字にマッチングします;
従って 100 万種類以上の Unicode 符号位置が含まれます。
このクラスは「否定」("negated") や「反転」("inverted")と呼ばれます。

=begin original

This syntax make the caret a special character inside a bracketed character
class, but only if it is the first character of the class. So if you want
the caret as one of the characters to match, either escape the caret or
else don't list it first.

=end original

この文法はキャレットを大かっこ文字クラスの内側で特別な文字にしますが、
クラスの最初の文字の場合のみです。
それでマッチングしたい文字の一つでキャレットを使いたい場合、キャレットを
エスケープするか、最初以外の位置に書いてください。

=begin original

In inverted bracketed character classes, Perl ignores the Unicode rules
that normally say that named sequence, and certain characters should
match a sequence of multiple characters use under caseless C</i>
matching.  Following those rules could lead to highly confusing
situations:

=end original

否定大かっこ文字クラスでは、通常は大文字小文字を無視した C</i> マッチングの
下では名前空間とある種の文字が複数の文字並びにマッチングするということを
Perl は無視します。
これらの規則に従うととても混乱する状況を引き起こすことになるからです:

 "ss" =~ /^[^\xDF]+$/ui;   # Matches!

=begin original

This should match any sequences of characters that aren't C<\xDF> nor
what C<\xDF> matches under C</i>.  C<"s"> isn't C<\xDF>, but Unicode
says that C<"ss"> is what C<\xDF> matches under C</i>.  So which one
"wins"? Do you fail the match because the string has C<ss> or accept it
because it has an C<s> followed by another C<s>?  Perl has chosen the
latter.  (See note in L</Bracketed Character Classes> above.)

=end original

これは C</i> の下では C<\xDF> または C<\xDF> にマッチングするもの以外の
任意の文字並びにマッチングするべきです。
C<"s"> は C<\xDF> ではありませんが、
C</i> の下では C<"ss"> は C<\xDF> がマッチングするものと Unicode は
言っています。
ではどちらが「勝つ」のでしょうか?
文字列は C<ss> だからマッチングに失敗するのでしょうか、
それともこれは C<s> の後にもう一つの C<s> があるから成功するのでしょうか?
Perl は後者を選択しました。
(前述の L</Bracketed Character Classes> を参照してください。)

=begin original

Examples:

=end original

例:

=begin original

 "e"  =~  /[^aeiou]/   #  No match, the 'e' is listed.
 "x"  =~  /[^aeiou]/   #  Match, as 'x' isn't a lowercase vowel.
 "^"  =~  /[^^]/       #  No match, matches anything that isn't a caret.
 "^"  =~  /[x^]/       #  Match, caret is not special here.

=end original

 "e"  =~  /[^aeiou]/   #  マッチングしない; 'e' がある。
 "x"  =~  /[^aeiou]/   #  マッチング; 'x' は小文字の母音ではない。
 "^"  =~  /[^^]/       #  マッチングしない; キャレット以外全てにマッチング。
 "^"  =~  /[x^]/       #  マッチング; キャレットはここでは特別ではない。

=head3 Backslash Sequences

(逆スラッシュシーケンス)

=begin original

You can put any backslash sequence character class (with the exception of
C<\N> and C<\R>) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, C<[a-f\d]> matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.

=end original

大かっこ文字クラスの中に(C<\N> と C<\R> を例外として)逆スラッシュシーケンス
文字クラスを置くことができ、逆スラッシュシーケンスにマッチングする全ての
文字を文字クラスの中に置いたかのように動作します。
例えば、C<[a-f\d]> は任意の 10 進数字、あるいは 'a' から 'f' までの小文字に
マッチングします。

=begin original

C<\N> within a bracketed character class must be of the forms C<\N{I<name>}>
or C<\N{U+I<hex char>}>, and NOT be the form that matches non-newlines,
for the same reason that a dot C<.> inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.

=end original

大かっこ文字クラスの中のドット C<.> が特別な意味を持たないのと同じ理由で、
大かっこ文字クラスの中の C<\N> は C<\N{I<name>}> または
C<\N{U+I<hex char>}> の形式で、かつ非改行マッチング形式でない形でなければ
なりません: これはほとんど何でもマッチングするので、一般的には起こって
欲しいことではありません。

=begin original

Examples:

=end original

例:

=begin original

 /[\p{Thai}\d]/     # Matches a character that is either a Thai
                    # character, or a digit.
 /[^\p{Arabic}()]/  # Matches a character that is neither an Arabic
                    # character, nor a parenthesis.

=end original

 /[\p{Thai}\d]/     # タイ文字または数字の文字に
                    # マッチングする。
 /[^\p{Arabic}()]/  # アラビア文字でもかっこでもない文字に
                    # マッチングする。

=begin original

Backslash sequence character classes cannot form one of the endpoints
of a range.  Thus, you can't say:

=end original

逆スラッシュシーケンス文字クラスは範囲の端点の一つにはできません。
従って、以下のようにはできません:

 /[\p{Thai}-\d]/     # Wrong!

=head3 POSIX Character Classes
X<character class> X<\p> X<\p{}>
X<alpha> X<alnum> X<ascii> X<blank> X<cntrl> X<digit> X<graph>
X<lower> X<print> X<punct> X<space> X<upper> X<word> X<xdigit>

(POSIX 文字クラス)

=begin original

POSIX character classes have the form C<[:class:]>, where I<class> is the
name, and the C<[:> and C<:]> delimiters. POSIX character classes only appear
I<inside> bracketed character classes, and are a convenient and descriptive
way of listing a group of characters.

=end original

POSIX 文字クラスは C<[:class:]> の形式で、I<class> は名前、C<[:> と C<:]> は
デリミタです。
POSIX 文字クラスは大かっこ文字クラスの I<内側> にのみ現れ、文字のグループを
一覧するのに便利で記述的な方法です。

=begin original

Be careful about the syntax,

=end original

文法について注意してください、

 # Correct:
 $string =~ /[[:alpha:]]/

 # Incorrect (will warn):
 $string =~ /[:alpha:]/

=begin original

The latter pattern would be a character class consisting of a colon,
and the letters C<a>, C<l>, C<p> and C<h>.
POSIX character classes can be part of a larger bracketed character class.
For example,

=end original

後者のパターンは、コロンおよび C<a>, C<l>, C<p>, C<h> の文字からなる
文字クラスです。
これら文字クラスはより大きな大かっこ文字クラスの一部にできます。
例えば、

 [01[:alpha:]%]

=begin original

is valid and matches '0', '1', any alphabetic character, and the percent sign.

=end original

これは妥当で、'0'、'1'、任意の英字、パーセントマークにマッチングします。

=begin original

Perl recognizes the following POSIX character classes:

=end original

Perl は以下の POSIX 文字クラスを認識します:

=begin original

 alpha  Any alphabetical character (e.g., [A-Za-z]).
 alnum  Any alphanumeric character (e.g., [A-Za-z0-9]).
 ascii  Any character in the ASCII character set.
 blank  A GNU extension, equal to a space or a horizontal tab ("\t").
 cntrl  Any control character.  See Note [2] below.
 digit  Any decimal digit (e.g., [0-9]), equivalent to "\d".
 graph  Any printable character, excluding a space.  See Note [3] below.
 lower  Any lowercase character (e.g., [a-z]).
 print  Any printable character, including a space.  See Note [4] below.
 punct  Any graphical character excluding "word" characters.  Note [5].
 space  Any whitespace character. "\s" including the vertical tab
        ("\cK").
 upper  Any uppercase character (e.g., [A-Z]).
 word   A Perl extension (e.g., [A-Za-z0-9_]), equivalent to "\w".
 xdigit Any hexadecimal digit (e.g., [0-9a-fA-F]).  Note [7].

=end original

 alpha  任意の英字 (例: [A-Za-z])。
 alnum  任意の英数字。(例: [A-Za-z0-9])
 ascii  任意の ASCII 文字集合の文字。
 blank  GNU 拡張; スペースまたは水平タブ (\t) と同じ。
 cntrl  任意の制御文字。後述の [2] 参照。
 digit  任意の 10 進数字 (例: [0-9]); "\d" と等価。
 graph  任意の表示文字; スペースを除く。後述の [3] 参照。
 lower  任意の小文字 (例: [a-z])。
 print  任意の表示文字; スペースを含む。後述の [4] 参照。
 punct  任意の「単語」文字を除く表示文字。[5] 参照。
 space  任意の空白文字。水平タブ ("\cK") を含む "\s"。
 upper  任意の大文字 (例: [A-Z])。
 word   Perl 拡張 (例: [A-Za-z0-9_]); "\w" と等価。
 xdigit 任意の 16 進文字 (例: [0-9a-fA-F])。[7] 参照。

=begin original

Like the L<Unicode properties|/Unicode Properties>, most of the POSIX
properties match the same regardless of whether case-insensitive (C</i>)
matching is in effect or not.  The two exceptions are C<[:upper:]> and
C<[:lower:]>.  Under C</i>, they each match the union of C<[:upper:]> and
C<[:lower:]>.

=end original

L<Unicode properties|/Unicode Properties> と同様、
ほとんどの POSIX 特性は、大文字小文字無視 (C</i>) が有効かどうかに関わらず
同じものにマッチングします。
二つの例外は C<[:upper:]> と C<[:lower:]> です。
C</i> の下では、これらそれぞれ C<[:upper:]> と C<[:lower:]> の和集合に
マッチングします。

=begin original

Most POSIX character classes have two Unicode-style C<\p> property
counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between POSIX character classes and these counterparts.

=end original

ほとんどの POSIX 文字クラスには、対応する二つの Unicode 式の C<\p> 特性が
あります。
(これは公式 Unicode 特性ではなく、公式 Unicode 特性から派生した Perl
エクステンションです。)
以下の表は POSIX 文字クラスと対応するものとの関連を示します。

=begin original

One counterpart, in the column labelled "ASCII-range Unicode" in
the table, matches only characters in the ASCII character set.

=end original

対応物の一つである、表で "ASCII-range Unicode" と書かれた列のものは、
ASCII 文字集合の文字にのみマッチングします。

=begin original

The other counterpart, in the column labelled "Full-range Unicode", matches any
appropriate characters in the full Unicode character set.  For example,
C<\p{Alpha}> matches not just the ASCII alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
An entry in the column labelled "backslash sequence" is a (short)
equivalent.

=end original

もう一つの対応物である、"Full-range Unicode" と書かれた列のものは、
Unicode 文字集合全体の中の適切な任意の文字にマッチングします。
例えば、C<\p{Alpha}> は単に ASCII アルファベット文字だけでなく、
Unicode 文字集合全体の中からアルファベットと考えられる任意の文字に
マッチングします。
"backslash sequence" の列は (短い) 同義語です。

 [[:...:]]      ASCII-range          Full-range  backslash  Note
                 Unicode              Unicode     sequence
 -----------------------------------------------------
   alpha      \p{PosixAlpha}       \p{XPosixAlpha}
   alnum      \p{PosixAlnum}       \p{XPosixAlnum}
   ascii      \p{ASCII}
   blank      \p{PosixBlank}       \p{XPosixBlank}  \h      [1]
                                   or \p{HorizSpace}        [1]
   cntrl      \p{PosixCntrl}       \p{XPosixCntrl}          [2]
   digit      \p{PosixDigit}       \p{XPosixDigit}  \d
   graph      \p{PosixGraph}       \p{XPosixGraph}          [3]
   lower      \p{PosixLower}       \p{XPosixLower}
   print      \p{PosixPrint}       \p{XPosixPrint}          [4]
   punct      \p{PosixPunct}       \p{XPosixPunct}          [5]
              \p{PerlSpace}        \p{XPerlSpace}   \s      [6]
   space      \p{PosixSpace}       \p{XPosixSpace}          [6]
   upper      \p{PosixUpper}       \p{XPosixUpper}
   word       \p{PosixWord}        \p{XPosixWord}   \w
   xdigit     \p{PosixXDigit}      \p{XPosixXDigit}         [7]

=over 4

=item [1]

=begin original

C<\p{Blank}> and C<\p{HorizSpace}> are synonyms.

=end original

C<\p{Blank}> と C<\p{HorizSpace}> は同義語です。

=item [2]

=begin original

Control characters don't produce output as such, but instead usually control
the terminal somehow: for example, newline and backspace are control characters.
On ASCII platforms, in the ASCII range, characters whose code points are
between 0 and 31 inclusive, plus 127 (C<DEL>) are control characters; on
EBCDIC platforms, their counterparts are control characters.

=end original

制御文字はそれ自体は出力されず、普通は何か端末を制御します: 例えば
改行と後退は制御文字です。
ASCII プラットフォームで、ASCII の範囲では、符号位置が 0 から 31 までの
範囲の文字および 127 (C<DEL>) が制御文字です;
EBCDIC プラットフォームでは、対応するものは制御文字です。

=item [3]

=begin original

Any character that is I<graphical>, that is, visible. This class consists
of all alphanumeric characters and all punctuation characters.

=end original

I<graphical>、つまり見える文字。
このクラスは全ての英数字と全ての句読点文字。

=item [4]

=begin original

All printable characters, which is the set of all graphical characters
plus those whitespace characters which are not also controls.

=end original

全ての表示可能な文字; 全ての graphical 文字に加えて制御文字でない空白文字。

=item [5]

=begin original

C<\p{PosixPunct}> and C<[[:punct:]]> in the ASCII range match all
non-controls, non-alphanumeric, non-space characters:
C<[-!"#$%&'()*+,./:;<=E<gt>?@[\\\]^_`{|}~]> (although if a locale is in effect,
it could alter the behavior of C<[[:punct:]]>).

=end original

ASCII の範囲の C<\p{PosixPunct}> と C<[[:punct:]]> は全ての非制御、非英数字、
非空白文字にマッチングします:
C<[-!"#$%&'()*+,./:;<=E<gt>?@[\\\]^_`{|}~]> (しかしロケールが有効なら、
C<[[:punct:]]> の振る舞いが変わります)。

=begin original

The similarly named property, C<\p{Punct}>, matches a somewhat different
set in the ASCII range, namely
C<[-!"#%&'()*,./:;?@[\\\]_{}]>.  That is, it is missing the nine
characters C<[$+E<lt>=E<gt>^`|~]>.
This is because Unicode splits what POSIX considers to be punctuation into two
categories, Punctuation and Symbols.

=end original

似たような名前の特性 C<\p{Punct}> は、ASCII 範囲の異なる集合である
C<[-!"#%&'()*,./:;?@[\\\]_{}]> にマッチングします。
つまり、C<[$+E<lt>=E<gt>^`|~]> の 9 文字はありません。
これは、Unicode は POSIX が句読点と考えるものを二つのカテゴリ
Punctuation と Symbols に分けているからです。

=begin original

C<\p{XPosixPunct}> and (under Unicode rules) C<[[:punct:]]>, match what
C<\p{PosixPunct}> matches in the ASCII range, plus what C<\p{Punct}>
matches.  This is different than strictly matching according to
C<\p{Punct}>.  Another way to say it is that
if Unicode rules are in effect, C<[[:punct:]]> matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.

=end original

C<\p{XPosixPunct}> と (Unicode の規則の下での) C<[[:punct:]]> は、
ASCII の範囲で C<\p{PosixPunct}> がマッチングする物に加えて、
C<\p{Punct}> がマッチングする物にマッチングします。
これは C<\p{Punct}> に従って正確にマッチングする物と異なります。
Unicode 規則が有効な場合のもう一つの言い方は、C<[[:punct:]]> は Unicode が
句読点として扱うものに加えて、Unicode が "symbols" として扱う ASCII 範囲の
全ての文字にマッチングします。

=item [6]

=begin original

C<\p{XPerlSpace}> and C<\p{Space}> match identically starting with Perl
v5.18.  In earlier versions, these differ only in that in non-locale
matching, C<\p{XPerlSpace}> did not match the vertical tab, C<\cK>.
Same for the two ASCII-only range forms.

=end original

C<\p{XPerlSpace}> と C<\p{Space}> は、Perl v5.18 からは同じように
マッチングします。
以前のバージョンでは、これらの違いは、非ロケールマッチングでは
C<\p{XPerlSpace}> は垂直タブ C<\cK> にもマッチングしないということだけです。
二つの ASCII のみの範囲の形式では同じです。

=item [7]

=begin original

Unlike C<[[:digit:]]> which matches digits in many writing systems, such
as Thai and Devanagari, there are currently only two sets of hexadecimal
digits, and it is unlikely that more will be added.  This is because you
not only need the ten digits, but also the six C<[A-F]> (and C<[a-f]>)
to correspond.  That means only the Latin script is suitable for these,
and Unicode has only two sets of these, the familiar ASCII set, and the
fullwidth forms starting at U+FF10 (FULLWIDTH DIGIT ZERO).

=end original

タイ文字やデバナーガリ文字のように多くの書記体系の数字にマッチングする
C<[[:digit:]]> と異なり、16 進数の二つの集合だけで、これ以上追加されることは
おそらくありません。
これは、対応するのに 10 の数字だけでなく、6 個の C<[A-F]> (および C<[a-f]>) も
必要だからです。
これは、Latin 用字のみがこれらに適合していて、
Unicode はこれらの二つの集合、つまり慣れ親しんだ
ASCII 集合と、U+FF10 (FULLWIDTH DIGIT ZERO) から始まる全角形式のみを
持つということです。

=back

=begin original

There are various other synonyms that can be used besides the names
listed in the table.  For example, C<\p{XPosixAlpha}> can be written as
C<\p{Alpha}>.  All are listed in
L<perluniprops/Properties accessible through \p{} and \P{}>.

=end original

表に挙げられている名前以外にも様々なその他の同義語が使えます。
例えば、C<\p{XPosixAlpha}> は C<\p{Alpha}> と書けます。
全ての一覧は
L<perluniprops/Properties accessible through \p{} and \P{}> に
あります。

=begin original

Both the C<\p> counterparts always assume Unicode rules are in effect.
On ASCII platforms, this means they assume that the code points from 128
to 255 are Latin-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin-1 or UTF-8.  In contrast, the
POSIX character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:

=end original

C<\p> に対応するものの両方は常に Unicode の規則が有効であることを仮定します。
これは、ASCII プラットフォームでは、128 から 255 の符号位置は
Latin-1 であることを仮定するということで、ロケールの規則の下で
これらを使うということは、ロケールが Latin-1 か UTF-8 であることが
補償されていない限り賢明ではないということです。
一方、POSIX 文字クラスはロケールの規則の下で有用です。
これらは次のように、実際に有効な規則に影響を受けます:

=over

=item If the C</a> modifier, is in effect ...

(C</a> が有効なら...)

=begin original

Each of the POSIX classes matches exactly the same as their ASCII-range
counterparts.

=end original

それぞれの POSIX クラスは ASCII の範囲で対応する正確に同じものに
マッチングします。

=item otherwise ...

(さもなければ ...)

=over

=item For code points above 255 ...

(256 以上の符号位置では ...)

=begin original

The POSIX class matches the same as its Full-range counterpart.

=end original

POSIX クラスはその Full の範囲で対応する同じものにマッチングします。

=item For code points below 256 ...

(255 以下の符号位置では ...)

=over

=item if locale rules are in effect ...

(ロケール規則が有効なら ...)

=begin original

The POSIX class matches according to the locale, except:

=end original

POSIX クラスはロケールに従ってマッチングします; 例外は:

=over

=item C<word>

=begin original

also includes the platform's native underscore character, no matter what
the locale is.

=end original

それに加えて、ロケールが何かに関わらず、プラットフォームのネイティブな
下線文字を使います。

=item C<ascii>

=begin original

on platforms that don't have the POSIX C<ascii> extension, this matches
just the platform's native ASCII-range characters.

=end original

POSIX C<ascii> 拡張を持たないプラットフォームでは、
これは単にプラットフォームのネイティブな ASCII の範囲の文字に
マッチングします。

=item C<blank>

=begin original

on platforms that don't have the POSIX C<blank> extension, this matches
just the platform's native tab and space characters.

=end original

on platforms that don't have the 
POSIX C<blank> 格調を持たないプラットフォームでは、
これは単にプラットフォームのネイティブなタブとすぺーす文字に
マッチングします。

=back

=item if, instead, Unicode rules are in effect ...

(そうではなく、Unicode 規則が有効なら ...)

=begin original

The POSIX class matches the same as the Full-range counterpart.

=end original

POSIX クラスは Full の範囲の対応する同じものにマッチングします。

=item otherwise ...

(さもなければ ...)

=begin original

The POSIX class matches the same as the ASCII range counterpart.

=end original

POSIX クラスは ASCII の範囲の同じものにマッチングします。

=back

=back

=back

=begin original

Which rules apply are determined as described in
L<perlre/Which character set modifier is in effect?>.

=end original

どの規則を適用するかは L<perlre/Which character set modifier is in effect?> で
記述されている方法で決定されます。

=head4 Negation of POSIX character classes
X<character class, negation>

(POSIX 文字クラスの否定)

=begin original

A Perl extension to the POSIX character class is the ability to
negate it. This is done by prefixing the class name with a caret (C<^>).
Some examples:

=end original

POSIX 文字クラスに対する Perl の拡張は否定の機能です。
これはクラス名の前にキャレット (C<^>) を置くことで実現します。
いくつかの例です:

     POSIX         ASCII-range     Full-range  backslash
                    Unicode         Unicode    sequence
 -----------------------------------------------------
 [[:^digit:]]   \P{PosixDigit}  \P{XPosixDigit}   \D
 [[:^space:]]   \P{PosixSpace}  \P{XPosixSpace}
                \P{PerlSpace}   \P{XPerlSpace}    \S
 [[:^word:]]    \P{PerlWord}    \P{XPosixWord}    \W

=begin original

The backslash sequence can mean either ASCII- or Full-range Unicode,
depending on various factors as described in L<perlre/Which character set modifier is in effect?>.

=end original

逆スラッシュシーケンスは ASCII- か Full-range Unicode のどちらかを意味します;
どちらが使われるかは L<perlre/Which character set modifier is in effect?> で
記述されている様々な要素に依存します。

=head4 [= =] and [. .]

([= =] と [. .])

=begin original

Perl recognizes the POSIX character classes C<[=class=]> and
C<[.class.]>, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.

=end original

Perl は POSIX 文字クラス C<[=class=]> と C<[.class.]> を認識しますが、
これらには(まだ?)対応していません。
このような構文を使おうとすると例外が発生します。

=head4 Examples

(例)

=begin original

 /[[:digit:]]/            # Matches a character that is a digit.
 /[01[:lower:]]/          # Matches a character that is either a
                          # lowercase letter, or '0' or '1'.
 /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
                          # except the letters 'a' to 'f' and 'A' to
                          # 'F'.  This is because the main character
                          # class is composed of two POSIX character
                          # classes that are ORed together, one that
                          # matches any digit, and the other that
                          # matches anything that isn't a hex digit.
                          # The OR adds the digits, leaving only the
                          # letters 'a' to 'f' and 'A' to 'F' excluded.

=end original

 /[[:digit:]]/            # 数字の文字にマッチングする。
 /[01[:lower:]]/          # 小文字、'0'、'1' のいずれかの文字に
                          # マッチングする。
 /[[:digit:][:^xdigit:]]/ # 'a' から 'f' と 'A' から 'F' 以外の任意の文字に
                          # マッチング。これはメインの文字クラスでは二つの
                          # POSIX 文字クラスが OR され、一つは任意の数字に
                          # マッチングし、もう一つは 16 進文字でない全ての
                          # 文字にマッチングします。OR は数字を加え、
                          # 'a' から 'f' および 'A' から 'F' のみが
                          # 除外されて残ります。
                          # 

=head3 Extended Bracketed Character Classes
X<character class>
X<set operations>

(拡張大かっこ文字クラス)

=begin original

This is a fancy bracketed character class that can be used for more
readable and less error-prone classes, and to perform set operations,
such as intersection. An example is

=end original

これはしゃれた大かっこ文字クラスで、より読みやすく、エラーが発生しにくい
クラスや、交差などの集合演算を実行するために使用できます。

 /(?[ \p{Thai} & \p{Digit} ])/

=begin original

This will match all the digit characters that are in the Thai script.

=end original

これは、タイ語スクリプト内のすべての数字と一致します。

=begin original

This is an experimental feature available starting in 5.18, and is
subject to change as we gain field experience with it.  Any attempt to
use it will raise a warning, unless disabled via

=end original

これは 5.18 から利用できる実験的な機能で、現場での経験を積むにつれて
変更される可能性があります。
これを使用しようとすると、次のようにして無効にしない限り、警告が表示されます:

 no warnings "experimental::regex_sets";

=begin original

Comments on this feature are welcome; send email to
C<perl5-porters@perl.org>.

=end original

この機能に関するコメントを歓迎します。
C<perl5-porters@perl.org> に電子メールを送ってください。

=begin original

The rules used by L<C<use re 'strict>|re/'strict' mode> apply to this
construct.

=end original

L<C<use re 'strict>|re/'strict' mode> で使われる規則はこの構文に
適用されます。

=begin original

We can extend the example above:

=end original

上記の例を拡張できます:

 /(?[ ( \p{Thai} + \p{Lao} ) & \p{Digit} ])/

=begin original

This matches digits that are in either the Thai or Laotian scripts.

=end original

これはタイ語またはラオス語のいずれかの数字と一致します。

=begin original

Notice the white space in these examples.  This construct always has
the C<E<sol>xx> modifier turned on within it.

=end original

これらの例の中の空白に注意してください。
この構文では、その中では常に C<E<sol>xx> 修飾子がオンになっています。

=begin original

The available binary operators are:

=end original

使用可能な 2 項演算子は次のとおりです:

 &    intersection
 +    union
 |    another name for '+', hence means union
 -    subtraction (the result matches the set consisting of those
      code points matched by the first operand, excluding any that
      are also matched by the second operand)
 ^    symmetric difference (the union minus the intersection).  This
      is like an exclusive or, in that the result is the set of code
      points that are matched by either, but not both, of the
      operands.

=begin original

There is one unary operator:

=end original

単項演算子が一つあります。

 !    complement

=begin original

All the binary operators left associate; C<"&"> is higher precedence
than the others, which all have equal precedence.  The unary operator
right associates, and has highest precedence.  Thus this follows the
normal Perl precedence rules for logical operators.  Use parentheses to
override the default precedence and associativity.

=end original

すべての二項演算子は左結合です; C<"&"> はその他よりも高い優先順位を持ち、
それ以外は同等の優先順位を持ちます。
単項演算子は右結合で、最も高い優先順位を持ちます。
従って、これは通常の Perl の論理演算子に関する優先順位規則に従います。
デフォルトの優先順位と結合を上書きするにはかっこを使います。

=begin original

The main restriction is that everything is a metacharacter.  Thus,
you cannot refer to single characters by doing something like this:

=end original

主な制限は、すべてがメタ文字であるということです。
したがって、以下のようにして単一文字を参照することはできません:

 /(?[ a + b ])/ # Syntax error!

=begin original

The easiest way to specify an individual typable character is to enclose
it in brackets:

=end original

タイプ可能な個々の文字を指定する最も簡単な方法は、次のように
かっこで囲むことです:

 /(?[ [a] + [b] ])/

=begin original

(This is the same thing as C<[ab]>.)  You could also have said the
equivalent:

=end original

(これはC<[ab]>と同じことです)。
同じことを言うこともできます:

 /(?[[ a b ]])/

=begin original

(You can, of course, specify single characters by using, C<\x{...}>,
C<\N{...}>, etc.)

=end original

(もちろん、C<\x{...}> や C<\N{...}> などを使用して 1 文字を
指定することもできます。)

=begin original

This last example shows the use of this construct to specify an ordinary
bracketed character class without additional set operations.  Note the
white space within it.  This is allowed because C<E<sol>xx> is
automatically turned on within this construct.

=end original

この最後の例では、この構文を使用して、追加の集合操作なしで
通常の大かっこ文字クラスを指定する方法を示しています。
この中に空白があることに注意してください。
C<E<sol>xx> は、この構文の内側で自動的に有効になるのでこれが許されます。

=begin original

All the other escapes accepted by normal bracketed character classes are
accepted here as well.

=end original

通常の大かっこ文字クラスで受け入れられる他のエスケープは
すべてここでも受け入れられます。

=begin original

Because this construct compiles under
L<C<use re 'strict>|re/'strict' mode>,  unrecognized escapes that
generate warnings in normal classes are fatal errors here, as well as
all other warnings from these class elements, as well as some
practices that don't currently warn outside C<re 'strict'>.  For example
you cannot say

=end original

この構文は L<C<use re 'strict>|re/'strict' mode> の下でコンパイルされるので、
通常のクラスで警告を生成する
認識されないエスケープはここでは致命的なエラーです;
これらのクラス要素からのその他すべての警告も同様で、
C<re 'strict'> の外側では、現在警告していないいくつかのプラクティスも
同様です。
例えば次のようにはできません:

 /(?[ [ \xF ] ])/     # Syntax error!

=begin original

You have to have two hex digits after a braceless C<\x> (use a leading
zero to make two).  These restrictions are to lower the incidence of
typos causing the class to not match what you thought it would.

=end original

中かっこのない C<\x> の後には 2 桁の 16 進数が必要です(2 桁にするには
先頭の 0 を使用します)。
これらの制限は、クラスが想定したものと一致しない原因となる
タイプミスの発生を減らすためです。

=begin original

If a regular bracketed character class contains a C<\p{}> or C<\P{}> and
is matched against a non-Unicode code point, a warning may be
raised, as the result is not Unicode-defined.  No such warning will come
when using this extended form.

=end original

通常の大かっこ文字クラスに C<\p{}> や C<\P{}> が含まれていて、
非 Unicode 符号位置に対してマッチングした場合、
結果は Unicode で定義されていないので、警告が発生します。
このような警告は、拡張形式を使った場合は発生しません。

=begin original

The final difference between regular bracketed character classes and
these, is that it is not possible to get these to match a
multi-character fold.  Thus,

=end original

通常の大かっこ文字クラスとこれらのクラスの最後の違いは、
これらを複数文字畳み込みにマッチングさせることができないということです。
従って:

 /(?[ [\xDF] ])/iu

=begin original

does not match the string C<ss>.

=end original

は文字列 C<ss> と一致しません。

=begin original

You don't have to enclose POSIX class names inside double brackets,
hence both of the following work:

=end original

POSIX クラス名を二重かっこで囲む必要はありません;
そのため、以下の両方とも動作します:

 /(?[ [:word:] - [:lower:] ])/
 /(?[ [[:word:]] - [[:lower:]] ])/

=begin original

Any contained POSIX character classes, including things like C<\w> and C<\D>
respect the C<E<sol>a> (and C<E<sol>aa>) modifiers.

=end original

C<\w> や C<\D> などの POSIX 文字クラスは、C<E<sol>a>
(および C<E<sol>aa> )修飾子を尊重します。

=begin original

Note that C<< (?[ ]) >> is a regex-compile-time construct.  Any attempt
to use something which isn't knowable at the time the containing regular
expression is compiled is a fatal error.  In practice, this means
just three limitations:

=end original

C<< (?[ ]) >> は コンパイル時正規表現構文であることに注意してください。
正規表現を含むコンパイル時に未知のものを使用しようとすると、
致命的なエラーになります。
実際には、これは三つの制限を意味します:

=over 4

=item 1

=begin original

When compiled within the scope of C<use locale> (or the C<E<sol>l> regex
modifier), this construct assumes that the execution-time locale will be
a UTF-8 one, and the generated pattern always uses Unicode rules.  What
gets matched or not thus isn't dependent on the actual runtime locale, so
tainting is not enabled.  But a C<locale> category warning is raised
if the runtime locale turns out to not be UTF-8.

=end original

C<use locale> (または C<E<sol>l> 正規表現修飾子)の
スコープ内でコンパイルされると、この構文は実行時ロケールが
UTF-8 のものであることを仮定し、
生成されたパターンは常に Unicode の規則を使います。
従ってマッチングするかどうかは実際の実行時ロケールには関係なく、
汚染チェックモードは有効になりません。
しかし、実行時ロケールが UTF-8 以外になると、
C<locale> カテゴリの警告が発生します。

=item 2

=begin original

Any
L<user-defined property|perlunicode/"User-Defined Character Properties">
used must be already defined by the time the regular expression is
compiled (but note that this construct can be used instead of such
properties).

=end original

使用される
L<ユーザー定義特性|perlunicode/"User-Defined Character Properties"> は、
正規表現がコンパイルされるときにすでに定義されている必要があります
(ただし、このような特性の代わりにこの構文を使用することもできます)。

=item 3

=begin original

A regular expression that otherwise would compile
using C<E<sol>d> rules, and which uses this construct will instead
use C<E<sol>u>.  Thus this construct tells Perl that you don't want
C<E<sol>d> rules for the entire regular expression containing it.

=end original

C<E<sol>d> 規則を使用してコンパイルされ、この構文を使用する正規表現は、
代わりに C<E<sol>u> を使用します。
したがって、この構文は、C<E<sol>d> 規則が含まれている
正規表現全体に対して C<E<sol>d> 規則が必要ないことを Perl に通知します。

=back

=begin original

Note that skipping white space applies only to the interior of this
construct.  There must not be any space between any of the characters
that form the initial C<(?[>.  Nor may there be space between the
closing C<])> characters.

=end original

空白のスキップは、この構造体の内部にのみ適用されることに注意してください。
最初の C<(?[> を形成する文字の間に空白を入れることはできません。
また、終わりの C<])> 文字の間に空白を入れることもできません。

=begin original

Just as in all regular expressions, the pattern can be built up by
including variables that are interpolated at regex compilation time.
But its best to compile each sub-component.

=end original

すべての正規表現と同様に、正規表現コンパイル時に補完される変数を
含めることでパターンを構築できます。
しかし部分要素毎にコンパイルするのが最善です。

 my $thai_or_lao = qr/(?[ \p{Thai} + \p{Lao} ])/;
 my $lower = qr/(?[ \p{Lower} + \p{Digit} ])/;

=begin original

When these are embedded in another pattern, what they match does not
change, regardless of parenthesization or what modifiers are in effect
in that outer pattern.  If you fail to compile the subcomponents, you
can get some nasty surprises.  For example:

=end original

これらが別のパターンに埋め込まれている場合、親子関係やその外側のパターンで
有効な修飾子に関係なく、一致するものは変わりません。
部分要素をコンパイルするのに失敗すると、扱いにくい驚きを受けることに
なるかもしれません。
例えば:

 my $thai_or_lao = '\p{Thai} + \p{Lao}';
 ...
 qr/(?[ \p{Digit} & $thai_or_lao ])/;

=begin original

compiles to

=end original

これは次のようにコンパイルされます:

 qr/(?[ \p{Digit} & \p{Thai} + \p{Lao} ])/;

=begin original

But this does not have the effect that someone reading the source code
would likely expect, as the intersection applies just to C<\p{Thai}>,
excluding the Laotian.  Its best to compile the subcomponents, but you
could also parenthesize the component pieces:

=end original

しかし、これは、ソースコードを読んでいる人が期待するような効果はありません;
なぜなら、この交差は C<\p{Thai}> だけに適用され、ラオス語には
適用されないからです。
部分要素毎にコンパイルするのが最善ですが、
要素をかっこで囲むことでも回避できます:

 my $thai_or_lao = '( \p{Thai} + \p{Lao} )';

=begin original

But any modifiers will still apply to all the components:

=end original

ただし、修飾子はすべてのコンポーネントに適用されます:

 my $lower = '\p{Lower} + \p{Digit}';
 qr/(?[ \p{Greek} & $lower ])/i;

=begin original

matches upper case things.  So just, compile the subcomponents, as
illustrated above.

=end original

これは大文字のものと一致します。
従って、既に示したように、単に部分要素をコンパイルしてください。

=begin original

Due to the way that Perl parses things, your parentheses and brackets
may need to be balanced, even including comments.  If you run into any
examples, please submit them to L<https://github.com/Perl/perl5/issues>,
so that we can have a concrete example for this man page.

=end original

Perl の構文解析方法によっては、コメントを含めてもかっこと大かっこの
バランスを取る必要がある場合があります。
もし何か例を見つけたら、L<https://github.com/Perl/perl5/issues> に
登録してください。
そうすれば、この man ページの具体的な例を得ることができます。

=begin original

We may change it so that things that remain legal uses in normal bracketed
character classes might become illegal within this experimental
construct.  One proposal, for example, is to forbid adjacent uses of the
same character, as in C<(?[ [aa] ])>.  The motivation for such a change
is that this usage is likely a typo, as the second "a" adds nothing.

=end original

たとえば、C<(?[ [aa] ])> のように、同じ文字を隣接して使用すること
を禁止することが提案されています。
このような変更の動機は、2 番目の "a" は何も追加しないので、この使用は
タイプミスである可能性が高いということです。

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org> (5.10.1-)
Status: completed

=end meta

