
=encoding euc-jp

=head1 NAME

=begin original

DBI::DBD - Perl DBI Database Driver Writer's Guide

=end original

DBI::DBD - DBI データベースドライバ作成者ガイド

=head1 SYNOPSIS

  perldoc DBI::DBD

=head2 Version and volatility

(バージョンと変更可能性)

=begin original

This document is I<still> a minimal draft which is in need of further work.

=end original

このドキュメントは I<未だに> さらに作業を進めるために必要最小限のドラフトです。

=begin original

The changes will occur both because the B<DBI> specification is changing
and hence the requirements on B<DBD> drivers change, and because feedback
from people reading this document will suggest improvements to it.

=end original

B<DBI> の仕様変更やその結果 B<DBD> ドライバに要求されることが変更されること、
そしてこのドキュメントを読んだ人たちからフィードバックが改善を
提案することの二つの理由により変更が発生します。

=begin original

Please read the B<DBI> documentation first and fully, including the B<DBI> FAQ.
Then reread the B<DBI> specification again as you're reading this. It'll help.

=end original

まず B<DBI> FAQを含めてすべての B<DBI> ドキュメントをお読みください。
これを読むときには B<DBI> 仕様を読み返します。
これは助けとなるでしょう。

=begin original

This document is a patchwork of contributions from various authors.
More contributions (preferably as patches) are very welcome.

=end original

このドキュメントは多くの作者からよせられた原稿を集めたものです。
さらなる寄稿(どちらかといえばパッチとして)は大歓迎です。

=head1 DESCRIPTION

=begin original

This document is primarily intended to help people writing new
database drivers for the Perl Database Interface (Perl DBI).
It may also help others interested in discovering why the internals of
a B<DBD> driver are written the way they are.

=end original

このドキュメントは第一に Perl データベースインターフェース(Perl DBI)のための
新しいデータベースドライバを作成する人達を助けることを目指しています。
B<DBD> ドライバの内部がどうしてそのように書かれているのかを理解したい
他の人たちにも助けになるでしょう。

=begin original

This is a guide.  Few (if any) of the statements in it are completely
authoritative under all possible circumstances.  This means you will
need to use judgement in applying the guidelines in this document.
If in I<any> doubt at all, please do contact the I<dbi-dev> mailing list
(details given below) where Tim Bunce and other driver authors can help.

=end original

これはガイドです。
すべての可能な環境下で完全に権威のある文は
(もしあったとしても)あまりありません。
つまりこのドキュメントでのガイドラインを適用するときには判断が
必要になります。
もし I<少しでも> 疑問な点があれば、どうか Tim Bunce や他のドライバの作者が
助けてくれる I<dbi-dev> メーリングリスト(詳細は以下にあります)に
コンタクトしてください。

=head1 CREATING A NEW DRIVER

(新しいドライバを作る)

=begin original

The first rule for creating a new database driver for the Perl DBI is
very simple: B<DON'T!>

=end original

Perl DBI のための新しいデータベースドライバを作るための最初の規則は
とても単純です: B<作らない!>

=begin original

There is usually a driver already available for the database you want
to use, almost regardless of which database you choose. Very often, the
database will provide an ODBC driver interface, so you can often use
B<DBD::ODBC> to access the database. This is typically less convenient
on a Unix box than on a Microsoft Windows box, but there are numerous
options for ODBC driver managers on Unix too, and very often the ODBC
driver is provided by the database supplier.

=end original

There is usually a driver already available for the database you want
to use, almost regardless of which database you choose. Very often, the
database will provide an ODBC driver interface, so you can often use
B<DBD::ODBC> to access the database. This is typically less convenient
on a Unix box than on a Microsoft Windows box, but there are numerous
options for ODBC driver managers on Unix too, and very often the ODBC
driver is provided by the database supplier.
(TBT)

=begin original

Before deciding that you need to write a driver, do your homework to
ensure that you are not wasting your energies.

=end original

Before deciding that you need to write a driver, do your homework to
ensure that you are not wasting your energies.
(TBT)

=begin original

[As of December 2002, the consensus is that if you need an ODBC driver
manager on Unix, then the unixODBC driver (available from
L<http://www.unixodbc.org/>) is the way to go.]

=end original

[As of December 2002, the consensus is that if you need an ODBC driver
manager on Unix, then the unixODBC driver (available from
L<http://www.unixodbc.org/>) is the way to go.]
(TBT)

=begin original

The second rule for creating a new database driver for the Perl DBI is
also very simple: B<Don't -- get someone else to do it for you!>

=end original

The second rule for creating a new database driver for the Perl DBI is
also very simple: B<Don't -- get someone else to do it for you!>
(TBT)

=begin original

Nevertheless, there are occasions when it is necessary to write a new
driver, often to use a proprietary language or API to access the
database more swiftly, or more comprehensively, than an ODBC driver can.
Then you should read this document very carefully, but with a suitably
sceptical eye.

=end original

Nevertheless, there are occasions when it is necessary to write a new
driver, often to use a proprietary language or API to access the
database more swiftly, or more comprehensively, than an ODBC driver can.
Then you should read this document very carefully, but with a suitably
sceptical eye.
(TBT)

=begin original

If there is something in here that does not make any sense, question it.
You might be right that the information is bogus, but don't come to that
conclusion too quickly.

=end original

If there is something in here that does not make any sense, question it.
You might be right that the information is bogus, but don't come to that
conclusion too quickly.
(TBT)

=head2 URLs and mailing lists

(URL とメーリングリスト)

=begin original

The primary web-site for locating B<DBI> software and information is

=end original

B<DBI> ソフトウェアと情報が置いてある第一の WEB サイトは

  http://dbi.perl.org/

=begin original

There are two main and one auxiliary mailing lists for people working
with B<DBI>.  The primary lists are I<dbi-users@perl.org> for general users
of B<DBI> and B<DBD> drivers, and I<dbi-dev@perl.org> mainly for B<DBD> driver
writers (don't join the I<dbi-dev> list unless you have a good reason).
The auxiliary list is I<dbi-announce@perl.org> for announcing new
releases of B<DBI> or B<DBD> drivers.

=end original

B<DBI> で作業している人々のために主には二つ、そして補助的な一つの
メーリングリストがあります。
主なリストは、B<DBI> と B<DBD> ドライバの一般的な利用者のための
I<dbi-users@fugue.com>、主に B<DBD> ドライバの作者のための
I<dbi-dev@fugue.comです>(たいした理由も無く I<dbi-dev> リストには
参加しないで下さい)。
補助的なリストは B<DBI> または B<DBD> ドライバの新しいリリースを
アナウンスするための I<dbi-announce@fugue.com> です。

=begin original

You can join these lists by accessing the web-site L<http://dbi.perl.org/>.
The lists are closed so you cannot send email to any of the lists
unless you join the list first.

=end original

これらのリストには Web サイト L<http://dbi.perl.org/> から
参加することができます。
そのリストは閉じているので、まずリストに参加しなければリストのメールを
送信することが出来ません。

=begin original

You should also consider monitoring the I<comp.lang.perl.*> newsgroups,
especially I<comp.lang.perl.modules>.

=end original

また I<comp.lang.perl.*> ニュースグループ、特に I<comp.lang.perl.modules> を
モニタすることも考慮してください。

=head2 The Cheetah book

(チータ本)

=begin original

The definitive book on Perl DBI is the Cheetah book, so called because
of the picture on the cover. Its proper title is 'I<Programming the
Perl DBI: Database programming with Perl>' by Alligator Descartes
and Tim Bunce, published by O'Reilly Associates, February 2000, ISBN
1-56592-699-4. Buy it now if you have not already done so, and read it.

=end original

Perl DBI についての決定版はチータ本(表紙の絵からこう呼ばれます)です。
正しいタイトルは
'I<Programming the Perl DBI: Database programming with Perl>' by
Alligator Descartes and Tim Bunce, published by O'Reilly Associates,
February 2000, ISBN 1-56592-699-4 です
(訳注:和訳は「入門Perl DBI」ISBN 4873110505)。
まだ買っていなければ、今すぐ買いましょう。

=head2 Locating drivers

(ドライバの置き場所)

=begin original

Before writing a new driver, it is in your interests to find out
whether there already is a driver for your database.  If there is such
a driver, it would be much easier to make use of it than to write your
own!

=end original

新しいドライバを書く前に、あなたのデータベースのためのドライバが
あるかどうかが気になるでしょう。
そのようなドライバがあれば、自分自身で作成するよりももっと簡単です!

=begin original

The primary web-site for locating Perl software is
L<http://search.cpan.org/>.  You should look under the various
modules listings for the software you are after. For example:

=end original

Perl ソフトウェアを置いておくための一番の WEB サイトは
L<http://search.cpan.org/> です。
たくさんのモジュールのリストがあります。
例えば:

  http://search.cpan.org/modlist/Database_Interfaces

=begin original

Follow the B<DBD::> and B<DBIx::> links at the top to see those subsets.

=end original

これらのサブセットを見るために一番上の B<DBD::> と B<DBIx::> のリンクを
辿ってください。

=begin original

See the B<DBI> docs for information on B<DBI> web sites and mailing lists.

=end original

情報については B<DBI> Web サイトの B<DBI> ドキュメントやメーリングリストを
ご覧下さい。

=head2 Registering a new driver

(新しいドライバを登録する)

=begin original

Before going through any official registration process, you will need
to establish that there is no driver already in the works. You'll do
that by asking the B<DBI> mailing lists whether there is such a driver
available, or whether anybody is working on one.

=end original

公式の登録処理を始める前に、すでに作業に入っているドライバが無いことを
確認する必要があります。
DBI メーリングリストに利用できるそのようなドライバがあるか、だれかが
それについて作業していないかを尋ねることによって、確認することができます。

=begin original

When you get the go ahead, you will need to establish the name of the
driver and a prefix for the driver. Typically, the name is based on the
name of the database software it uses, and the prefix is a contraction
of that. Hence, B<DBD::Oracle> has the name I<Oracle> and the prefix
'I<ora_>'. The prefix must be lowercase and contain no underscores other
than the one at the end.

=end original

When you get the go ahead, you will need to establish the name of the
driver and a prefix for the driver. Typically, the name is based on the
name of the database software it uses, and the prefix is a contraction
of that. Hence, B<DBD::Oracle> has the name I<Oracle> and the prefix
'I<ora_>'. The prefix must be lowercase and contain no underscores other
than the one at the end.
(TBT)

=begin original

This information will be recorded in the B<DBI> module. Apart from
documentation purposes, registration is a prerequisite for
L<installing private methods|DBI/install_method>.

=end original

This information will be recorded in the B<DBI> module. Apart from
documentation purposes, registration is a prerequisite for
L<installing private methods|DBI/install_method>.
(TBT)

=begin original

If you are writing a driver which will not be distributed on CPAN, then
you should choose a prefix beginning with 'I<x_>', to avoid potential
prefix collisions with drivers registered in the future. Thus, if you
wrote a non-CPAN distributed driver called B<DBD::CustomDB>, the prefix
might be 'I<x_cdb_>'.

=end original

If you are writing a driver which will not be distributed on CPAN, then
you should choose a prefix beginning with 'I<x_>', to avoid potential
prefix collisions with drivers registered in the future. Thus, if you
wrote a non-CPAN distributed driver called B<DBD::CustomDB>, the prefix
might be 'I<x_cdb_>'.
(TBT)

=begin original

This document assumes you are writing a driver called B<DBD::Driver>, and
that the prefix 'I<drv_>' is assigned to the driver.

=end original

This document assumes you are writing a driver called B<DBD::Driver>, and
that the prefix 'I<drv_>' is assigned to the driver.
(TBT)

=head2 Two styles of database driver


(2 種類のデータベースドライバ)

=begin original

There are two distinct styles of database driver that can be written to
work with the Perl DBI.

=end original

Perl DBI と共に動作するために書かれるデータベースドライバには
二つの異なった種類があります。

=begin original

Your driver can be written in pure Perl, requiring no C compiler.
When feasible, this is the best solution, but most databases are not
written in such a way that this can be done. Some examples of pure
Perl drivers are B<DBD::File> and B<DBD::CSV>.

=end original

ドライバを、C コンパイラを必要としないピュア Perl で書くことができます。
可能なら、これが最善の解法ですが、ほとんどのデータベースはこれが
できるような方法で書かれていません。
ピュア Perl ドライバの例は B<DBD::File> と B<DBD::CSV> です。

=begin original

Alternatively, and most commonly, your driver will need to use some C
code to gain access to the database. This will be classified as a C/XS
driver.

=end original

もう一つの、そしてより一般的な方法として、ドライバは
データベースへのアクセスを得るためにいくらかの C コードを使うことが必要です。
これは C/XS ドライバと分類されます。

=head2 What code will you write?

(書く必要のあるコードは?)

=begin original

There are a number of files that need to be written for either a pure
Perl driver or a C/XS driver. There are no extra files needed only by
a pure Perl driver, but there are several extra files needed only by a
C/XS driver.

=end original

There are a number of files that need to be written for either a pure
Perl driver or a C/XS driver. There are no extra files needed only by
a pure Perl driver, but there are several extra files needed only by a
C/XS driver.
(TBT)

=head3 Files common to pure Perl and C/XS drivers

=begin original

Assuming that your driver is called B<DBD::Driver>, these files are:

=end original

Assuming that your driver is called B<DBD::Driver>, these files are:
(TBT)

=over 4

=item * F<Makefile.PL>

=item * F<META.yml>

=item * F<README>

=item * F<MANIFEST>

=item * F<Driver.pm>

=item * F<lib/Bundle/DBD/Driver.pm>

=item * F<lib/DBD/Driver/Summary.pm>

=item * F<t/*.t>

=back

=begin original

The first four files are mandatory. F<Makefile.PL> is used to control
how the driver is built and installed. The F<README> file tells people
who download the file about how to build the module and any prerequisite
software that must be installed. The F<MANIFEST> file is used by the
standard Perl module distribution mechanism. It lists all the source
files that need to be distributed with your module. F<Driver.pm> is what
is loaded by the B<DBI> code; it contains the methods peculiar to your
driver.

=end original

The first four files are mandatory. F<Makefile.PL> is used to control
how the driver is built and installed. The F<README> file tells people
who download the file about how to build the module and any prerequisite
software that must be installed. The F<MANIFEST> file is used by the
standard Perl module distribution mechanism. It lists all the source
files that need to be distributed with your module. F<Driver.pm> is what
is loaded by the B<DBI> code; it contains the methods peculiar to your
driver.
(TBT)

=begin original

Although the F<META.yml> file is not B<required> you are advised to
create one. Of particular importance are the I<build_requires> and
I<configure_requires> attributes which newer CPAN modules understand.
You use these to tell the CPAN module (and CPANPLUS) that your build
and configure mechanisms require DBI. The best reference for META.yml
(at the time of writing) is
L<http://module-build.sourceforge.net/META-spec-v1.4.html>. You can find
a reasonable example of a F<META.yml> in DBD::ODBC.

=end original

Although the F<META.yml> file is not B<required> you are advised to
create one. Of particular importance are the I<build_requires> and
I<configure_requires> attributes which newer CPAN modules understand.
You use these to tell the CPAN module (and CPANPLUS) that your build
and configure mechanisms require DBI. The best reference for META.yml
(at the time of writing) is
L<http://module-build.sourceforge.net/META-spec-v1.4.html>. You can find
a reasonable example of a F<META.yml> in DBD::ODBC.
(TBT)

=begin original

The F<lib/Bundle/DBD/Driver.pm> file allows you to specify other Perl
modules on which yours depends in a format that allows someone to type a
simple command and ensure that all the pre-requisites are in place as
well as building your driver.

=end original

The F<lib/Bundle/DBD/Driver.pm> file allows you to specify other Perl
modules on which yours depends in a format that allows someone to type a
simple command and ensure that all the pre-requisites are in place as
well as building your driver.
(TBT)

=begin original

The F<lib/DBD/Driver/Summary.pm> file contains (an updated version of) the
information that was included - or that would have been included - in
the appendices of the Cheetah book as a summary of the abilities of your
driver and the associated database.

=end original

The F<lib/DBD/Driver/Summary.pm> file contains (an updated version of) the
information that was included - or that would have been included - in
the appendices of the Cheetah book as a summary of the abilities of your
driver and the associated database.
(TBT)

=begin original

The files in the F<t> subdirectory are unit tests for your driver.
You should write your tests as stringently as possible, while taking
into account the diversity of installations that you can encounter:

=end original

The files in the F<t> subdirectory are unit tests for your driver.
You should write your tests as stringently as possible, while taking
into account the diversity of installations that you can encounter:
(TBT)

=over 4

=item *

=begin original

Your tests should not casually modify operational databases.

=end original

Your tests should not casually modify operational databases.
(TBT)

=item *

=begin original

You should never damage existing tables in a database.

=end original

You should never damage existing tables in a database.
(TBT)

=item *

=begin original

You should code your tests to use a constrained name space within the
database. For example, the tables (and all other named objects) that are
created could all begin with 'I<dbd_drv_>'.

=end original

You should code your tests to use a constrained name space within the
database. For example, the tables (and all other named objects) that are
created could all begin with 'I<dbd_drv_>'.
(TBT)

=item *

=begin original

At the end of a test run, there should be no testing objects left behind
in the database.

=end original

At the end of a test run, there should be no testing objects left behind
in the database.
(TBT)

=item *

=begin original

If you create any databases, you should remove them.

=end original

If you create any databases, you should remove them.
(TBT)

=item *

=begin original

If your database supports temporary tables that are automatically
removed at the end of a session, then exploit them as often as possible.

=end original

If your database supports temporary tables that are automatically
removed at the end of a session, then exploit them as often as possible.
(TBT)

=item *

=begin original

Try to make your tests independent of each other. If you have a
test F<t/t11dowhat.t> that depends upon the successful running
of F<t/t10thingamy.t>, people cannot run the single test case
F<t/t11dowhat.t>. Further, running F<t/t11dowhat.t> twice in a row is
likely to fail (at least, if F<t/t11dowhat.t> modifies the database at
all) because the database at the start of the second run is not what you
saw at the start of the first run.

=end original

Try to make your tests independent of each other. If you have a
test F<t/t11dowhat.t> that depends upon the successful running
of F<t/t10thingamy.t>, people cannot run the single test case
F<t/t11dowhat.t>. Further, running F<t/t11dowhat.t> twice in a row is
likely to fail (at least, if F<t/t11dowhat.t> modifies the database at
all) because the database at the start of the second run is not what you
saw at the start of the first run.
(TBT)

=item *

=begin original

Document in your F<README> file what you do, and what privileges people
need to do it.

=end original

Document in your F<README> file what you do, and what privileges people
need to do it.
(TBT)

=item *

=begin original

You can, and probably should, sequence your tests by including a test
number before an abbreviated version of the test name; the tests are run
in the order in which the names are expanded by shell-style globbing.

=end original

You can, and probably should, sequence your tests by including a test
number before an abbreviated version of the test name; the tests are run
in the order in which the names are expanded by shell-style globbing.
(TBT)

=item *

=begin original

It is in your interests to ensure that your tests work as widely
as possible.

=end original

It is in your interests to ensure that your tests work as widely
as possible.
(TBT)

=back

=begin original

Many drivers also install sub-modules B<DBD::Driver::SubModule>
for any of a variety of different reasons, such as to support
the metadata methods (see the discussion of L</METADATA METHODS>
below). Such sub-modules are conventionally stored in the directory
F<lib/DBD/Driver>. The module itself would usually be in a file
F<SubModule.pm>. All such sub-modules should themselves be version
stamped (see the discussions far below).

=end original

Many drivers also install sub-modules B<DBD::Driver::SubModule>
for any of a variety of different reasons, such as to support
the metadata methods (see the discussion of L</METADATA METHODS>
below). Such sub-modules are conventionally stored in the directory
F<lib/DBD/Driver>. The module itself would usually be in a file
F<SubModule.pm>. All such sub-modules should themselves be version
stamped (see the discussions far below).
(TBT)

=head3 Extra files needed by C/XS drivers

=begin original

The software for a C/XS driver will typically contain at least four
extra files that are not relevant to a pure Perl driver.

=end original

The software for a C/XS driver will typically contain at least four
extra files that are not relevant to a pure Perl driver.
(TBT)

=over 4

=item * F<Driver.xs>

=item * F<Driver.h>

=item * F<dbdimp.h>

=item * F<dbdimp.c>

=back

=begin original

The F<Driver.xs> file is used to generate C code that Perl can call to gain
access to the C functions you write that will, in turn, call down onto
your database software.

=end original

The F<Driver.xs> file is used to generate C code that Perl can call to gain
access to the C functions you write that will, in turn, call down onto
your database software.
(TBT)

=begin original

The F<Driver.h> header is a stylized header that ensures you can access the
necessary Perl and B<DBI> macros, types, and function declarations.

=end original

The F<Driver.h> header is a stylized header that ensures you can access the
necessary Perl and B<DBI> macros, types, and function declarations.
(TBT)

=begin original

The F<dbdimp.h> is used to specify which functions have been implemented by
your driver.

=end original

The F<dbdimp.h> is used to specify which functions have been implemented by
your driver.
(TBT)

=begin original

The F<dbdimp.c> file is where you write the C code that does the real work
of translating between Perl-ish data types and what the database expects
to use and return.

=end original

The F<dbdimp.c> file is where you write the C code that does the real work
of translating between Perl-ish data types and what the database expects
to use and return.
(TBT)

=begin original

There are some (mainly small, but very important) differences between
the contents of F<Makefile.PL> and F<Driver.pm> for pure Perl and C/XS
drivers, so those files are described both in the section on creating a
pure Perl driver and in the section on creating a C/XS driver.

=end original

There are some (mainly small, but very important) differences between
the contents of F<Makefile.PL> and F<Driver.pm> for pure Perl and C/XS
drivers, so those files are described both in the section on creating a
pure Perl driver and in the section on creating a C/XS driver.
(TBT)

=begin original

Obviously, you can add extra source code files to the list.

=end original

Obviously, you can add extra source code files to the list.
(TBT)

=head2 Requirements on a driver and driver writer

(ドライバとドライバ作者に必要なこと)

=begin original

To be remotely useful, your driver must be implemented in a format that
allows it to be distributed via CPAN, the Comprehensive Perl Archive
Network (L<http://www.cpan.org/> and L<http://search.cpan.org>).
Of course, it is easier if you do not have to meet this criterion, but
you will not be able to ask for much help if you do not do so, and
no-one is likely to want to install your module if they have to learn a
new installation mechanism.

=end original

To be remotely useful, your driver must be implemented in a format that
allows it to be distributed via CPAN, the Comprehensive Perl Archive
Network (L<http://www.cpan.org/> and L<http://search.cpan.org>).
Of course, it is easier if you do not have to meet this criterion, but
you will not be able to ask for much help if you do not do so, and
no-one is likely to want to install your module if they have to learn a
new installation mechanism.
(TBT)

=head1 CREATING A PURE PERL DRIVER

(ピュア Perl ドライバを作る)

=begin original

Writing a pure Perl driver is surprisingly simple. However, there are
some problems you should be aware of. The best option is of course
picking up an existing driver and carefully modifying one method
after the other.

=end original

純粋な Perl ドライバを書くことは驚くほど簡単です。
しかし気をつけなければならない問題があります。
もちろん一番よい選択子は既にあるドライバをピックアップして、注意深く
一つ一つののメソッドを変更していくことです。

=begin original

Also look carefully at B<DBD::AnyData> and B<DBD::Template>.

=end original

Also look carefully at B<DBD::AnyData> and B<DBD::Template>.
(TBT)

=begin original

As an example we take a look at the B<DBD::File> driver, a driver for
accessing plain files as tables, which is part of the B<DBD::CSV> package.

=end original

例として B<DBD::File> ドライバについて見ていきます; これはプレーンな
ファイルをテーブルとしてアクセスするもので B<DBD::CSV> の一部です。

=begin original

The minimal set of files we have to implement are F<Makefile.PL>,
F<README>, F<MANIFEST> and F<Driver.pm>.

=end original

最低限、実装しなければいけないファイルは F<Makefile.PL>,
F<README>, F<MANIFEST>, F<Driver.pm> です。

=head2 Pure Perl version of Makefile.PL

(ピュア Perl 版の Makefile.PL)

=begin original

You typically start with writing F<Makefile.PL>, a Makefile
generator. The contents of this file are described in detail in
the L<ExtUtils::MakeMaker> man pages. It is definitely a good idea
if you start reading them. At least you should know about the
variables I<CONFIGURE>, I<DEFINED>, I<PM>, I<DIR>, I<EXE_FILES>,
I<INC>, I<LIBS>, I<LINKTYPE>, I<NAME>, I<OPTIMIZE>, I<PL_FILES>,
I<VERSION>, I<VERSION_FROM>, I<clean>, I<depend>, I<realclean> from
the L<ExtUtils::MakeMaker> man page: these are used in almost any
F<Makefile.PL>.

=end original

まず通常は Makefile ジェネレータである F<Makefile.PL> を書くことから
始めます。
このファイルの内容は L<ExtUtils::MakeMaker> の man ページに詳しく
記述されています。
まずこれを読むことはとてもよいことです。
最低限 L<ExtUtils::MakeMaker> man ページから
I<CONFIGURE>, I<DEFINED>, I<PM>, I<DIR>, I<EXE_FILES>,
I<INC>, I<LIBS>, I<LINKTYPE>, I<NAME>, I<OPTIMIZE>, I<PL_FILES>,
I<VERSION>, I<VERSION_FROM>, I<clean>, I<depend>, I<realclean> 変数に
ついて知っておいてください: これらはほとんどすべての
F<Makefile.PL> で使われます。

=begin original

Additionally read the section on I<Overriding MakeMaker Methods> and the
descriptions of the I<distcheck>, I<disttest> and I<dist> targets: They
will definitely be useful for you.

=end original

さらに I<Overriding MakeMaker Methods> (MakeMaker メソッドの
オーバーライド)の節や stcheck, disttest, dist ターゲットの説明についても
読んでください: それらは間違い無く有用です。

=begin original

Of special importance for B<DBI> drivers is the I<postamble> method from
the L<ExtUtils::MM_Unix> man page.

=end original

B<DBI> ドライバにとって特に重要なのは L<ExtUtils::MM_Unix> man ページでの
I<postambleme> メソッドです。

=begin original

For Emacs users, I recommend the I<libscan> method, which removes
Emacs backup files (file names which end with a tilde '~') from lists of
files.

=end original

Eamcs ユーザには I<libscan> メソッドをお勧めします; which removes
Emacs backup files (file names which end with a tilde '~') from lists of
files.
(TBT)

=begin original

Now an example, I use the word C<Driver> wherever you should insert
your driver's name:

=end original

さて例です; C<Driver> という単語を使っているところにはあなたのドライバの
名前を入れてください:

  # -*- perl -*-

  use ExtUtils::MakeMaker;

  WriteMakefile(
      dbd_edit_mm_attribs( {
          'NAME'         => 'DBD::Driver',
          'VERSION_FROM' => 'Driver.pm',
          'INC'          => '',
          'dist'         => { 'SUFFIX'   => '.gz',
                              'COMPRESS' => 'gzip -9f' },
          'realclean'    => { FILES => '*.xsi' },
          'PREREQ_PM'    => '1.03',
          'CONFIGURE'    => sub {
              eval {require DBI::DBD;};
              if ($@) {
                  warn $@;
                  exit 0;
              }
              my $dbi_arch_dir = dbd_dbi_arch_dir();
              if (exists($opts{INC})) {
                  return {INC => "$opts{INC} -I$dbi_arch_dir"};
              } else {
                  return {INC => "-I$dbi_arch_dir"};
              }
          }
      },
      { create_pp_tests => 1})
  );

  package MY;
  sub postamble { return main::dbd_postamble(@_); }
  sub libscan {
      my ($self, $path) = @_;
      ($path =~ m/\~$/) ? undef : $path;
  }

=begin original

Note the calls to C<dbd_edit_mm_attribs()> and C<dbd_postamble()>.

=end original

Note the calls to C<dbd_edit_mm_attribs()> and C<dbd_postamble()>.
(TBT)

=begin original

The second hash reference in the call to C<dbd_edit_mm_attribs()>
(containing C<create_pp_tests()>) is optional; you should not use it
unless your driver is a pure Perl driver (that is, it does not use C and
XS code). Therefore, the call to C<dbd_edit_mm_attribs()> is not
relevant for C/XS drivers and may be omitted; simply use the (single)
hash reference containing NAME etc as the only argument to C<WriteMakefile()>.

=end original

The second hash reference in the call to C<dbd_edit_mm_attribs()>
(containing C<create_pp_tests()>) is optional; you should not use it
unless your driver is a pure Perl driver (that is, it does not use C and
XS code). Therefore, the call to C<dbd_edit_mm_attribs()> is not
relevant for C/XS drivers and may be omitted; simply use the (single)
hash reference containing NAME etc as the only argument to C<WriteMakefile()>.
(TBT)

=begin original

Note that the C<dbd_edit_mm_attribs()> code will fail if you do not have a
F<t> sub-directory containing at least one test case.

=end original

Note that the C<dbd_edit_mm_attribs()> code will fail if you do not have a
F<t> sub-directory containing at least one test case.
(TBT)

=begin original

I<PREREQ_PM> tells MakeMaker that DBI (version 1.03 in this case) is
required for this module. This will issue a warning that DBI 1.03 is
missing if someone attempts to install your DBD without DBI 1.03. See
I<CONFIGURE> below for why this does not work reliably in stopping cpan
testers failing your module if DBI is not installed.

=end original

I<PREREQ_PM> tells MakeMaker that DBI (version 1.03 in this case) is
required for this module. This will issue a warning that DBI 1.03 is
missing if someone attempts to install your DBD without DBI 1.03. See
I<CONFIGURE> below for why this does not work reliably in stopping cpan
testers failing your module if DBI is not installed.
(TBT)

=begin original

I<CONFIGURE> is a subroutine called by MakeMaker during
C<WriteMakefile>.  By putting the C<require DBI::DBD> in this section
we can attempt to load DBI::DBD but if it is missing we exit with
success. As we exit successfully without creating a Makefile when
DBI::DBD is missing cpan testers will not report a failure. This may
seem at odds with I<PREREQ_PM> but I<PREREQ_PM> does not cause
C<WriteMakefile> to fail (unless you also specify PREREQ_FATAL which
is strongly discouraged by MakeMaker) so C<WriteMakefile> would
continue to call C<dbd_dbi_arch_dir> and fail.

=end original

I<CONFIGURE> is a subroutine called by MakeMaker during
C<WriteMakefile>.  By putting the C<require DBI::DBD> in this section
we can attempt to load DBI::DBD but if it is missing we exit with
success. As we exit successfully without creating a Makefile when
DBI::DBD is missing cpan testers will not report a failure. This may
seem at odds with I<PREREQ_PM> but I<PREREQ_PM> does not cause
C<WriteMakefile> to fail (unless you also specify PREREQ_FATAL which
is strongly discouraged by MakeMaker) so C<WriteMakefile> would
continue to call C<dbd_dbi_arch_dir> and fail.
(TBT)

=begin original

All drivers must use C<dbd_postamble()> or risk running into problems.

=end original

All drivers must use C<dbd_postamble()> or risk running into problems.
(TBT)

=begin original

Note the specification of I<VERSION_FROM>; the named file
(F<Driver.pm>) will be scanned for the first line that looks like an
assignment to I<$VERSION>, and the subsequent text will be used to
determine the version number.  Note the commentary in
L<ExtUtils::MakeMaker> on the subject of correctly formatted version
numbers.

=end original

Note the specification of I<VERSION_FROM>; the named file
(F<Driver.pm>) will be scanned for the first line that looks like an
assignment to I<$VERSION>, and the subsequent text will be used to
determine the version number.  Note the commentary in
L<ExtUtils::MakeMaker> on the subject of correctly formatted version
numbers.
(TBT)

=begin original

If your driver depends upon external software (it usually will), you
will need to add code to ensure that your environment is workable
before the call to C<WriteMakefile()>. If you need to check for the
existence of an external library and perhaps modify I<INC> to include
the paths to where the external library header files are located and
you cannot find the library or header files make sure you output a
message saying they cannot be found but C<exit 0> (success) B<before>
calling C<WriteMakefile> or CPAN testers will fail your module if the
external library is not found.

=end original

If your driver depends upon external software (it usually will), you
will need to add code to ensure that your environment is workable
before the call to C<WriteMakefile()>. If you need to check for the
existence of an external library and perhaps modify I<INC> to include
the paths to where the external library header files are located and
you cannot find the library or header files make sure you output a
message saying they cannot be found but C<exit 0> (success) B<before>
calling C<WriteMakefile> or CPAN testers will fail your module if the
external library is not found.
(TBT)

=begin original

A full-fledged I<Makefile.PL> can be quite large (for example, the
files for B<DBD::Oracle> and B<DBD::Informix> are both over 1000 lines
long, and the Informix one uses - and creates - auxiliary modules
too).

=end original

A full-fledged I<Makefile.PL> can be quite large (for example, the
files for B<DBD::Oracle> and B<DBD::Informix> are both over 1000 lines
long, and the Informix one uses - and creates - auxiliary modules
too).
(TBT)

=begin original

See also L<ExtUtils::MakeMaker> and L<ExtUtils::MM_Unix>. Consider using
L<CPAN::MakeMaker> in place of I<ExtUtils::MakeMaker>.

=end original

See also L<ExtUtils::MakeMaker> and L<ExtUtils::MM_Unix>. Consider using
L<CPAN::MakeMaker> in place of I<ExtUtils::MakeMaker>.
(TBT)

=head2 README

=begin original

The L<README> file should describe what the driver is for, the
pre-requisites for the build process, the actual build process, how to
report errors, and who to report them to.

=end original

L<README> ファイルは何のためのドライバか、ビルド処理のために事前に
必要なことは何か、実際のビルド処理、どうやって誰にエラーを報告するかについて
記述するべきです。

=begin original

Users will find ways of breaking the driver build and test process
which you would never even have dreamed to be possible in your worst
nightmares. Therefore, you need to write this document defensively,
precisely and concisely.

=end original

あなたの最悪の悪夢のなかですら思っても見なかったような方法で、利用者は
ドライバのビルドやテスト処理を失敗させる方法を見つけます。
従って、このためこのドキュメントは守りを固めて、正確に、簡潔に書く
必要があります。

=begin original

As always, use the F<README> from one of the established drivers as a basis
for your own; the version in B<DBD::Informix> is worth a look as it has
been quite successful in heading off problems.

=end original

いつも通り、既にあるドライバの F<README> を、あなたのものの基本として
使いましょう; the version in B<DBD::Informix> is worth a look as it has
been quite successful in heading off problems.
(TBT)

=over 4

=item *

=begin original

Note that users will have versions of Perl and B<DBI> that are both older
and newer than you expected, but this will seldom cause much trouble.
When it does, it will be because you are using features of B<DBI> that are
not supported in the version they are using.

=end original

Note that users will have versions of Perl and B<DBI> that are both older
and newer than you expected, but this will seldom cause much trouble.
When it does, it will be because you are using features of B<DBI> that are
not supported in the version they are using.
(TBT)

=item *

=begin original

Note that users will have versions of the database software that are
both older and newer than you expected. You will save yourself time in
the long run if you can identify the range of versions which have been
tested and warn about versions which are not known to be OK.

=end original

Note that users will have versions of the database software that are
both older and newer than you expected. You will save yourself time in
the long run if you can identify the range of versions which have been
tested and warn about versions which are not known to be OK.
(TBT)

=item *

=begin original

Note that many people trying to install your driver will not be experts
in the database software.

=end original

Note that many people trying to install your driver will not be experts
in the database software.
(TBT)

=item *

=begin original

Note that many people trying to install your driver will not be experts
in C or Perl.

=end original

Note that many people trying to install your driver will not be experts
in C or Perl.
(TBT)

=back

=head2 MANIFEST

=begin original

The F<MANIFEST> will be used by the Makefile's dist target to build the
distribution tar file that is uploaded to CPAN. It should list every
file that you want to include in your distribution, one per line.

=end original

F<MANIFEST> は Makefile の dist ターゲットによって、CPAN に
アップロードされる配布 tar ファイルを構築するために使われます。
配布に含めたいすべてのファイルを 1 行ずつリストにします。

=head2 lib/Bundle/DBD/Driver.pm

=begin original

The CPAN module provides an extremely powerful bundle mechanism that
allows you to specify pre-requisites for your driver.

=end original

CPAN モジュールは、あなたのドライバにあらかじめ必要なものを指定することを
可能とするとても強力なバンドル機構を提供します。

=begin original

The primary pre-requisite is B<Bundle::DBI>; you may want or need to add
some more. With the bundle set up correctly, the user can type:

=end original

まずあらかじめ必要なものは B<Bundle::DBIです>; あなたは他のものも
欲しかったり、必要だったりするかもしれません。
バンドル設定を正しく行えば、ユーザが以下のようにタイプすると:

        perl -MCPAN -e 'install Bundle::DBD::Driver'

=begin original

and Perl will download, compile, test and install all the Perl modules
needed to build your driver.

=end original

Perl はあなたのドライバを構築するために必要とされるすべての
Perl モジュールをダウンロード、コンパイル、テスト、
インストールしてくれます。

=begin original

The prerequisite modules are listed in the C<CONTENTS> section, with the
official name of the module followed by a dash and an informal name or
description.

=end original

あらかじめ必要なモジュールは C<CONTENTS> セクションに、公式の名前と
ダッシュを付けて非公式な名前または説明を一覧にします。

=over 4

=item *

=begin original

Listing B<Bundle::DBI> as the main pre-requisite simplifies life.

=end original

B<Bundle::DBI> を主要なあらかじめ必要なものとしてリストに載せることは、
ものごとを簡単にさせます。

=item *

=begin original

Don't forget to list your driver.

=end original

あなたのドライバをリストに載せるのを忘れないで下さい。

=item *

=begin original

Note that unless the DBMS is itself a Perl module, you cannot list it as
a pre-requisite in this file.

=end original

DBMS そのものは Perl モジュールでなければ、このファイルでのあらかじめ
必要なもののリストに載せることが出来ないことに注意してください。

=item *

=begin original

You should keep the version of the bundle the same as the version of
your driver.

=end original

バンドルのバージョンはあなたのドライバのバージョンと同じにするべきです。

=item *

=begin original

You should add configuration management, copyright, and licencing
information at the top.

=end original

構成管理、著作権、ライセンス情報をを加えたいかもしれません。

=back

=begin original

A suitable skeleton for this file is shown below.

=end original

このファイルの適切な骨格を以下に示します。

  package Bundle::DBD::Driver;

  $VERSION = '0.01';

  1;

  __END__

  =head1 NAME

  Bundle::DBD::Driver - A bundle to install all DBD::Driver related modules

  =head1 SYNOPSIS

  C<perl -MCPAN -e 'install Bundle::DBD::Driver'>

  =head1 CONTENTS

  Bundle::DBI  - Bundle for DBI by TIMB (Tim Bunce)

  DBD::Driver  - DBD::Driver by YOU (Your Name)

  =head1 DESCRIPTION

  This bundle includes all the modules used by the Perl Database
  Interface (DBI) driver for Driver (DBD::Driver), assuming the
  use of DBI version 1.13 or later, created by Tim Bunce.

  If you've not previously used the CPAN module to install any
  bundles, you will be interrogated during its setup phase.
  But when you've done it once, it remembers what you told it.
  You could start by running:

    C<perl -MCPAN -e 'install Bundle::CPAN'>

  =head1 SEE ALSO

  Bundle::DBI

  =head1 AUTHOR

  Your Name E<lt>F<you@yourdomain.com>E<gt>

  =head1 THANKS

  This bundle was created by ripping off Bundle::libnet created by
  Graham Barr E<lt>F<gbarr@ti.com>E<gt>, and radically simplified
  with some information from Jochen Wiedmann E<lt>F<joe@ispsoft.de>E<gt>.
  The template was then included in the DBI::DBD documentation by
  Jonathan Leffler E<lt>F<jleffler@informix.com>E<gt>.

  =cut

=head2 lib/DBD/Driver/Summary.pm

=begin original

There is no substitute for taking the summary file from a driver that
was documented in the Perl book (such as B<DBD::Oracle> or B<DBD::Informix> or
B<DBD::ODBC>, to name but three), and adapting it to describe the
facilities available via B<DBD::Driver> when accessing the Driver database.

=end original

There is no substitute for taking the summary file from a driver that
was documented in the Perl book (such as B<DBD::Oracle> or B<DBD::Informix> or
B<DBD::ODBC>, to name but three), and adapting it to describe the
facilities available via B<DBD::Driver> when accessing the Driver database.
(TBT)

=head2 Pure Perl version of Driver.pm

(ピュア Perl 版の Driver.pm)

=begin original

The F<Driver.pm> file defines the Perl module B<DBD::Driver> for your driver.
It will define a package B<DBD::Driver> along with some version information,
some variable definitions, and a function C<driver()> which will have a more
or less standard structure.

=end original

F<Driver.pm> ファイルは Perl モジュール B<DBD::Driver> をあなたの
ドライバ用として定義します。
いくつかのバージョン情報、いくつかの変数定義、そして関数 C<driver()> と
ともに、標準よりも多くあるいは少ない構造を持つパッケージ B<DBD::Driver> を
定義します。

=begin original

It will also define three sub-packages of B<DBD::Driver>:

=end original

It will also define three sub-packages of B<DBD::Driver>:
(TBT)

=over 4

=item DBD::Driver::dr

=begin original

with methods C<connect()>, C<data_sources()> and C<disconnect_all()>;

=end original

with methods C<connect()>, C<data_sources()> and C<disconnect_all()>;
(TBT)

=item DBD::Driver::db

=begin original

with methods such as C<prepare()>;

=end original

with methods such as C<prepare()>;
(TBT)

=item DBD::Driver::st

=begin original

with methods such as C<execute()> and C<fetch()>.

=end original

with methods such as C<execute()> and C<fetch()>.
(TBT)

=back

=begin original

The F<Driver.pm> file will also contain the documentation specific to
B<DBD::Driver> in the format used by perldoc.

=end original

F<Driver.pm> ファイルには perldoc によって使われるフォーマットで
B<DBD::Driver> についての仕様のドキュメントも入れます。

=begin original

In a pure Perl driver, the F<Driver.pm> file is the core of the
implementation. You will need to provide all the key methods needed by B<DBI>.

=end original

In a pure Perl driver, the F<Driver.pm> file is the core of the
implementation. You will need to provide all the key methods needed by B<DBI>.
(TBT)

=begin original

Now let's take a closer look at an excerpt of F<File.pm> as an example.
We ignore things that are common to any module (even non-DBI modules)
or really specific to the B<DBD::File> package.

=end original

さあ例として F<File.pm> の引用について詳しく見てみましょう。
どのモジュールにも共通となる(DBI 以外のモジュールでさえ)こと、あるいは
本当に B<DBD::File> パッケージに特有のものについては無視します。

=head3 The DBD::Driver package

=head4 The header

  package DBD::File;

  use strict;
  use vars qw($VERSION $drh);

  $VERSION = "1.23.00"  # Version number of DBD::File

=begin original

This is where the version number of your driver is specified, and is
where F<Makefile.PL> looks for this information. Please ensure that any
other modules added with your driver are also version stamped so that
CPAN does not get confused.

=end original

This is where the version number of your driver is specified, and is
where F<Makefile.PL> looks for this information. Please ensure that any
other modules added with your driver are also version stamped so that
CPAN does not get confused.
(TBT)

=begin original

It is recommended that you use a two-part (1.23) or three-part (1.23.45)
version number. Also consider the CPAN system, which gets confused and
considers version 1.10 to precede version 1.9, so that using a raw CVS,
RCS or SCCS version number is probably not appropriate (despite being
very common).

=end original

It is recommended that you use a two-part (1.23) or three-part (1.23.45)
version number. Also consider the CPAN system, which gets confused and
considers version 1.10 to precede version 1.9, so that using a raw CVS,
RCS or SCCS version number is probably not appropriate (despite being
very common).
(TBT)

=begin original

For Subversion you could use:

=end original

For Subversion you could use:
(TBT)

  $VERSION = sprintf("12.%06d", q$Revision$ =~ /(\d+)/o);

=begin original

(use lots of leading zeros on the second portion so if you move the code to a
shared repository like svn.perl.org the much larger revision numbers won't
cause a problem, at least not for a few years).  For RCS or CVS you can use:

=end original

(use lots of leading zeros on the second portion so if you move the code to a
shared repository like svn.perl.org the much larger revision numbers won't
cause a problem, at least not for a few years).  For RCS or CVS you can use:
(TBT)

  $VERSION = sprintf "%d.%02d", '$Revision$ ' =~ /(\d+)\.(\d+)/;

=begin original

which pads out the fractional part with leading zeros so all is well
(so long as you don't go past x.99)

=end original

which pads out the fractional part with leading zeros so all is well
(so long as you don't go past x.99)
(TBT)

  $drh = undef;         # holds driver handle once initialized

=begin original

This is where the driver handle will be stored, once created.
Note that you may assume there is only one handle for your driver.

=end original

作成されたら、ここにドライバハンドルが格納されます。
ドライバにはたった一つのハンドルしかないと想定できるということに
注意してください。

=head4 The driver constructor

=begin original

The C<driver()> method is the driver handle constructor. Note that
the C<driver()> method is in the B<DBD::Driver> package, not in
one of the sub-packages B<DBD::Driver::dr>, B<DBD::Driver::db>, or
B<DBD::Driver::db>.

=end original

C<driver()> メソッドがドライバハンドルのコンストラクタです。
Note that
the C<driver()> method is in the B<DBD::Driver> package, not in
one of the sub-packages B<DBD::Driver::dr>, B<DBD::Driver::db>, or
B<DBD::Driver::db>.
(TBT)

  sub driver
  {
      return $drh if $drh;      # already created - return same one
      my ($class, $attr) = @_;

      $class .= "::dr";

      DBD::Driver::db->install_method('drv_example_dbh_method');
      DBD::Driver::st->install_method('drv_example_sth_method');

      # not a 'my' since we use it above to prevent multiple drivers
      $drh = DBI::_new_drh($class, {
              'Name'        => 'File',
              'Version'     => $VERSION,
              'Attribution' => 'DBD::File by Jochen Wiedmann',
          })
          or return undef;

      return $drh;
  }

=begin original

This is a reasonable example of how B<DBI> implements its handles. There
are three kinds: B<driver handles> (typically stored in I<$drh>; from
now on called I<drh> or I<$drh>), B<database handles> (from now on
called I<dbh> or I<$dbh>) and B<statement handles> (from now on called
I<sth> or I<$sth>).

=end original

B<DBI> がどのようにそのハンドルを実装するかというよい例です。
ハンドルは３種類あります:B<ドライバハンドル>(通常は I<$drh> に
格納されます、以降 I<drh> または I<$drh> とします)、B<データベースハンドル>
(以降 I<dbh> または I<$dbh> とします)、そして B<文ハンドル>
(以降 I<sth> または I<$sth> とします)です。

=begin original

The prototype of C<DBI::_new_drh()> is

=end original

C<DBI::_new_drh()> のプロトタイプは以下のようになります

  $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);

=begin original

with the following arguments:

=end original

以下の引数を取ります:

=over 4

=item I<$class>

=begin original

is typically the class for your driver, (for example, "DBD::File::dr"),
passed as the first argument to the C<driver()> method.

=end original

通常ドライバのためのクラスになります; (たとえば "DBD::File::dr") が
最初の引数として C<driver()> メソッドに渡されます。 

=item I<$public_attrs>

=begin original

is a hash ref to attributes like I<Name>, I<Version>, and I<Attribution>.
These are processed and used by B<DBI>. You had better not make any
assumptions about them nor should you add private attributes here.

=end original

これは I<Name>, I<Version>, I<Attributrion> といった属性の
ハッシュリファレンスです。
これらは B<DBI> によって処理され利用されます。
これらについて何か想定しないようがよいですし、ここに独自の属性を
追加してはいけません。

=item I<$private_attrs>

=begin original

This is another (optional) hash ref with your private attributes.
B<DBI> will store them and otherwise leave them alone.

=end original

これがもう一つの(オプションの)独自の属性を持ったハッシュリファレンスです。
B<DBI> はこれを補完して、それ以外は手を出しません。 

=back

=begin original

The C<DBI::_new_drh()> method and the C<driver()> method both return C<undef>
for failure (in which case you must look at I<$DBI::err> and I<$DBI::errstr>
for the failure information, because you have no driver handle to use).

=end original

C<DBI::new_drh()> メソッドと C<driver()> メソッドは失敗すると両方とも
C<undef> を返します(この場合、ドライバハンドルがないので
失敗情報については I<$DBI::err> と I<$DBI::errstr> を見る必要があります)。

=head4 Using install_method() to expose driver-private methods

    DBD::Foo::db->install_method($method_name, \%attr);

=begin original

Installs the driver-private method named by $method_name into the
DBI method dispatcher so it can be called directly, avoiding the
need to use the func() method.

=end original

Installs the driver-private method named by $method_name into the
DBI method dispatcher so it can be called directly, avoiding the
need to use the func() method.
(TBT)

=begin original

It is called as a static method on the driver class to which the
method belongs. The method name must begin with the corresponding
registered driver-private prefix. For example, for DBD::Oracle
$method_name must being with 'C<ora_>', and for DBD::AnyData it
must begin with 'C<ad_>'.

=end original

It is called as a static method on the driver class to which the
method belongs. The method name must begin with the corresponding
registered driver-private prefix. For example, for DBD::Oracle
$method_name must being with 'C<ora_>', and for DBD::AnyData it
must begin with 'C<ad_>'.
(TBT)

=begin original

The attributes can be used to provide fine control over how the DBI
dispatcher handles the dispatching of the method. However, at this
point, it's undocumented and very liable to change. (Volunteers to
polish up and document the interface are very welcome to get in
touch via dbi-dev@perl.org)

=end original

The attributes can be used to provide fine control over how the DBI
dispatcher handles the dispatching of the method. However, at this
point, it's undocumented and very liable to change. (Volunteers to
polish up and document the interface are very welcome to get in
touch via dbi-dev@perl.org)
(TBT)

=begin original

Methods installed using install_method default to the standard error
handling behaviour for DBI methods: clearing err and errstr before
calling the method, and checking for errors to trigger RaiseError 
etc. on return. This differs from the default behaviour of func(). 

=end original

Methods installed using install_method default to the standard error
handling behaviour for DBI methods: clearing err and errstr before
calling the method, and checking for errors to trigger RaiseError 
etc. on return. This differs from the default behaviour of func(). 
(TBT)

=begin original

Note for driver authors: The DBD::Foo::xx->install_method call won't
work until the class-hierarchy has been setup. Normally the DBI
looks after that just after the driver is loaded. This means
install_method() can't be called at the time the driver is loaded
unless the class-hierarchy is set up first. The way to do that is
to call the setup_driver() method:

=end original

Note for driver authors: The DBD::Foo::xx->install_method call won't
work until the class-hierarchy has been setup. Normally the DBI
looks after that just after the driver is loaded. This means
install_method() can't be called at the time the driver is loaded
unless the class-hierarchy is set up first. The way to do that is
to call the setup_driver() method:
(TBT)

    DBI->setup_driver('DBD::Foo');

=begin original

before using install_method().

=end original

before using install_method().
(TBT)

=head4 The CLONE special subroutine

=begin original

Also needed here, in the B<DBD::Driver> package, is a C<CLONE()> method
that will be called by perl when an interpreter is cloned. All your
C<CLONE()> method needs to do, currently, is clear the cached I<$drh> so
the new interpreter won't start using the cached I<$drh> from the old
interpreter:

=end original

Also needed here, in the B<DBD::Driver> package, is a C<CLONE()> method
that will be called by perl when an interpreter is cloned. All your
C<CLONE()> method needs to do, currently, is clear the cached I<$drh> so
the new interpreter won't start using the cached I<$drh> from the old
interpreter:
(TBT)

  sub CLONE {
    undef $drh;
  }

=begin original

See L<http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe>
for details.

=end original

See L<http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe>
for details.
(TBT)

=head3 The DBD::Driver::dr package

=begin original

The next lines of code look as follows:

=end original

次の行は以下のコードのようになります:

  package DBD::Driver::dr; # ====== DRIVER ======

  $DBD::Driver::dr::imp_data_size = 0;

=begin original

Note that no I<@ISA> is needed here, or for the other B<DBD::Driver::*>
classes, because the B<DBI> takes care of that for you when the driver is
loaded.

=end original

ドライバがロードされるとき、B<DBI> があなたに代わって面倒を見てくれるので、
ここや他の B<DBD::Driver::*> のために I<@ISA> が必要ないことに
注意してください。

 *FIX ME* Explain what the imp_data_size is, so that implementors aren't
 practicing cargo-cult programming.

=head4 The database handle constructor

=begin original

The database handle constructor is the driver's (hence the changed
namespace) C<connect()> method:

=end original

データベースハンドルコンストラクタはドライバの (従って変更された
名前空間の) C<connect()> メソッドです:

  sub connect
  {
      my ($drh, $dr_dsn, $user, $auth, $attr) = @_;

      # Some database specific verifications, default settings
      # and the like can go here. This should only include
      # syntax checks or similar stuff where it's legal to
      # 'die' in case of errors.
      # For example, many database packages requires specific
      # environment variables to be set; this could be where you
      # validate that they are set, or default them if they are not set.

      my $driver_prefix = "drv_"; # the assigned prefix for this driver

      # Process attributes from the DSN; we assume ODBC syntax
      # here, that is, the DSN looks like var1=val1;...;varN=valN
      foreach my $var ( split /;/, $dr_dsn ) {
          my ($attr_name, $attr_value) = split '=', $var, 2;
	  return $drh->set_err($DBI::stderr, "Can't parse DSN part '$var'")
              unless defined $attr_value;

          # add driver prefix to attribute name if it doesn't have it already
          $attr_name = $driver_prefix.$attr_name
              unless $attr_name =~ /^$driver_prefix/o;

	  # Store attribute into %$attr, replacing any existing value.
          # The DBI will STORE() these into $dbh after we've connected
	  $attr->{$attr_name} = $attr_value;
      }

      # Get the attributes we'll use to connect.
      # We use delete here because these no need to STORE them
      my $db = delete $attr->{drv_database} || delete $attr->{drv_db}
          or return $drh->set_err($DBI::stderr, "No database name given in DSN '$dr_dsn'");
      my $host = delete $attr->{drv_host} || 'localhost';
      my $port = delete $attr->{drv_port} || 123456;

      # Assume you can attach to your database via drv_connect:
      my $connection = drv_connect($db, $host, $port, $user, $auth)
          or return $drh->set_err($DBI::stderr, "Can't connect to $dr_dsn: ...");

      # create a 'blank' dbh (call superclass constructor)
      my ($outer, $dbh) = DBI::_new_dbh($drh, { Name => $dr_dsn });

      $dbh->STORE('Active', 1 );
      $dbh->{drv_connection} = $connection;

      return $outer;
  }

=begin original

This is mostly the same as in the I<driver handle constructor> above.
The arguments are described in L<DBI>.

=end original

これは上記の I<ドライバハンドルコンストラクタ> とほとんど同じです。
属性は L<DBI> マニュアルページに記述されています。

=begin original

The constructor C<DBI::_new_dbh()> is called, returning a database handle.
The constructor's prototype is:

=end original

コンストラクタ C<DBI::_new_dbh()> が呼ばれるとデータベースハンドルを返します。
コンストラクタのプロトタイプは以下の通りです:

  ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);

=begin original

with similar arguments to those in the I<driver handle constructor>,
except that the I<$class> is replaced by I<$drh>. The I<Name> attribute
is a standard B<DBI> attribute (see L<DBI/Database Handle Attributes>).

=end original

I<$class> が I<$drh> に変わる以外は、I<ドライバハンドルコンストラクタ> と
同じ引数を取ります。
The I<Name> attribute
is a standard B<DBI> attribute (see L<DBI/Database Handle Attributes>).
(TBT)

=begin original

In scalar context, only the outer handle is returned.

=end original

In scalar context, only the outer handle is returned.
(TBT)

=begin original

Note the use of the C<STORE()> method for setting the I<dbh> attributes.
That's because within the driver code, the handle object you have is
the 'inner' handle of a tied hash, not the outer handle that the
users of your driver have.

=end original

I<dbh> 属性を設定するために C<STORE()> メソッドを使うことに注意してください。
これはドライバコードでは、あなたが持っているハンドルオブジェクトは
tieされたハッシュの「内部用('inner')」ハンドルであり、ドライバの利用者が
持っている「外部用(outer)」ハンドルではないためです。

=begin original

Because you have the inner handle, tie magic doesn't get invoked
when you get or set values in the hash. This is often very handy for
speed when you want to get or set simple non-special driver-specific
attributes.

=end original

内部用ハンドルを持っているので、ハッシュから値を取得したり、ハッシュに
設定するときtieの仕掛けは呼び出されません。
シンプルで特定でないドライバ特有の属性を取得したり、設定したいときに
スピードの面からとても重宝します。

=begin original

However, some attribute values, such as those handled by the B<DBI> like
I<PrintError>, don't actually exist in the hash and must be read via
C<$h-E<gt>FETCH($attrib)> and set via C<$h-E<gt>STORE($attrib, $value)>.
If in any doubt, use these methods.

=end original

しかし B<DBI> によって扱われる I<PrintError> のようないくつかの属性値は、
ハッシュには実際には存在しません。
そして C<$h-E<gt>FETCH($attrib)> によって読みこまれ、
C<$h-E<gt>STORE($attrib, $value)> によって設定されなければなりません。
疑問があれば、これらのメソッドを使ってください。

=head4 The data_sources() method

=begin original

The C<data_sources()> method must populate and return a list of valid data
sources, prefixed with the "I<dbi:Driver>" incantation that allows them to
be used in the first argument of the C<DBI-E<gt>connect()> method.
An example of this might be scanning the F<$HOME/.odbcini> file on Unix
for ODBC data sources (DSNs).

=end original

The C<data_sources()> method must populate and return a list of valid data
sources, prefixed with the "I<dbi:Driver>" incantation that allows them to
be used in the first argument of the C<DBI-E<gt>connect()> method.
An example of this might be scanning the F<$HOME/.odbcini> file on Unix
for ODBC data sources (DSNs).
(TBT)

=begin original

As a trivial example, consider a fixed list of data sources:

=end original

As a trivial example, consider a fixed list of data sources:
(TBT)

  sub data_sources
  {
      my($drh, $attr) = @_;
      my(@list) = ();
      # You need more sophisticated code than this to set @list...
      push @list, "dbi:Driver:abc";
      push @list, "dbi:Driver:def";
      push @list, "dbi:Driver:ghi";
      # End of code to set @list
      return @list;
  }

=head4 The disconnect_all() method

=begin original

If you need to release any resources when the driver is unloaded, you
can provide a disconnect_all method.

=end original

If you need to release any resources when the driver is unloaded, you
can provide a disconnect_all method.
(TBT)

=head4 Other driver handle methods

=begin original

If you need any other driver handle methods, they can follow here.

=end original

If you need any other driver handle methods, they can follow here.
(TBT)

=head4 Error handling

=begin original

It is quite likely that something fails in the connect method.
With B<DBD::File> for example, you might catch an error when setting the
current directory to something not existent by using the
(driver-specific) I<f_dir> attribute.

=end original

connectメソッドでなんらかの失敗があるというのはよくあることです。
例えば B<DBD::File> では、I<f_dir> 属性を使って存在しないディレクトリに
カレントディレクトリを設定するとエラーとなります。 

=begin original

To report an error, you use the C<set_err()> method:

=end original

エラーを報告するためには、C<DBI::set_err> メソッドを使います:

  $h->set_err($err, $errmsg, $state);

=begin original

This will ensure that the error is recorded correctly and that
I<RaiseError> and I<PrintError> etc are handled correctly.

=end original

これはエラーが正しく記録されること、I<RaiseError> や I<PrintError> などが
正しく扱われることを保証します。

=begin original

Typically you'll always use the method instance, aka your method's first
argument.

=end original

典型的には常にこのメソッドインスタンスを、いわゆるメソッドの最初の
引数として使います。

=begin original

As C<set_err()> always returns C<undef> your error handling code can
usually be simplified to something like this:

=end original

C<set_err> は常に C<undef> を返すので、エラーを扱うコードは通常、
以下のように単純にすることができます:

  return $h->set_err($err, $errmsg, $state) if ...;

=head3 The DBD::Driver::db package

  package DBD::Driver::db; # ====== DATABASE ======

  $DBD::Driver::db::imp_data_size = 0;

=head4 The statement handle constructor

=begin original

There's nothing much new in the statement handle constructor, which
is the C<prepare()> method:

=end original

文ハンドルコンストラクタでは新しいことはあまりありません;
C<prepare()> メソッドです:

  sub prepare
  {
      my ($dbh, $statement, @attribs) = @_;

      # create a 'blank' sth
      my ($outer, $sth) = DBI::_new_sth($dbh, { Statement => $statement });

      $sth->STORE('NUM_OF_PARAMS', ($statement =~ tr/?//));

      $sth->{drv_params} = [];

      return $outer;
  }

=begin original

This is still the same -- check the arguments and call the super class
constructor C<DBI::_new_sth()>. Again, in scalar context, only the outer
handle is returned. The I<Statement> attribute should be cached as
shown.

=end original

ここまではまだ同じです -- 引数をチェックし、上位クラスコンストラクタ
C<DBI::_new_sth> を呼び出します。
Again, in scalar context, only the outer
handle is returned. The I<Statement> attribute should be cached as
shown.
(TBT)

=begin original

Note the prefix I<drv_> in the attribute names: it is required that
all your private attributes use a lowercase prefix unique to your driver.
As mentioned earlier in this document, the B<DBI> contains a registry of
known driver prefixes and may one day warn about unknown attributes
that don't have a registered prefix.

=end original

属性名での接頭辞 I<drv_> に注意してください:独自の属性はすべて小文字の
そのような接頭辞を使わなければなりません。
As mentioned earlier in this document, the B<DBI> contains a registry of
known driver prefixes and may one day warn about unknown attributes
that don't have a registered prefix.
(TBT)

=begin original

Note that we parse the statement here in order to set the attribute
I<NUM_OF_PARAMS>. The technique illustrated is not very reliable; it can
be confused by question marks appearing in quoted strings, delimited
identifiers or in SQL comments that are part of the SQL statement. We
could set I<NUM_OF_PARAMS> in the C<execute()> method instead because
the B<DBI> specification explicitly allows a driver to defer this, but then
the user could not call C<bind_param()>.

=end original

ここで属性 I<NUM_OF_PARAMS> を設定するために文を解析することに
注意してください。
The technique illustrated is not very reliable; it can
be confused by question marks appearing in quoted strings, delimited
identifiers or in SQL comments that are part of the SQL statement.
B<DBI> の仕様は明確に後に遅らせることを許しているので、
C<execute()> メソッドで I<NUM_OF_PARAMS> を設定することができますが、
しかしながら、その場合は C<bind_param()> を呼び出すことが出来ません。

=head4 Transaction handling

=begin original

Pure Perl drivers will rarely support transactions. Thus your C<commit()>
and C<rollback()> methods will typically be quite simple:

=end original

ピュア Perl ドライバではほとんどトランザクションをサポートしていません。
このため C<commit()> と C<rollback()> メソッドは通常とても単純です:

  sub commit
  {
      my ($dbh) = @_;
      if ($dbh->FETCH('Warn')) {
          warn("Commit ineffective while AutoCommit is on");
      }
      0;
  }

  sub rollback {
      my ($dbh) = @_;
      if ($dbh->FETCH('Warn')) {
          warn("Rollback ineffective while AutoCommit is on");
      }
      0;
  }

=begin original

Or even simpler, just use the default methods provided by the B<DBI> that
do nothing except return C<undef>.

=end original

Or even simpler, just use the default methods provided by the B<DBI> that
do nothing except return C<undef>.
(TBT)

=begin original

The B<DBI>'s default C<begin_work()> method can be used by inheritance.

=end original

The B<DBI>'s default C<begin_work()> method can be used by inheritance.
(TBT)

=head4 The STORE() and FETCH() methods

=begin original

These methods (that we have already used, see above) are called for
you, whenever the user does a:

=end original

これらのメソッド(既に使っています。上記をご覧下さい)は、利用者が
以下のようにしたり:

  $dbh->{$attr} = $val;

=begin original

or, respectively,

=end original

またはこの反対にするときに使われます:

  $val = $dbh->{$attr};

=begin original

See L<perltie> for details on tied hash refs to understand why these
methods are required.

=end original

なぜ tie されたハッシュリファレンスにはこれらのメソッドが必要なのかを
理解するための詳細については L<perltie> をご覧下さい。

=begin original

The B<DBI> will handle most attributes for you, in particular attributes
like I<RaiseError> or I<PrintError>. All you have to do is handle your
driver's private attributes and any attributes, like I<AutoCommit> and
I<ChopBlanks>, that the B<DBI> can't handle for you.

=end original

B<DBI> は大抵の属性、特に I<RaiseError> や I<PrintError> といった属性を、
あなたに代わって取り扱います。
ドライバ独自の属性や B<DBI> が扱うことが出来ない I<AutoCommit> や
I<ChopBlanks> といった属性だけを取り扱わなければなりません。

=begin original

A good example might look like this:

=end original

よい例は以下のようになります:

  sub STORE
  {
      my ($dbh, $attr, $val) = @_;
      if ($attr eq 'AutoCommit') {
          # AutoCommit is currently the only standard attribute we have
          # to consider.
          if (!$val) { die "Can't disable AutoCommit"; }
          return 1;
      }
      if ($attr =~ m/^drv_/) {
          # Handle only our private attributes here
          # Note that we could trigger arbitrary actions.
          # Ideally we should warn about unknown attributes.
          $dbh->{$attr} = $val; # Yes, we are allowed to do this,
          return 1;             # but only for our private attributes
      }
      # Else pass up to DBI to handle for us
      $dbh->SUPER::STORE($attr, $val);
  }

  sub FETCH
  {
      my ($dbh, $attr) = @_;
      if ($attr eq 'AutoCommit') { return 1; }
      if ($attr =~ m/^drv_/) {
          # Handle only our private attributes here
          # Note that we could trigger arbitrary actions.
          return $dbh->{$attr}; # Yes, we are allowed to do this,
                                # but only for our private attributes
      }
      # Else pass up to DBI to handle
      $dbh->SUPER::FETCH($attr);
  }

=begin original

The B<DBI> will actually store and fetch driver-specific attributes (with all
lowercase names) without warning or error, so there's actually no need to
implement driver-specific any code in your C<FETCH()> and C<STORE()>
methods unless you need extra logic/checks, beyond getting or setting
the value.

=end original

B<DBI> は実際には警告もエラーもなしに、ドライバ特有の属性(すべて小文字の
名前で)を格納し、取り出します。
そのため値の取得や設定で特別なロジック／チェックを必要としないのであれば、
実際には C<FETCH()> や C<STORE()> メソッドに、ドライバ特有のコードは何も
実装する必要はありません。

=begin original

Unless your driver documentation indicates otherwise, the return value of
the C<STORE()> method is unspecified and the caller shouldn't use that value.

=end original

Unless your driver documentation indicates otherwise, the return value of
the C<STORE()> method is unspecified and the caller shouldn't use that value.
(TBT)

=head4 Other database handle methods

(その他のデータベースハンドルメソッド)

=begin original

As with the driver package, other database handle methods may follow here.
In particular you should consider a (possibly empty) C<disconnect()>
method and possibly a C<quote()> method if B<DBI>'s default isn't correct for
you. You may also need the C<type_info_all()> and C<get_info()> methods,
as described elsewhere in this document.

=end original

この後に他のデータベースハンドルメソッドをいれることができます。
(DBIのデフォルトが正しくなければ)特に(ひっとしたら空かもしれない
C<disconnect()> メソッド、C<quote()> メソッドについてよく検討してください。
You may also need the C<type_info_all()> and C<get_info()> methods,
as described elsewhere in this document.
(TBT)

=begin original

Where reasonable use C<$h-E<gt>SUPER::foo()> to call the B<DBI>'s method in
some or all cases and just wrap your custom behavior around that.

=end original

Where reasonable use C<$h-E<gt>SUPER::foo()> to call the B<DBI>'s method in
some or all cases and just wrap your custom behavior around that.
(TBT)

=begin original

If you want to use private trace flags you'll probably want to be
able to set them by name. To do that you'll need to define a
C<parse_trace_flag()> method (note that's "parse_trace_flag", singular,
not "parse_trace_flags", plural).

=end original

If you want to use private trace flags you'll probably want to be
able to set them by name. To do that you'll need to define a
C<parse_trace_flag()> method (note that's "parse_trace_flag", singular,
not "parse_trace_flags", plural).
(TBT)

  sub parse_trace_flag {
      my ($h, $name) = @_;
      return 0x01000000 if $name eq 'foo';
      return 0x02000000 if $name eq 'bar';
      return 0x04000000 if $name eq 'baz';
      return 0x08000000 if $name eq 'boo';
      return 0x10000000 if $name eq 'bop';
      return $h->SUPER::parse_trace_flag($name);
  }

=begin original

All private flag names must be lowercase, and all private flags
must be in the top 8 of the 32 bits.

=end original

All private flag names must be lowercase, and all private flags
must be in the top 8 of the 32 bits.
(TBT)

=head3 The DBD::Driver::st package

=begin original

This package follows the same pattern the others do:

=end original

This package follows the same pattern the others do:
(TBT)

  package DBD::Driver::st;

  $DBD::Driver::st::imp_data_size = 0;

=head4 The execute() and bind_param() methods

=begin original

This is perhaps the most difficult method because we have to consider
parameter bindings here. In addition to that, there are a number of
statement attributes which must be set for inherited B<DBI> methods to
function correctly (see L</Statement attributes> below).

=end original

ここでパラメータバインディングを考慮しなければならないために、これが多分
最も難しいメソッドです。
In addition to that, there are a number of
statement attributes which must be set for inherited B<DBI> methods to
function correctly (see L</Statement attributes> below).
(TBT)

=begin original

We present a simplified implementation by using the I<drv_params>
attribute from above:

=end original

上記から I<drv_params> 属性を使うことにより簡単になった実装を示します:

  sub bind_param
  {
      my ($sth, $pNum, $val, $attr) = @_;
      my $type = (ref $attr) ? $attr->{TYPE} : $attr;
      if ($type) {
          my $dbh = $sth->{Database};
          $val = $dbh->quote($sth, $type);
      }
      my $params = $sth->{drv_params};
      $params->[$pNum-1] = $val;
      1;
  }

  sub execute
  {
      my ($sth, @bind_values) = @_;

      # start of by finishing any previous execution if still active
      $sth->finish if $sth->FETCH('Active');

      my $params = (@bind_values) ?
          \@bind_values : $sth->{drv_params};
      my $numParam = $sth->FETCH('NUM_OF_PARAMS');
      return $sth->set_err($DBI::stderr, "Wrong number of parameters")
          if @$params != $numParam;
      my $statement = $sth->{'Statement'};
      for (my $i = 0;  $i < $numParam;  $i++) {
          $statement =~ s/?/$params->[$i]/; # XXX doesn't deal with quoting etc!
      }
      # Do anything ... we assume that an array ref of rows is
      # created and store it:
      $sth->{'drv_data'} = $data;
      $sth->{'drv_rows'} = @$data; # number of rows
      $sth->STORE('NUM_OF_FIELDS') = $numFields;
      $sth->{Active} = 1;
      @$data || '0E0';
  }

=begin original

There are a number of things you should note here.

=end original

ここでいくつか注意しなければならないがあります。

=begin original

We initialize the I<NUM_OF_FIELDS> and I<Active> attributes here,
because they are essential for C<bind_columns()> to work.

=end original

ここで I<NUM_OF_FIELDS> 属性を設定することです。
というのも C<bind_columns()> 属性が機能するためには必須だからです。

=begin original

We use attribute C<$sth-E<gt>{Statement}> which we created
within C<prepare()>. The attribute C<$sth-E<gt>{Database}>, which is
nothing else than the I<dbh>, was automatically created by B<DBI>.

=end original

そして属性 C<$sth-E<gt>{Statement}> を使います;
これは C<prepare()> の中で生成しています。
属性 C<$sth-E<gt>{Database}>、これは I<dth> 以外のなにものでもないのですが、
自動的に B<DBI> によって作成されます。

=begin original

Finally, note that (as specified in the B<DBI> specification) we return the
string C<'0E0'> instead of the number 0, so that the result tests true but
equal to zero.

=end original

最後に、(B<DBI> 仕様で指定されている通り) 数値 0 ではなく、
文字列 C<'0E0'> を返すことに注意してください;
そのため so that the result tests true but equal to zero.
(TBT)

  $sth->execute() or die $sth->errstr;

=head4 The execute_array(), execute_for_fetch() and bind_param_array() methods

=begin original

In general, DBD's only need to implement C<execute_for_fetch()> and
C<bind_param_array>. DBI's default C<execute_array()> will invoke the
DBD's C<execute_for_fetch()> as needed.

=end original

In general, DBD's only need to implement C<execute_for_fetch()> and
C<bind_param_array>. DBI's default C<execute_array()> will invoke the
DBD's C<execute_for_fetch()> as needed.
(TBT)

=begin original

The following sequence describes the interaction between
DBI C<execute_array> and a DBD's C<execute_for_fetch>:

=end original

The following sequence describes the interaction between
DBI C<execute_array> and a DBD's C<execute_for_fetch>:
(TBT)

=over

=item 1

=begin original

App calls C<$sth-E<gt>execute_array(\%attrs, @array_of_arrays)>

=end original

App calls C<$sth-E<gt>execute_array(\%attrs, @array_of_arrays)>
(TBT)

=item 2

=begin original

If C<@array_of_arrays> was specified, DBI processes C<@array_of_arrays> by calling
DBD's C<bind_param_array()>. Alternately, App may have directly called
C<bind_param_array()>

=end original

If C<@array_of_arrays> was specified, DBI processes C<@array_of_arrays> by calling
DBD's C<bind_param_array()>. Alternately, App may have directly called
C<bind_param_array()>
(TBT)

=item 3

=begin original

DBD validates and binds each array

=end original

DBD validates and binds each array
(TBT)

=item 4

=begin original

DBI retrieves the validated param arrays from DBD's ParamArray attribute

=end original

DBI retrieves the validated param arrays from DBD's ParamArray attribute
(TBT)

=item 5

=begin original

DBI calls DBD's C<execute_for_fetch($fetch_tuple_sub, \@tuple_status)>,
where C<&$fetch_tuple_sub> is a closure to iterate over the
returned ParamArray values, and C<\@tuple_status> is an array to receive
the disposition status of each tuple.

=end original

DBI calls DBD's C<execute_for_fetch($fetch_tuple_sub, \@tuple_status)>,
where C<&$fetch_tuple_sub> is a closure to iterate over the
returned ParamArray values, and C<\@tuple_status> is an array to receive
the disposition status of each tuple.
(TBT)

=item 6

=begin original

DBD iteratively calls C<&$fetch_tuple_sub> to retrieve parameter tuples
to be added to its bulk database operation/request.

=end original

DBD iteratively calls C<&$fetch_tuple_sub> to retrieve parameter tuples
to be added to its bulk database operation/request.
(TBT)

=item 7

=begin original

when DBD reaches the limit of tuples it can handle in a single database
operation/request, or the C<&$fetch_tuple_sub> indicates no more
tuples by returning undef, the DBD executes the bulk operation, and
reports the disposition of each tuple in \@tuple_status.

=end original

when DBD reaches the limit of tuples it can handle in a single database
operation/request, or the C<&$fetch_tuple_sub> indicates no more
tuples by returning undef, the DBD executes the bulk operation, and
reports the disposition of each tuple in \@tuple_status.
(TBT)

=item 8

=begin original

DBD repeats steps 6 and 7 until all tuples are processed.

=end original

DBD repeats steps 6 and 7 until all tuples are processed.
(TBT)

=back

=begin original

E.g., here's the essence of L<DBD::Oracle>'s execute_for_fetch:

=end original

E.g., here's the essence of L<DBD::Oracle>'s execute_for_fetch:
(TBT)

       while (1) {
           my @tuple_batch;
           for (my $i = 0; $i < $batch_size; $i++) {
                push @tuple_batch, [ @{$fetch_tuple_sub->() || last} ];
           }
           last unless @tuple_batch;
           my $res = ora_execute_array($sth, \@tuple_batch,
              scalar(@tuple_batch), $tuple_batch_status);
           push @$tuple_status, @$tuple_batch_status;
       }

=begin original

Note that DBI's default execute_array()/execute_for_fetch() implementation
requires the use of positional (i.e., '?') placeholders. Drivers
which B<require> named placeholders must either emulate positional
placeholders (e.g., see L<DBD::Oracle>), or must implement their own
execute_array()/execute_for_fetch() methods to properly sequence bound
parameter arrays.

=end original

Note that DBI's default execute_array()/execute_for_fetch() implementation
requires the use of positional (i.e., '?') placeholders. Drivers
which B<require> named placeholders must either emulate positional
placeholders (e.g., see L<DBD::Oracle>), or must implement their own
execute_array()/execute_for_fetch() methods to properly sequence bound
parameter arrays.
(TBT)

=head4 Fetching data

=begin original

Only one method needs to be written for fetching data, C<fetchrow_arrayref()>.
The other methods, C<fetchrow_array()>, C<fetchall_arrayref()>, etc, as well
as the database handle's C<select*> methods are part of B<DBI>, and call
C<fetchrow_arrayref()> as necessary.

=end original

Only one method needs to be written for fetching data, C<fetchrow_arrayref()>.
The other methods, C<fetchrow_array()>, C<fetchall_arrayref()>, etc, as well
as the database handle's C<select*> methods are part of B<DBI>, and call
C<fetchrow_arrayref()> as necessary.
(TBT)

  sub fetchrow_arrayref
  {
      my ($sth) = @_;
      my $data = $sth->{drv_data};
      my $row = shift @$data;
      if (!$row) {
          $sth->STORE(Active => 0); # mark as no longer active
          return undef;
      }
      if ($sth->FETCH('ChopBlanks')) {
          map { $_ =~ s/\s+$//; } @$row;
      }
      return $sth->_set_fbav($row);
  }
  *fetch = \&fetchrow_arrayref; # required alias for fetchrow_arrayref

=begin original

Note the use of the method C<_set_fbav()> -- this is required so that
C<bind_col()> and C<bind_columns()> work.

=end original

メソッド C<_set_fbav> を使っていることに注意してください -- これは
C<bind_col()> や C<bind_columns()> が機能するために必要です。

=begin original

If an error occurs which leaves the I<$sth> in a state where remaining rows
can't be fetched then I<Active> should be turned off before the method returns.

=end original

If an error occurs which leaves the I<$sth> in a state where remaining rows
can't be fetched then I<Active> should be turned off before the method returns.
(TBT)

=begin original

The C<rows()> method for this driver can be implemented like this:

=end original

The C<rows()> method for this driver can be implemented like this:
(TBT)

  sub rows { shift->{drv_rows} }

=begin original

because it knows in advance how many rows it has fetched.
Alternatively you could delete that method and so fallback
to the B<DBI>'s own method which does the right thing based
on the number of calls to C<_set_fbav()>.

=end original

because it knows in advance how many rows it has fetched.
Alternatively you could delete that method and so fallback
to the B<DBI>'s own method which does the right thing based
on the number of calls to C<_set_fbav()>.
(TBT)

=head4 The more_results method

=begin original

If your driver doesn't support multiple result sets, then don't even implement this method.

=end original

If your driver doesn't support multiple result sets, then don't even implement this method.
(TBT)

=begin original

Otherwise, this method needs to get the statement handle ready to fetch results
from the next result set, if there is one. Typically you'd start with:

=end original

Otherwise, this method needs to get the statement handle ready to fetch results
from the next result set, if there is one. Typically you'd start with:
(TBT)

    $sth->finish;

=begin original

then you should delete all the attributes from the attribute cache that may no
longer be relevant for the new result set:

=end original

then you should delete all the attributes from the attribute cache that may no
longer be relevant for the new result set:
(TBT)

    delete $sth->{$_}
        for qw(NAME TYPE PRECISION SCALE ...);

=begin original

for drivers written in C use:

=end original

for drivers written in C use:
(TBT)

    hv_delete((HV*)SvRV(sth), "NAME", 4, G_DISCARD);
    hv_delete((HV*)SvRV(sth), "NULLABLE", 8, G_DISCARD);
    hv_delete((HV*)SvRV(sth), "NUM_OF_FIELDS", 13, G_DISCARD);
    hv_delete((HV*)SvRV(sth), "PRECISION", 9, G_DISCARD);
    hv_delete((HV*)SvRV(sth), "SCALE", 5, G_DISCARD);
    hv_delete((HV*)SvRV(sth), "TYPE", 4, G_DISCARD);

=begin original

Don't forget to also delete, or update, any driver-private attributes that may
not be correct for the next resultset.

=end original

Don't forget to also delete, or update, any driver-private attributes that may
not be correct for the next resultset.
(TBT)

=begin original

The NUM_OF_FIELDS attribute is a special case. It should be set using STORE:

=end original

The NUM_OF_FIELDS attribute is a special case. It should be set using STORE:
(TBT)

    $sth->STORE(NUM_OF_FIELDS => 0); /* for DBI <= 1.53 */
    $sth->STORE(NUM_OF_FIELDS => $new_value);

=begin original

for drivers written in C use this incantation:

=end original

for drivers written in C use this incantation:
(TBT)

    /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */
    DBIc_NUM_FIELDS(imp_sth) = 0; /* for DBI <= 1.53 */
    DBIc_STATE(imp_xxh)->set_attr_k(sth, sv_2mortal(newSVpvn("NUM_OF_FIELDS",13)), 0,
        sv_2mortal(newSViv(mysql_num_fields(imp_sth->result)))
    );

=begin original

For DBI versions prior to 1.54 you'll also need to explicitly adjust the
number of elements in the row buffer array (C<DBIc_FIELDS_AV(imp_sth)>)
to match the new result set. Fill any new values with newSV(0) not &sv_undef.
Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null,
but that would mean bind_columns() wouldn't work across result sets.

=end original

For DBI versions prior to 1.54 you'll also need to explicitly adjust the
number of elements in the row buffer array (C<DBIc_FIELDS_AV(imp_sth)>)
to match the new result set. Fill any new values with newSV(0) not &sv_undef.
Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null,
but that would mean bind_columns() wouldn't work across result sets.
(TBT)

=head4 Statement attributes

=begin original

The main difference between I<dbh> and I<sth> attributes is, that you
should implement a lot of attributes here that are required by
the B<DBI>, such as I<NAME>, I<NULLABLE>, I<TYPE>, etc. See
L<DBI/Statement Handle Attributes> for a complete list.

=end original

I<dbh> と I<sth> 属性の主な違いは、ここでは B<DBI> によって要求されている
たくさんの属性を実装しなければならないことです。
例えば: I<NAME>, I<NULLABLE>, I<TYPE> など。
完全なリストについては L<DBI/Statement Handle Attributes> を
参照してください。

=begin original

Pay attention to attributes which are marked as read only, such as
I<NUM_OF_PARAMS>. These attributes can only be set the first time
a statement is executed. If a statement is prepared, then executed
multiple times, warnings may be generated.

=end original

Pay attention to attributes which are marked as read only, such as
I<NUM_OF_PARAMS>. These attributes can only be set the first time
a statement is executed. If a statement is prepared, then executed
multiple times, warnings may be generated.
(TBT)

=begin original

You can protect against these warnings, and prevent the recalculation
of attributes which might be expensive to calculate (such as the
I<NAME> and I<NAME_*> attributes):

=end original

You can protect against these warnings, and prevent the recalculation
of attributes which might be expensive to calculate (such as the
I<NAME> and I<NAME_*> attributes):
(TBT)

    my $storedNumParams = $sth->FETCH('NUM_OF_PARAMS');
    if (!defined $storedNumParams or $storedNumFields < 0) {
        $sth->STORE('NUM_OF_PARAMS') = $numParams;

        # Set other useful attributes that only need to be set once
        # for a statement, like $sth->{NAME} and $sth->{TYPE}
    }

=begin original

One particularly important attribute to set correctly (mentioned in
L<DBI/ATTRIBUTES COMMON TO ALL HANDLES> is I<Active>. Many B<DBI> methods,
including C<bind_columns()>, depend on this attribute.

=end original

One particularly important attribute to set correctly (mentioned in
L<DBI/ATTRIBUTES COMMON TO ALL HANDLES> is I<Active>. Many B<DBI> methods,
including C<bind_columns()>, depend on this attribute.
(TBT)

=begin original

Besides that the C<STORE()> and C<FETCH()> methods are mainly the same
as above for I<dbh>'s.

=end original

C<STORE()> と C<FETCH()> のほかのメソッドは概ね上記の I<dbh> のものと
同じです。

=head4 Other statement methods

=begin original

A trivial C<finish()> method to discard stored data, reset any attributes
(such as I<Active>) and do C<$sth-E<gt>SUPER::finish()>.

=end original

平凡な C<finish()> メソッドは格納されたデータを捨て、(I<Active> のような)
全ての属性をリセットし、C<$sth-E<gt>SUPER::finish()> をします。

=begin original

If you've defined a C<parse_trace_flag()> method in B<::db> you'll also want
it in B<::st>, so just alias it in:

=end original

If you've defined a C<parse_trace_flag()> method in B<::db> you'll also want
it in B<::st>, so just alias it in:
(TBT)

  *parse_trace_flag = \&DBD::foo:db::parse_trace_flag;

=begin original

And perhaps some other methods that are not part of the B<DBI>
specification, in particular to make metadata available.
Remember that they must have names that begin with your drivers
registered prefix so they can be installed using C<install_method()>.

=end original

そしておそらく B<DBI> 仕様にはないいくつかの他のメソッド、特に
メタデータの作成が利用可能です。
Remember that they must have names that begin with your drivers
registered prefix so they can be installed using C<install_method()>.
(TBT)

=begin original

If C<DESTROY()> is called on a statement handle that's still active
(C<$sth-E<gt>{Active}> is true) then it should effectively call C<finish()>.

=end original

If C<DESTROY()> is called on a statement handle that's still active
(C<$sth-E<gt>{Active}> is true) then it should effectively call C<finish()>.
(TBT)

    sub DESTROY {
        my $sth = shift;
        $sth->finish if $sth->FETCH('Active');
    }

=head2 Tests

(テスト)

=begin original

The test process should conform as closely as possibly to the Perl
standard test harness.

=end original

テストプロセスは Perl 標準規約(Perl standard test harness)にできるだけ
従うべきです。

=begin original

In particular, most (all) of the tests should be run in the F<t> sub-directory,
and should simply produce an C<ok> when run under C<make test>.
For details on how this is done, see the Camel book and the section in
Chapter 7, "The Standard Perl Library" on L<Test::Harness>.

=end original

特にテストのほとんど(全て)は F<t> サブディレクトリで
実行されなければなりません。
そして C<make test> で実行されたときには単純に C<ok> だけを生成するべきです。
これがどのようにするかについての詳細についてはラクダ本の
第 7 章「標準 Perl ライブラリ」の L<Test::Harness> のセクションを
ごらんください。

=begin original

The tests may need to adapt to the type of database which is being used
for testing, and to the privileges of the user testing the driver. For
example, the B<DBD::Informix> test code has to adapt in a number of
places to the type of database to which it is connected as different
Informix databases have different capabilities: some of the tests are
for databases without transaction logs; others are for databases with a
transaction log; some versions of the server have support for blobs, or
stored procedures, or user-defined data types, and others do not.

=end original

テストはテストするために使われるデータベースのタイプやドライバを
テストするユーザの権限に合わせる必要があるかもしれません。
例えば、B<DBD::Informix> のテストコードは多くの場所で、異なった
Informix データベースが異なった能力を持っているのに合わせて、
接続されているデータベースのタイプに順応しなければなりません:
some of the tests are
for databases without transaction logs; others are for databases with a
transaction log; some versions of the server have support for blobs, or
stored procedures, or user-defined data types, and others do not.
(TBT)

=begin original

When a complete file of tests must be skipped, you can provide a reason
in a pseudo-comment:

=end original

When a complete file of tests must be skipped, you can provide a reason
in a pseudo-comment:
(TBT)

    if ($no_transactions_available)
    {
        print "1..0 # Skip: No transactions available\n";
        exit 0;
    }

=begin original

Consider downloading the B<DBD::Informix> code and look at the code in
F<DBD/Informix/TestHarness.pm> which is used throughout the
B<DBD::Informix> tests in the F<t> sub-directory.

=end original

Consider downloading the B<DBD::Informix> code and look at the code in
F<DBD/Informix/TestHarness.pm> which is used throughout the
B<DBD::Informix> tests in the F<t> sub-directory.
(TBT)

=head1 CREATING A C/XS DRIVER

(C/XS ドライバを作る)

=begin original

Please also see the section under L<CREATING A PURE PERL DRIVER>
regarding the creation of the F<Makefile.PL>.

=end original

Please also see the section under L<CREATING A PURE PERL DRIVER>
regarding the creation of the F<Makefile.PL>.
(TBT)

=begin original

Creating a new C/XS driver from scratch will always be a daunting task.
You can and should greatly simplify your task by taking a good
reference driver implementation and modifying that to match the
database product for which you are writing a driver.

=end original

ありあわせからC/XSドライバを作成することは、気の重たくなる作業です。
参照となるドライバ実装をピックアップし、それをドライバを書こうとしている
データベース製品にあうように改造することによってかなり簡単に
することができますし、するべきです。

=begin original

The de facto reference driver has been the one for B<DBD::Oracle> written
by Tim Bunce, who is also the author of the B<DBI> package. The B<DBD::Oracle>
module is a good example of a driver implemented around a C-level API.

=end original

事実上のリファレンスドライバは B<DBI> パッケージの作者でもある
Tim Bunce によって書かれた B<DBD::Oracle> でした。
B<DBD::Oracle> モジュールは C レベル API によって実装されている、
よい例です。

=begin original

Nowadays it it seems better to base on B<DBD::ODBC>, another driver
maintained by Tim and Jeff Urlwin, because it offers a lot of metadata
and seems to become the guideline for the future development. (Also as
B<DBD::Oracle> digs deeper into the Oracle 8 OCI interface it'll get even
more hairy than it is now.)

=end original

今日では Tim とJeff Urlwin によってメンテナンスされている
B<DBD::ODBC> という別のドライバを元にしたほうがよいようです。
というのも数多くのメタデータを提供していますし、将来の開発のための
ガイドラインとなるようにも思われます(B<DBD::Oracle> も
Oracle 8 OCI インターフェースに深く掘り下げているので、いまでは
ほんのわずかの差しかないでしょう)。

=begin original

The B<DBD::Informix> driver is one driver implemented using embedded SQL
instead of a function-based API.
B<DBD::Ingres> may also be worth a look.

=end original

B<DBD::Informix> ドライバは、関数ベース API ではなく埋め込みSQL
(embedded SQL)を使ったドライバのよいリファレンスです。
B<DBD::Ingress> も一見の価値があります。

=head2 C/XS version of Driver.pm

(C/XS 版の Driver.pm)

=begin original

A lot of the code in the F<Driver.pm> file is very similar to the code for pure Perl modules
- see above.  However,
there are also some subtle (and not so subtle) differences, including:

=end original

A lot of the code in the F<Driver.pm> file is very similar to the code for pure Perl modules
- see above.  However,
there are also some subtle (and not so subtle) differences, including:
(TBT)

=over 8

=item *

=begin original

The variables I<$DBD::Driver::{dr|db|st}::imp_data_size> are not defined
here, but in the XS code, because they declare the size of certain
C structures.

=end original

変数 I<$DBD::Driver::{dr|db|st}::imp_data_size> は、ここで定義されません;
かわりにXSのコードの中で定義されます; というのも、それらはあるCの
構造体の大きさを宣言しているからです。

=item *

=begin original

Some methods are typically moved to the XS code, in particular
C<prepare()>, C<execute()>, C<disconnect()>, C<disconnect_all()> and the
C<STORE()> and C<FETCH()> methods.

=end original

典型的にはいくつかのメソッド、特に
C<prepare()>, C<execute()>, C<disconnect()>, C<disconnect_all()>
そして C<STORE()> および C<FETCH()> メソッドは XS コードに移っています。

=item *

=begin original

Other methods are still part of F<Driver.pm>, but have callbacks to
the XS code.

=end original

他のメソッドはまだ F<Driver.pm> の一部ですが、XS コードにコールバックを
持っています。

=item *

=begin original

If the driver-specific parts of the I<imp_drh_t> structure need to be
formally initialized (which does not seem to be a common requirement),
then you need to add a call to an appropriate XS function in the driver
method of C<DBD::Driver::driver()>, and you define the corresponding function
in F<Driver.xs>, and you define the C code in F<dbdimp.c> and the prototype in
F<dbdimp.h>.

=end original

If the driver-specific parts of the I<imp_drh_t> structure need to be
formally initialized (which does not seem to be a common requirement),
then you need to add a call to an appropriate XS function in the driver
method of C<DBD::Driver::driver()>, and you define the corresponding function
in F<Driver.xs>, and you define the C code in F<dbdimp.c> and the prototype in
F<dbdimp.h>.
(TBT)

=begin original

For example, B<DBD::Informix> has such a requirement, and adds the
following call after the call to C<_new_drh()> in F<Informix.pm>:

=end original

For example, B<DBD::Informix> has such a requirement, and adds the
following call after the call to C<_new_drh()> in F<Informix.pm>:
(TBT)

  DBD::Informix::dr::driver_init($drh);

=begin original

and the following code in F<Informix.xs>:

=end original

and the following code in F<Informix.xs>:
(TBT)

  # Initialize the DBD::Informix driver data structure
  void
  driver_init(drh)
      SV *drh
      CODE:
      ST(0) = dbd_ix_dr_driver_init(drh) ? &sv_yes : &sv_no;

=begin original

and the code in F<dbdimp.h> declares:

=end original

and the code in F<dbdimp.h> declares:
(TBT)

  extern int dbd_ix_dr_driver_init(SV *drh);

=begin original

and the code in F<dbdimp.ec> (equivalent to F<dbdimp.c>) defines:

=end original

and the code in F<dbdimp.ec> (equivalent to F<dbdimp.c>) defines:
(TBT)

  /* Formally initialize the DBD::Informix driver structure */
  int
  dbd_ix_dr_driver(SV *drh)
  {
      D_imp_drh(drh);
      imp_drh->n_connections = 0;       /* No active connections */
      imp_drh->current_connection = 0;  /* No current connection */
      imp_drh->multipleconnections = (ESQLC_VERSION >= 600) ? True : False;
      dbd_ix_link_newhead(&imp_drh->head);  /* Empty linked list of connections */
      return 1;
  }

=begin original

B<DBD::Oracle> has a similar requirement but gets around it by checking
whether the private data part of the driver handle is all zeroed out,
rather than add extra functions.

=end original

B<DBD::Oracle> has a similar requirement but gets around it by checking
whether the private data part of the driver handle is all zeroed out,
rather than add extra functions.
(TBT)

=back

=begin original

Now let's take a closer look at an excerpt from F<Oracle.pm> (revised
heavily to remove idiosyncrasies) as an example, ignoring things that
were already discussed for pure Perl drivers.

=end original

さあ例として F<Oracle.pm> (revised heavily to remove idiosyncrasies)
の一部をさらに詳しく見てみましょう; 既にピュア Perl ドライバで
説明したことは無視します。

=head3 The connect method

=begin original

The connect method is the database handle constructor.
You could write either of two versions of this method: either one which
takes connection attributes (new code) and one which ignores them (old
code only).

=end original

The connect method is the database handle constructor.
You could write either of two versions of this method: either one which
takes connection attributes (new code) and one which ignores them (old
code only).
(TBT)

=begin original

If you ignore the connection attributes, then you omit all mention of
the I<$auth> variable (which is a reference to a hash of attributes), and
the XS system manages the differences for you.

=end original

If you ignore the connection attributes, then you omit all mention of
the I<$auth> variable (which is a reference to a hash of attributes), and
the XS system manages the differences for you.
(TBT)

  sub connect
  {
      my ($drh, $dbname, $user, $auth, $attr) = @_;

      # Some database specific verifications, default settings
      # and the like following here. This should only include
      # syntax checks or similar stuff where it's legal to
      # 'die' in case of errors.

      my $dbh = DBI::_new_dbh($drh, {
              'Name'   => $dbname,
          })
          or return undef;

      # Call the driver-specific function _login in Driver.xs file which
      # calls the DBMS-specific function(s) to connect to the database,
      # and populate internal handle data.
      DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
          or return undef;

      $dbh;
  }

=begin original

This is mostly the same as in the pure Perl case, the exception being
the use of the private C<_login()> callback, which is the function
that will really connect to the database. It is implemented in
F<Driver.xst> (you should not implement it) and calls
C<dbd_db_login6()> or C<dbd_db_login6_sv> from F<dbdimp.c>. See below
for details.

=end original

これはピュア Perl の場合とほとんど同じです。
違いはプライベートな C<_login()> コールバック
(これは実際にデータベースに接続します) を使っていることです;
これは F<Driver.xst> で実装されます(あなたはこれを実装するべきでは
ありません)そして F<dbdimp.c> から C<dbd_db_login6()> または
C<dbd_db_login6_sv> を呼び出します。
詳細は下記をご覧下さい。

=begin original

If your driver has driver-specific attributes which may be passed in the
connect method and hence end up in C<$attr> in C<dbd_db_login6> then it
is best to delete any you process so DBI does not send them again
via STORE after connect. You can do this in C like this:

=end original

If your driver has driver-specific attributes which may be passed in the
connect method and hence end up in C<$attr> in C<dbd_db_login6> then it
is best to delete any you process so DBI does not send them again
via STORE after connect. You can do this in C like this:
(TBT)

  DBD_ATTRIB_DELETE(attr, "my_attribute_name",
                    strlen("my_attribute_name"));

=begin original

However, prior to DBI subversion version 11605 (and fixed post 1.607)
DBD_ATTRIB_DELETE segfaulted so if you cannot guarantee the DBI version
will be post 1.607 you need to use:

=end original

However, prior to DBI subversion version 11605 (and fixed post 1.607)
DBD_ATTRIB_DELETE segfaulted so if you cannot guarantee the DBI version
will be post 1.607 you need to use:
(TBT)

  hv_delete((HV*)SvRV(attr), "my_attribute_name",
                     strlen("my_attribute_name"), G_DISCARD);

 *FIX ME* Discuss removing attributes in Perl code.

=head3 The disconnect_all method

 *FIX ME* T.B.S

=head3 The data_sources method

=begin original

If your C<data_sources()> method can be implemented in pure Perl, then do
so because it is easier than doing it in XS code (see the section above
for pure Perl drivers).

=end original

If your C<data_sources()> method can be implemented in pure Perl, then do
so because it is easier than doing it in XS code (see the section above
for pure Perl drivers).
(TBT)

=begin original

If your C<data_sources()> method must call onto compiled functions, then
you will need to define I<dbd_dr_data_sources> in your F<dbdimp.h> file, which
will trigger F<Driver.xst> (in B<DBI> v1.33 or greater) to generate the XS
code that calls your actual C function (see the discussion below for
details) and you do not code anything in F<Driver.pm> to handle it.

=end original

If your C<data_sources()> method must call onto compiled functions, then
you will need to define I<dbd_dr_data_sources> in your F<dbdimp.h> file, which
will trigger F<Driver.xst> (in B<DBI> v1.33 or greater) to generate the XS
code that calls your actual C function (see the discussion below for
details) and you do not code anything in F<Driver.pm> to handle it.
(TBT)

=head3 The prepare method

=begin original

The prepare method is the statement handle constructor, and most of it
is not new. Like the C<connect()> method, it now has a C callback:

=end original

The prepare method is the statement handle constructor, and most of it
is not new.
C<connect()> メソッドと同様に、C コールバックを持ちます:
(TBT)

  package DBD::Driver::db; # ====== DATABASE ======
  use strict;

  sub prepare
  {
      my ($dbh, $statement, $attribs) = @_;

      # create a 'blank' sth
      my $sth = DBI::_new_sth($dbh, {
          'Statement' => $statement,
          })
          or return undef;

      # Call the driver-specific function _prepare in Driver.xs file
      # which calls the DBMS-specific function(s) to prepare a statement
      # and populate internal handle data.
      DBD::Driver::st::_prepare($sth, $statement, $attribs)
          or return undef;
      $sth;
  }

=head3 The execute method

 *FIX ME* T.B.S

=head3 The fetchrow_arrayref method

 *FIX ME* T.B.S

=head3 Other methods?

 *FIX ME* T.B.S

=head2 Driver.xs

=begin original

F<Driver.xs> should look something like this:

=end original

F<Driver.xs> は以下のような感じになります:

  #include "Driver.h"

  DBISTATE_DECLARE;

  INCLUDE: Driver.xsi

  MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr

  /* Non-standard drh XS methods following here, if any.       */
  /* If none (the usual case), omit the MODULE line above too. */

  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db

  /* Non-standard dbh XS methods following here, if any.       */
  /* Currently this includes things like _list_tables from     */
  /* DBD::mSQL and DBD::mysql.                                 */

  MODULE = DBD::Driver    PACKAGE = DBD::Driver::st

  /* Non-standard sth XS methods following here, if any.       */
  /* In particular this includes things like _list_fields from */
  /* DBD::mSQL and DBD::mysql for accessing metadata.          */

=begin original

Note especially the include of F<Driver.xsi> here: B<DBI> inserts stub
functions for almost all private methods here which will typically do
much work for you.

=end original

特にここで F<Driver.xsi> のインクルードに注意してください:
B<DBI> は、ほとんどのプライベートなメソッドのためのスタブ関数をここに
入れており、それらは通常はあなたに代っていろんな機能をします。

=begin original

Wherever you really have to implement something, it will call a private
function in F<dbdimp.c>, and this is what you have to implement.

=end original

なにかを本当に実装する必要があるときには、F<dbdimp.c> でプライベートな
関数を呼びます; これがあなたは実装しなけばならないものです。

=begin original

You need to set up an extra routine if your driver needs to export
constants of its own, analogous to the SQL types available when you say:

=end original

You need to set up an extra routine if your driver needs to export
constants of its own, analogous to the SQL types available when you say:
(TBT)

  use DBI qw(:sql_types);

 *FIX ME* T.B.S

=head2 Driver.h

=begin original

F<Driver.h> is very simple and the operational contents should look like this:

=end original

F<Driver.h> はとても単純で、以下のようになります:

  #ifndef DRIVER_H_INCLUDED
  #define DRIVER_H_INCLUDED

  #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
  #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */

  #include <DBIXS.h>      /* installed by the DBI module  */

  #include "dbdimp.h"

  #include "dbivport.h"   /* see below                    */

  #include <dbd_xsh.h>    /* installed by the DBI module  */

  #endif /* DRIVER_H_INCLUDED */

=begin original

The F<DBIXS.h> header defines most of the interesting information that
the writer of a driver needs.

=end original

The F<DBIXS.h> header defines most of the interesting information that
the writer of a driver needs.
(TBT)

=begin original

The file F<dbd_xsh.h> header provides prototype declarations for the C
functions that you might decide to implement. Note that you should
normally only define one of C<dbd_db_login()>, C<dbd_db_login6()> or
C<dbd_db_login6_sv> unless you are intent on supporting really old
versions of B<DBI> (prior to B<DBI> 1.06) as well as modern
versions. The only standard, B<DBI>-mandated functions that you need
write are those specified in the F<dbd_xsh.h> header. You might also
add extra driver-specific functions in F<Driver.xs>.

=end original

The file F<dbd_xsh.h> header provides prototype declarations for the C
functions that you might decide to implement. Note that you should
normally only define one of C<dbd_db_login()>, C<dbd_db_login6()> or
C<dbd_db_login6_sv> unless you are intent on supporting really old
versions of B<DBI> (prior to B<DBI> 1.06) as well as modern
versions. The only standard, B<DBI>-mandated functions that you need
write are those specified in the F<dbd_xsh.h> header. You might also
add extra driver-specific functions in F<Driver.xs>.
(TBT)

=begin original

The F<dbivport.h> file should be I<copied> from the latest B<DBI> release
into your distribution each time you modify your driver. Its job is to
allow you to enhance your code to work with the latest B<DBI> API while
still allowing your driver to be compiled and used with older versions
of the B<DBI> (for example, when the C<DBIh_SET_ERR_CHAR()> macro was added
to B<DBI> 1.41, an emulation of it was added to F<dbivport.h>). This makes
users happy and your life easier. Always read the notes in F<dbivport.h>
to check for any limitations in the emulation that you should be aware
of.

=end original

The F<dbivport.h> file should be I<copied> from the latest B<DBI> release
into your distribution each time you modify your driver. Its job is to
allow you to enhance your code to work with the latest B<DBI> API while
still allowing your driver to be compiled and used with older versions
of the B<DBI> (for example, when the C<DBIh_SET_ERR_CHAR()> macro was added
to B<DBI> 1.41, an emulation of it was added to F<dbivport.h>). This makes
users happy and your life easier. Always read the notes in F<dbivport.h>
to check for any limitations in the emulation that you should be aware
of.
(TBT)

=begin original

With B<DBI> v1.51 or better I recommend that the driver defines
I<PERL_NO_GET_CONTEXT> before F<DBIXS.h> is included. This can significantly
improve efficiency when running under a thread enabled perl. (Remember that
the standard perl in most Linux distributions is built with threads enabled.
So is ActiveState perl for Windows, and perl built for Apache mod_perl2.)
If you do this there are some things to keep in mind:

=end original

With B<DBI> v1.51 or better I recommend that the driver defines
I<PERL_NO_GET_CONTEXT> before F<DBIXS.h> is included. This can significantly
improve efficiency when running under a thread enabled perl. (Remember that
the standard perl in most Linux distributions is built with threads enabled.
So is ActiveState perl for Windows, and perl built for Apache mod_perl2.)
If you do this there are some things to keep in mind:
(TBT)

=over 4

=item *

=begin original

If I<PERL_NO_GET_CONTEXT> is defined, then every function that calls the Perl
API will need to start out with a C<dTHX;> declaration.

=end original

If I<PERL_NO_GET_CONTEXT> is defined, then every function that calls the Perl
API will need to start out with a C<dTHX;> declaration.
(TBT)

=item *

=begin original

You'll know which functions need this, because the C compiler will
complain that the undeclared identifier C<my_perl> is used if I<and only if>
the perl you are using to develop and test your driver has threads enabled.

=end original

You'll know which functions need this, because the C compiler will
complain that the undeclared identifier C<my_perl> is used if I<and only if>
the perl you are using to develop and test your driver has threads enabled.
(TBT)

=item *

=begin original

If you don't remember to test with a thread-enabled perl before making
a release it's likely that you'll get failure reports from users who are.

=end original

If you don't remember to test with a thread-enabled perl before making
a release it's likely that you'll get failure reports from users who are.
(TBT)

=item *

=begin original

For driver private functions it is possible to gain even more
efficiency by replacing C<dTHX;> with C<pTHX_> prepended to the
parameter list and then C<aTHX_> prepended to the argument list where
the function is called.

=end original

For driver private functions it is possible to gain even more
efficiency by replacing C<dTHX;> with C<pTHX_> prepended to the
parameter list and then C<aTHX_> prepended to the argument list where
the function is called.
(TBT)

=back

=begin original

See L<perlguts/How multiple interpreters and concurrency are supported> for
additional information about I<PERL_NO_GET_CONTEXT>.

=end original

See L<perlguts/How multiple interpreters and concurrency are supported> for
additional information about I<PERL_NO_GET_CONTEXT>.
(TBT)

=head2 Implementation header dbdimp.h

(ヘッダ dbdimp.h の実装)

=begin original

This header file has two jobs:

=end original

このヘッダファイルは二つの役割があります:

=begin original

First it defines data structures for your private part of the handles.

=end original

第一にハンドルのプライベートな部分のためのデータ構造を定義します。

=begin original

Second it defines macros that rename the generic names like
C<dbd_db_login()> to database specific names like C<ora_db_login()>. This
avoids name clashes and enables use of different drivers when you work
with a statically linked perl.

=end original

第二に C<dbd_db_login()> のような一般的な名前を C<ora_db_login()> のような
データベース特有の名前に変更するマクロを定義します。
これにより名前の衝突をさけ、静的にリンクされた Perl で動かしたときに
異なるドライバを使うことを可能になります。

=begin original

It also will have the important task of disabling XS methods that you
don't want to implement.

=end original

実装したくないXSメソッドを使えなくするという重要な働きも持っています。

=begin original

Finally, the macros will also be used to select alternate
implementations of some functions. For example, the C<dbd_db_login()>
function is not passed the attribute hash.

=end original

最後にいくつかの関数の代りの実装を選ぶためにもマクロが使われます。
例えば、現在定義されている C<dbd_db_login()> 関数には属性ハッシュは
渡されません。

=begin original

Since B<DBI> v1.06, if a C<dbd_db_login6()> macro is defined (for a function
with 6 arguments), it will be used instead with the attribute hash
passed as the sixth argument.

=end original

Since B<DBI> v1.06, if a C<dbd_db_login6()> macro is defined (for a function
with 6 arguments), it will be used instead with the attribute hash
passed as the sixth argument.
(TBT)

=begin original

Since B<DBI> post v1.607, if a C<dbd_db_login6_sv()> macro is defined (for
a function like dbd_db_login6 but with scalar pointers for the dbname,
username and password), it will be used instead. This will allow your
login6 function to see if there are any Unicode characters in the
dbname.

=end original

Since B<DBI> post v1.607, if a C<dbd_db_login6_sv()> macro is defined (for
a function like dbd_db_login6 but with scalar pointers for the dbname,
username and password), it will be used instead. This will allow your
login6 function to see if there are any Unicode characters in the
dbname.
(TBT)

=begin original

People used to just pick Oracle's F<dbdimp.c> and use the same names,
structures and types. I strongly recommend against that. At first glance
this saves time, but your implementation will be less readable. It was
just hell when I had to separate B<DBI> specific parts, Oracle specific
parts, mSQL specific parts and mysql specific parts in B<DBD::mysql>'s
I<dbdimp.h> and I<dbdimp.c>. (B<DBD::mysql> was a port of B<DBD::mSQL>
which was based on B<DBD::Oracle>.) [Seconded, based on the experience
taking B<DBD::Informix> apart, even though the version inherited in 1996
was only based on B<DBD::Oracle>.]

=end original

Oracle の F<dbdimp.c> だけをピックアップし、いくつかの名前、構造体、
データ型を使う人々がいますが、私はこれには強く反対の勧告をします。
一見、これは時間を節約するように見えますが、あなたの実装を
読みにくくしてしまいます。
B<DBI> 仕様と Oracle 特有の部分、mSQL 特有の部分、mysql 特有の部分を
B<DBD::mysql> の I<dbdimp.h> と I<dbdimp.c>
(B<DBD::mysql> は B<DBD::Oracle> を基本とした B<DBD::mSQL> のポートです)を
分けるというのは地獄です。
[Seconded, based on the experience
taking B<DBD::Informix> apart, even though the version inherited in 1996
was only based on B<DBD::Oracle>.]
(TBT)

=begin original

This part of the driver is I<your exclusive part>. Rewrite it from
scratch, so it will be clean and short: in other words, a better piece
of code. (Of course keep an eye on other people's work.)

=end original

ドライバのこの部分は I<あなたの独占部分> です。
一から書きなおしましょう; そうすることによりきれいで短くなります:
言い換えればよりよいコード片になります。
(もちろん他の人たちの作品も見てください。)

  struct imp_drh_st {
      dbih_drc_t com;           /* MUST be first element in structure   */
      /* Insert your driver handle attributes here */
  };

  struct imp_dbh_st {
      dbih_dbc_t com;           /* MUST be first element in structure   */
      /* Insert your database handle attributes here */
  };

  struct imp_sth_st {
      dbih_stc_t com;           /* MUST be first element in structure   */
      /* Insert your statement handle attributes here */
  };

  /*  Rename functions for avoiding name clashes; prototypes are  */
  /*  in dbd_xst.h                                                */
  #define dbd_init            drv_dr_init
  #define dbd_db_login6_sv    drv_db_login_sv
  #define dbd_db_do           drv_db_do
  ... many more here ...

=begin original

These structures implement your private part of the handles.

=end original

これらの構造体はハンドルのプライベートな部分を実装します。

=begin original

You I<have> to use the name C<imp_dbh_{dr|db|st}> and the first field
I<must> be of type I<dbih_drc_t|_dbc_t|_stc_t> and I<must> be called
C<com>.

=end original

C<imp_dbh_{dr|db|st}> という名前を使う I<必要があり>、最初のフィールドの型は
I<dbih_drc_t|_dbc_t|_stc_t> でなければ I<ならず>、C<com> を呼び出さなければ
I<なりません>。

=begin original

You should never access these fields directly, except by using the
I<DBIc_xxx()> macros below.

=end original

以下に示す I<DBIc_xxx()> を使う以外に、このフィールドに
直接アクセスしてはいけません。

=head2 Implementation source dbdimp.c

(ソース dbdimp.c の実装)

=begin original

Conventionally, F<dbdimp.c> is the main implementation file (but
B<DBD::Informix> calls the file F<dbdimp.ec>). This section includes a
short note on each function that is used in the F<Driver.xsi> template
and thus I<has> to be implemented.

=end original

Conventionally, F<dbdimp.c> is the main implementation file (but
B<DBD::Informix> calls the file F<dbdimp.ec>). This section includes a
short note on each function that is used in the F<Driver.xsi> template
and thus I<has> to be implemented.
(TBT)

=begin original

Of course, you will probably also need to implement other support
functions, which should usually be file static if they are placed in
F<dbdimp.c>. If they are placed in other files, you need to list those
files in F<Makefile.PL> (and F<MANIFEST>) to handle them correctly.

=end original

Of course, you will probably also need to implement other support
functions, which should usually be file static if they are placed in
F<dbdimp.c>. If they are placed in other files, you need to list those
files in F<Makefile.PL> (and F<MANIFEST>) to handle them correctly.
(TBT)

=begin original

It is wise to adhere to a namespace convention for your functions to
avoid conflicts. For example, for a driver with prefix I<drv_>, you
might call externally visible functions I<dbd_drv_xxxx>. You should also
avoid non-constant global variables as much as possible to improve the
support for threading.

=end original

It is wise to adhere to a namespace convention for your functions to
avoid conflicts. For example, for a driver with prefix I<drv_>, you
might call externally visible functions I<dbd_drv_xxxx>. You should also
avoid non-constant global variables as much as possible to improve the
support for threading.
(TBT)

=begin original

Since Perl requires support for function prototypes (ANSI or ISO or
Standard C), you should write your code using function prototypes too.

=end original

Since Perl requires support for function prototypes (ANSI or ISO or
Standard C), you should write your code using function prototypes too.
(TBT)

=begin original

It is possible to use either the unmapped names such as C<dbd_init()> or
the mapped names such as C<dbd_ix_dr_init()> in the F<dbdimp.c> file.
B<DBD::Informix> uses the mapped names which makes it easier to identify
where to look for linkage problems at runtime (which will report errors
using the mapped names).

=end original

It is possible to use either the unmapped names such as C<dbd_init()> or
the mapped names such as C<dbd_ix_dr_init()> in the F<dbdimp.c> file.
B<DBD::Informix> uses the mapped names which makes it easier to identify
where to look for linkage problems at runtime (which will report errors
using the mapped names).
(TBT)

=begin original

Most other drivers, and in particular B<DBD::Oracle>, use the unmapped
names in the source code which makes it a little easier to compare code
between drivers and eases discussions on the I<dbi-dev> mailing list.
The majority of the code fragments here will use the unmapped names.

=end original

Most other drivers, and in particular B<DBD::Oracle>, use the unmapped
names in the source code which makes it a little easier to compare code
between drivers and eases discussions on the I<dbi-dev> mailing list.
The majority of the code fragments here will use the unmapped names.
(TBT)

=begin original

Ultimately, you should provide implementations for most of the
functions listed in the F<dbd_xsh.h> header. The exceptions are
optional functions (such as C<dbd_st_rows()>) and those functions with
alternative signatures, such as C<dbd_db_login6_sv>,
C<dbd_db_login6()> and I<dbd_db_login()>. Then you should only
implement one of the alternatives, and generally the newer one of the
alternatives.

=end original

Ultimately, you should provide implementations for most of the
functions listed in the F<dbd_xsh.h> header. The exceptions are
optional functions (such as C<dbd_st_rows()>) and those functions with
alternative signatures, such as C<dbd_db_login6_sv>,
C<dbd_db_login6()> and I<dbd_db_login()>. Then you should only
implement one of the alternatives, and generally the newer one of the
alternatives.
(TBT)

=head3 The dbd_init method

  #include "Driver.h"

  DBISTATE_DECLARE;

  void dbd_init(dbistate_t* dbistate)
  {
      DBISTATE_INIT;  /*  Initialize the DBI macros  */
  }

=begin original

The C<dbd_init()> function will be called when your driver is first
loaded; the bootstrap command in C<DBD::Driver::dr::driver()> triggers this,
and the call is generated in the I<BOOT> section of F<Driver.xst>.
These statements are needed to allow your driver to use the B<DBI> macros.
They will include your private header file F<dbdimp.h> in turn.
Note that I<DBISTATE_INIT> requires the name of the argument to C<dbd_init()>
to be called C<dbistate()>.

=end original

C<dbd_init()> はドライバが初めてロードされたときに呼ばれます;
the bootstrap command in C<DBD::Driver::dr::driver()> triggers this,
and the call is generated in the I<BOOT> section of F<Driver.xst>.
これらの文は B<DBI> マクロを使用するために必要です。
それらはプライベートなヘッダファイル F<dbdimp.h> に代わりに
インクルードされます。
Note that I<DBISTATE_INIT> requires the name of the argument to C<dbd_init()>
to be called C<dbistate()>.
(TBT)

=head3 The dbd_drv_error method

=begin original

You need a function to record errors so B<DBI> can access them properly.
You can call it whatever you like, but we'll call it C<dbd_drv_error()>
here.

=end original

B<DBI> が適切にアクセスできるようなエラーの記録を取り扱う関数が必要です。
好きな名前をつけることができますが、ここでは C<dbd_drv_error()> と呼びます。

=begin original

The argument list depends on your database software; different systems
provide different ways to get at error information.

=end original

The argument list depends on your database software; different systems
provide different ways to get at error information.
(TBT)

  static void dbd_drv_error(SV *h, int rc, const char *what)
  {

=begin original

Note that I<h> is a generic handle, may it be a driver handle, a
database or a statement handle.

=end original

I<h> が汎用的なハンドルであること、それはドライバハンドル、
データベースまたは文ハンドルでありうることに注意してください。

      D_imp_xxh(h);

=begin original

This macro will declare and initialize a variable I<imp_xxh> with
a pointer to your private handle pointer. You may cast this to
to I<imp_drh_t>, I<imp_dbh_t> or I<imp_sth_t>.

=end original

このマクロは変数 I<imp_xxh> を宣言し、プライベートなハンドルポンンタへの
ポインタで初期化します。
これを I<imp_drh_t>, I<imp_dbh_t>, I<imp_sth_t> にキャストすることもできます。

=begin original

To record the error correctly, equivalent to the C<set_err()> method,
use one of the C<DBIh_SET_ERR_CHAR(...)> or C<DBIh_SET_ERR_SV(...)> macros,
which were added in B<DBI> 1.41:

=end original

To record the error correctly, equivalent to the C<set_err()> method,
use one of the C<DBIh_SET_ERR_CHAR(...)> or C<DBIh_SET_ERR_SV(...)> macros,
which were added in B<DBI> 1.41:
(TBT)

  DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
  DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);

=begin original

For C<DBIh_SET_ERR_SV> the I<err>, I<errstr>, I<state>, and I<method>
parameters are C<SV*> (use &sv_undef instead of NULL).

=end original

For C<DBIh_SET_ERR_SV> the I<err>, I<errstr>, I<state>, and I<method>
parameters are C<SV*> (use &sv_undef instead of NULL).
(TBT)

=begin original

For C<DBIh_SET_ERR_CHAR> the I<err_c>, I<errstr>, I<state>, I<method>
parameters are C<char*>.

=end original

For C<DBIh_SET_ERR_CHAR> the I<err_c>, I<errstr>, I<state>, I<method>
parameters are C<char*>.
(TBT)

=begin original

The I<err_i> parameter is an C<IV> that's used instead of I<err_c> if
I<err_c> is C<Null>.

=end original

The I<err_i> parameter is an C<IV> that's used instead of I<err_c> if
I<err_c> is C<Null>.
(TBT)

=begin original

The I<method> parameter can be ignored.

=end original

The I<method> parameter can be ignored.
(TBT)

=begin original

The C<DBIh_SET_ERR_CHAR> macro is usually the simplest to use when you
just have an integer error code and an error message string:

=end original

The C<DBIh_SET_ERR_CHAR> macro is usually the simplest to use when you
just have an integer error code and an error message string:
(TBT)

  DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);

=begin original

As you can see, any parameters that aren't relevant to you can be C<Null>.

=end original

As you can see, any parameters that aren't relevant to you can be C<Null>.
(TBT)

=begin original

To make drivers compatible with B<DBI> < 1.41 you should be using F<dbivport.h>
as described in L</Driver.h> above.

=end original

To make drivers compatible with B<DBI> < 1.41 you should be using F<dbivport.h>
as described in L</Driver.h> above.
(TBT)

=begin original

The (obsolete) macros such as C<DBIh_EVENT2> should be removed from drivers.

=end original

The (obsolete) macros such as C<DBIh_EVENT2> should be removed from drivers.
(TBT)

=begin original

The names C<dbis> and C<DBIS>, which were used in previous versions of
this document, should be replaced with the C<DBIc_STATE(imp_xxh)> macro.

=end original

The names C<dbis> and C<DBIS>, which were used in previous versions of
this document, should be replaced with the C<DBIc_STATE(imp_xxh)> macro.
(TBT)

=begin original

The name C<DBILOGFP>, which was also used in previous versions of this
document, should be replaced by C<DBIc_LOGPIO(imp_xxh)>.

=end original

The name C<DBILOGFP>, which was also used in previous versions of this
document, should be replaced by C<DBIc_LOGPIO(imp_xxh)>.
(TBT)

=begin original

Your code should not call the C C<E<lt>stdio.hE<gt>> I/O functions; you
should use C<PerlIO_printf()> as shown:

=end original

Your code should not call the C C<E<lt>stdio.hE<gt>> I/O functions; you
should use C<PerlIO_printf()> as shown:
(TBT)

      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar %s: %s\n",
              foo, neatsvpv(errstr,0));

=begin original

That's the first time we see how tracing works within a B<DBI> driver. Make
use of this as often as you can, but don't output anything at a trace
level less than 3. Levels 1 and 2 are reserved for the B<DBI>.

=end original

B<DBI> ドライバの中でトレースログがどのように動くのかをみるのは、これが
初めてです。
できるだけ多くこれを使ってください; but don't output anything at a trace
level less than 3. Levels 1 and 2 are reserved for the B<DBI>.
(TBT)

=begin original

You can define up to 8 private trace flags using the top 8 bits
of C<DBIc_TRACE_FLAGS(imp)>, that is: C<0xFF000000>. See the
C<parse_trace_flag()> method elsewhere in this document.

=end original

You can define up to 8 private trace flags using the top 8 bits
of C<DBIc_TRACE_FLAGS(imp)>, that is: C<0xFF000000>. See the
C<parse_trace_flag()> method elsewhere in this document.
(TBT)

=head3 The dbd_dr_data_sources method

=begin original

This method is optional; the support for it was added in B<DBI> v1.33.

=end original

This method is optional; the support for it was added in B<DBI> v1.33.
(TBT)

=begin original

As noted in the discussion of F<Driver.pm>, if the data sources
can be determined by pure Perl code, do it that way. If, as in
B<DBD::Informix>, the information is obtained by a C function call, then
you need to define a function that matches the prototype:

=end original

As noted in the discussion of F<Driver.pm>, if the data sources
can be determined by pure Perl code, do it that way. If, as in
B<DBD::Informix>, the information is obtained by a C function call, then
you need to define a function that matches the prototype:
(TBT)

  extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);

=begin original

An outline implementation for B<DBD::Informix> follows, assuming that the
C<sqgetdbs()> function call shown will return up to 100 databases names,
with the pointers to each name in the array dbsname and the name strings
themselves being stores in dbsarea.

=end original

An outline implementation for B<DBD::Informix> follows, assuming that the
C<sqgetdbs()> function call shown will return up to 100 databases names,
with the pointers to each name in the array dbsname and the name strings
themselves being stores in dbsarea.
(TBT)

  AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
  {
      int ndbs;
      int i;
      char *dbsname[100];
      char  dbsarea[10000];
      AV *av = Nullav;

      if (sqgetdbs(&ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
      {
          av = NewAV();
          av_extend(av, (I32)ndbs);
          sv_2mortal((SV *)av);
          for (i = 0; i < ndbs; i++)
            av_store(av, i, newSVpvf("dbi:Informix:%s", dbsname[i]));
      }
      return(av);
  }

=begin original

The actual B<DBD::Informix> implementation has a number of extra lines of
code, logs function entry and exit, reports the error from C<sqgetdbs()>,
and uses C<#define>'d constants for the array sizes.

=end original

The actual B<DBD::Informix> implementation has a number of extra lines of
code, logs function entry and exit, reports the error from C<sqgetdbs()>,
and uses C<#define>'d constants for the array sizes.
(TBT)

=head3 The dbd_db_login6 method

  int dbd_db_login6_sv(SV* dbh, imp_dbh_t* imp_dbh, SV* dbname,
                       SV* user, SV* auth, SV *attr);

  or

  int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
                   char* user, char* auth, SV *attr);

=begin original

This function will really connect to the database. The argument I<dbh>
is the database handle. I<imp_dbh> is the pointer to the handles private
data, as is I<imp_xxx> in C<dbd_drv_error()> above. The arguments
I<dbname>, I<user>, I<auth> and I<attr> correspond to the arguments of
the driver handle's C<connect()> method.

=end original

この関数は実際にデータベースに接続します。
引数 I<dbh> はデータベースハンドルです。
I<imp_dbh> は上記 C<dbd_drv_error()> の I<imp_xxx> のように、
プライベートデータへのポインタです。
引数 I<dbname>, I<user>, I<auth>, I<attr> はドライバハンドルの
C<connect()> メソッドに対応します。

=begin original

You will quite often use database specific attributes here, that are
specified in the DSN. I recommend you parse the DSN (using Perl) within
the C<connect()> method and pass the segments of the DSN via the
attributes parameter through C<_login()> to C<dbd_db_login6()>.

=end original

ここでは、たくさんのデータベース特有の属性を使うでしょう、それらは
DSN で指定されます。
(Perl を使って) DSN を C<connect()> メソッドで解析し、C<_login()> から
C<dbd_db_login6()> にハンドル属性として渡すことをお勧めします。

=begin original

Here's how you fetch them; as an example we use I<hostname> attribute,
which can be up to 12 characters long excluding null terminator:

=end original

それらをどのように取り出すか、I<hostname> 属性をを使う例を示します;
which can be up to 12 characters long excluding null terminator:
(TBT)

  SV** svp;
  STRLEN len;
  char* hostname;

  if ( (svp = DBD_ATTRIB_GET_SVP(attr, "drv_hostname", 12)) && SvTRUE(*svp)) {
      hostname = SvPV(*svp, len);
      DBD_ATTRIB_DELETE(attr, "drv_hostname", 12); /* avoid later STORE */
  } else {
      hostname = "localhost";
  }

=begin original

If you handle any driver specific attributes in the dbd_db_login6
method you probably want to delete them from C<attr> (as above with
DBD_ATTRIB_DELETE). If you don't delete your handled attributes DBI
will call C<STORE> for each attribute after the connect/login and this
is at best redundant for attributes you have already processed.

=end original

If you handle any driver specific attributes in the dbd_db_login6
method you probably want to delete them from C<attr> (as above with
DBD_ATTRIB_DELETE). If you don't delete your handled attributes DBI
will call C<STORE> for each attribute after the connect/login and this
is at best redundant for attributes you have already processed.
(TBT)

=begin original

B<Note: Until revision 11605 (post DBI 1.607), there was a problem with
DBD_ATTRIBUTE_DELETE so unless you require a DBI version after 1.607
you need to replace each DBD_ATTRIBUTE_DELETE call with:>

=end original

B<Note: Until revision 11605 (post DBI 1.607), there was a problem with
DBD_ATTRIBUTE_DELETE so unless you require a DBI version after 1.607
you need to replace each DBD_ATTRIBUTE_DELETE call with:>
(TBT)

  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)

=begin original

Note that you can also obtain standard attributes such as I<AutoCommit> and
I<ChopBlanks> from the attributes parameter, using C<DBD_ATTRIB_GET_IV> for
integer attributes.

=end original

Note that you can also obtain standard attributes such as I<AutoCommit> and
I<ChopBlanks> from the attributes parameter, using C<DBD_ATTRIB_GET_IV> for
integer attributes.
(TBT)

=begin original

If, for example, your database does not support transactions but
I<AutoCommit> is set off (requesting transaction support), then you can
emulate a 'failure to connect'.

=end original

If, for example, your database does not support transactions but
I<AutoCommit> is set off (requesting transaction support), then you can
emulate a 'failure to connect'.
(TBT)

=begin original

Now you should really connect to the database. In general, if the
connection fails, it is best to ensure that all allocated resources are
released so that the handle does not need to be destroyed separately. If
you are successful (and possibly even if you fail but you have allocated
some resources), you should use the following macros:

=end original

ついに実際にデータベースに接続しなければなりません。
In general, if the
connection fails, it is best to ensure that all allocated resources are
released so that the handle does not need to be destroyed separately.
もし成功すれば(あるいは失敗した場合であっても、リソースを占有していれば)、
以下のマクロを使わなければなりません:
(TBT)

  DBIc_IMPSET_on(imp_dbh);

=begin original

This indicates that the driver (implementor) has allocated resources in
the I<imp_dbh> structure and that the implementors private C<dbd_db_destroy()>
function should be called when the handle is destroyed.

=end original

これはそのドライバ(実装)が I<imp_dbh> 構造体のなかでリソースを
占有していること、そしてそのハンドルが破壊されるとき、実装のプライベートな
C<dbd_db_destroy()> 関数が呼ばれなければならないことを示します。

  DBIc_ACTIVE_on(imp_dbh);

=begin original

This indicates that the handle has an active connection to the server
and that the C<dbd_db_disconnect()> function should be called before the
handle is destroyed.

=end original

これはそのハンドラがサーバへのアクティブな接続を持っていること、そして
そのハンドルが破壊される前にその C<dbd_db_disconnect()> 関数が
呼ばれなければならないことを示します。

=begin original

Note that if you do need to fail, you should report errors via the I<drh>
or I<imp_drh> rather than via I<dbh> or I<imp_dbh> because I<imp_dbh> will be
destroyed by the failure, so errors recorded in that handle will not be
visible to B<DBI>, and hence not the user either.

=end original

Note that if you do need to fail, you should report errors via the I<drh>
or I<imp_drh> rather than via I<dbh> or I<imp_dbh> because I<imp_dbh> will be
destroyed by the failure, so errors recorded in that handle will not be
visible to B<DBI>, and hence not the user either.
(TBT)

=begin original

Note too, that the function is passed I<dbh> and I<imp_dbh>, and there
is a macro C<D_imp_drh_from_dbh> which can recover the I<imp_drh> from
the I<imp_dbh>. However, there is no B<DBI> macro to provide you with the
I<drh> given either the I<imp_dbh> or the I<dbh> or the I<imp_drh> (and
there's no way to recover the I<dbh> given just the I<imp_dbh>).

=end original

Note too, that the function is passed I<dbh> and I<imp_dbh>, and there
is a macro C<D_imp_drh_from_dbh> which can recover the I<imp_drh> from
the I<imp_dbh>. However, there is no B<DBI> macro to provide you with the
I<drh> given either the I<imp_dbh> or the I<dbh> or the I<imp_drh> (and
there's no way to recover the I<dbh> given just the I<imp_dbh>).
(TBT)

=begin original

This suggests that, despite the above notes about C<dbd_drv_error()>
taking an C<SV *>, it may be better to have two error routines, one
taking I<imp_dbh> and one taking I<imp_drh> instead. With care, you can
factor most of the formatting code out so that these are small routines
calling a common error formatter. See the code in B<DBD::Informix>
1.05.00 for more information.

=end original

This suggests that, despite the above notes about C<dbd_drv_error()>
taking an C<SV *>, it may be better to have two error routines, one
taking I<imp_dbh> and one taking I<imp_drh> instead. With care, you can
factor most of the formatting code out so that these are small routines
calling a common error formatter. See the code in B<DBD::Informix>
1.05.00 for more information.
(TBT)

=begin original

The C<dbd_db_login6()> function should return I<TRUE> for success,
I<FALSE> otherwise.

=end original

C<dbd_db_login6()> 関数は成功すれば I<TRUE>、そうでなければ
I<FALSE> を返さなければなりません。

=begin original

Drivers implemented long ago may define the five-argument function
C<dbd_db_login()> instead of C<dbd_db_login6()>. The missing argument is
the attributes. There are ways to work around the missing attributes,
but they are ungainly; it is much better to use the 6-argument form.
Even later drivers will use C<dbd_db_login6_sv()> which provides the
dbname, username and password as SVs.

=end original

Drivers implemented long ago may define the five-argument function
C<dbd_db_login()> instead of C<dbd_db_login6()>. The missing argument is
the attributes. There are ways to work around the missing attributes,
but they are ungainly; it is much better to use the 6-argument form.
Even later drivers will use C<dbd_db_login6_sv()> which provides the
dbname, username and password as SVs.
(TBT)

=head3 The dbd_db_commit and dbd_db_rollback methods

  int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
  int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);

=begin original

These are used for commit and rollback. They should return I<TRUE> for
success, I<FALSE> for error.

=end original

これらはコミットとロールバックのために使われます。
成功すれば I<TRUE>、そうでなければ I<FALSE> を返さなければなりません。

=begin original

The arguments I<dbh> and I<imp_dbh> are the same as for C<dbd_db_login6()>
above; I will omit describing them in what follows, as they appear
always.

=end original

引数 I<dbh> とI<imp_dbh> は上述の C<dbd_db_login6()> と同じです;
これ以降、これらが現れたときには説明を省略します。

=begin original

These functions should return I<TRUE> for success, I<FALSE> otherwise.

=end original

These functions should return I<TRUE> for success, I<FALSE> otherwise.
(TBT)

=head3 The dbd_db_disconnect method

=begin original

This is your private part of the C<disconnect()> method. Any I<dbh> with
the I<ACTIVE> flag on must be disconnected. (Note that you have to set
it in C<dbd_db_connect()> above.)

=end original

これは C<disconnect()> メソッドのプライベートな部分です。
I<ACTIVE> フラグがオンになっている、すべての I<dbh> は
切断されなければなりません。
(上記 C<dbd_db_connect()> でそれを設定しなければならないことに注意。)

  int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);

=begin original

The database handle will return I<TRUE> for success, I<FALSE> otherwise.
In any case it should do a:

=end original

データベースハンドルは成功すれば I<TRUE>、そうでなければ I<FALSE> を
返さなければなりません。
その場合には:

  DBIc_ACTIVE_off(imp_dbh);

=begin original

before returning so B<DBI> knows that C<dbd_db_disconnect()> was executed.

=end original

リターンする前には B<DBI> に C<dbd_db_disconnect()> が実行されたことを
知らせるためにする必要があります。

=begin original

Note that there's nothing to stop a I<dbh> being I<disconnected> while
it still have active children. If your database API reacts badly to
trying to use an I<sth> in this situation then you'll need to add code
like this to all I<sth> methods:

=end original

Note that there's nothing to stop a I<dbh> being I<disconnected> while
it still have active children. If your database API reacts badly to
trying to use an I<sth> in this situation then you'll need to add code
like this to all I<sth> methods:
(TBT)

  if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
    return 0;

=begin original

Alternatively, you can add code to your driver to keep explicit track of
the statement handles that exist for each database handle and arrange
to destroy those handles before disconnecting from the database. There
is code to do this in B<DBD::Informix>. Similar comments apply to the
driver handle keeping track of all the database handles.

=end original

Alternatively, you can add code to your driver to keep explicit track of
the statement handles that exist for each database handle and arrange
to destroy those handles before disconnecting from the database. There
is code to do this in B<DBD::Informix>. Similar comments apply to the
driver handle keeping track of all the database handles.
(TBT)

=begin original

Note that the code which destroys the subordinate handles should only
release the associated database resources and mark the handles inactive;
it does not attempt to free the actual handle structures.

=end original

Note that the code which destroys the subordinate handles should only
release the associated database resources and mark the handles inactive;
it does not attempt to free the actual handle structures.
(TBT)

=begin original

This function should return I<TRUE> for success, I<FALSE> otherwise, but
it is not clear what anything can do about a failure.

=end original

This function should return I<TRUE> for success, I<FALSE> otherwise, but
it is not clear what anything can do about a failure.
(TBT)

=head3 The dbd_db_discon_all method

  int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);

=begin original

This function may be called at shutdown time. It should make
best-efforts to disconnect all database handles - if possible. Some
databases don't support that, in which case you can do nothing
but return 'success'.

=end original

この関数はシャットダウンの時に呼ばれるかもしれません。
もし可能であれば−すべてのデータベースハンドルを切断するように全力を
尽くさなければなりません。
いくつかのデータベースはそれをサポートしていません。
その場合には 'success' を返すことしか出来ません。

=begin original

This function should return I<TRUE> for success, I<FALSE> otherwise, but
it is not clear what anything can do about a failure.

=end original

This function should return I<TRUE> for success, I<FALSE> otherwise, but
it is not clear what anything can do about a failure.
(TBT)

=head3 The dbd_db_destroy method

=begin original

This is your private part of the database handle destructor. Any I<dbh> with
the I<IMPSET> flag on must be destroyed, so that you can safely free
resources. (Note that you have to set it in C<dbd_db_connect()> above.)

=end original

これはデータベースハンドラのデストラクタのプライベートな部分です。
安全にリソースを解放できるように、I<IMPSET> フラグがオンであるすべての
I<dbh> は破壊されなければなりません。
(上記 C<dbd_db_connect()> でそれを設定しなければならないことに注意。)

  void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
  {
      DBIc_IMPSET_off(imp_dbh);
  }

=begin original

The B<DBI> F<Driver.xst> code will have called C<dbd_db_disconnect()> for you,
if the handle is still 'active', before calling C<dbd_db_destroy()>.

=end original

ハンドラがまだアクティブであれば C<dbd_db_destroy()> を呼ぶ前に、
B<DBI> F<Driver.xst> コードが代わりに C<dbd_db_disconnect()> を
呼ばせるでしょう。

=begin original

Before returning the function must switch I<IMPSET> to off, so B<DBI> knows
that the destructor was called.

=end original

リターンの前に、B<DBI> にデストラクタが既に呼ばれたことを知らせるために、
関数は I<IMPSET> をオフに切り替えなければなりません。

=begin original

A B<DBI> handle doesn't keep references to its children. But children
do keep references to their parents. So a database handle won't be
C<DESTROY>'d until all its children have been C<DESTROY>'d.

=end original

A B<DBI> handle doesn't keep references to its children. But children
do keep references to their parents. So a database handle won't be
C<DESTROY>'d until all its children have been C<DESTROY>'d.
(TBT)

=head3 The dbd_db_STORE_attrib method

=begin original

This function handles

=end original

この関数は以下のものを扱います

  $dbh->{$key} = $value;

=begin original

Its prototype is:

=end original

そのプロトタイプは以下のものです。

  int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
                          SV* valuesv);

=begin original

You do not handle all attributes; on the contrary, you should not handle
B<DBI> attributes here: leave this to B<DBI>. (There are two exceptions,
I<AutoCommit> and I<ChopBlanks>, which you should care about.)

=end original

あなたがすべての B<DBI> 属性をここで扱わなってはいけないのとは反対に、
あなたはすべての属性を扱いません:これを B<DBI> にまかせてください
(唯一の例外は、I<AutoCommit> と I<ChopBlanks> です; これは注意してください。)

=begin original

The return value is I<TRUE> if you have handled the attribute or I<FALSE>
otherwise. If you are handling an attribute and something fails, you
should call C<dbd_drv_error()>, so B<DBI> can raise exceptions, if desired.
If C<dbd_drv_error()> returns, however, you have a problem: the user will
never know about the error, because he typically will not check
C<$dbh-E<gt>errstr()>.

=end original

戻り値は、もしその属性を扱ったのであれば I<TRUE> そうでなければ
I<FALSE> です。
属性を扱って何か失敗すれば、必要であれば B<DBI> が例外を起こせるように、
C<dbd_drv_error()> を呼ばなければなりません。
もし C<dbd_drv_error()> が戻っても、問題があります:通常は
C<$dbh-E<gt>errstr()> をチェックしないので、ユーザはそのエラーについて
分からないでしょう。

=begin original

I cannot recommend a general way of going on, if C<dbd_drv_error()> returns,
but there are examples where even the B<DBI> specification expects that
you C<croak()>. (See the I<AutoCommit> method in L<DBI>.)

=end original

もし C<dbd_drv_error()> が返ってきたら、処理を続けるという一般的な方法は
推奨できません。
しかし B<DBI> 仕様で C<croak()> することを期待しているところでさえ、
そうしているという例もあります。
(L<DBI>  の I<AutoCommit> メソッドをご覧ください。)

=begin original

If you have to store attributes, you should either use your private
data structure I<imp_xxx>, the handle hash (via C<(HV*)SvRV(dbh)>), or use
the private I<imp_data>.

=end original

属性を格納する必要があれば、プライベートなデータ構造 I<imp_xxx> を使い、
(C<(HV*)SvRV(dbh)> を通して)ハッシュを扱うか、プライベートな
I<imp_data> を使ってください。

=begin original

The first is best for internal C values like integers or pointers and
where speed is important within the driver. The handle hash is best for
values the user may want to get/set via driver-specific attributes.
The private I<imp_data> is an additional C<SV> attached to the handle. You
could think of it as an unnamed handle attribute. It's not normally used.

=end original

前者の方が integer やポインタといった内部 C の値に向いていますし、ドライバで
スピードが重要なところに向いています。
ハンドルハッシュはドライバ特有の属性を取得／設定したいかもしらない
値にと向いています。
プライベートな I<imp_data> はハンドルに付与された追加的な C<SV> です。
名前のないハンドル属性と考えることもができます。
通常は使われません。

=head3 The dbd_db_FETCH_attrib method

=begin original

This is the counterpart of C<dbd_db_STORE_attrib()>, needed for:

=end original

これは C<dbd_db_STORE_attrib()> の逆で、以下のために必要です:

  $value = $dbh->{$key};

=begin original

Its prototype is:

=end original

そのプロトタイプは以下のようになります:

  SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);

=begin original

Unlike all previous methods this returns an C<SV> with the value. Note
that you should normally execute C<sv_2mortal()>, if you return a nonconstant
value. (Constant values are C<&sv_undef>, C<&sv_no> and C<&sv_yes>.)

=end original

これまでのすべてのメソッドと違って、これは値をもった C<SV> を返します。
もし定数値でない値を返すのであれば、通常は C<sv_2mortal()> を
実行しなければならないことに注意してください。
(定数値は C<&sv_undef>, C<&sv_no>, C<&sv_yes> です。)

=begin original

Note, that B<DBI> implements a caching algorithm for attribute values.
If you think, that an attribute may be fetched, you store it in the
I<dbh> itself:

=end original

B<DBI> は属性値のためのキャッシュするアルゴリズムを実装していることに
注意してください。
属性がフェッチされていると思うのであれば、I<dbh> それ自身に格納します:

  if (cacheit) /* cache value for later DBI 'quick' fetch? */
      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);

=head3 The dbd_st_prepare method

=begin original

This is the private part of the C<prepare()> method. Note that you
B<must not> really execute the statement here. You may, however,
preparse and validate the statement, or do similar things.

=end original

これは C<prepare()> メソッドのプライベートな部分です。
実際にここで文を実行しては B<いけない> ことに注意してください。
しかし、文を準備して適正チェックや同じようなことを
することができます。

  int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
                     SV* attribs);

=begin original

A typical, simple, possibility is to do nothing and rely on the perl
C<prepare()> code that set the I<Statement> attribute on the handle. This
attribute can then be used by C<dbd_st_execute()>.

=end original

典型的な、単純な可能性は、
to do nothing and rely on the perl
C<prepare()> code that set the I<Statement> attribute on the handle.
この属性はそれから C<dbd_st_execute()> で使われます。
(TBT)

=begin original

If the driver supports placeholders then the I<NUM_OF_PARAMS> attribute
must be set correctly by C<dbd_st_prepare()>:

=end original

If the driver supports placeholders then the I<NUM_OF_PARAMS> attribute
must be set correctly by C<dbd_st_prepare()>:
(TBT)

  DBIc_NUM_PARAMS(imp_sth) = ...

=begin original

If you can, you should also setup attributes like I<NUM_OF_FIELDS>, I<NAME>,
etc. here, but B<DBI> doesn't require that - they can be deferred until
execute() is called. However, if you do, document it.

=end original

できることなら、I<NUM_OF_FIELDS>、I<NAME> といった属性をここで
設定するべきですが、B<DBI> はそれを要求はしません - 
they can be deferred until execute() is called.
しかし、そうしたのであれば、ドキュメントに残しましょう。
(TBT)

=begin original

In any case you should set the I<IMPSET> flag, as you did in
C<dbd_db_connect()> above:

=end original

どんな場合であっても、上記 C<dbd_db_connect()> でやったのと同じように
I<IMPSET> フラグを設定しなければなりません:

  DBIc_IMPSET_on(imp_sth);

=head3 The dbd_st_execute method

=begin original

This is where a statement will really be executed.

=end original

ここで文が本当に実行されます:

  int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);

=begin original

Note that you must be aware a statement may be executed repeatedly.
Also, you should not expect that C<finish()> will be called between two
executions, so you might need code, like the following, near the start
of the function:

=end original

文が繰り返し実行されることもあることに気がつかなければ
ならないことに注意してください。
また二つの実行の間に C<finish()> が呼ばれることも期待してはいけません;
so you might need code, like the following, near the start
of the function:
(TBT)

  if (DBIc_ACTIVE(imp_sth))
      dbd_st_finish(h, imp_sth);

=begin original

If your driver supports the binding of parameters (it should!), but the
database doesn't, you must do it here. This can be done as follows:

=end original

あなたのドライバがパラメータのバインドをサポートしている
(そうすべきですが)のに、データベースがそうでなければ、
ここでそれをしなければならないでしょう。
それは以下のようにすることができます:

  SV *svp;
  char* statement = DBD_ATTRIB_GET_PV(h, "Statement", 9, svp, "");
  int numParam = DBIc_NUM_PARAMS(imp_sth);
  int i;

  for (i = 0; i < numParam; i++)
  {
      char* value = dbd_db_get_param(sth, imp_sth, i);
      /* It is your drivers task to implement dbd_db_get_param,    */
      /* it must be setup as a counterpart of dbd_bind_ph.         */
      /* Look for '?' and replace it with 'value'.  Difficult      */
      /* task, note that you may have question marks inside        */
      /* quotes and comments the like ...  :-(                     */
      /* See DBD::mysql for an example. (Don't look too deep into  */
      /* the example, you will notice where I was lazy ...)        */
  }

=begin original

The next thing is to really execute the statement.

=end original

次にやることは文を本当に実行することです。

=begin original

Note that you must set the attributes I<NUM_OF_FIELDS>, I<NAME>, etc
when the statement is successfully executed if the driver has not
already done so: they may be used even before a potential C<fetchrow()>.
In particular you have to tell B<DBI> the number of fields that the
statement has, because it will be used by B<DBI> internally. Thus the
function will typically ends with:

=end original

まだやっていなければ、文が正常に実行されたら、
I<NUM_OF_FIELDS>, I<NAME> といった属性を準備しなければならないことに
注意してください:それらは潜在的な C<fetchrow()> の前にでも
使われるかもしれません。
B<DBI> 内部で使われるため、特に B<DBI> にはその文が
持っているフィールドの数を伝えなければなりません。
こうしてこの関数は通常以下のようにして終了します:

  if (isSelectStatement) {
      DBIc_NUM_FIELDS(imp_sth) = numFields;
      DBIc_ACTIVE_on(imp_sth);
  }

=begin original

It is important that the I<ACTIVE> flag only be set for C<SELECT>
statements (or any other statements that can return many
values from the database using a cursor-like mechanism). See
C<dbd_db_connect()> above for more explanations.

=end original

I<ACTIVE> フラグを C<SELECT> 文のためだけに設定するのは
重要なことです
(or any other statements that can return many
values from the database using a cursor-like mechanism)。
さらに詳しい説明は上記の C<dbd_db_connect()> をご覧ください。

=begin original

There plans for a preparse function to be provided by B<DBI>, but this has
not reached fruition yet.
Meantime, if you want to know how ugly it can get, try looking at the
C<dbd_ix_preparse()> in B<DBD::Informix> F<dbdimp.ec> and the related
functions in F<iustoken.c> and F<sqltoken.c>.

=end original

There plans for a preparse function to be provided by B<DBI>, but this has
not reached fruition yet.
Meantime, if you want to know how ugly it can get, try looking at the
C<dbd_ix_preparse()> in B<DBD::Informix> F<dbdimp.ec> and the related
functions in F<iustoken.c> and F<sqltoken.c>.
(TBT)

=head3 The dbd_st_fetch method

=begin original

This function fetches a row of data. The row is stored in in an array,
of C<SV>'s that B<DBI> prepares for you. This has two advantages: it is fast
(you even reuse the C<SV>'s, so they don't have to be created after the
first C<fetchrow()>), and it guarantees that B<DBI> handles C<bind_cols()> for
you.

=end original

この関数はデータの行を取り出します。
行は B<DBI> があなたのために用意した C<SV> の配列に格納されます。
これには二つの利点があります:それは速く(最初の C<fetchrow()> の後に
作成する必要がないので、C<SV> を再利用することもできます)、
B<DBI> が C<bind_cols()> を扱うことを保証します。

=begin original

What you do is the following:

=end original

やらなければならないことは以下の通りです:

  AV* av;
  int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
      is constant for this statement. There are drivers where this is
      not the case! */
  int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
  int i;

  if (!fetch_new_row_of_data(...)) {
      ... /* check for error or end-of-data */
      DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
      return Nullav;
  }
  /* get the fbav (field buffer array value) for this row       */
  /* it is very important to only call this after you know      */
  /* that you have a row of data to return.                     */
  av = DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);
  for (i = 0; i < numFields; i++) {
      SV* sv = fetch_a_field(..., i);
      if (chopBlanks && SvOK(sv) && type_is_blank_padded(field_type[i])) {
          /*  Remove white space from end (only) of sv  */
      }
      sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
  }
  return av;

=begin original

There's no need to use a C<fetch_a_field()> function returning an C<SV*>.
It's more common to use your database API functions to fetch the
data as character strings and use code like this:

=end original

C<SV*> を返す C<fetch_a_field()> 関数を使う必要はありません。
文字列としてデータを取り出すデータベース API 関数を使い、以下のようにする
方がもっと一般的です:

  sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);

=begin original

C<NULL> values must be returned as C<undef>. You can use code like this:

=end original

C<NULL> 値は C<undef> で返さなければなりません:以下のようにすることができます:

  SvOK_off(AvARRAY(av)[i]);

=begin original

The function returns the C<AV> prepared by B<DBI> for success or C<Nullav>
otherwise.

=end original

この関数は成功すれば B<DBI> によって用意された C<AV> を、そうでなければ
C<Nullav> を返します。

 *FIX ME* Discuss what happens when there's no more data to fetch.
 Are errors permitted if another fetch occurs after the first fetch
 that reports no more data. (Permitted, not required.)

=begin original

If an error occurs which leaves the I<$sth> in a state where remaining
rows can't be fetched then I<Active> should be turned off before the
method returns.

=end original

If an error occurs which leaves the I<$sth> in a state where remaining
rows can't be fetched then I<Active> should be turned off before the
method returns.
(TBT)

=head3 The dbd_st_finish3 method

=begin original

The C<$sth-E<gt>finish()> method can be called if the user wishes to
indicate that no more rows will be fetched even if the database has more
rows to offer, and the B<DBI> code can call the function when handles are
being destroyed. See the B<DBI> specification for more background details.

=end original

C<$sth-E<gt>finish()> メソッドはデータベースが提供する行をまだ
持っていたとしても、ユーザがもう行をとりださないということを
示したいという場合、そして
the B<DBI> code can call the function when handles are
being destroyed
に呼ぶことができます。
背景についての詳細は B<DBI> ドキュメントをご覧下さい。
(TBT)

=begin original

In both circumstances, the B<DBI> code ends up calling the
C<dbd_st_finish3()> method (if you provide a mapping for
C<dbd_st_finish3()> in F<dbdimp.h>), or C<dbd_st_finish()> otherwise.
The difference is that C<dbd_st_finish3()> takes a third argument which
is an C<int> with the value 1 if it is being called from a C<destroy()>
method and 0 otherwise.

=end original

In both circumstances, the B<DBI> code ends up calling the
C<dbd_st_finish3()> method (if you provide a mapping for
C<dbd_st_finish3()> in F<dbdimp.h>), or C<dbd_st_finish()> otherwise.
The difference is that C<dbd_st_finish3()> takes a third argument which
is an C<int> with the value 1 if it is being called from a C<destroy()>
method and 0 otherwise.
(TBT)

=begin original

Note that B<DBI> v1.32 and earlier test on C<dbd_db_finish3()> to call
C<dbd_st_finish3()>; if you provide C<dbd_st_finish3()>, either define
C<dbd_db_finish3()> too, or insist on B<DBI> v1.33 or later.

=end original

Note that B<DBI> v1.32 and earlier test on C<dbd_db_finish3()> to call
C<dbd_st_finish3()>; if you provide C<dbd_st_finish3()>, either define
C<dbd_db_finish3()> too, or insist on B<DBI> v1.33 or later.
(TBT)

=begin original

All it I<needs> to do is turn off the I<Active> flag for the I<sth>.
It will only be called by F<Driver.xst> code, if the driver has set I<ACTIVE>
to on for the I<sth>.

=end original

必要なのは I<sth> のための I<Active> フラグをオフに切りかえることだけです。
ドライバが I<sth> のために I<ACTIVE> を設定しているならば、
F<Driver.xst> コードによって呼ばれるだけです。

=begin original

Outline example:

=end original

概略の例:

  int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
      if (DBIc_ACTIVE(imp_sth))
      {
          /* close cursor or equivalent action */
          DBIc_ACTIVE_off(imp_sth);
      }
      return 1;
  }

=begin original

The from_destroy parameter is true if C<dbd_st_finish3()> is being called
from C<DESTROY()> - and so the statement is about to be destroyed.
For many drivers there is no point in doing anything more than turning off
the I<Active> flag in this case.

=end original

The from_destroy parameter is true if C<dbd_st_finish3()> is being called
from C<DESTROY()> - and so the statement is about to be destroyed.
For many drivers there is no point in doing anything more than turning off
the I<Active> flag in this case.
(TBT)

=begin original

The function returns I<TRUE> for success, I<FALSE> otherwise, but there isn't
a lot anyone can do to recover if there is an error.

=end original

この関数は成功すれば I<TRUE>、そうでなければ I<FALSE> を返しますが、
エラーの場合に回復するために出来ることはあまりありません。

=head3 The dbd_st_destroy method

=begin original

This function is the private part of the statement handle destructor.

=end original

この関数は文ハンドルのデストラクタのプライベートな部分です。

  void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
      ... /* any clean-up that's needed */
      DBIc_IMPSET_off(imp_sth); /* let DBI know we've done it   */
  }

=begin original

The B<DBI> F<Driver.xst> code will call C<dbd_st_finish()> for you, if the
I<sth> has the I<ACTIVE> flag set, before calling C<dbd_st_destroy()>.

=end original

C<dbd_st_destroy()> を呼び出す前に I<sth> が I<ACTIVE> フラグを
設定していれば、B<DBI> F<Driver.xst> コードはあなたに代わって
C<dbd_st_finish()> を呼び出します。

=head3 The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods

=begin original

These functions correspond to C<dbd_db_STORE()> and C<dbd_db_FETCH()> attrib
above, except that they are for statement handles.
See above.

=end original

これらの関数は文ハンドル用であることを除けば、上記の
C<dbd_db_STORE()> と C<dbd_db_FETCH()> に対応します。
上記をご覧下さい。

  int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
                          SV* valuesv);
  SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);

=head3 The dbd_bind_ph method

=begin original

This function is internally used by the C<bind_param()> method, the
C<bind_param_inout()> method and by the B<DBI> F<Driver.xst> code if
C<execute()> is called with any bind parameters.

=end original

この関数は C<bind_param()>, C<bind_param_inout()> そして
C<execute()> がバインド変数を伴って呼ばれるならば
B<DBI> F<Driver.xst> コードによって内部的に使用されます。

  int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
                   SV *value, IV sql_type, SV *attribs,
                   int is_inout, IV maxlen);

=begin original

The I<param> argument holds an C<IV> with the parameter number (1, 2, ...).
The I<value> argument is the parameter value and I<sql_type> is its type.

=end original

I<param> 引数はパラメータ番号(1,2,....) を持った C<IV> を保持します。
I<value> 引数はパラメータの値、I<sql_type> はそのデータ型です。

=begin original

If your driver does not support C<bind_param_inout()> then you should
ignore I<maxlen> and croak if I<is_inout> is I<TRUE>.

=end original

もしあなたのドライバが C<bind_param_inout()> をサポートしなければ
I<maxlen> を無視し、I<is_inout> が I<TRUE> であれば
警告(croak)しなければなりません。

=begin original

If your driver I<does> support C<bind_param_inout()> then you should
note that I<value> is the C<SV> I<after> dereferencing the reference
passed to C<bind_param_inout()>.

=end original

もしあなたのドライバが C<bind_param_inout()> をサポート I<する> のであれば、
C<bind_param_inout()> に渡されるリファレンスをデリファレンスした I<後>、
I<value> は C<SV> であることに注意しなければなりません。

=begin original

In drivers of simple databases the function will, for example, store
the value in a parameter array and use it later in C<dbd_st_execute()>.
See the B<DBD::mysql> driver for an example.

=end original

簡単なデータベースのドライバでは、関数は例えばパラメータ配列に格納し、後の
C<dbd_st_execute()> の中で使うでしょう。
例として B<DBD::mysql> ドライバをご覧下さい。

=head3 Implementing bind_param_inout support

=begin original

To provide support for parameters bound by reference rather than by
value, the driver must do a number of things.  First, and most
importantly, it must note the references and stash them in its own
driver structure.  Secondly, when a value is bound to a column, the
driver must discard any previous reference bound to the column.  On
each execute, the driver must evaluate the references and internally
bind the values resulting from the references.  This is only applicable
if the user writes:

=end original

To provide support for parameters bound by reference rather than by
value, the driver must do a number of things.  First, and most
importantly, it must note the references and stash them in its own
driver structure.  Secondly, when a value is bound to a column, the
driver must discard any previous reference bound to the column.  On
each execute, the driver must evaluate the references and internally
bind the values resulting from the references.  This is only applicable
if the user writes:
(TBT)

  $sth->execute;

=begin original

If the user writes:

=end original

If the user writes:
(TBT)

  $sth->execute(@values);

=begin original

then B<DBI> automatically calls the binding code for each element of
I<@values>.  These calls are indistinguishable from explicit user calls to
C<bind_param()>.

=end original

then B<DBI> automatically calls the binding code for each element of
I<@values>.  These calls are indistinguishable from explicit user calls to
C<bind_param()>.
(TBT)

=head2 C/XS version of Makefile.PL

(C/XS 版の Makefile.PL)

=begin original

The F<Makefile.PL> file for a C/XS driver is similar to the code needed
for a pure Perl driver, but there are a number of extra bits of
information needed by the build system.

=end original

The F<Makefile.PL> file for a C/XS driver is similar to the code needed
for a pure Perl driver, but there are a number of extra bits of
information needed by the build system.
(TBT)

=begin original

For example, the attributes list passed to C<WriteMakefile()> needs
to specify the object files that need to be compiled and built into
the shared object (DLL). This is often, but not necessarily, just
F<dbdimp.o> (unless that should be F<dbdimp.obj> because you're building
on MS Windows).

=end original

For example, the attributes list passed to C<WriteMakefile()> needs
to specify the object files that need to be compiled and built into
the shared object (DLL). This is often, but not necessarily, just
F<dbdimp.o> (unless that should be F<dbdimp.obj> because you're building
on MS Windows).
(TBT)

=begin original

Note that you can reliably determine the extension of the object files
from the I<$Config{obj_ext}> values, and there are many other useful pieces
of configuration information lurking in that hash.
You get access to it with:

=end original

Note that you can reliably determine the extension of the object files
from the I<$Config{obj_ext}> values, and there are many other useful pieces
of configuration information lurking in that hash.
You get access to it with:
(TBT)

    use Config;

=head2 Methods which do not need to be written

(書く必要のないメソッド)

=begin original

The B<DBI> code implements the majority of the methods which are accessed
using the notation C<DBI-E<gt>function()>, the only exceptions being
C<DBI-E<gt>connect()> and C<DBI-E<gt>data_sources()> which require
support from the driver.

=end original

B<DBI> コードは C<DBI-E<gt>function()> といった書き方を使って
アクセスされるメソッドの多くを実装しています;
唯一の例外は C<DBI-E<gt>connect()> と C<DBI-E<gt>data_sources()> で、
これはドライバからのサポートを必要とします。

=begin original

The B<DBI> code implements the following documented driver, database and
statement functions which do not need to be written by the B<DBD> driver
writer.

=end original

B<DBI> コードは以下に書かれているドライバ、データベース、そして
文関数を実装しています。これらは B<DBD> ドライバの作者は書く
必要がありません。

=over 4

=item $dbh->do()

=begin original

The default implementation of this function prepares, executes and
destroys the statement.  This can be replaced if there is a better
way to implement this, such as C<EXECUTE IMMEDIATE> which can
sometimes be used if there are no parameters.

=end original

この関数のデフォルトの実装はその文を準備(prepare)し、
実行(execute)し、破壊(destroy)します。
もしパラメータがなければ場合によっては使うことが出来る
C<EXECUTE IMMEDIATE> のように、実装するのによりよい方法があれば、これを
置きかえることができます。

=item $h->errstr()

=item $h->err()

=item $h->state()

=item $h->trace()

=begin original

The B<DBD> driver does not need to worry about these routines at all.

=end original

これらのルーチンについて、B<DBD> ドライバはまったく心配する必要がありません。

=item $h->{ChopBlanks}

=begin original

This attribute needs to be honored during C<fetch()> operations, but does
not need to be handled by the attribute handling code.

=end original

この属性は C<fetch()> 操作の間は気にしなければなりませんが、属性を
取り扱う部分で扱われる必要はありません。

=item $h->{RaiseError}

=begin original

The B<DBD> driver does not need to worry about this attribute at all.

=end original

B<DBD> ドライバはこの属性についてまったく心配する必要がありません。

=item $h->{PrintError}

=begin original

The B<DBD> driver does not need to worry about this attribute at all.

=end original

B<DBD> ドライバはこの属性についてまったく心配する必要がありません。

=item $sth->bind_col()

=begin original

Assuming the driver uses the C<DBIc_DBISTATE(imp_xxh)-E<gt>get_fbav()>
function (C drivers, see below), or the C<$sth-E<gt>_set_fbav($data)>
method (Perl drivers) the driver does not need to do anything about this
routine.

=end original

C<DBIc_DBISTATE(imp_xxh)-E<gt>get_fbav()> 関数(Cドライバ、以下を参照)、
または C<$sth-E<gt>_set_fbav($data)> メソッド(Perlドライバ)を使う
ドライバであれば、ドライバはこのルーチンについて何もする必要がありません。

=item $sth->bind_columns()

=begin original

Regardless of whether the driver uses
C<DBIc_DBISTATE(imp_xxh)-E<gt>get_fbav()>, the driver does not need
to do anything about this routine as it simply iteratively calls
C<$sth-E<gt>bind_col()>.

=end original

ドライバが C<DBIc_DBISTATE(imp_xxh)-E<gt>get_fbav()> を
使っているかどうかに関らず、それが単に内部的に
C<$sth-E<gt>bind_col()> を呼ぶので、ドライバはこのルーチンについて
何もする必要がありません。

=back

=begin original

The B<DBI> code implements a default implementation of the following
functions which do not need to be written by the B<DBD> driver writer
unless the default implementation is incorrect for the Driver.

=end original

B<DBI> コードはデフォルトの実装がそのドライバにとって正しくないのでなければ、
B<DBD> ドライバの作者がそれを書かなくて済むように、以下の関数のデフォルトを
実装しています。

=over 4

=item $dbh->quote()

=begin original

This should only be written if the database does not accept the ANSI
SQL standard for quoting strings, with the string enclosed in single
quotes and any embedded single quotes replaced by two consecutive
single quotes.

=end original

データベースがクォートされた文字列のための、シングルクォートで囲まれ、
埋め込まれたシングルクォートは一つのシングルクォートにつき二つの
シングルクォートで置き換えるという、ANSI SQL標準を受け取らない場合にのみ、
書かれる必要があります。

=begin original

For the two argument form of quote, you need to implement the
C<type_info()> method to provide the information that quote needs.

=end original

二つのクォートの形式の引数のために、クォートが必要とする情報を
提供するための C<type_info()> メソッドを実装する必要があります。

=item $dbh->ping()

=begin original

This should be implemented as a simple efficient way to determine
whether the connection to the database is still alive. Typically
code like this:

=end original

データベースへの接続がまだ生きているかどうかを判定するための単純な
効率的な方法として実装されなければなりません。
典型的には以下のようになります:

  sub ping {
      my $dbh = shift;
      $sth = $dbh->prepare_cached(q{
          select * from A_TABLE_NAME where 1=0
      }) or return 0;
      $sth->execute or return 0;
      $sth->finish;
      return 1;
  }

=begin original

where I<A_TABLE_NAME> is the name of a table that always exists (such as a
database system catalogue).

=end original

I<A_TABLE_NAME> は(データベースのシステムカタログのような)常に存在する
テーブルの名前です

=back

=head1 METADATA METHODS

(メタデータメソッド)

=begin original

The exposition above ignores the B<DBI> MetaData methods.
The metadata methods are all associated with a database handle.

=end original

The exposition above ignores the B<DBI> MetaData methods.
The metadata methods are all associated with a database handle.
(TBT)

=head2 Using DBI::DBD::Metadata

(DBI::DBD::Metadata を使う)

=begin original

The B<DBI::DBD::Metadata> module is a good semi-automatic way for the
developer of a B<DBD> module to write the C<get_info()> and C<type_info()>
functions quickly and accurately.

=end original

The B<DBI::DBD::Metadata> module is a good semi-automatic way for the
developer of a B<DBD> module to write the C<get_info()> and C<type_info()>
functions quickly and accurately.
(TBT)

=head3 Generating the get_info method

=begin original

Prior to B<DBI> v1.33, this existed as the method C<write_getinfo_pm()>
in the B<DBI::DBD> module. From B<DBI> v1.33, it exists as the method
C<write_getinfo_pm()> in the B<DBI::DBD::Metadata> module. This
discussion assumes you have B<DBI> v1.33 or later.

=end original

Prior to B<DBI> v1.33, this existed as the method C<write_getinfo_pm()>
in the B<DBI::DBD> module. From B<DBI> v1.33, it exists as the method
C<write_getinfo_pm()> in the B<DBI::DBD::Metadata> module. This
discussion assumes you have B<DBI> v1.33 or later.
(TBT)

=begin original

You examine the documentation for C<write_getinfo_pm()> using:

=end original

You examine the documentation for C<write_getinfo_pm()> using:
(TBT)

    perldoc DBI::DBD::Metadata

=begin original

To use it, you need a Perl B<DBI> driver for your database which implements
the C<get_info()> method. In practice, this means you need to install
B<DBD::ODBC>, an ODBC driver manager, and an ODBC driver for your
database.

=end original

To use it, you need a Perl B<DBI> driver for your database which implements
the C<get_info()> method. In practice, this means you need to install
B<DBD::ODBC>, an ODBC driver manager, and an ODBC driver for your
database.
(TBT)

=begin original

With the pre-requisites in place, you might type:

=end original

With the pre-requisites in place, you might type:
(TBT)

    perl -MDBI::DBD::Metadata -we \
       "write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })"

=begin original

The procedure writes to standard output the code that should be added to
your F<Driver.pm> file and the code that should be written to
F<lib/DBD/Driver/GetInfo.pm>.

=end original

The procedure writes to standard output the code that should be added to
your F<Driver.pm> file and the code that should be written to
F<lib/DBD/Driver/GetInfo.pm>.
(TBT)

=begin original

You should review the output to ensure that it is sensible.

=end original

You should review the output to ensure that it is sensible.
(TBT)

=head3 Generating the type_info method

=begin original

Given the idea of the C<write_getinfo_pm()> method, it was not hard
to devise a parallel method, C<write_typeinfo_pm()>, which does the
analogous job for the B<DBI> C<type_info_all()> metadata method. The
C<write_typeinfo_pm()> method was added to B<DBI> v1.33.

=end original

Given the idea of the C<write_getinfo_pm()> method, it was not hard
to devise a parallel method, C<write_typeinfo_pm()>, which does the
analogous job for the B<DBI> C<type_info_all()> metadata method. The
C<write_typeinfo_pm()> method was added to B<DBI> v1.33.
(TBT)

=begin original

You examine the documentation for C<write_typeinfo_pm()> using:

=end original

You examine the documentation for C<write_typeinfo_pm()> using:
(TBT)

    perldoc DBI::DBD::Metadata

=begin original

The setup is exactly analogous to the mechanism described in
L</Generating the get_info method>.

=end original

The setup is exactly analogous to the mechanism described in
L</Generating the get_info method>.
(TBT)

=begin original

With the pre-requisites in place, you might type:

=end original

With the pre-requisites in place, you might type:
(TBT)

    perl -MDBI::DBD::Metadata -we \
       "write_typeinfo (qw{ dbi:ODBC:foo_db username password Driver })"

=begin original

The procedure writes to standard output the code that should be added to
your F<Driver.pm> file and the code that should be written to
F<lib/DBD/Driver/TypeInfo.pm>.

=end original

The procedure writes to standard output the code that should be added to
your F<Driver.pm> file and the code that should be written to
F<lib/DBD/Driver/TypeInfo.pm>.
(TBT)

=begin original

You should review the output to ensure that it is sensible.

=end original

You should review the output to ensure that it is sensible.
(TBT)

=head2 Writing DBD::Driver::db::get_info

(DBD::Driver::db::get_info を書く)

=begin original

If you use the B<DBI::DBD::Metadata> module, then the code you need is
generated for you.

=end original

If you use the B<DBI::DBD::Metadata> module, then the code you need is
generated for you.
(TBT)

=begin original

If you decide not to use the B<DBI::DBD::Metadata> module, you
should probably borrow the code from a driver that has done so (eg
B<DBD::Informix> from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in F<Driver.pm> will be very simple; the method in
F<lib/DBD/Driver/GetInfo.pm> is not very much more complex unless your
DBMS itself is much more complex.

=end original

If you decide not to use the B<DBI::DBD::Metadata> module, you
should probably borrow the code from a driver that has done so (eg
B<DBD::Informix> from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in F<Driver.pm> will be very simple; the method in
F<lib/DBD/Driver/GetInfo.pm> is not very much more complex unless your
DBMS itself is much more complex.
(TBT)

=begin original

Note that some of the B<DBI> utility methods rely on information from the
C<get_info()> method to perform their operations correctly. See, for
example, the C<quote_identifier()> and quote methods, discussed below.

=end original

Note that some of the B<DBI> utility methods rely on information from the
C<get_info()> method to perform their operations correctly. See, for
example, the C<quote_identifier()> and quote methods, discussed below.
(TBT)

=head2 Writing DBD::Driver::db::type_info_all

(DBD::Driver::db::type_info_all を書く)

=begin original

If you use the C<DBI::DBD::Metadata> module, then the code you need is
generated for you.

=end original

If you use the C<DBI::DBD::Metadata> module, then the code you need is
generated for you.
(TBT)

=begin original

If you decide not to use the C<DBI::DBD::Metadata> module, you
should probably borrow the code from a driver that has done so (eg
C<DBD::Informix> from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in F<Driver.pm> will be very simple; the method in
F<lib/DBD/Driver/TypeInfo.pm> is not very much more complex unless your
DBMS itself is much more complex.

=end original

If you decide not to use the C<DBI::DBD::Metadata> module, you
should probably borrow the code from a driver that has done so (eg
C<DBD::Informix> from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in F<Driver.pm> will be very simple; the method in
F<lib/DBD/Driver/TypeInfo.pm> is not very much more complex unless your
DBMS itself is much more complex.
(TBT)

=head2 Writing DBD::Driver::db::type_info

(DBD::Driver::db::type_info を書く)

=begin original

The guidelines on writing this method are still not really clear.
No sample implementation is available.

=end original

The guidelines on writing this method are still not really clear.
No sample implementation is available.
(TBT)

=head2 Writing DBD::Driver::db::table_info

(DBD::Driver::db::table_info を書く)

 *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.

=head2 Writing DBD::Driver::db::column_info

(DBD::Driver::db::column_info を書く)

 *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.

=head2 Writing DBD::Driver::db::primary_key_info

(DBD::Driver::db::primary_key_info を書く)

 *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.

=head2 Writing DBD::Driver::db::primary_key

(DBD::Driver::db::primary_key を書く)

 *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.

=head2 Writing DBD::Driver::db::foreign_key_info

(DBD::Driver::db::foreign_key_info を書く)

 *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.

=head2 Writing DBD::Driver::db::tables

(DBD::Driver::db::tables を書く)

=begin original

This method generates an array of names in a format suitable for being
embedded in SQL statements in places where a table name is expected.

=end original

This method generates an array of names in a format suitable for being
embedded in SQL statements in places where a table name is expected.
(TBT)

=begin original

If your database hews close enough to the SQL standard or if you have
implemented an appropriate C<table_info()> function and and the appropriate
C<quote_identifier()> function, then the B<DBI> default version of this method
will work for your driver too.

=end original

If your database hews close enough to the SQL standard or if you have
implemented an appropriate C<table_info()> function and and the appropriate
C<quote_identifier()> function, then the B<DBI> default version of this method
will work for your driver too.
(TBT)

=begin original

Otherwise, you have to write a function yourself, such as:

=end original

Otherwise, you have to write a function yourself, such as:
(TBT)

    sub tables
    {
        my($dbh, $cat, $sch, $tab, $typ) = @_;
        my(@res);
        my($sth) = $dbh->table_info($cat, $sch, $tab, $typ);
        my(@arr);
        while (@arr = $sth->fetchrow_array)
        {
            push @res, $dbh->quote_identifier($arr[0], $arr[1], $arr[2]);
        }
        return @res;
    }

=begin original

See also the default implementation in F<DBI.pm>.

=end original

See also the default implementation in F<DBI.pm>.
(TBT)

=head2 Writing DBD::Driver::db::quote

(DBD::Driver::db::quote を書く)

=begin original

This method takes a value and converts it into a string suitable for
embedding in an SQL statement as a string literal.

=end original

This method takes a value and converts it into a string suitable for
embedding in an SQL statement as a string literal.
(TBT)

=begin original

If your DBMS accepts the SQL standard notation for strings (single
quotes around the string as a whole with any embedded single quotes
doubled up), then you do not need to write this method as B<DBI> provides a
default method that does it for you.

=end original

If your DBMS accepts the SQL standard notation for strings (single
quotes around the string as a whole with any embedded single quotes
doubled up), then you do not need to write this method as B<DBI> provides a
default method that does it for you.
(TBT)

=begin original

If your DBMS uses an alternative notation or escape mechanism, then you
need to provide an equivalent function. For example, suppose your DBMS
used C notation with double quotes around the string and backslashes
escaping both double quotes and backslashes themselves. Then you might
write the function as:

=end original

If your DBMS uses an alternative notation or escape mechanism, then you
need to provide an equivalent function. For example, suppose your DBMS
used C notation with double quotes around the string and backslashes
escaping both double quotes and backslashes themselves. Then you might
write the function as:
(TBT)

    sub quote
    {
        my($dbh, $str) = @_;
        $str =~ s/["\\]/\\$&/gmo;
        return qq{"$str"};
    }

=begin original

Handling newlines and other control characters is left as an exercise
for the reader.

=end original

Handling newlines and other control characters is left as an exercise
for the reader.
(TBT)

=begin original

This sample method ignores the I<$data_type> indicator which is the
optional second argument to the method.

=end original

This sample method ignores the I<$data_type> indicator which is the
optional second argument to the method.
(TBT)

=head2 Writing DBD::Driver::db::quote_identifier

(DBD::Driver::db::quote_identifier を書く)

=begin original

This method is called to ensure that the name of the given table (or
other database object) can be embedded into an SQL statement without
danger of misinterpretation. The result string should be usable in the
text of an SQL statement as the identifier for a table.

=end original

This method is called to ensure that the name of the given table (or
other database object) can be embedded into an SQL statement without
danger of misinterpretation. The result string should be usable in the
text of an SQL statement as the identifier for a table.
(TBT)

=begin original

If your DBMS accepts the SQL standard notation for quoted identifiers
(which uses double quotes around the identifier as a whole, with any
embedded double quotes doubled up) and accepts I<"schema"."identifier">
(and I<"catalog"."schema"."identifier"> when a catalog is specified), then
you do not need to write this method as B<DBI> provides a default method
that does it for you.

=end original

If your DBMS accepts the SQL standard notation for quoted identifiers
(which uses double quotes around the identifier as a whole, with any
embedded double quotes doubled up) and accepts I<"schema"."identifier">
(and I<"catalog"."schema"."identifier"> when a catalog is specified), then
you do not need to write this method as B<DBI> provides a default method
that does it for you.
(TBT)

=begin original

In fact, even if your DBMS does not handle exactly that notation but
you have implemented the C<get_info()> method and it gives the correct
responses, then it will work for you. If your database is fussier, then
you need to implement your own version of the function.

=end original

In fact, even if your DBMS does not handle exactly that notation but
you have implemented the C<get_info()> method and it gives the correct
responses, then it will work for you. If your database is fussier, then
you need to implement your own version of the function.
(TBT)

=begin original

For example, B<DBD::Informix> has to deal with an environment variable
I<DELIMIDENT>. If it is not set, then the DBMS treats names enclosed in
double quotes as strings rather than names, which is usually a syntax
error. Additionally, the catalog portion of the name is separated from
the schema and table by a different delimiter (colon instead of dot),
and the catalog portion is never enclosed in quotes. (Fortunately,
valid strings for the catalog will never contain weird characters that
might need to be escaped, unless you count dots, dashes, slashes and
at-signs as weird.) Finally, an Informix database can contain objects
that cannot be accessed because they were created by a user with the
I<DELIMIDENT> environment variable set, but the current user does not
have it set. By design choice, the C<quote_identifier()> method encloses
those identifiers in double quotes anyway, which generally triggers a
syntax error, and the metadata methods which generate lists of tables
etc omit those identifiers from the result sets.

=end original

For example, B<DBD::Informix> has to deal with an environment variable
I<DELIMIDENT>. If it is not set, then the DBMS treats names enclosed in
double quotes as strings rather than names, which is usually a syntax
error. Additionally, the catalog portion of the name is separated from
the schema and table by a different delimiter (colon instead of dot),
and the catalog portion is never enclosed in quotes. (Fortunately,
valid strings for the catalog will never contain weird characters that
might need to be escaped, unless you count dots, dashes, slashes and
at-signs as weird.) Finally, an Informix database can contain objects
that cannot be accessed because they were created by a user with the
I<DELIMIDENT> environment variable set, but the current user does not
have it set. By design choice, the C<quote_identifier()> method encloses
those identifiers in double quotes anyway, which generally triggers a
syntax error, and the metadata methods which generate lists of tables
etc omit those identifiers from the result sets.
(TBT)

    sub quote_identifier
    {
        my($dbh, $cat, $sch, $obj) = @_;
        my($rv) = "";
        my($qq) = (defined $ENV{DELIMIDENT}) ? '"' : '';
        $rv .= qq{$cat:} if (defined $cat);
        if (defined $sch)
        {
            if ($sch !~ m/^\w+$/o)
            {
                $qq = '"';
                $sch =~ s/$qq/$qq$qq/gm;
            }
            $rv .= qq{$qq$sch$qq.};
        }
        if (defined $obj)
        {
            if ($obj !~ m/^\w+$/o)
            {
                $qq = '"';
                $obj =~ s/$qq/$qq$qq/gm;
            }
            $rv .= qq{$qq$obj$qq};
        }
        return $rv;
    }

=begin original

Handling newlines and other control characters is left as an exercise
for the reader.

=end original

Handling newlines and other control characters is left as an exercise
for the reader.
(TBT)

=begin original

Note that there is an optional fourth parameter to this function which
is a reference to a hash of attributes; this sample implementation
ignores that.

=end original

Note that there is an optional fourth parameter to this function which
is a reference to a hash of attributes; this sample implementation
ignores that.
(TBT)

=begin original

This sample implementation also ignores the single-argument variant of
the method.

=end original

This sample implementation also ignores the single-argument variant of
the method.
(TBT)

=head1 TRACING

(トレース)

=begin original

Tracing in DBI is controlled with a combination of a trace level and a
set of flags which together are known as the trace settings. The trace
settings are stored in a single integer and divided into levels and
flags by a set of masks (C<DBIc_TRACE_LEVEL_MASK> and
C<DBIc_TRACE_FLAGS_MASK>).

=end original

Tracing in DBI is controlled with a combination of a trace level and a
set of flags which together are known as the trace settings. The trace
settings are stored in a single integer and divided into levels and
flags by a set of masks (C<DBIc_TRACE_LEVEL_MASK> and
C<DBIc_TRACE_FLAGS_MASK>).
(TBT)

=begin original

Each handle has it's own trace settings and so does the DBI. When you
call a method the DBI merges the handles settings into its own for the
duration of the call: the trace flags of the handle are OR'd into the
trace flags of the DBI, and if the handle has a higher trace level
then the DBI trace level is raised to match it. The previous DBI trace
settings are restored when the called method returns.

=end original

Each handle has it's own trace settings and so does the DBI. When you
call a method the DBI merges the handles settings into its own for the
duration of the call: the trace flags of the handle are OR'd into the
trace flags of the DBI, and if the handle has a higher trace level
then the DBI trace level is raised to match it. The previous DBI trace
settings are restored when the called method returns.
(TBT)

=head2 Trace Level

(トレースレベル)

=begin original

The trace level is the first 4 bits of the trace settings (masked by
C<DBIc_TRACE_FLAGS_MASK>) and represents trace levels of 1 to 15. Do
not output anything at trace levels less than 3 as they are reserved
for DBI.

=end original

The trace level is the first 4 bits of the trace settings (masked by
C<DBIc_TRACE_FLAGS_MASK>) and represents trace levels of 1 to 15. Do
not output anything at trace levels less than 3 as they are reserved
for DBI.
(TBT)

=begin original

For advice on what to output at each level see "Trace Levels" in
L<DBI>.

=end original

For advice on what to output at each level see "Trace Levels" in
L<DBI>.
(TBT)

=begin original

To test for a trace level you can use the C<DBIc_TRACE_LEVEL> macro
like this:

=end original

To test for a trace level you can use the C<DBIc_TRACE_LEVEL> macro
like this:
(TBT)

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar");
  }

=begin original

Also B<note> the use of PerlIO_printf which you should always use for
tracing and never the C C<stdio.h> I/O functions.

=end original

Also B<note> the use of PerlIO_printf which you should always use for
tracing and never the C C<stdio.h> I/O functions.
(TBT)

=head2 Trace Flags

(トレースフラグ)

=begin original

Trace flags are used to enable tracing of specific activities within
the DBI and drivers. The DBI defines some trace flags and drivers can
define others. DBI trace flag names begin with a capital letter and
driver specific names begin with a lowercase letter. For a list of DBI
defined trace flags see "Trace Flags" in L<DBI>.

=end original

Trace flags are used to enable tracing of specific activities within
the DBI and drivers. The DBI defines some trace flags and drivers can
define others. DBI trace flag names begin with a capital letter and
driver specific names begin with a lowercase letter. For a list of DBI
defined trace flags see "Trace Flags" in L<DBI>.
(TBT)

=begin original

If you want to use private trace flags you'll probably want to be able
to set them by name. Drivers are expected to override the
parse_trace_flag (note the singular) and check if $trace_flag_name is
a driver specific trace flags and, if not, then call the DBIs default
parse_trace_flag(). To do that you'll need to define a
parse_trace_flag() method like this:

=end original

If you want to use private trace flags you'll probably want to be able
to set them by name. Drivers are expected to override the
parse_trace_flag (note the singular) and check if $trace_flag_name is
a driver specific trace flags and, if not, then call the DBIs default
parse_trace_flag(). To do that you'll need to define a
parse_trace_flag() method like this:
(TBT)

  sub parse_trace_flag {
      my ($h, $name) = @_;
      return 0x01000000 if $name eq 'foo';
      return 0x02000000 if $name eq 'bar';
      return 0x04000000 if $name eq 'baz';
      return 0x08000000 if $name eq 'boo';
      return 0x10000000 if $name eq 'bop';
      return $h->SUPER::parse_trace_flag($name);
  }

=begin original

All private flag names must be lowercase, and all private flags must
be in the top 8 of the 32 bits of C<DBIc_TRACE_FLAGS(imp)> i.e.,
0xFF000000.

=end original

All private flag names must be lowercase, and all private flags must
be in the top 8 of the 32 bits of C<DBIc_TRACE_FLAGS(imp)> i.e.,
0xFF000000.
(TBT)

=begin original

If you've defined a parse_trace_flag() method in ::db you'll also want
it in ::st, so just alias it in:

=end original

If you've defined a parse_trace_flag() method in ::db you'll also want
it in ::st, so just alias it in:
(TBT)

  *parse_trace_flag = \&DBD::foo:db::parse_trace_flag;

=begin original

You may want to act on the current 'SQL' trace flag that DBI defines
to output SQL prepared/executed as DBI currently does not do SQL
tracing.

=end original

You may want to act on the current 'SQL' trace flag that DBI defines
to output SQL prepared/executed as DBI currently does not do SQL
tracing.
(TBT)

=head2 Trace Macros

(トレースマクロ)

=begin original

Access to the trace level and trace flags is via a set of macros.

=end original

Access to the trace level and trace flags is via a set of macros.
(TBT)

  DBIc_TRACE_SETTINGS(imp) returns the trace settings
  DBIc_TRACE_LEVEL(imp) returns the trace level
  DBIc_TRACE_FLAGS(imp) returns the trace flags
  DBIc_TRACE(imp, flags, flaglevel, level)

  e.g.,

  DBIc_TRACE(imp, 0, 0, 4)
    if level >= 4

  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
    if tracing DBDtf_FOO & level>=2 or level>=4

  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
    as above but never trace just due to level

=head1 WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE

(古い Perl インターフェースのためのエミュレーション層を書く)

=begin original

Study F<Oraperl.pm> (supplied with B<DBD::Oracle>) and F<Ingperl.pm> (supplied
with B<DBD::Ingres>) and the corresponding I<dbdimp.c> files for ideas.

=end original

考え方については、(B<DBD::Oracle> と一緒に提供される)F<Oraperl.pm>、
(B<DBD::Ingres> と一緒に提供される)F<Ingperl.pm> そして対応する
I<dbdimp.c> ファイルを勉強してください。 

=begin original

Note that the emulation code sets C<$dbh-E<gt>{CompatMode} = 1;> for each
connection so that the internals of the driver can implement behaviour
compatible with the old interface when dealing with those handles.

=end original

エミュレーションコードは各接続について C<$dbh-E<gt>{CompatMode} = 1;> を
設定していることに注意してください。
これはドライバの内部でそれらを扱うときに、古いインターフェースと互換性を
もった動きを実装できるようにするためです。

=head2 Setting emulation perl variables

(エミュレーション perl 変数の設定)

=begin original

For example, ingperl has a I<$sql_rowcount> variable. Rather than try
to manually update this in F<Ingperl.pm> it can be done faster in C code.
In C<dbd_init()>:

=end original

例えば ingperl は変数 I<$sql_rowcount> を持っています。
これを F<Ingperl.pm> のなかで手動で更新するよりは、C コードで
やってしまう方がむしろ速いでしょう。
C<dbd_init()> では:

  sql_rowcount = perl_get_sv("Ingperl::sql_rowcount", GV_ADDMULTI);

=begin original

In the relevant places do:

=end original

対応する場所は以下のようにします:

  if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
      sv_setiv(sql_rowcount, the_row_count);

=head1 OTHER MISCELLANEOUS INFORMATION

(その他の様々な情報)

=head2 The imp_xyz_t types

(imp_xyz_t 型)

=begin original

Any handle has a corresponding C structure filled with private data.
Some of this data is reserved for use by B<DBI> (except for using the
DBIc macros below), some is for you. See the description of the
F<dbdimp.h> file above for examples. Most functions in F<dbdimp.c>
are passed both the handle C<xyz> and a pointer to C<imp_xyz>. In
rare cases, however, you may use the following macros:

=end original

すべてのハンドルはプライベートがいっぱい入った対応する C 構造体を持ちます。
このデータの一部は B<DBI> のために予約されています(以下の DBIc マクロを
使うのを除いて)、一部はあなたのためです。
例として上記の F<dbdimp.h> の説明をご覧下さい。
F<dbdimp.c> のほとんどの関数はハンドル C<xyz> と C<imp_xyz> へのポインタを
渡されます。
しかしながら、まれに以下のマクロを使うこともできます。

=over 4

=item D_imp_dbh(dbh)

=begin original

Given a function argument I<dbh>, declare a variable I<imp_dbh> and
initialize it with a pointer to the handles private data. Note: This
must be a part of the function header, because it declares a variable.

=end original

関数引数 I<dbh> 変数を与えられ、I<imp_dbh> を宣言し、それをハンドルへの
プライベートデータへのポインタで初期化します。
注意:これは関数ヘッダの一部でなければなりません、というのも変数を
宣言するからです。

=item D_imp_sth(sth)

=begin original

Likewise for statement handles.

=end original

文ハンドルと同様です。

=item D_imp_xxx(h)

=begin original

Given any handle, declare a variable I<imp_xxx> and initialize it
with a pointer to the handles private data. It is safe, for example,
to cast I<imp_xxx> to C<imp_dbh_t*>, if C<DBIc_TYPE(imp_xxx) == DBIt_DB>.
(You can also call C<sv_derived_from(h, "DBI::db")>, but that's much
slower.)

=end original

すべてのハンドルを与えられ、変数 I<imp_xxx> を宣言し、それをハンドルの
プライベートデータへのポインタで初期化します。
例えば、C<DBIc_TYPE(imp_xxx) == DBIt_DB> であれば、I<imp_xxx> を
I<imp_dbh_t*> にキャストするのは安全です
(C<sv_derived_from(h, "DBI::db")> を呼ぶこともできますが、それはもっと
時間がかかります)

=item D_imp_dbh_from_sth

=begin original

Given a I<imp_sth>, declare a variable I<imp_dbh> and initialize it with a
pointer to the parent database handle's implementors structure.

=end original

I<imp_sth> を与えられ、変数 I<imp_dbh> を宣言し、それを
親データベースハンドルの実装構造へのポインタで初期化します。

=back

=head2 Using DBIc_IMPSET_on

(DBIc_IMPSET_on を使う)

=begin original

The driver code which initializes a handle should use C<DBIc_IMPSET_on()>
as soon as its state is such that the cleanup code must be called.
When this happens is determined by your driver code.

=end original

ハンドルを初期化するドライバコードは、後片付けコードが
呼ばれなければならないような状態になったらすぐに、C<DBIc_IMPSET_on()> を
使わなければなりません。
これが発生するときはドライバコードによって判定されます。

=begin original

B<Failure to call this can lead to corruption of data structures.>

=end original

B<これを呼び出すのに失敗するとデータ構造がおかしくなるかもしれません。>

=begin original

For example, B<DBD::Informix> maintains a linked list of database
handles in the driver, and within each handle, a linked list of
statements. Once a statement is added to the linked list, it is crucial
that it is cleaned up (removed from the list). When I<DBIc_IMPSET_on()>
was being called too late, it was able to cause all sorts of problems.

=end original

例えば B<DBD::Informix> はドライバで、リンクされたデータベースハンドルの
リストを、そして各ハンドルでは状態のリンクされたリスト管理します。
一度リンクされたリストに文が追加されると、片付けられるのは
(リストから削除される)のはとても重要です。
I<DBIc_IMPSET_on()> が呼ばれるのが遅すぎると、あらゆる種類の障害を
起こす可能性があります。

=head2 Using DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off()

(DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off() を使う)

=begin original

Once upon a long time ago, the only way of handling the internal B<DBI>
boolean flags/attributes was through macros such as:

=end original

その昔、以下のようなマクロを通すのが内部 B<DBI> ブール値のフラグ／属性を扱う
唯一の方法でした:

  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off

=begin original

Each of these took an I<imp_xxh> pointer as an argument.

=end original

これらのそれぞれはimp_xxhポインタを引数として取ります。

=begin original

Since then, new attributes have been added such as I<ChopBlanks>,
I<RaiseError> and I<PrintError>, and these do not have the full set of
macros. The approved method for handling these is now the four macros:

=end original

その後、I<ChopBlanks>, I<RaiseError>, I<PrintError> といった新しく
加えられた属性は、マクロのフルセットを持ちません。
これらを扱うために認められている方法はいまや四つのマクロです:

  DBIc_is(imp, flag)
  DBIc_has(imp, flag)       an alias for DBIc_is
  DBIc_on(imp, flag)
  DBIc_off(imp, flag)
  DBIc_set(imp, flag, on)   set if on is true, else clear

=begin original

Consequently, the C<DBIc_XXXXX> family of macros is now mostly deprecated
and new drivers should avoid using them, even though the older drivers
will probably continue to do so for quite a while yet. However...

=end original

したがってマクロの C<DBIc_XXXXX> の種類はいまやほとんど止めるように
いわれており、古いドライバはおそらくしばらくの間は
そうするでしょうけれども、新しいドライバはそれらを使うことを避けるべきです。
しかしながら...

=begin original

There is an I<important exception> to that. The I<ACTIVE> and I<IMPSET>
flags should be set via the C<DBIc_ACTIVE_on()> and C<DBIc_IMPSET_on()> macros,
and unset via the C<DBIc_ACTIVE_off()> and C<DBIc_IMPSET_off()> macros.

=end original

重要な例外があります。
I<ACTIVE> と I<IMPSET> フラグは I<DBIc_ACTIVE_on()> と I<DBIc_IMPSET_on()>
マクロによって設定され、I<DBIc_ACTIVE_off()> と I<DBIc_IMPSET_off()> に
よって解除なければなりません。

=head2 Using the get_fbav() method

(get_fbav() メソッドを使う)

=begin original

B<THIS IS CRITICAL for C/XS drivers>.

=end original

B<THIS IS CRITICAL for C/XS drivers>.
(TBT)

=begin original

The C<$sth-E<gt>bind_col()> and C<$sth-E<gt>bind_columns()> documented
in the B<DBI> specification do not have to be implemented by the driver
writer because B<DBI> takes care of the details for you.

=end original

B<DBI> の仕様でドキュメント化されている C<$sth-E<gt>bind_col()> と
C<$sth-E<gt>bind_columns()> はドライバの作者によって実行される
必要はありません; というのも B<DBI> が代りに面倒を見てくれるからです。

=begin original

However, the key to ensuring that bound columns work is to call the
function C<DBIc_DBISTATE(imp_xxh)-E<gt>get_fbav()> in the code which
fetches a row of data.

=end original

しかしカラムのバインドが機能することを保証する鍵は、データの行を取り出す
C<DBIc_DBISTATE(imp_xxh)-E<gt>get_fbav()> 関数を呼び出すことです。

=begin original

This returns an C<AV>, and each element of the C<AV> contains the C<SV> which
should be set to contain the returned data.

=end original

これは C<AV> を返し、そして C<AV> の各要素は返されるデータを持つように
設定されるべき C<SV> を持っています。

=begin original

The pure Perl equivalent is the C<$sth-E<gt>_set_fbav($data)> method, as
described in the part on pure Perl drivers.

=end original

ピュア Perl の等価物は、ドライバの部分で記述される
C<$sth-E<gt>_set_fbav($data)> メソッドです。

=head2 Casting strings to Perl types based on a SQL type

(文字列を SQL 型による Perl 型にキャストする)

=begin original

DBI from 1.611 (and DBIXS_REVISION 13606) defines the
sql_type_cast_svpv method which may be used to cast a string
representation of a value to a more specific Perl type based on a SQL
type. You should consider using this method when processing bound
column data as it provides some support for the TYPE bind_col
attribute which is rarely used in drivers.

=end original

DBI from 1.611 (and DBIXS_REVISION 13606) defines the
sql_type_cast_svpv method which may be used to cast a string
representation of a value to a more specific Perl type based on a SQL
type. You should consider using this method when processing bound
column data as it provides some support for the TYPE bind_col
attribute which is rarely used in drivers.
(TBT)

  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)

=begin original

C<sv> is what you would like cast, C<sql_type> is one of the DBI defined
SQL types (e.g., C<SQL_INTEGER>) and C<flags> is a bitmask as follows:

=end original

C<sv> is what you would like cast, C<sql_type> is one of the DBI defined
SQL types (e.g., C<SQL_INTEGER>) and C<flags> is a bitmask as follows:
(TBT)

=over

=item DBIstcf_STRICT

=begin original

If set this indicates you want an error state returned if the cast
cannot be performed.

=end original

If set this indicates you want an error state returned if the cast
cannot be performed.
(TBT)

=item DBIstcf_DISCARD_STRING

=begin original

If set and the pv portion of the C<sv> is cast then this will cause
sv's pv to be freed up.

=end original

If set and the pv portion of the C<sv> is cast then this will cause
sv's pv to be freed up.
(TBT)

=back

=begin original

sql_type_cast_svpv returns the following states:

=end original

sql_type_cast_svpv returns the following states:
(TBT)

 -2 sql_type is not handled - sv not changed
 -1 sv is undef, sv not changed
  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
  2 sv was cast ok

=begin original

The current implementation of sql_type_cast_svpv supports
C<SQL_INTEGER>, C<SQL_DOUBLE> and C<SQL_NUMERIC>. C<SQL_INTEGER> uses
sv_2iv and hence may set IV, UV or NV depending on the
number. C<SQL_DOUBLE> uses sv_2nv so may set NV and C<SQL_NUMERIC>
will set IV or UV or NV.

=end original

The current implementation of sql_type_cast_svpv supports
C<SQL_INTEGER>, C<SQL_DOUBLE> and C<SQL_NUMERIC>. C<SQL_INTEGER> uses
sv_2iv and hence may set IV, UV or NV depending on the
number. C<SQL_DOUBLE> uses sv_2nv so may set NV and C<SQL_NUMERIC>
will set IV or UV or NV.
(TBT)

=begin original

DBIstcf_STRICT should be implemented as the StrictlyTyped attribute
and DBIstcf_DISCARD_STRING implemented as the DiscardString attribute
to the bind_col method and both default to off.

=end original

DBIstcf_STRICT should be implemented as the StrictlyTyped attribute
and DBIstcf_DISCARD_STRING implemented as the DiscardString attribute
to the bind_col method and both default to off.
(TBT)

=begin original

See DBD::Oracle for an example of how this is used.

=end original

See DBD::Oracle for an example of how this is used.
(TBT)

=head1 SUBCLASSING DBI DRIVERS

(DBI ドライバのサブクラス化)

=begin original

This is definitely an open subject. It can be done, as demonstrated by
the B<DBD::File> driver, but it is not as simple as one might think.

=end original

これは完全にオープンな議題です。
B<DBD::File> ドライバが証明しているように、それは可能です。
しかし思っているほど簡単ではないかもしれません。

=begin original

(Note that this topic is different from subclassing the B<DBI>. For an
example of that, see the F<t/subclass.t> file supplied with the B<DBI>.)

=end original

(このトピックは B<DBI> のサブクラス化とは違うことに注意してください。
その例については、B<DBI> と一緒に提供される F<t/subclass.t> ファイルを
ご覧下さい。)

=begin original

The main problem is that the I<dbh>'s and I<sth>'s that your C<connect()> and
C<prepare()> methods return are not instances of your B<DBD::Driver::db>
or B<DBD::Driver::st> packages, they are not even derived from it.
Instead they are instances of the B<DBI::db> or B<DBI::st> classes or
a derived subclass. Thus, if you write a method C<mymethod()> and do a

=end original

主な問題は、C<connect()> や C<prepare()> メソッドが返す I<dbh> のそして
I<sth> は B<DBD::Driver::db> や B<DBD::Driver::st> の
インスタンスではありません; そこから派生したものですらありません。
その代わりに B<DBD::db> や B<DBD::st> クラスまたは派生したサブクラスの
インスタンスです。
このため、もし C<mymethod()> を書いて、以下のようにすると

  $dbh->mymethod()

=begin original

then the autoloader will search for that method in the package B<DBI::db>.
Of course you can instead to a

=end original

autoloader は B<DBI::db> パッケージでそのメソッドを探します。
もちろん代りに以下のようにすることもできます

  $dbh->func('mymethod')

=begin original

and that will indeed work, even if C<mymethod()> is inherited, but not
without additional work. Setting I<@ISA> is not sufficient.

=end original

そして、もし C<mymethod()> が継承されていたとしても、これは本当に
機能しますが、追加的な機能はありません。I<@ISA> を設定することだけでは
不充分です。

=head2 Overwriting methods

(メソッドの上書き)

=begin original

The first problem is, that the C<connect()> method has no idea of
subclasses. For example, you cannot implement base class and subclass
in the same file: The C<install_driver()> method wants to do a

=end original

最初の問題は、C<connect()> メソッドにはサブクラスの考えがないことです。
例えば同じファイルにベースとなるクラスとサブクラスを
実行することはできません:C<install_driver()> メソッドが以下のようにしたい。

  require DBD::Driver;

=begin original

In particular, your subclass B<has> to be a separate driver, from
the view of B<DBI>, and you cannot share driver handles.

=end original

特に、あなたのサブクラスは B<DBI>の視点からは別のドライバに
なる B<べき> です。
そしてドライバハンドルを共有することはできません。

=begin original

Of course that's not much of a problem. You should even be able
to inherit the base classes C<connect()> method. But you cannot
simply overwrite the method, unless you do something like this,
quoted from B<DBD::CSV>:

=end original

それはもちろん大した問題ではありません。
ベースクラスの C<connect()> メソッドを継承することできるはずです。
しかし以下のようなことをしないかぎり、簡単にメソッドを
上書きすることはできません。
B<DBD::CSV> から引用すると:

  sub connect ($$;$$$) {
      my ($drh, $dbname, $user, $auth, $attr) = @_;

      my $this = $drh->DBD::File::dr::connect($dbname, $user, $auth, $attr);
      if (!exists($this->{csv_tables})) {
          $this->{csv_tables} = {};
      }

      $this;
  }

=begin original

Note that we cannot do a

=end original

以下のような

  $drh->SUPER::connect($dbname, $user, $auth, $attr);

=begin original

as we would usually do in a an OO environment, because I<$drh> is an instance
of B<DBI::dr>. And note, that the C<connect()> method of B<DBD::File> is
able to handle subclass attributes. See the description of Pure Perl
drivers above.

=end original

通常にOO環境でおこなうようにできないことに注意してください; 
というのも I<$drh> は B<DBI::dr> のインスタンスだからです。
そして B<DBD::File> の C<connect()> メソッドはサブクラスの属性を扱うことが
出来ることも注意してください。
上記のピュア Perl ドライバの説明をご覧下さい。

=begin original

It is essential that you always call superclass method in the above
manner. However, that should do.

=end original

上記の方法で常にスーパークラスメソッドを呼ぶことは非常に重要です。
しかしながら、それはそうすべきです。

=head2 Attribute handling

(属性の扱い)

=begin original

Fortunately the B<DBI> specifications allow a simple, but still
performant way of handling attributes. The idea is based on the
convention that any driver uses a prefix I<driver_> for its private
methods. Thus it's always clear whether to pass attributes to the super
class or not. For example, consider this C<STORE()> method from the
B<DBD::CSV> class:

=end original

幸いなことに B<DBI> 仕様は簡単でありながら、パフォーマンスのよい属性を
取り扱う方法を可能にしています。
この考え方は、すべてのドライバはプライベートはメソッドのためには
接頭語 I<driver_> を使うという約束を基本にしています。
このため属性をスーパークラスに渡すのか、そうでないのかは常に明確です。
例えば B<DBD::CSV> クラスからの C<STORE()> メソッドについて考えてみてください:

  sub STORE {
      my ($dbh, $attr, $val) = @_;
      if ($attr !~ /^driver_/) {
          return $dbh->DBD::File::db::STORE($attr, $val);
      }
      if ($attr eq 'driver_foo') {
      ...
  }

=cut

=head1 AUTHORS

Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi-users@perl.org>.

=begin meta

Translated: 川合孝典 <GCD00051@nifty.ne.jp> (1.14)
Updated: SHIRAKATA Kentaro <argrath@ub32.org> (1.612)
Status: stalled

=end meta

=cut

