
=encoding euc-jp

=head1 NAME

=begin original

Test::Builder - Backend for building test libraries

=end original

Test::Builder - テストライブラリを構築するためのバックエンド

=head1 SYNOPSIS

  package My::Test::Module;
  use base 'Test::Builder::Module';

  my $CLASS = __PACKAGE__;

  sub ok {
      my($test, $name) = @_;
      my $tb = $CLASS->builder;

      $tb->ok($test, $name);
  }

=head1 DESCRIPTION

=begin original

Test::Simple and Test::More have proven to be popular testing modules,
but they're not always flexible enough.  Test::Builder provides a
building block upon which to write your own test libraries I<which can
work together>.

=end original

Test::Simple と Test::More は有名なテストモジュールとして実績がありますが、
常に十分な柔軟性があるわけではありません。
Test::Builder は I<共に動作するような> 独自のテストライブラリを書くための
基礎になります。

=head2 Construction

(構築)

=over 4

=item B<new>

  my $Test = Test::Builder->new;

=begin original

Returns a Test::Builder object representing the current state of the
test.

=end original

Returns a Test::Builder object representing the current state of the
test.
(TBT)

=begin original

Since you only run one test per program C<new> always returns the same
Test::Builder object.  No matter how many times you call C<new()>, you're
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.

=end original

Since you only run one test per program C<new> always returns the same
Test::Builder object.  No matter how many times you call C<new()>, you're
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.
(TBT)

=begin original

If you want a completely new Test::Builder object different from the
singleton, use C<create>.

=end original

If you want a completely new Test::Builder object different from the
singleton, use C<create>.
(TBT)

=cut

=item B<create>

  my $Test = Test::Builder->create;

=begin original

Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of C<new()> if you're testing
a Test::Builder based module, but otherwise you probably want C<new>.

=end original

Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of C<new()> if you're testing
a Test::Builder based module, but otherwise you probably want C<new>.
(TBT)

=begin original

B<NOTE>: the implementation is not complete.  C<level>, for example, is
still shared amongst B<all> Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.

=end original

B<NOTE>: the implementation is not complete.  C<level>, for example, is
still shared amongst B<all> Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.
(TBT)

=cut

=item B<child>

  my $child = $builder->child($name_of_child);
  $child->plan( tests => 4 );
  $child->ok(some_code());
  ...
  $child->finalize;

=begin original

Returns a new instance of C<Test::Builder>.  Any output from this child will
be indented four spaces more than the parent's indentation.  When done, the
C<finalize> method I<must> be called explicitly.

=end original

Returns a new instance of C<Test::Builder>.  Any output from this child will
be indented four spaces more than the parent's indentation.  When done, the
C<finalize> method I<must> be called explicitly.
(TBT)

=begin original

Trying to create a new child with a previous child still active (i.e.,
C<finalize> not called) will C<croak>.

=end original

Trying to create a new child with a previous child still active (i.e.,
C<finalize> not called) will C<croak>.
(TBT)

=begin original

Trying to run a test when you have an open child will also C<croak> and cause
the test suite to fail.

=end original

Trying to run a test when you have an open child will also C<croak> and cause
the test suite to fail.
(TBT)

=cut

=item B<subtest>

    $builder->subtest($name, \&subtests);

=begin original

See documentation of C<subtest> in Test::More.

=end original

See documentation of C<subtest> in Test::More.
(TBT)

=cut

=begin _private

=item B<_plan_handled>

    if ( $Test->_plan_handled ) { ... }

Returns true if the developer has explicitly handled the plan via:

=over 4

=item * Explicitly setting the number of tests

=item * Setting 'no_plan'

=item * Set 'skip_all'.

=back

This is currently used in subtests when we implicitly call C<< $Test->done_testing >>
if the developer has not set a plan.

=end _private

=cut

=item B<finalize>

  my $ok = $child->finalize;

=begin original

When your child is done running tests, you must call C<finalize> to clean up
and tell the parent your pass/fail status.

=end original

When your child is done running tests, you must call C<finalize> to clean up
and tell the parent your pass/fail status.
(TBT)

=begin original

Calling finalize on a child with open children will C<croak>.

=end original

Calling finalize on a child with open children will C<croak>.
(TBT)

=begin original

If the child falls out of scope before C<finalize> is called, a failure
diagnostic will be issued and the child is considered to have failed.

=end original

If the child falls out of scope before C<finalize> is called, a failure
diagnostic will be issued and the child is considered to have failed.
(TBT)

=begin original

No attempt to call methods on a child after C<finalize> is called is
guaranteed to succeed.

=end original

No attempt to call methods on a child after C<finalize> is called is
guaranteed to succeed.
(TBT)

=begin original

Calling this on the root builder is a no-op.

=end original

Calling this on the root builder is a no-op.
(TBT)

=cut

=item B<parent>

 if ( my $parent = $builder->parent ) {
     ...
 }

=begin original

Returns the parent C<Test::Builder> instance, if any.  Only used with child
builders for nested TAP.

=end original

Returns the parent C<Test::Builder> instance, if any.  Only used with child
builders for nested TAP.
(TBT)

=cut

=item B<name>

 diag $builder->name;

=begin original

Returns the name of the current builder.  Top level builders default to C<$0>
(the name of the executable).  Child builders are named via the C<child>
method.  If no name is supplied, will be named "Child of $parent->name".

=end original

Returns the name of the current builder.  Top level builders default to C<$0>
(the name of the executable).  Child builders are named via the C<child>
method.  If no name is supplied, will be named "Child of $parent->name".
(TBT)

=cut

=item B<reset>

  $Test->reset;

=begin original

Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.

=end original

Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.
(TBT)

=cut

=back

=head2 Setting up tests

(テストの設定)

=begin original

These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.

=end original

These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.
(TBT)

=over 4

=item B<plan>

  $Test->plan('no_plan');
  $Test->plan( skip_all => $reason );
  $Test->plan( tests => $num_tests );

=begin original

A convenient way to set up your tests.  Call this and Test::Builder
will print the appropriate headers and take the appropriate actions.

=end original

A convenient way to set up your tests.  Call this and Test::Builder
will print the appropriate headers and take the appropriate actions.
(TBT)

=begin original

If you call C<plan()>, don't call any of the other methods below.

=end original

If you call C<plan()>, don't call any of the other methods below.
(TBT)

=begin original

If a child calls "skip_all" in the plan, a C<Test::Builder::Exception> is
thrown.  Trap this error, call C<finalize()> and don't run any more tests on
the child.

=end original

If a child calls "skip_all" in the plan, a C<Test::Builder::Exception> is
thrown.  Trap this error, call C<finalize()> and don't run any more tests on
the child.
(TBT)

 my $child = $Test->child('some child');
 eval { $child->plan( $condition ? ( skip_all => $reason ) : ( tests => 3 )  ) };
 if ( eval { $@->isa('Test::Builder::Exception') } ) {
    $child->finalize;
    return;
 }
 # run your tests

=cut

=item B<expected_tests>

    my $max = $Test->expected_tests;
    $Test->expected_tests($max);

=begin original

Gets/sets the number of tests we expect this test to run and prints out
the appropriate headers.

=end original

Gets/sets the number of tests we expect this test to run and prints out
the appropriate headers.
(TBT)

=cut

=item B<no_plan>

  $Test->no_plan;

=begin original

Declares that this test will run an indeterminate number of tests.

=end original

Declares that this test will run an indeterminate number of tests.
(TBT)

=cut

=begin private

=item B<_output_plan>

  $tb->_output_plan($max);
  $tb->_output_plan($max, $directive);
  $tb->_output_plan($max, $directive => $reason);

Handles displaying the test plan.

If a C<$directive> and/or C<$reason> are given they will be output with the
plan.  So here's what skipping all tests looks like:

    $tb->_output_plan(0, "SKIP", "Because I said so");

It sets C<< $tb->{Have_Output_Plan} >> and will croak if the plan was already
output.

=end private

=cut

=item B<done_testing>

  $Test->done_testing();
  $Test->done_testing($num_tests);

=begin original

Declares that you are done testing, no more tests will be run after this point.

=end original

Declares that you are done testing, no more tests will be run after this point.
(TBT)

=begin original

If a plan has not yet been output, it will do so.

=end original

If a plan has not yet been output, it will do so.
(TBT)

=begin original

$num_tests is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If C<no_plan> was declared,
this will override.

=end original

$num_tests is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If C<no_plan> was declared,
this will override.
(TBT)

=begin original

If C<done_testing()> is called twice, the second call will issue a
failing test.

=end original

If C<done_testing()> is called twice, the second call will issue a
failing test.
(TBT)

=begin original

If C<$num_tests> is omitted, the number of tests run will be used, like
no_plan.

=end original

If C<$num_tests> is omitted, the number of tests run will be used, like
no_plan.
(TBT)

=begin original

C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
safer. You'd use it like so:

=end original

C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
safer. You'd use it like so:
(TBT)

    $Test->ok($a == $b);
    $Test->done_testing();

=begin original

Or to plan a variable number of tests:

=end original

Or to plan a variable number of tests:
(TBT)

    for my $test (@tests) {
        $Test->ok($test);
    }
    $Test->done_testing(@tests);

=cut

=item B<has_plan>

  $plan = $Test->has_plan

=begin original

Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
of expected tests).

=end original

Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
of expected tests).
(TBT)

=cut

=item B<skip_all>

  $Test->skip_all;
  $Test->skip_all($reason);

=begin original

Skips all the tests, using the given C<$reason>.  Exits immediately with 0.

=end original

Skips all the tests, using the given C<$reason>.  Exits immediately with 0.
(TBT)

=cut

=item B<exported_to>

  my $pack = $Test->exported_to;
  $Test->exported_to($pack);

=begin original

Tells Test::Builder what package you exported your functions to.

=end original

Tells Test::Builder what package you exported your functions to.
(TBT)

=begin original

This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.

=end original

This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.
(TBT)

=cut

=back

=head2 Running tests

(テストの実行)

=begin original

These actually run the tests, analogous to the functions in Test::More.

=end original

These actually run the tests, analogous to the functions in Test::More.
(TBT)

=begin original

They all return true if the test passed, false if the test failed.

=end original

They all return true if the test passed, false if the test failed.
(TBT)

=begin original

C<$name> is always optional.

=end original

C<$name> is always optional.
(TBT)

=over 4

=item B<ok>

  $Test->ok($test, $name);

=begin original

Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
like Test::Simple's C<ok()>.

=end original

Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
like Test::Simple's C<ok()>.
(TBT)

=cut

=item B<is_eq>

  $Test->is_eq($got, $expected, $name);

=begin original

Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
string version.

=end original

Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
string version.
(TBT)

=begin original

C<undef> only ever matches another C<undef>.

=end original

C<undef> only ever matches another C<undef>.
(TBT)

=item B<is_num>

  $Test->is_num($got, $expected, $name);

=begin original

Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
numeric version.

=end original

Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
numeric version.
(TBT)

=begin original

C<undef> only ever matches another C<undef>.

=end original

C<undef> only ever matches another C<undef>.
(TBT)

=cut

=item B<isnt_eq>

  $Test->isnt_eq($got, $dont_expect, $name);

=begin original

Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
the string version.

=end original

Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
the string version.
(TBT)

=item B<isnt_num>

  $Test->isnt_num($got, $dont_expect, $name);

=begin original

Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
the numeric version.

=end original

Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
the numeric version.
(TBT)

=cut

=item B<like>

  $Test->like($this, qr/$regex/, $name);
  $Test->like($this, '/$regex/', $name);

=begin original

Like Test::More's C<like()>.  Checks if $this matches the given C<$regex>.

=end original

Like Test::More's C<like()>.  Checks if $this matches the given C<$regex>.
(TBT)

=item B<unlike>

  $Test->unlike($this, qr/$regex/, $name);
  $Test->unlike($this, '/$regex/', $name);

=begin original

Like Test::More's C<unlike()>.  Checks if $this B<does not match> the
given C<$regex>.

=end original

Like Test::More's C<unlike()>.  Checks if $this B<does not match> the
given C<$regex>.
(TBT)

=cut

=item B<cmp_ok>

  $Test->cmp_ok($this, $type, $that, $name);

=begin original

Works just like Test::More's C<cmp_ok()>.

=end original

Works just like Test::More's C<cmp_ok()>.
(TBT)

    $Test->cmp_ok($big_num, '!=', $other_big_num);

=cut

=back

=head2 Other Testing Methods

(その他のテストメソッド)

=begin original

These are methods which are used in the course of writing a test but are not themselves tests.

=end original

These are methods which are used in the course of writing a test but are not themselves tests.
(TBT)

=over 4

=item B<BAIL_OUT>

    $Test->BAIL_OUT($reason);

=begin original

Indicates to the Test::Harness that things are going so badly all
testing should terminate.  This includes running any additional test
scripts.

=end original

Indicates to the Test::Harness that things are going so badly all
testing should terminate.  This includes running any additional test
scripts.
(TBT)

=begin original

It will exit with 255.

=end original

It will exit with 255.
(TBT)

=cut

=for deprecated
BAIL_OUT() used to be BAILOUT()

=cut

=item B<skip>

    $Test->skip;
    $Test->skip($why);

=begin original

Skips the current test, reporting C<$why>.

=end original

Skips the current test, reporting C<$why>.
(TBT)

=cut

=item B<todo_skip>

  $Test->todo_skip;
  $Test->todo_skip($why);

=begin original

Like C<skip()>, only it will declare the test as failing and TODO.  Similar
to

=end original

Like C<skip()>, only it will declare the test as failing and TODO.  Similar
to
(TBT)

    print "not ok $tnum # TODO $why\n";

=cut

=begin _unimplemented

=item B<skip_rest>

  $Test->skip_rest;
  $Test->skip_rest($reason);

=begin original

Like C<skip()>, only it skips all the rest of the tests you plan to run
and terminates the test.

=end original

Like C<skip()>, only it skips all the rest of the tests you plan to run
and terminates the test.
(TBT)

=begin original

If you're running under C<no_plan>, it skips once and terminates the
test.

=end original

If you're running under C<no_plan>, it skips once and terminates the
test.
(TBT)

=end _unimplemented

=back

=head2 Test building utility methods

(テスト構築ユーティリティメソッド)

=begin original

These methods are useful when writing your own test methods.

=end original

These methods are useful when writing your own test methods.
(TBT)

=over 4

=item B<maybe_regex>

  $Test->maybe_regex(qr/$regex/);
  $Test->maybe_regex('/$regex/');

=begin original

This method used to be useful back when Test::Builder worked on Perls
before 5.6 which didn't have qr//.  Now its pretty useless.

=end original

This method used to be useful back when Test::Builder worked on Perls
before 5.6 which didn't have qr//.  Now its pretty useless.
(TBT)

=begin original

Convenience method for building testing functions that take regular
expressions as arguments.

=end original

Convenience method for building testing functions that take regular
expressions as arguments.
(TBT)

=begin original

Takes a quoted regular expression produced by C<qr//>, or a string
representing a regular expression.

=end original

Takes a quoted regular expression produced by C<qr//>, or a string
representing a regular expression.
(TBT)

=begin original

Returns a Perl value which may be used instead of the corresponding
regular expression, or C<undef> if its argument is not recognised.

=end original

Returns a Perl value which may be used instead of the corresponding
regular expression, or C<undef> if its argument is not recognised.
(TBT)

=begin original

For example, a version of C<like()>, sans the useful diagnostic messages,
could be written as:

=end original

For example, a version of C<like()>, sans the useful diagnostic messages,
could be written as:
(TBT)

  sub laconic_like {
      my ($self, $this, $regex, $name) = @_;
      my $usable_regex = $self->maybe_regex($regex);
      die "expecting regex, found '$regex'\n"
          unless $usable_regex;
      $self->ok($this =~ m/$usable_regex/, $name);
  }

=cut

=begin private

=item B<_try>

    my $return_from_code          = $Test->try(sub { code });
    my($return_from_code, $error) = $Test->try(sub { code });

Works like eval BLOCK except it ensures it has no effect on the rest
of the test (ie. C<$@> is not set) nor is effected by outside
interference (ie. C<$SIG{__DIE__}>) and works around some quirks in older
Perls.

C<$error> is what would normally be in C<$@>.

It is suggested you use this in place of eval BLOCK.

=cut

=end private

=item B<is_fh>

    my $is_fh = $Test->is_fh($thing);

=begin original

Determines if the given C<$thing> can be used as a filehandle.

=end original

Determines if the given C<$thing> can be used as a filehandle.
(TBT)

=cut

=back

=head2 Test style

(テストスタイル)

=over 4

=item B<level>

    $Test->level($how_high);

=begin original

How far up the call stack should C<$Test> look when reporting where the
test failed.

=end original

How far up the call stack should C<$Test> look when reporting where the
test failed.
(TBT)

=begin original

Defaults to 1.

=end original

Defaults to 1.
(TBT)

=begin original

Setting L<$Test::Builder::Level> overrides.  This is typically useful
localized:

=end original

Setting L<$Test::Builder::Level> overrides.  This is typically useful
localized:
(TBT)

    sub my_ok {
        my $test = shift;

        local $Test::Builder::Level = $Test::Builder::Level + 1;
        $TB->ok($test);
    }

=begin original

To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.

=end original

To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.
(TBT)

=cut

=item B<use_numbers>

    $Test->use_numbers($on_or_off);

=begin original

Whether or not the test should output numbers.  That is, this if true:

=end original

Whether or not the test should output numbers.  That is, this if true:
(TBT)

  ok 1
  ok 2
  ok 3

=begin original

or this if false

=end original

or this if false
(TBT)

  ok
  ok
  ok

=begin original

Most useful when you can't depend on the test output order, such as
when threads or forking is involved.

=end original

Most useful when you can't depend on the test output order, such as
when threads or forking is involved.
(TBT)

=begin original

Defaults to on.

=end original

Defaults to on.
(TBT)

=cut

=item B<no_diag>

    $Test->no_diag($no_diag);

=begin original

If set true no diagnostics will be printed.  This includes calls to
C<diag()>.

=end original

If set true no diagnostics will be printed.  This includes calls to
C<diag()>.
(TBT)

=item B<no_ending>

    $Test->no_ending($no_ending);

=begin original

Normally, Test::Builder does some extra diagnostics when the test
ends.  It also changes the exit code as described below.

=end original

Normally, Test::Builder does some extra diagnostics when the test
ends.  It also changes the exit code as described below.
(TBT)

=begin original

If this is true, none of that will be done.

=end original

If this is true, none of that will be done.
(TBT)

=item B<no_header>

    $Test->no_header($no_header);

=begin original

If set to true, no "1..N" header will be printed.

=end original

If set to true, no "1..N" header will be printed.
(TBT)

=cut

=back

=head2 Output

(出力)

=begin original

Controlling where the test output goes.

=end original

Controlling where the test output goes.
(TBT)

=begin original

It's ok for your test to change where STDOUT and STDERR point to,
Test::Builder's default output settings will not be affected.

=end original

It's ok for your test to change where STDOUT and STDERR point to,
Test::Builder's default output settings will not be affected.
(TBT)

=over 4

=item B<diag>

    $Test->diag(@msgs);

=begin original

Prints out the given C<@msgs>.  Like C<print>, arguments are simply
appended together.

=end original

Prints out the given C<@msgs>.  Like C<print>, arguments are simply
appended together.
(TBT)

=begin original

Normally, it uses the C<failure_output()> handle, but if this is for a
TODO test, the C<todo_output()> handle is used.

=end original

Normally, it uses the C<failure_output()> handle, but if this is for a
TODO test, the C<todo_output()> handle is used.
(TBT)

=begin original

Output will be indented and marked with a # so as not to interfere
with test output.  A newline will be put on the end if there isn't one
already.

=end original

Output will be indented and marked with a # so as not to interfere
with test output.  A newline will be put on the end if there isn't one
already.
(TBT)

=begin original

We encourage using this rather than calling print directly.

=end original

We encourage using this rather than calling print directly.
(TBT)

=begin original

Returns false.  Why?  Because C<diag()> is often used in conjunction with
a failing test (C<ok() || diag()>) it "passes through" the failure.

=end original

Returns false.  Why?  Because C<diag()> is often used in conjunction with
a failing test (C<ok() || diag()>) it "passes through" the failure.
(TBT)

    return ok(...) || diag(...);

=for blame transfer
Mark Fowler <mark@twoshortplanks.com>

=cut

=item B<note>

    $Test->note(@msgs);

=begin original

Like C<diag()>, but it prints to the C<output()> handle so it will not
normally be seen by the user except in verbose mode.

=end original

Like C<diag()>, but it prints to the C<output()> handle so it will not
normally be seen by the user except in verbose mode.
(TBT)

=cut

=item B<explain>

    my @dump = $Test->explain(@msgs);

=begin original

Will dump the contents of any references in a human readable format.
Handy for things like...

=end original

Will dump the contents of any references in a human readable format.
Handy for things like...
(TBT)

    is_deeply($have, $want) || diag explain $have;

=begin original

or

=end original

or
(TBT)

    is_deeply($have, $want) || note explain $have;

=cut

=begin _private

=item B<_print>

    $Test->_print(@msgs);

Prints to the C<output()> filehandle.

=end _private

=cut

=item B<output>

=item B<failure_output>

=item B<todo_output>

    my $filehandle = $Test->output;
    $Test->output($filehandle);
    $Test->output($filename);
    $Test->output(\$scalar);

=begin original

These methods control where Test::Builder will print its output.
They take either an open C<$filehandle>, a C<$filename> to open and write to
or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.

=end original

These methods control where Test::Builder will print its output.
They take either an open C<$filehandle>, a C<$filename> to open and write to
or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.
(TBT)

=begin original

B<output> is where normal "ok/not ok" test output goes.

=end original

B<output> is where normal "ok/not ok" test output goes.
(TBT)

=begin original

Defaults to STDOUT.

=end original

Defaults to STDOUT.
(TBT)

=begin original

B<failure_output> is where diagnostic output on test failures and
C<diag()> goes.  It is normally not read by Test::Harness and instead is
displayed to the user.

=end original

B<failure_output> is where diagnostic output on test failures and
C<diag()> goes.  It is normally not read by Test::Harness and instead is
displayed to the user.
(TBT)

=begin original

Defaults to STDERR.

=end original

Defaults to STDERR.
(TBT)

=begin original

C<todo_output> is used instead of C<failure_output()> for the
diagnostics of a failing TODO test.  These will not be seen by the
user.

=end original

C<todo_output> is used instead of C<failure_output()> for the
diagnostics of a failing TODO test.  These will not be seen by the
user.
(TBT)

=begin original

Defaults to STDOUT.

=end original

Defaults to STDOUT.
(TBT)

=cut

=item reset_outputs

  $tb->reset_outputs;

=begin original

Resets all the output filehandles back to their defaults.

=end original

Resets all the output filehandles back to their defaults.
(TBT)

=cut

=item carp

  $tb->carp(@message);

=begin original

Warns with C<@message> but the message will appear to come from the
point where the original test function was called (C<< $tb->caller >>).

=end original

Warns with C<@message> but the message will appear to come from the
point where the original test function was called (C<< $tb->caller >>).
(TBT)

=item croak

  $tb->croak(@message);

=begin original

Dies with C<@message> but the message will appear to come from the
point where the original test function was called (C<< $tb->caller >>).

=end original

Dies with C<@message> but the message will appear to come from the
point where the original test function was called (C<< $tb->caller >>).
(TBT)

=cut

=back

=head2 Test Status and Info

(テストステータスと情報)

=over 4

=item B<current_test>

    my $curr_test = $Test->current_test;
    $Test->current_test($num);

=begin original

Gets/sets the current test number we're on.  You usually shouldn't
have to set this.

=end original

Gets/sets the current test number we're on.  You usually shouldn't
have to set this.
(TBT)

=begin original

If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.

=end original

If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.
(TBT)

=cut

=item B<is_passing>

   my $ok = $builder->is_passing;

=begin original

Indicates if the test suite is currently passing.

=end original

Indicates if the test suite is currently passing.
(TBT)

=begin original

More formally, it will be false if anything has happened which makes
it impossible for the test suite to pass.  True otherwise.

=end original

More formally, it will be false if anything has happened which makes
it impossible for the test suite to pass.  True otherwise.
(TBT)

=begin original

For example, if no tests have run C<is_passing()> will be true because
even though a suite with no tests is a failure you can add a passing
test to it and start passing.

=end original

For example, if no tests have run C<is_passing()> will be true because
even though a suite with no tests is a failure you can add a passing
test to it and start passing.
(TBT)

=begin original

Don't think about it too much.

=end original

Don't think about it too much.
(TBT)

=cut

=item B<summary>

    my @tests = $Test->summary;

=begin original

A simple summary of the tests so far.  True for pass, false for fail.
This is a logical pass/fail, so todos are passes.

=end original

A simple summary of the tests so far.  True for pass, false for fail.
This is a logical pass/fail, so todos are passes.
(TBT)

=begin original

Of course, test #1 is $tests[0], etc...

=end original

Of course, test #1 is $tests[0], etc...
(TBT)

=cut

=item B<details>

    my @tests = $Test->details;

=begin original

Like C<summary()>, but with a lot more detail.

=end original

Like C<summary()>, but with a lot more detail.
(TBT)

    $tests[$test_num - 1] = 
            { 'ok'       => is the test considered a pass?
              actual_ok  => did it literally say 'ok'?
              name       => name of the test (if any)
              type       => type of test (if any, see below).
              reason     => reason for the above (if any)
            };

=begin original

'ok' is true if Test::Harness will consider the test to be a pass.

=end original

'ok' is true if Test::Harness will consider the test to be a pass.
(TBT)

=begin original

'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.

=end original

'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.
(TBT)

=begin original

'name' is the name of the test.

=end original

'name' is the name of the test.
(TBT)

=begin original

'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:

=end original

'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:
(TBT)

    skip        see skip()
    todo        see todo()
    todo_skip   see todo_skip()
    unknown     see below

=begin original

Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when C<current_test()> is changed.
In these cases, Test::Builder doesn't know the result of the test, so
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left C<undef>.

=end original

Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when C<current_test()> is changed.
In these cases, Test::Builder doesn't know the result of the test, so
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left C<undef>.
(TBT)

=begin original

For example "not ok 23 - hole count # TODO insufficient donuts" would
result in this structure:

=end original

For example "not ok 23 - hole count # TODO insufficient donuts" would
result in this structure:
(TBT)

    $tests[22] =    # 23 - 1, since arrays start from 0.
      { ok        => 1,   # logically, the test passed since its todo
        actual_ok => 0,   # in absolute terms, it failed
        name      => 'hole count',
        type      => 'todo',
        reason    => 'insufficient donuts'
      };

=cut

=item B<todo>

    my $todo_reason = $Test->todo;
    my $todo_reason = $Test->todo($pack);

=begin original

If the current tests are considered "TODO" it will return the reason,
if any.  This reason can come from a C<$TODO> variable or the last call
to C<todo_start()>.

=end original

If the current tests are considered "TODO" it will return the reason,
if any.  This reason can come from a C<$TODO> variable or the last call
to C<todo_start()>.
(TBT)

=begin original

Since a TODO test does not need a reason, this function can return an
empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
to determine if you are currently inside a TODO block.

=end original

Since a TODO test does not need a reason, this function can return an
empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
to determine if you are currently inside a TODO block.
(TBT)

=begin original

C<todo()> is about finding the right package to look for C<$TODO> in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on C<$Level + 1>, since C<todo()> is usually called inside
a test function.  As a last resort it will use C<exported_to()>.

=end original

C<todo()> is about finding the right package to look for C<$TODO> in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on C<$Level + 1>, since C<todo()> is usually called inside
a test function.  As a last resort it will use C<exported_to()>.
(TBT)

=begin original

Sometimes there is some confusion about where todo() should be looking
for the C<$TODO> variable.  If you want to be sure, tell it explicitly
what $pack to use.

=end original

Sometimes there is some confusion about where todo() should be looking
for the C<$TODO> variable.  If you want to be sure, tell it explicitly
what $pack to use.
(TBT)

=cut

=item B<find_TODO>

    my $todo_reason = $Test->find_TODO();
    my $todo_reason = $Test->find_TODO($pack);

=begin original

Like C<todo()> but only returns the value of C<$TODO> ignoring
C<todo_start()>.

=end original

Like C<todo()> but only returns the value of C<$TODO> ignoring
C<todo_start()>.
(TBT)

=begin original

Can also be used to set C<$TODO> to a new value while returning the
old value:

=end original

Can also be used to set C<$TODO> to a new value while returning the
old value:
(TBT)

    my $old_reason = $Test->find_TODO($pack, 1, $new_reason);

=cut

=item B<in_todo>

    my $in_todo = $Test->in_todo;

=begin original

Returns true if the test is currently inside a TODO block.

=end original

Returns true if the test is currently inside a TODO block.
(TBT)

=cut

=item B<todo_start>

    $Test->todo_start();
    $Test->todo_start($message);

=begin original

This method allows you declare all subsequent tests as TODO tests, up until
the C<todo_end> method has been called.

=end original

This method allows you declare all subsequent tests as TODO tests, up until
the C<todo_end> method has been called.
(TBT)

=begin original

The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
whether or not we're in a TODO test.  However, often we find that this is not
possible to determine (such as when we want to use C<$TODO> but
the tests are being executed in other packages which can't be inferred
beforehand).

=end original

The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
whether or not we're in a TODO test.  However, often we find that this is not
possible to determine (such as when we want to use C<$TODO> but
the tests are being executed in other packages which can't be inferred
beforehand).
(TBT)

=begin original

Note that you can use this to nest "todo" tests

=end original

Note that you can use this to nest "todo" tests
(TBT)

 $Test->todo_start('working on this');
 # lots of code
 $Test->todo_start('working on that');
 # more code
 $Test->todo_end;
 $Test->todo_end;

=begin original

This is generally not recommended, but large testing systems often have weird
internal needs.

=end original

This is generally not recommended, but large testing systems often have weird
internal needs.
(TBT)

=begin original

We've tried to make this also work with the TODO: syntax, but it's not
guaranteed and its use is also discouraged:

=end original

We've tried to make this also work with the TODO: syntax, but it's not
guaranteed and its use is also discouraged:
(TBT)

 TODO: {
     local $TODO = 'We have work to do!';
     $Test->todo_start('working on this');
     # lots of code
     $Test->todo_start('working on that');
     # more code
     $Test->todo_end;
     $Test->todo_end;
 }

=begin original

Pick one style or another of "TODO" to be on the safe side.

=end original

Pick one style or another of "TODO" to be on the safe side.
(TBT)

=cut

=item C<todo_end>

 $Test->todo_end;

=begin original

Stops running tests as "TODO" tests.  This method is fatal if called without a
preceding C<todo_start> method call.

=end original

Stops running tests as "TODO" tests.  This method is fatal if called without a
preceding C<todo_start> method call.
(TBT)

=cut

=item B<caller>

    my $package = $Test->caller;
    my($pack, $file, $line) = $Test->caller;
    my($pack, $file, $line) = $Test->caller($height);

=begin original

Like the normal C<caller()>, except it reports according to your C<level()>.

=end original

Like the normal C<caller()>, except it reports according to your C<level()>.
(TBT)

=begin original

C<$height> will be added to the C<level()>.

=end original

C<$height> will be added to the C<level()>.
(TBT)

=begin original

If C<caller()> winds up off the top of the stack it report the highest context.

=end original

If C<caller()> winds up off the top of the stack it report the highest context.
(TBT)

=cut

=back

=cut

=begin _private

=over 4

=item B<_sanity_check>

  $self->_sanity_check();

Runs a bunch of end of test sanity checks to make sure reality came
through ok.  If anything is wrong it will die with a fairly friendly
error message.

=cut

=item B<_whoa>

  $self->_whoa($check, $description);

A sanity check, similar to C<assert()>.  If the C<$check> is true, something
has gone horribly wrong.  It will die with the given C<$description> and
a note to contact the author.

=cut

=item B<_my_exit>

  _my_exit($exit_num);

Perl seems to have some trouble with exiting inside an C<END> block.
5.6.1 does some odd things.  Instead, this function edits C<$?>
directly.  It should B<only> be called from inside an C<END> block.
It doesn't actually exit, that's your job.

=cut

=back

=end _private

=cut

=head1 EXIT CODES

(終了コード)

=begin original

If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.

=end original

If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.
(TBT)

=begin original

So the exit codes are...

=end original

So the exit codes are...
(TBT)

    0                   all tests successful
    255                 test died or all passed but wrong # of tests run
    any other number    how many failed (including missing or extras)

=begin original

If you fail more than 254 tests, it will be reported as 254.

=end original

If you fail more than 254 tests, it will be reported as 254.
(TBT)

=head1 THREADS

(スレッド)

=begin original

In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
number is shared amongst all threads.  This means if one thread sets
the test number using C<current_test()> they will all be effected.

=end original

In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
number is shared amongst all threads.  This means if one thread sets
the test number using C<current_test()> they will all be effected.
(TBT)

=begin original

While versions earlier than 5.8.1 had threads they contain too many
bugs to support.

=end original

While versions earlier than 5.8.1 had threads they contain too many
bugs to support.
(TBT)

=begin original

Test::Builder is only thread-aware if threads.pm is loaded I<before>
Test::Builder.

=end original

Test::Builder is only thread-aware if threads.pm is loaded I<before>
Test::Builder.
(TBT)

=head1 MEMORY

(メモリ)

=begin original

An informative hash, accessible via C<<details()>>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.

=end original

An informative hash, accessible via C<<details()>>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.
(TBT)

=begin original

In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing "normal" (code) compares and
triggering fail() should anything go unexpected.

=end original

In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing "normal" (code) compares and
triggering fail() should anything go unexpected.
(TBT)

=begin original

Future versions of Test::Builder will have a way to turn history off.

=end original

Future versions of Test::Builder will have a way to turn history off.
(TBT)

=head1 EXAMPLES

=begin original

CPAN can provide the best examples.  Test::Simple, Test::More,
Test::Exception and Test::Differences all use Test::Builder.

=end original

CPAN は最良の例を提供します。
Test::Simple, Test::More, Test::Exception, Test::Differences は全て
Test::Builder を使っています。

=head1 SEE ALSO

Test::Simple, Test::More, Test::Harness

=head1 AUTHORS

=begin original

Original code by chromatic, maintained by Michael G Schwern
E<lt>schwern@pobox.comE<gt>

=end original

Original code by chromatic, maintained by Michael G Schwern
E<lt>schwern@pobox.comE<gt>
(TBT)

=head1 COPYRIGHT

Copyright 2002-2008 by chromatic E<lt>chromatic@wgz.orgE<gt> and
                       Michael G Schwern E<lt>schwern@pobox.comE<gt>.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=begin original

See F<http://www.perl.com/perl/misc/Artistic.html>

=end original

F<http://www.perl.com/perl/misc/Artistic.html> を参照してください。

=cut


