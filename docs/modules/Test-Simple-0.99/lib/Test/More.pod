=encoding utf8

=head1 NAME

=begin original

Test::More - yet another framework for writing test scripts

=end original

Test::More - テストを書くためのもう一つのフレームワーク

=head1 SYNOPSIS

  use Test::More tests => 23;
  # or
  use Test::More skip_all => $reason;
  # or
  use Test::More;   # see done_testing()

  require_ok( 'Some::Module' );

=begin original

 # Various ways to say "ok"
 ok($got eq $expected, $test_name);

=end original

  # 「ok」と示すためのさまざまな方法
  ok($got eq $expected, $test_name);

  is  ($got, $expected, $test_name);
  isnt($got, $expected, $test_name);

=begin original

  # Rather than print STDERR "# here's what went wrong\n"
  diag("here's what went wrong");

=end original

  # print STDERR "# here's what went wrong\n" とするよりも
  diag("here's what went wrong");

  like  ($got, qr/expected/, $test_name);
  unlike($got, qr/expected/, $test_name);

  cmp_ok($got, '==', $expected, $test_name);

  is_deeply($got_complex_structure, $expected_complex_structure, $test_name);

  SKIP: {
      skip $why, $how_many unless $have_some_feature;

      ok( foo(),       $test_name );
      is( foo(42), 23, $test_name );
  };

  TODO: {
      local $TODO = $why;

      ok( foo(),       $test_name );
      is( foo(42), 23, $test_name );
  };

  can_ok($module, @methods);
  isa_ok($object, $class);

  pass($test_name);
  fail($test_name);

  BAIL_OUT($why);

  # UNIMPLEMENTED!!!

  my @status = Test::More::status;

=head1 DESCRIPTION

=begin original

B<STOP!> If you're just getting started writing tests, have a look at
L<Test::Simple> first.  This is a drop in replacement for Test::Simple
which you can switch to once you get the hang of basic testing.

=end original

B<待った!>
もし、今初めて、テストを書こうとしているのなら、L<Test::Simple>をまず
見てください。
Test::Moreは、基本的なテストのコツを得て、置き換え可能な Test::Simple の差込式の
置換です。

=begin original

The purpose of this module is to provide a wide range of testing
utilities.  Various ways to say "ok" with better diagnostics,
facilities to skip tests, test future features and compare complicated
data structures.  While you can do almost anything with a simple
C<ok()> function, it doesn't provide good diagnostic output.

=end original

このモジュールの目的は、大幅なテストユーティリティを提供することです。
よりよい診断で「ok」と示す方法を用意したり、テストを簡単にスキップしたり、
将来的な実装をテストしたり、複雑なデータ構造を比較したりする様々な機能が
あります。
単純な C<ok()> 関数でほとんど全てのことが出来ますが、C<ok()> 関数は、良い
診断出力を提供しません。

=head2 I love it when a plan comes together

(計画が一緒に来るなら、それを大事にする)

=begin original

Before anything else, you need a testing plan.  This basically declares
how many tests your script is going to run to protect against premature
failure.

=end original

他の何より前に、テストの計画が必要です。 
スクリプトが行おうとしているテストがいくつであるかというこの基本的な宣言は、
原始的な失敗に対する保護になります。

=begin original

The preferred way to do this is to declare a plan when you C<use Test::More>.

=end original

この保護を行う好ましい方法は、C<use Test::More> を書く時に、計画を
宣言することです。

  use Test::More tests => 23;

=begin original

There are cases when you will not know beforehand how many tests your
script is going to run.  In this case, you can declare your tests at
the end.

=end original

スクリプトが行おうとしているテストがいくつあるかを事前に知らないような、まれな
ケースがあります。
こういうケースでは、最後にテストを宣言することができます。


  use Test::More;
  
  ... run your tests ...
  
  done_testing( $number_of_tests_run );

=begin original

Sometimes you really don't know how many tests were run, or it's too
difficult to calculate.  In which case you can leave off
$number_of_tests_run.

=end original

いくつのテストが実行されるか本当に分からない時や、計算するのが大変な時に
使えます。
そのようなケースでは、$number_of_tests_run を省くこともできます。

=begin original

In some cases, you'll want to completely skip an entire testing script.

=end original

いくつかのケースでは、あるテストスクリプト全てを完全にスキップしたいでしょう。

  use Test::More skip_all => $skip_reason;

=begin original

Your script will declare a skip with the reason why you skipped and
exit immediately with a zero (success).  See L<Test::Harness> for
details.

=end original

スクリプトが、なぜスキップするのかの理由を宣言すると、即座に0(成功)で終了します。
詳細については L<Test::Harness> をみてください。

=begin original

If you want to control what functions Test::More will export, you
have to use the 'import' option.  For example, to import everything
but 'fail', you'd do:

=end original

Test::More がエクスポートする関数をコントロールしたければ、
'import' オプションを使う必要があります。
たとえば、'fail' を除いて、全てをインポートしたいなら、次のようにします：

  use Test::More tests => 23, import => ['!fail'];

=begin original

Alternatively, you can use the plan() function.  Useful for when you
have to calculate the number of tests.

=end original

代わりに、plan() 関数を使うことが出来ます。
テストの数を計算しなければならないなら、有益です。

  use Test::More;
  plan tests => keys %Stuff * 3;

=begin original

or for deciding between running the tests at all:

=end original

または、テストを走らせている間に決めるためには：

  use Test::More;
  if( $^O eq 'MacOS' ) {
      plan skip_all => 'Test irrelevant on MacOS';
  }
  else {
      plan tests => 42;
  }

=cut

=over 4

=item B<done_testing>

    done_testing();
    done_testing($number_of_tests);

=begin original

If you don't know how many tests you're going to run, you can issue
the plan when you're done running tests.

=end original

実行しようとしているテストがいくつかわからない場合、テストの実行を終えたときに
計画を発表することができます。

=begin original

$number_of_tests is the same as plan(), it's the number of tests you
expected to run.  You can omit this, in which case the number of tests
you ran doesn't matter, just the fact that your tests ran to
conclusion.

=end original

$number_of_tests は、plan() と同じです。実行しようとしているテストの数です。
これを省略することもできます。その場合、テストの数は問題にしません。
最後までテストが実行されたかを問題にします。

=begin original

This is safer than and replaces the "no_plan" plan.

=end original

"no_plan" な計画より安全で、"no_plan" を置き換えるものです。

=back


=cut

=head2 Test names

(テストの名前)

=begin original

By convention, each test is assigned a number in order.  This is
largely done automatically for you.  However, it's often very useful to
assign a name to each test.  Which would you rather see:

=end original

便宜のために、それぞれのテストは、順番に番号が割り振られています。
これは、主に自動的に行われます。
ですが、テストに名前を割り当てると、とても有益なことがよくあります。
どちらがよいでしょうか:

  ok 4
  not ok 5
  ok 6

=begin original

or

=end original

というのと、

  ok 4 - basic multi-variable
  not ok 5 - simple exponential
  ok 6 - force == mass * acceleration

=begin original

The later gives you some idea of what failed.  It also makes it easier
to find the test in your script, simply search for "simple
exponential".

=end original

後者は、何が失敗したかの手がかりを与えてくれます。
また、スクリプト中のテストを見つけやすくなり、「簡単な指数関数」を楽に探せます。

=begin original

All test functions take a name argument.  It's optional, but highly
suggested that you use it.

=end original

全てのテストの関数は、名前を引数にとります。
名前の引数は、オプションではありますが、使うことが強く推奨されています。

=head2 I'm ok, you're not ok.

(わたしは、OK 、あなたは、だめ)

=begin original

The basic purpose of this module is to print out either "ok #" or "not
ok #" depending on if a given test succeeded or failed.  Everything
else is just gravy.

=end original

このモジュールの基本的な目的は、与えたテストが、失敗したか、成功したかで、
「ok 番号」か、「not ok 番号」のどちらかを出力することです。
他の全ては、ただのおまけです。

=begin original

All of the following print "ok" or "not ok" depending on if the test
succeeded or failed.  They all also return true or false,
respectively.

=end original

この下に書いているものは全て、テストが成功したか失敗したかどうかによって、
「ok」か「not ok」を表示します。
それらは、全て、それぞれ真か偽を返します。

=over 4

=item B<ok>

  ok($got eq $expected, $test_name);

=begin original

This simply evaluates any expression (C<$got eq $expected> is just a
simple example) and uses that to determine if the test succeeded or
failed.  A true expression passes, a false one fails.  Very simple.

=end original

これは単純に、どんな式も評価します(C<$got eq $expected>はただの簡単な例です)。
そして、テストが成功したかどうかを決めるのに使います。
真の式は合格し、偽の式は失敗です。とても簡単です。

=begin original

For example:

=end original

たとえば:

    ok( $exp{9} == 81,                   'simple exponential' );
    ok( Film->can('db_Main'),            'set_db()' );
    ok( $p->tests == 4,                  'saw tests' );
    ok( !grep(!defined $_, @items),      'all items defined' );


=begin original

(Mnemonic:  "This is ok.")

=end original

(覚えかた:  "This is ok.")

=begin original

$test_name is a very short description of the test that will be printed
out.  It makes it very easy to find a test in your script when it fails
and gives others an idea of your intentions.  $test_name is optional,
but we B<very> strongly encourage its use.

=end original

$test_name は、とても短いテストの説明で、実行時に出力されます。
$test_name は、テストが失敗した場合に、スクリプト中のテストをとても
見つけやすくします。
それに、他の人に、あなたの意図する考えを伝えます。$test_name は、
オプションですが、使うことが強く勧められています。

=begin original

Should an ok() fail, it will produce some diagnostics:

=end original

万一、ok() が失敗した場合、ちょっとした診断を提供します:

    not ok 18 - sufficient mucus
    #   Failed test 'sufficient mucus'
    #   in foo.t at line 42.

=begin original

This is the same as Test::Simple's ok() routine.

=end original

これは、Test::Simple の C<ok()> ルーチンと同じです。

=item B<is>

=item B<isnt>

  is  ( $got, $expected, $test_name );
  isnt( $got, $expected, $test_name );

=begin original

Similar to ok(), is() and isnt() compare their two arguments
with C<eq> and C<ne> respectively and use the result of that to
determine if the test succeeded or failed.  So these:

=end original

ok() と is() と isnt() の類似点は、二つの引数をそれぞれC<eq> と C<ne> で
比較し、その結果を使って、テストが成功したか、失敗したかを決めることです。
それで、これらは：

    # Is the ultimate answer 42?
    is( ultimate_answer(), 42,          "Meaning of Life" );

    # $foo isn't empty
    isnt( $foo, '',     "Got some foo" );

=begin original

are similar to these:

=end original

次と似ています:

    ok( ultimate_answer() eq 42,        "Meaning of Life" );
    ok( $foo ne '',     "Got some foo" );

(覚えかた:  "This is that."  "This isn't that.")

=begin original

C<undef> will only ever match C<undef>.  So you can test a value
against C<undef> like this:

=end original

C<undef>は C<undef>にのみマッチします。C<undef>にたいして値をテストしたければ、
次のようにします:

    is($not_defined, undef, "undefined as expected");

=begin original

(Mnemonic:  "This is that."  "This isn't that.")

=end original

(覚えかた:  "This is that."  "This isn't that.")

=begin original

So why use these?  They produce better diagnostics on failure.  ok()
cannot know what you are testing for (beyond the name), but is() and
isnt() know what the test was and why it failed.  For example this
test:

=end original

どうしてこれらを使うのでしょう？
is() と isnt() は、失敗に関して、よりよい診断をだします。
ok() は、(名前以上には)何のためにテストをしているのか知ることが出来ませんが、
is() と isnt() は、テストが何で、テストがなぜ失敗したかを知っています。
たとえばこのテスト：

    my $foo = 'waffle';  my $bar = 'yarblokos';
    is( $foo, $bar,   'Is foo the same as bar?' );

=begin original

Will produce something like this:

=end original

このようなものを出力します:

    not ok 17 - Is foo the same as bar?
    #   Failed test 'Is foo the same as bar?'
    #   in foo.t at line 139.
    #          got: 'waffle'
    #     expected: 'yarblokos'

=begin original

So you can figure out what went wrong without rerunning the test.

=end original

これで、テストを再度走らせずに何が間違ったのか、判断できます。

=begin original

You are encouraged to use is() and isnt() over ok() where possible,
however do not be tempted to use them to find out if something is
true or false!

=end original

可能なら、is() と isnt()をok()の代わりに使うことを勧めます。
ですが、何かが、真であるか偽であるかを見つけ出すために、
is() と isnt() を使おうとしてはいけません!

  # XXX BAD!
  is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );

=begin original

This does not check if C<exists $brooklyn{tree}> is true, it checks if
it returns 1.  Very different.  Similar caveats exist for false and 0.
In these cases, use ok().

=end original

このコードは、C<exsits $brooklyn{tree}> が真であるかどうかをチェックしません。
このコードは、1 を返すかどうかをチェックします。これらはまったく違います。
似たような警告は、偽 と 0 にも在ります。こういうケースでは、ok() を使います。

  ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );

=begin original

A simple call to isnt() usually does not provide a strong test but there
are cases when you cannot say much more about a value than that it is
different from some other value:

=end original

単純に isnt() を呼び出すのは、普通、強いテストを提供しません。
値について他の値から違っていることより値について言えないような時に、
適しています。


  new_ok $obj, "Foo";

  my $clone = $obj->clone;
  isa_ok $obj, "Foo", "Foo->clone";

  isnt $obj, $clone, "clone() produces a different object";

=begin original

For those grammatical pedants out there, there's an C<isn't()>
function which is an alias of isnt().

=end original

文法学者ぶる人のために、書いておくと、C<isn't()> 関数は isnt() 関数の
エイリアスとして存在してます。

=item B<like>

  like( $got, qr/expected/, $test_name );

=begin original

Similar to ok(), like() matches $got against the regex C<qr/expected/>.

=end original

ok() と似ていますが、like() は、 引数の$gotを正規表現の C<qr/expected/> に
マッチさせます。

=begin original

So this:

=end original

このように:

    like($got, qr/expected/, 'this is like that');

=begin original

is similar to:

=end original

これは、次と似ています:

    ok( $got =~ m/expected/, 'this is like that');

=begin original

(Mnemonic "This is like that".)

=end original

(覚えかた  "This is like that".)

=begin original

The second argument is a regular expression.  It may be given as a
regex reference (i.e. C<qr//>) or (for better compatibility with older
perls) as a string that looks like a regex (alternative delimiters are
currently not supported):

=end original

二番目の引数は正規表現です。正規表現のリファレンス
(たとえば、C<qr//>)や、(古いPerlと、より互換性を持たせるなら)
正規表現に見える文字列(代替の区切りは、現在サポートされていません)として
与えられます。

    like( $got, '/expected/', 'this is like that' );

=begin original

Regex options may be placed on the end (C<'/expected/i'>).

=end original

正規表現のオプションは終わりに置かれます (C<'/expected/i'>)。

=begin original

Its advantages over ok() are similar to that of is() and isnt().  Better
diagnostics on failure.

=end original

ok() と比べたときの利点は、is() と isnt() の利点に似ています。
失敗に関して、よく診断します。

=item B<unlike>

  unlike( $got, qr/expected/, $test_name );

=begin original

Works exactly as like(), only it checks if $got B<does not> match the
given pattern.

=end original

like()のように働きますが、 $got が与えたパターンにマッチB<しない>ことだけを
チェックします。

=item B<cmp_ok>

  cmp_ok( $got, $op, $expected, $test_name );

=begin original

Halfway between C<ok()> and C<is()> lies C<cmp_ok()>.  This allows you
to compare two arguments using any binary perl operator.  The test
passes if the comparison is true and fails otherwise.

=end original

C<ok()> と C<is()> の中間に C<cmp_ok()> があります。 
これは、すべてのバイナリのPerlの演算子を使って、2つの引数を比較することが
できます。
比較が真であれば、テストはパスし、そうなければ、失敗します。

    # ok( $got eq $expected );
    cmp_ok( $got, 'eq', $expected, 'this eq that' );

    # ok( $got == $expected );
    cmp_ok( $got, '==', $expected, 'this == that' );

    # ok( $got && $expected );
    cmp_ok( $got, '&&', $expected, 'this && that' );
    ...etc...

=begin original

Its advantage over ok() is when the test fails you'll know what $got
and $expected were:

=end original

ok() と比べたときの cmp_ok の 利点は、テストが失敗したときに、
$got と $expected が何かがわかることです。

    not ok 1
    #   Failed test in foo.t at line 12.
    #     '23'
    #         &&
    #     undef

=begin original

It's also useful in those cases where you are comparing numbers and
is()'s use of C<eq> will interfere:

=end original

cmp_ok は、数を比較する際や、is() を C<eq> として使うことが、干渉する際に、
有益でしょう:

    cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );

=begin original

It's especially useful when comparing greater-than or smaller-than 
relation between values:

=end original

2つの値の大小の比較に使うと、非常に便利です。

    cmp_ok( $some_value, '<=', $upper_limit );

=cut

=item B<can_ok>

  can_ok($module, @methods);
  can_ok($object, @methods);

=begin original

Checks to make sure the $module or $object can do these @methods
(works with functions, too).

=end original

$module か $object が 複数のメソッド(または、関数)@methodsを実行できるかを
チェックします。

    can_ok('Foo', qw(this that whatever));

=begin original

is almost exactly like saying:

=end original

上の表現は、実際は、以下のような意味です:

    ok( Foo->can('this') && 
        Foo->can('that') && 
        Foo->can('whatever') 
      );

=begin original

only without all the typing and with a better interface.  Handy for
quickly testing an interface.

=end original

すべてをタイプしなくていい、よりよいインターフェースです。
素早いテストのための、手ごろなインターフェースです。

=begin original

No matter how many @methods you check, a single can_ok() call counts
as one test.  If you desire otherwise, use:

=end original

いくつの @methods があるか、チェックすることは、大したことではありません。
一つの can_ok() は一つのテストとして、カウントされます。
別の方法で、やりたいなら、次のように使います:


    foreach my $meth (@methods) {
        can_ok('Foo', $meth);
    }

=item B<isa_ok>

  isa_ok($object,   $class, $object_name);
  isa_ok($subclass, $class, $object_name);
  isa_ok($ref,      $type,  $ref_name);

=begin original

Checks to see if the given C<< $object->isa($class) >>.  Also checks to make
sure the object was defined in the first place.  Handy for this sort
of thing:

=end original

C<< $object->isa($class) >> が与えられているかどうかを見るためのチェック。
オブジェクトが最初の場所で定義されているか確かめるためのチェックでもあります。

    my $obj = Some::Module->new;
    isa_ok( $obj, 'Some::Module' );

=begin original

where you'd otherwise have to write

=end original

代わりに次のように書けます：

    my $obj = Some::Module->new;
    ok( defined $obj && $obj->isa('Some::Module') );

=begin original

to safeguard against your test script blowing up.

=end original

テストスクリプトが、吹っ飛ぶのを防ぐためのセーフガードです。

=begin original

You can also test a class, to make sure that it has the right ancestor:

=end original

クラスもテストできます。
正しい先祖か確かめます。

    isa_ok( 'Vole', 'Rodent' );

=begin original

It works on references, too:

=end original

リファレンスでも動きます：

    isa_ok( $array_ref, 'ARRAY' );

=begin original

The diagnostics of this test normally just refer to 'the object'.  If
you'd like them to be more specific, you can supply an $object_name
(for example 'Test customer').

=end original

このテストの診断は、通常、ただ、'そのオブジェクト'のリファレンスです。
それらをもっと特定したいなら、$object_name
(たとえば、'Test customer')を供給できます。

=item B<new_ok>

  my $obj = new_ok( $class );
  my $obj = new_ok( $class => \@args );
  my $obj = new_ok( $class => \@args, $object_name );

=begin original

A convenience function which combines creating an object and calling
isa_ok() on that object.

=end original

オブジェクトを作り、そのオブジェクトで、isa_ok() の呼び出しをくっつけた
便利な関数です。

=begin original

It is basically equivalent to:

=end original

これは、次のものと基本的に同じです:

    my $obj = $class->new(@args);
    isa_ok $obj, $class, $object_name;

=begin original

If @args is not given, an empty list will be used.

=end original

@args が与えられなければ、空のリストが使われます。

=begin original

This function only works on new() and it assumes new() will return
just a single object which isa C<$class>.

=end original

この関数は、 new() でのみ動き、new() が　C<$class> と isa である
一つのオブジェクトを返すことを想定しています。


=cut

=item B<subtest>

    subtest $name => \&code;

=begin original

subtest() runs the &code as its own little test with its own plan and
its own result.  The main test counts this as a single test using the
result of the whole subtest to determine if its ok or not ok.

=end original

subtest() は &code をそれ自身の計画と結果をもつそれ自身小さなテストとして、
実行します。
メインのテストは一つのテストとしてカウントします。
サブテスト全体の結果を使って、ok か not ok か決定します。

=begin original

For example...

=end original

例えば...

  use Test::More tests => 3;
 
  pass("First test");

  subtest 'An example subtest' => sub {
      plan tests => 2;

      pass("This is a subtest");
      pass("So is this");
  };

  pass("Third test");

=begin original

This would produce.

=end original

以下のように出力されます。

  1..3
  ok 1 - First test
      # Subtest: An example subtest
      1..2
      ok 1 - This is a subtest
      ok 2 - So is this
  ok 2 - An example subtest
  ok 3 - Third test

=begin original

A subtest may call "skip_all".  No tests will be run, but the subtest is
considered a skip.

=end original

subtest は、"skip_all" を呼んでもかまいません。
テストは実行されませんが、subtest は skip されたと考えられます。

  subtest 'skippy' => sub {
      plan skip_all => 'cuz I said so';
      pass('this test will never be run');
  };

=begin original

Returns true if the subtest passed, false otherwise.

=end original

subtestが通れば、真を返し、他は偽を返します。

=begin original

Due to how subtests work, you may omit a plan if you desire.  This adds an
implicit C<done_testing()> to the end of your subtest.  The following two
subtests are equivalent:

=end original

サブテストがどのように動かすかによって、望むなら計画を省くことができます。
C<done_testing()> を暗に行い、サブテストを終わらせます。以下の2つの
サブテストは同じです:

  subtest 'subtest with implicit done_testing()', sub {
      ok 1, 'subtests with an implicit done testing should work';
      ok 1, '... and support more than one test';
      ok 1, '... no matter how many tests are run';
  };

  subtest 'subtest with explicit done_testing()', sub {
      ok 1, 'subtests with an explicit done testing should work';
      ok 1, '... and support more than one test';
      ok 1, '... no matter how many tests are run';
      done_testing();
  };


=cut

=item B<pass>

=item B<fail>

  pass($test_name);
  fail($test_name);

=begin original

Sometimes you just want to say that the tests have passed.  Usually
the case is you've got some complicated condition that is difficult to
wedge into an ok().  In this case, you can simply use pass() (to
declare the test ok) or fail (for not ok).  They are synonyms for
ok(1) and ok(0).

=end original

時には、ただ、テストがパスしたと示したいでしょう。
普通、このケースは、ok() に、押し込むことが難しい複雑な条件になっています。
こういう場合、単純に pass() (テストが ok であると宣言するために)か、
fail (not ok のために)かを使えます。
これらは、ok(1) と、ok(0) の同意語です。

=begin original

Use these very, very, very sparingly.

=end original

pass() と fail() を使うことはひじょーに慎重に判断してください。

=cut

=back

=head2 Module tests

(モジュールのテスト)

=begin original

Sometimes you want to test if a module, or a list of modules, can
successfully load.  For example, you'll often want a first test which
simply loads all the modules in the distribution to make sure they
work before going on to do more complicated testing.

=end original

モジュール、またはモジュールのリストが正しくロードされるかをテストをしたい場合、
例えば、より複雑なテストを行う前に、ディストリビューションの全てのモジュールが
動くことを確かめるために、単純にロードする、最初のテストが欲しい場合がよくあるでしょう。

=begin original

For such purposes we have C<use_ok> and C<require_ok>.

=end original

そのような目的のために、C<use_ok> と、C<require_ok> があります。

=over 4

=item B<require_ok>

   require_ok($module);
   require_ok($file);

=begin original

Tries to C<require> the given $module or $file.  If it loads
successfully, the test will pass.  Otherwise it fails and displays the
load error.

=end original

与えられた $module か $file を C<require> を試して、成功すれば、
テストはパスします。そうでなければ、失敗し、ロードエラーを表示します。

=begin original

C<require_ok> will guess whether the input is a module name or a
filename.

=end original

C<require_ok> は、入力がモジュール名かファイル名かのどちらかをル推測します。

=begin original

No exception will be thrown if the load fails.

=end original

ロードが失敗しても、例外を出しません。

    # require Some::Module
    require_ok "Some::Module";

    # require "Some/File.pl";
    require_ok "Some/File.pl";

    # stop testing if any of your modules will not load
    for my $module (@module) {
        require_ok $module or BAIL_OUT "Can't load $module";
    }


=cut

=item B<use_ok>

   BEGIN { use_ok($module); }
   BEGIN { use_ok($module, @imports); }

=begin original

Like C<require_ok>, but it will C<use> the $module in question and
only loads modules, not files.

=end original

C<require_ok> と似ていますが、$module を C<use> します。
モジュールのみをロードし、ファイルは行いません。

=begin original

If you just want to test a module can be loaded, use C<require_ok>.

=end original

モジュールがロードされるかをテストしたいだけなら、C<require_ok>を使ってください。

=begin original

If you just want to load a module in a test, we recommend simply using
C<use> directly.  It will cause the test to stop.

=end original

テストでモジュールをロードしたければ、単純に C<use>を直接に使うことを
推奨します。テストを停止する原因になります。

=begin original

It's recommended that you run use_ok() inside a BEGIN block so its
functions are exported at compile-time and prototypes are properly
honored.

=end original

BEGIN ブロック内で、use_ok() を走らせることを推奨します。
これにより、この関数は、コンパイル時に export され、プロトタイプを適切に
受け取ります。

=begin original

If @imports are given, they are passed through to the use.  So this:

=end original

@import が与えれた場合、use の際に渡されます。次のように :

   BEGIN { use_ok('Some::Module', qw(foo bar)) }

=begin original

is like doing this:

=end original

次のようにするのと同じです：

   use Some::Module qw(foo bar);

=begin original

Version numbers can be checked like so:

=end original

バージョンは次のようにチェックできます:

   # Just like "use Some::Module 1.02"
   BEGIN { use_ok('Some::Module', 1.02) }

=begin original

Don't try to do this:

=end original

次のようにしようとしてはいけません：

   BEGIN {
       use_ok('Some::Module');

       ...some code that depends on the use...
       ...happening at compile time...
   }

=begin original

because the notion of "compile-time" is relative.  Instead, you want:

=end original

"compile-time"の記述が関係するからです。代わりに、次のようにしましょう。

  BEGIN { use_ok('Some::Module') }
  BEGIN { ...some code that depends on the use... }

=begin original

If you want the equivalent of C<use Foo ()>, use a module but not
import anything, use C<require_ok>.

=end original

C<use Foo ()> と同等のものがほしければ、モジュールを使うけれど、
何もインポートしない、C<require_ok> を使ってください。

  BEGIN { require_ok "Foo" }

=cut

=back


=head2 Complex data structures

(複雑なデータ構造)

=begin original

Not everything is a simple eq check or regex.  There are times you
need to see if two data structures are equivalent.  For these
instances Test::More provides a handful of useful functions.

=end original

全てが、単純な eq チェックや、正規表現ではありません。
たとえば、二つの配列がイコールであるかどうかを見る必要があるときもあります。
こういった例のために、Test::More は、ちょっとした有益な関数を提供しています。

=begin original

B<NOTE> I'm not quite sure what will happen with filehandles.

=end original

B<注意> ファイルハンドルについて起きることについて、あまり確信がありません。

=over 4

=item B<is_deeply>

  is_deeply( $got, $expected, $test_name );

=begin original

Similar to is(), except that if $got and $expected are references, it
does a deep comparison walking each data structure to see if they are
equivalent.  If the two structures are different, it will display the
place where they start differing.

=end original

is() と似ていますが、$got と $expected が、リファレンスです。
それぞれのデータの構造を見てまわり、それぞれが、イコールかどうか、深い比較を
します。
2つの構造が違っていれば、2つが違い始めた場所を示します。

=begin original

is_deeply() compares the dereferenced values of references, the
references themselves (except for their type) are ignored.  This means
aspects such as blessing and ties are not considered "different".

=end original

is_deeply() は、リファレンスの値の違いを比較します、
リファレンスそれ自身(その型をのぞき)は無視されます。
つまり、bless や tie のような側面は、"違う"と考えられません。

=begin original

is_deeply() currently has very limited handling of function reference
and globs.  It merely checks if they have the same referent.  This may
improve in the future.

=end original

is_deeply() は、今のところ、関数リファレンスと glob のハンドリングは
非常に限定的です。
単純に、同じ referent を持っているかをチェックします。
将来改善されるかもしれません。

=begin original

L<Test::Differences> and L<Test::Deep> provide more in-depth functionality
along these lines.

=end original

L<Test::Differences> と L<Test::Deep> は、より、徹底的な機能性を
提供しています。

=cut

=back


=head2 Diagnostics

(複数の診断)

=begin original

If you pick the right test function, you'll usually get a good idea of
what went wrong when it failed.  But sometimes it doesn't work out
that way.  So here we have ways for you to write your own diagnostic
messages which are safer than just C<print STDERR>.

=end original

正しいテスト関数を選んだなら、ふつう、そのテスト関数が失敗した場合に、
何が間違っているかについてよい情報を得ることができるでしょう。
ですが、時に、そういう風には、うまく働かないこともあります。
そのために、自分で自分自身の診断メッセージを書く方法があります。
C<print STDERR> よりも、安全です。

=over 4

=item B<diag>

  diag(@diagnostic_message);

=begin original

Prints a diagnostic message which is guaranteed not to interfere with
test output.  Like C<print> @diagnostic_message is simply concatenated
together.

=end original

テストの出力に干渉しないと保証されている診断メッセージを出力します。
C<print> のように、@diagnostic_message を単純に一緒につなぎます。

=begin original

Returns false, so as to preserve failure.

=end original

失敗のままにするために、偽を返します。

=begin original

Handy for this sort of thing:

=end original

次のような場合に、手ごろです：

    ok( grep(/foo/, @users), "There's a foo user" ) or
        diag("Since there's no foo, check that /etc/bar is set up right");

=begin original

which would produce:

=end original

次のようになります：

    not ok 42 - There's a foo user
    #   Failed test 'There's a foo user'
    #   in foo.t at line 52.
    # Since there's no foo, check that /etc/bar is set up right.

=begin original

You might remember C<ok() or diag()> with the mnemonic C<open() or
die()>.

=end original

C<ok() or diag()>を、C<open() or die()> のように覚えると覚えやすいでしょう。

=begin original

B<NOTE> The exact formatting of the diagnostic output is still
changing, but it is guaranteed that whatever you throw at it won't
interfere with the test.

=end original

B<注意> 診断の出力のためのフォーマットは、まだまだ流動的です。
しかし、それに何を渡してもテストに干渉しないことは保証されています。

=item B<note>

  note(@diagnostic_message);

=begin original

Like diag(), except the message will not be seen when the test is run
in a harness.  It will only be visible in the verbose TAP stream.

=end original

diag()と似ていますが，harnessでテストが動いている場合には、表示されません。
冗長なTAPストリームでのみ、見られます。


=begin original

Handy for putting in notes which might be useful for debugging, but
don't indicate a problem.

=end original

デバッグに有用なメモをおくのに手ごろですが，問題を指摘するのに
使ってはいけません。

    note("Tempfile is $tempfile");

=cut

=item B<explain>

  my @dump = explain @diagnostic_message;


=begin original

Will dump the contents of any references in a human readable format.
Usually you want to pass this into C<note> or C<diag>.

=end original

人が読みやすいフォーマットで、リファレンスの内容をダンプします。
C<note> や C<diag>に与えたいと思うでしょう。

=begin original

Handy for things like...

=end original

次のような場合に、手ごろです：

    is_deeply($have, $want) || diag explain $have;


=begin original

or

=end original

または、

    note explain \%args;
    Some::Class->method(%args);


=cut

=back


=head2 Conditional tests

(条件テスト)

=begin original

Sometimes running a test under certain conditions will cause the
test script to die.  A certain function or method isn't implemented
(such as fork() on MacOS), some resource isn't available (like a 
net connection) or a module isn't available.  In these cases it's
necessary to skip tests, or declare that they are supposed to fail
but will work in the future (a todo test).

=end original

ある条件下でテストを動かすことによって、テストスクリプトが死ぬ時があります。
(MacOSでのfork()のような)特定の関数やメソッドは実装されていなかったり、
(ネット接続のような)いくつかのリソースが利用できなかったり、
モジュールが利用できなかったりとか。
こういったケースでは、テストをスキップしなければならないか、
そうでなければ、失敗することが予想されるけれど、
将来的に動く(a todo test)であろうということを宣言しなければなりません。

=begin original

For more details on the mechanics of skip and todo tests see
L<Test::Harness>.

=end original

skip と todo テストの機構の詳細は、C<Test::Harness> を見て下さい。

=begin original

The way Test::More handles this is with a named block.  Basically, a
block of tests which can be skipped over or made todo.  It's best if I
just show you...

=end original

名前のついたブロックと一緒にある Test::More ハンドルの使い方。
基本的にテストのブロックは、スキップさせるか、todo にするかです。
ただコードを見せるのが最善でしょう…

=over 4

=item B<SKIP: BLOCK>

  SKIP: {
      skip $why, $how_many if $condition;

      ...normal testing code goes here...
  }

=begin original

This declares a block of tests that might be skipped, $how_many tests
there are, $why and under what $condition to skip them.  An example is
the easiest way to illustrate:

=end original

これは、スキップするテストのブロックを宣言します。
$how_many はテストの数、 $why は理由、$condition は、
どういう条件で、これらのテストをスキップするのかを意味します。
最も簡単な例を見せます：


    SKIP: {
        eval { require HTML::Lint };

        skip "HTML::Lint not installed", 2 if $@;

        my $lint = new HTML::Lint;
        isa_ok( $lint, "HTML::Lint" );

        $lint->parse( $html );
        is( $lint->errors, 0, "No errors found in HTML" );
    }

=begin original

If the user does not have HTML::Lint installed, the whole block of
code I<won't be run at all>.  Test::More will output special ok's
which Test::Harness interprets as skipped, but passing, tests.

=end original

ユーザが、HTML::Lint をインストールしていなければ、全てのブロックコードは、
I<まったく実行されないでしょう>。 Test::Moreは、特別な ok() を出力し、
Test::Harnes は、テストをスキップしたが、合格したと解釈します。

=begin original

It's important that $how_many accurately reflects the number of tests
in the SKIP block so the # of tests run will match up with your plan.
If your plan is C<no_plan> $how_many is optional and will default to 1.

=end original

テストの数が、計画にマッチするために、
$how_many が正しく SKIP ブロックの中のテストの数を反映することは重要です。
もし、計画が C<no_plan> であれば、$how_many はオプションで、デフォルトは
1 になります。

=begin original

It's perfectly safe to nest SKIP blocks.  Each SKIP block must have
the label C<SKIP>, or Test::More can't work its magic.

=end original

ネストする SKIP ブロックは完全に安全です。それぞれの SKIP ブロックには、
C<SKIP> ラベルがなければなりません、そうしないと、Test::More は、その魔法を
うまく使えません。

=begin original

You don't skip tests which are failing because there's a bug in your
program, or for which you don't yet have code written.  For that you
use TODO.  Read on.

=end original

失敗するテストをスキップしてはいけません。
失敗するのは、プログラムにバグがあるからですし、
そうでなければ、まだコードを書いていないからです。
TODO の使い方を書くので、読み続けてください。

=item B<TODO: BLOCK>

    TODO: {
        local $TODO = $why if $condition;

        ...ふつうのテストコードをここに続けてください...
    }

=begin original

Declares a block of tests you expect to fail and $why.  Perhaps it's
because you haven't fixed a bug or haven't finished a new feature:

=end original

失敗すると予測しているテストと、$why のブロックを宣言します。
たぶん、バグをまだ直していないか、新しい機能を作り終えていないのでしょう。

    TODO: {
        local $TODO = "URI::Geller not finished";

        my $card = "Eight of clubs";
        is( URI::Geller->your_card, $card, 'Is THIS your card?' );

        my $spoon;
        URI::Geller->bend_spoon;
        is( $spoon, 'bent',    "Spoon bending, that's original" );
    }

=begin original

With a todo block, the tests inside are expected to fail.  Test::More
will run the tests normally, but print out special flags indicating
they are "todo".  Test::Harness will interpret failures as being ok.
Should anything succeed, it will report it as an unexpected success.
You then know the thing you had todo is done and can remove the
TODO flag.

=end original

todoブロックでは、その中のテストは、失敗すると予期されます。
Test::More は、普通にテストを行いますが、特別なフラグを出力し、それのテストが
「todo」であることを示します。
Test::Harness は、この失敗を ok であると解釈します。
なんでも成功にし、予期しない成功と、報告します。
todo が解消されたと分かったら、TODO フラグを外すことが出来ます。

=begin original

The nice part about todo tests, as opposed to simply commenting out a
block of tests, is it's like having a programmatic todo list.  You know
how much work is left to be done, you're aware of what bugs there are,
and you'll know immediately when they're fixed.

=end original

todo テストの良いところは、テストのブロックを単純に
コメントアウトすることではなく、
プログラマ的な todo リストであるようになることです。
どれくらいするべき仕事が残っているのか分かるし、どのようなバグがあるのかも
気付きます。
また、それらのテストが修正された場合、即座に識別することが出来るでしょう。

=begin original

Once a todo test starts succeeding, simply move it outside the block.
When the block is empty, delete it.

=end original

一度、todo テストが成功し始めると、単純に、ブロックの外側に todo テストを
移します。
ブロックが空なら、削除します。

=item B<todo_skip>

    TODO: {
        todo_skip $why, $how_many if $condition;

        ...normal testing code...
    }

=begin original

With todo tests, it's best to have the tests actually run.  That way
you'll know when they start passing.  Sometimes this isn't possible.
Often a failing test will cause the whole program to die or hang, even
inside an C<eval BLOCK> with and using C<alarm>.  In these extreme
cases you have no choice but to skip over the broken tests entirely.

=end original

todo テストでは、実際にテストをなるべく走らせようとします。
このように、それらのテストがいつ通過し始めるかを知るでしょう。
こういうことが、可能でない時があります。
失敗するテストは全てのプログラムが死ぬか、ハングする原因になることが
よくあります。
C<eval BLOCK> の内側で、C<alarm> を使っても。
このような極端なケースでは、壊れたテストを完全にスキップする以外には、
選択の余地はありません。

=begin original

The syntax and behavior is similar to a C<SKIP: BLOCK> except the
tests will be marked as failing but todo.  Test::Harness will
interpret them as passing.

=end original

todoではなくテストが失敗としてマークされる以外は、
構文や振る舞いが C<SKIP: BLOCK> に似ています。
Test::Harness は、テストに合格していると解釈します。

=item When do I use SKIP vs. TODO?

(SKIP 対 TODO をどのように使い分けるのでしょう？)

=begin original

B<If it's something the user might not be able to do>, use SKIP.
This includes optional modules that aren't installed, running under
an OS that doesn't have some feature (like fork() or symlinks), or maybe
you need an Internet connection and one isn't available.

=end original

B<もし、ユーザが出来そうにないときには>、SKIP を使ってください。
これには、インストールされていないオプショナルなモジュールや、
(fork() や symlinks などの)機能を持っていない OS で実行することや、
インターネット接続を必要としているのに、それをユーザが
利用できないことも含みます。

=begin original

B<If it's something the programmer hasn't done yet>, use TODO.  This
is for any code you haven't written yet, or bugs you have yet to fix,
but want to put tests in your testing script (always a good idea).

=end original

B<もし、プログラマがまだ、やっていないときには>、TODO を使ってください。
これは、テストスクリプトに、テストを置きたい(常によい考えです)けれども、
まだ書いていないコードや、まだ直していないバグなどです。

=back


=head2 Test control

(テストの制御)

=over 4

=item B<BAIL_OUT>

    BAIL_OUT($reason);

=begin original

Indicates to the harness that things are going so badly all testing
should terminate.  This includes the running of any additional test scripts.

=end original

悲惨ななことになったため、すべてのテストを終了させるように、harness に
伝えます。
これは、どんな追加のテストスクリプトの実行も含みます。

=begin original

This is typically used when testing cannot continue such as a critical
module failing to compile or a necessary external utility not being
available such as a database connection failing.

=end original

データベース接続のような、重要なモジュールのコンパイルエラーや
必須の外部ユーティリティが利用できないようなために、
テストが続けられない場合に、典型的に使われます。

=begin original

The test will exit with 255.

=end original

テストは 255 で終了します。

=begin original

For even better control look at L<Test::Most>.

=end original

L<Test::Most> に、よりよい制御があります。


=cut

=back


=head2 Discouraged comparison functions

(推奨されない比較関数)

=begin original

The use of the following functions is discouraged as they are not
actually testing functions and produce no diagnostics to help figure
out what went wrong.  They were written before is_deeply() existed
because I couldn't figure out how to display a useful diff of two
arbitrary data structures.

=end original

下記の関数の使用は推奨されません。
これらは、実際にはテスト関数ではなく、
何が間違っているかを突き止める助けとなる診断は提供しません。
is_deeply() ができるより前に書かれた関数で、2つの任意のデータ構造の
違いを表示する有効な方法を考え付くことが出来なかったためです。

=begin original

These functions are usually used inside an ok().

=end original

これらは、ok() の中で使われるのが普通です。

    ok( eq_array(\@got, \@expected) );

C<is_deeply()> can do that better and with diagnostics.  

C<is_deeply()>は、より良いですし、診断もあります。

    is_deeply( \@got, \@expected );

=begin original

They may be deprecated in future versions.

=end original

将来のバージョンでなくなるかもしれません。

=over 4

=item B<eq_array>

  my $is_eq = eq_array(\@got, \@expected);

=begin original

Checks if two arrays are equivalent.  This is a deep check, so
multi-level structures are handled correctly.

=end original

2つの配列がイコールかどうかをチェックします。
これは、深いチェックであり、マルチレベルの構造が正確に扱われます。

=item B<eq_hash>

  my $is_eq = eq_hash(\%got, \%expected);

=begin original

Determines if the two hashes contain the same keys and values.  This
is a deep check.

=end original

二つのハッシュが同じキーと値を含んでいるかどうかを調べます。
これは深いチェックです。

=item B<eq_set>

  my $is_eq = eq_set(\@got, \@expected);

=begin original

Similar to eq_array(), except the order of the elements is B<not>
important.  This is a deep check, but the irrelevancy of order only
applies to the top level.

=end original

eq_array() と似ていますが、要素の順番は重要ではありません。
これは、深いチェックですが、順番の不整合は、トップレベルにしか
適用されません。

    ok( eq_set(\@got, \@expected) );

=begin original

Is better written:

=end original

より良い書き方:

    is_deeply( [sort @got], [sort @expected] );

=begin original

B<NOTE> By historical accident, this is not a true set comparison.
While the order of elements does not matter, duplicate elements do.

=end original

B<注意>
歴史的な都合により、これは、本当の set の比較ではありません。
要素の順番が問題ではない上に、重複した要素も問題にしません。

=begin original

B<NOTE> eq_set() does not know how to deal with references at the top
level.  The following is an example of a comparison which might not work:

=end original

B<注意>。eq_set() は、トップレベルでリファレンスをどう扱うかを知りません。
以下のものは、動かない比較の例です。

    eq_set([\1, \2], [\2, \1]);

=begin original

L<Test::Deep> contains much better set comparison functions.

=end original

L<Test::Deep> には、よりよい比較関数のセットがあります。

=cut

=back


=head2 Extending and Embedding Test::More

(Test::Moreの拡張と包含)

=begin original

Sometimes the Test::More interface isn't quite enough.  Fortunately,
Test::More is built on top of Test::Builder which provides a single,
unified backend for any test library to use.  This means two test
libraries which both use Test::Builder B<can be used together in the
same program>.

=end original

Test::More のインターフェースが、まったく十分でない時もあります。
幸運なことに、Test::More は、Test::Builder の上に作られています。
Test::Builder は、あらゆるテストライブラリーのための、一つの、統合された、
バックエンドを提供しています。
このことは、両方とも、Test::Builder を使っている、2つの
テストライブラリーならば、B<同じプログラムでいっしょに使えること>を
意味します。

=begin original

If you simply want to do a little tweaking of how the tests behave,
you can access the underlying Test::Builder object like so:

=end original

もし単純に、テストの挙動の仕方を微調整したければ、次のように、
ベースとされた Test::Builder オブジェクトにアクセスできます:

=over 4

=item B<builder>

    my $test_builder = Test::More->builder;

=begin original

Returns the Test::Builder object underlying Test::More for you to play
with.

=end original

Test::More で遊ぶための、Test::More の基礎をなす Test::Builder オブジェクトを
返します。

=cut

=back

=head1 EXIT CODES

(終了コード)

=begin original

If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.

=end original

すべてのテストがパスしたら、Test::Builder は 0 で終了します(通常です)。
何か間違っていたら，間違った数で終了します。計画しているよりも、
少ない(か、多い)か、見失ったか、余計なテストを走らせると、失敗したと
みなされます。
テストが実行されなければ、警告を投げ、255 で終了します。
テストが死んだら、たとえすべてのテストが成功しても、
失敗とみなし、255 で終了します。

=begin original

So the exit codes are...

=end original

終了コードは...

    0                   すべてのテストが成功
    255                 テストは死んだか、すべて成功したが、間違っている # of tests run
    any other number    間違った数(失敗か、余計なものを含む)

=begin original

If you fail more than 254 tests, it will be reported as 254.

=end original

254 以上のテストに失敗したら、254 を報告します。

=begin original

B<NOTE>  This behavior may go away in future versions.

=end original

B<注意>
この振る舞いは、将来のバージョンでなくなるかもしれません。

=head1 CAVEATS and NOTES

(警告と注意)

=over 4

=item 後方互換性

=begin original

Test::More works with Perls as old as 5.6.0.

=end original

Test::More は Perl 5.6.0 で動きます。

=back

=head1 COMPATIBILITY

(互換性)

=begin original

Test::More works with Perls as old as 5.8.1.

=end original

Test::Moreは、5.8.1 の古い Perl でも動きます。

=begin original

Thread support is not very reliable before 5.10.1, but that's
because threads are not very reliable before 5.10.1.

=end original

5.10.1 より前では、スレッドサポートはあまり信頼できません。しかし、それは、
threads が5.10.1 より前にあまり信頼でなかったからです。

=begin original

Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use C<done_testing()> but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More > 0.88.

=end original

Test::More は、Perl 5.6.2 のバージョンからコアモジュールですが、Test::More は、それから進化しています。よく使っている全ての機能が、Test::More のシップされたバージョンに存在するわけではありません。モジュールを書いているなら、パッケージのメタデータで、必要とする Test::More の最小のバージョンを指定していするのを忘れないでください。例えば、C<done_testing()> を使っており、ですが、スクリプトは、Perl 5.10.0 で動かしたいなら、Test::More > 0.88 が必要だと明示しなければなりません。

=begin original

Key feature milestones include:

=end original

重要な機能のマイルストーンは:

=over 4

=item subtests

=begin original

Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call C<done_testing()> until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.

=end original

サブテストは Test::More 0.94 でリリースされました。 Perl 5.12.0 に付属ます。サブテストは、0.96まで、暗黙的に、C<done_testing()>を呼びません; 0.98でされたこの修正がついている最初の Perl は、5.14.0 です。

=item C<done_testing()>

=begin original

This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 

=end original

Test::More 0.88 でリリースされました。Test::More 0.92 は Perl 5.10.1 の一部として付属します。

=item C<cmp_ok()>

=begin original

Although C<cmp_ok()> was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.

=end original

C<cmp_ok()> は、 0.40 で導入されましたが、0.86 で、オーバーロードされたオブジェクトを安全にするための重要なバグが修正されました; Test::More 0.92 の一部として、Perl 5.10.1 で最初にリリースされました。

=item C<new_ok()> C<note()> and C<explain()>

=begin original

These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 

=end original

これらは、Test::More 0.82 でリリースされました。Test::More 0.92 の一部として、Perl 5.10.1 で最初にリリースされました。

=back

=begin original

There is a full version history in the Changes file, and the Test::More versions included as core can be found using L<Module::CoreList>:

=end original

変更ファイルの完全なバージョンヒストリーです。また、L<Module::CoreList>を使えば、コアとして含まれた Test::More のバージョンがわかります。

    $ corelist -a Test::More


=head1 CAVEATS and NOTES

=over 4

=item utf8 / "Wide character in print"

=begin original

If you use utf8 or other non-ASCII characters with Test::More you
might get a "Wide character in print" warning.  Using C<binmode
STDOUT, ":utf8"> will not fix it.  Test::Builder (which powers
Test::More) duplicates STDOUT and STDERR.  So any changes to them,
including changing their output disciplines, will not be seem by
Test::More.

=end original

utf8 か non-ASCII な文字を Test::More と一緒に使う場合、
"Wide character in print" の警告が出るかもしれません。
C<binmode STDOUT, ":utf8"> を使っても、直りません。
Test::Builder (Test::Moreに力を与えている) STDOUT と STDERR を複製しています。
そのため、それらへのどんな変更も、それらの出力の仕方の変更も含み、
Test::More にはわかりません。

=begin original

One work around is to apply encodings to STDOUT and STDERR as early
as possible and before Test::More (or any other Test module) loads.

=end original

1つのワークアラウンドは Test::More (か、ほかの Test モジュール)がロードされる前に、
STDOUT と STDERR に可能な限り早くエンコーディングを適用することです。

    use open ':std', ':encoding(utf8)';
    use Test::More;

=begin original

A more direct work around is to change the filehandles used by
Test::Builder.

=end original

より直接的な対処方法としては、Test::Builderを使ってファイルハンドルを変更することです。


    my $builder = Test::More->builder;
    binmode $builder->output,         ":encoding(utf8)";
    binmode $builder->failure_output, ":encoding(utf8)";
    binmode $builder->todo_output,    ":encoding(utf8)";


=item Overloaded objects

(オーバーロードされたオブジェクト)

=begin original

String overloaded objects are compared B<as strings> (or in cmp_ok()'s
case, strings or numbers as appropriate to the comparison op).  This
prevents Test::More from piercing an object's interface allowing
better blackbox testing.  So if a function starts returning overloaded
objects instead of bare strings your tests won't notice the
difference.  This is good.

=end original

オーバーロードされたオブジェクトはB<文字列として>(または、 cmp_ok() では、
比較するオペレーターにしたがって、文字列か数字として)比較されます。
これは、Test::More が、より良いブラックボックステストを許している
オブジェクトのインターフェースを突き刺すのを妨げます。
そのため、関数が裸の文字列の代わりに、オーバーロードされた
オブジェクトを返すようになれば、あなたのテストは違いに気付かないでしょう。
これは良いことです。

=begin original

However, it does mean that functions like is_deeply() cannot be used to
test the internals of string overloaded objects.  In this case I would
suggest L<Test::Deep> which contains more flexible testing functions for
complex data structures.

=end original

ですが、is_deeply() のような関数が、オブジェクトがオーバーロードされた文字列の
内部のテストに使うことが出来ないというわけではありません。
このケースでは、L<Test::Deep> を提案します。
複雑なデータ構造のために、より柔軟なテスト関数があります。


=item Threads

=begin original

Test::More will only be aware of threads if "use threads" has been done
I<before> Test::More is loaded.  This is ok:

=end original

Test::More は、Test::More がロードされる前に、"use threads" がされている場合、
スレッドを意識します。
次は ok です:


    use threads;
    use Test::More;

=begin original

This may cause problems:

=end original

次のものは問題になります:

    use Test::More
    use threads;

=begin original

5.8.1 and above are supported.  Anything below that has too many bugs.

=end original

5.8.1 以上を想定しています。
それ未満のバージョンは、多くのバグがあります。

=back


=head1 HISTORY

(経緯)

=begin original

This is a case of convergent evolution with Joshua Pritikin's Test
module.  I was largely unaware of its existence when I'd first
written my own ok() routines.  This module exists because I can't
figure out how to easily wedge test names into Test's interface (along
with a few other problems).

=end original

これは、Joshua Pritikin のテストモジュールをまとめて進化させたものです。
自分の ok() ルーチンを最初に書いたとき、Pritikin のテストモジュールの存在に
まったく気づいていませんでした。
このモジュールが在るのは、簡単にテストの名前をテストのインターフェースに、
押し込む方法を見つけ出せなかったからです(他のいくつかの問題とともに)。

=begin original

The goal here is to have a testing utility that's simple to learn,
quick to use and difficult to trip yourself up with while still
providing more flexibility than the existing Test.pm.  As such, the
names of the most common routines are kept tiny, special cases and
magic side-effects are kept to a minimum.  WYSIWYG.

=end original

ここでのゴールは、存在する Test.pm より、柔軟性を提供しつつ
学びやすく、すぐに使えて、つまずきにくいテストのユーティリティです。
こんなわけで、ほとんどの共通のルーチンの名前は小さいままにして、
特別なケースと魔法の側面の効果は最小限にとどめました。
WYSIWYG（訳註:what you see is what you get）。


=head1 SEE ALSO

=begin original

L<Test::Simple> if all this confuses you and you just want to write
some tests.  You can upgrade to Test::More later (it's forward
compatible).

=end original

L<Test::Simple> もし、Test::More がまったく混乱させるだけのものであり、
ただ、テストを書きたいだけなら。
後で、Test::More にアップグレードできます(Test::More は、上位互換性が
あります)。

=begin original

L<Test::Harness> is the test runner and output interpreter for Perl.
It's the thing that powers C<make test> and where the C<prove> utility
comes from.

=end original

L<Test::Harness> は、テストを実行機であり、Perl の出力インタプリタです。
C<make test> に力を与えているものであり、C<prove> ユーティリティが
由来するところです。

=begin original

L<Test::Legacy> tests written with Test.pm, the original testing
module, do not play well with other testing libraries.  Test::Legacy
emulates the Test.pm interface and does play well with others.

=end original

L<Test::Legacy> は、Test.pm と一緒に書かれた、オリジナルの
テストモジュールです。
他のテストライブラリと一緒にまうまく動きません。
Test::Legacy は、Test.pm のインターフェースをエミュレートし、他のものと
うまく動きます。

=begin original

L<Test::Differences> for more ways to test complex data structures.
And it plays well with Test::More.

=end original

L<Test::Differences> 複雑なデータ構造をテストするためのより多くの
方法のために。
Test::More と一緒によくはたらきます。

=begin original

L<Test::Class> is like xUnit but more perlish.

=end original

L<Test::Class> は、xUnit に似ていますが、より perlっぽいです。

=begin original

L<Test::Deep> gives you more powerful complex data structure testing.

=end original

L<Test::Deep> は、より協力で複雑なデータ構造のテストができます。

=begin original

L<Test::Inline> shows the idea of embedded testing.

=end original

L<Test::Inline> テストを埋め込む考えを見せます。

=begin original

L<Bundle::Test> installs a whole bunch of useful test modules.

=end original

L<Bundle::Test> は、便利なテストもジュールを全部インストールします。

=head1 AUTHORS

Michael G Schwern E<lt>schwern@pobox.comE<gt> with much inspiration
from Joshua Pritikin's Test module and lots of help from Barrie
Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and
the perl-qa gang.

=head1 BUGS

See F<http://rt.cpan.org> to report and view bugs.


=head1 SOURCE

The source code repository for Test::More can be found at
F<http://github.com/schwern/test-more/>.


=head1 COPYRIGHT

Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See F<http://www.perl.com/perl/misc/Artistic.html>
