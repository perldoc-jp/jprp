
=encoding euc-jp

=head1 NAME

=begin original

Storable - persistence for Perl data structures

=end original

Storable - Perlデータ構造体の永続化

=head1 SYNOPSIS

 use Storable;
 store \%table, 'file';
 $hashref = retrieve('file');

 use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);

=begin original

 # Network order
 nstore \%table, 'file';
 $hashref = retrieve('file');	# There is NO nretrieve()

=end original

 # ネットワーク様式
 nstore \%table, 'file';
 $hashref = retrieve('file');   # There is NO nretrieve()

=begin original

 # Storing to and retrieving from an already opened file
 store_fd \@array, \*STDOUT;
 nstore_fd \%table, \*STDOUT;
 $aryref = fd_retrieve(\*SOCKET);
 $hashref = fd_retrieve(\*SOCKET);

=end original

 # 既にオープンされているファイルへ格納し、取込ます
 store_fd \@array, \*STDOUT;
 nstore_fd \%table, \*STDOUT;
 $aryref = fd_retrieve(\*SOCKET);
 $hashref = fd_retrieve(\*SOCKET);

=begin original

 # Serializing to memory
 $serialized = freeze \%table;
 %table_clone = %{ thaw($serialized) };

=end original

 # メモリへのシリアライズ
 $serialized = freeze \%table;
 %table_clone = %{ thaw($serialized) };

=begin original

 # Deep (recursive) cloning
 $cloneref = dclone($ref);

=end original

 # 深い（再帰的な）複写
 $cloneref = dclone($ref);

=begin original

 # Advisory locking
 use Storable qw(lock_store lock_nstore lock_retrieve)
 lock_store \%table, 'file';
 lock_nstore \%table, 'file';
 $hashref = lock_retrieve('file');

=end original

 # アドバイザリ・ロック
 use Storable qw(lock_store lock_nstore lock_retrieve)
 lock_store \%table, 'file';
 lock_nstore \%table, 'file';
 $hashref = lock_retrieve('file');

=head1 DESCRIPTION

=begin original

The Storable package brings persistence to your Perl data structures
containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be
conveniently stored to disk and retrieved at a later time.

=end original

Storableパッケージは、スカラー(SCALAR)、配列(ARRAY)、ハッシュ(HASH)、
オブジェクトのリファレンス(REF)を持ったPerlのデータ構造体を永続化します。
つまり簡単にディスクに格納し、後で取り込むことを可能にします。

=begin original

It can be used in the regular procedural way by calling C<store> with
a reference to the object to be stored, along with the file name where
the image should be written.

=end original

格納するオブジェクトへのリファレンスとイメージが書き込まれるファイル名を
指定してC<store>を呼び出すという、通常の手続き的な方法で使うことが出来ます。

=begin original

The routine returns C<undef> for I/O problems or other internal error,
a true value otherwise. Serious errors are propagated as a C<die> exception.

=end original

そのルーチンはI/O障害や他の内部エラーが発生するとC<undef>を返し、
そうでなければtrueを返します。重大なエラーはC<die>例外で伝えられます。

=begin original

To retrieve data stored to disk, use C<retrieve> with a file name.
The objects stored into that file are recreated into memory for you,
and a I<reference> to the root object is returned. In case an I/O error
occurs while reading, C<undef> is returned instead. Other serious
errors are propagated via C<die>.

=end original

ディスクに格納されたデータを取り込むには、ファイル名を付けてC<retrieve>を
使います。そしてそのファイルに格納されたオブジェクトはメモリ上に再生成されます。
元になるオブジェクトへのI<リファレンス>が返されます。読込の途中で
I/Oエラーが発生すると、C<undef>が代わりに返されます。
他の重大なエラーの場合には、エラーがC<die>を通じて伝えられます。

=begin original

Since storage is performed recursively, you might want to stuff references
to objects that share a lot of common data into a single array or hash
table, and then store that object. That way, when you retrieve back the
whole thing, the objects will continue to share what they originally shared.

=end original

格納が再帰的に行われるので、共通のデータの多くを共有しているオブジェクトへの
リファレンスたちを１つの配列またはハッシュテーブルに詰め込んでしまい、
そのオブジェクトを格納したいと思うかもしれません。この方法では、全体を
取り込んだときに、元々共有していたものを引き続き共有します。

=begin original

At the cost of a slight header overhead, you may store to an already
opened file descriptor using the C<store_fd> routine, and retrieve
from a file via C<fd_retrieve>. Those names aren't imported by default,
so you will have to do that explicitly if you need those routines.
The file descriptor you supply must be already opened, for read
if you're going to retrieve and for write if you wish to store.

=end original

ヘッダにちょっと手をいれると、C<store_fd>ルーチンを使って既に開いている
ファイル記述子に格納し、C<fd_retrieve>を通じてファイルから取り出すことが
できます。それらの名前はデフォルトではインポートされません。そのため、
これらのルーチンが必要であれば、明示的にインポートしなければいけません。
指定するファイル記述子は、取り込むつもりであれば読み込みread)で、
格納するつもりであれば書き込み(write)で、既に開かれていなければなりません。

	store_fd(\%table, *STDOUT) || die "can't store to stdout\n";
	$hashref = fd_retrieve(*STDIN);

=begin original

You can also store data in network order to allow easy sharing across
multiple platforms, or when storing on a socket known to be remotely
connected. The routines to call have an initial C<n> prefix for I<network>,
as in C<nstore> and C<nstore_fd>. At retrieval time, your data will be
correctly restored so you don't have to know whether you're restoring
from native or network ordered data.  Double values are stored stringified
to ensure portability as well, at the slight risk of loosing some precision
in the last decimals.

=end original

複数のプラットホームで共有することを簡単にしたり、リモートに接続されている
ことが分かっているソケットに格納するときに、ネットワーク様式で格納することも
出来ます。呼び出すルーチンにはC<nstore>とC<nstore_fd>のように、頭にnetworkを
表すnが付きます。取り込むときはデータが正しく元に戻るので、取り込むのが
ネイティブからなのか、ネットワーク様式のデータからなのかを知る必要は
ありません。double（倍精度浮動小数点数型）の値も移植性が保証されるように
文字列化されます。ただし最後の桁の精度が若干失われる危険性があります。

=begin original

When using C<fd_retrieve>, objects are retrieved in sequence, one
object (i.e. one recursive tree) per associated C<store_fd>.

=end original

C<retrieve_fd>を使うとき、オブジェクトは、対応するC<store_fd>毎、
1つのオブジェクト（つまり１つの再帰ツリー）を順番に取り込まれます。

=begin original

If you're more from the object-oriented camp, you can inherit from
Storable and directly store your objects by invoking C<store> as
a method. The fact that the root of the to-be-stored tree is a
blessed reference (i.e. an object) is special-cased so that the
retrieve does not provide a reference to that object but rather the
blessed object reference itself. (Otherwise, you'd get a reference
to that blessed object).

=end original

さらにオブジェクト指向陣営寄りであれば、Storableを継承して、
C<store>をメソッドとして呼び出すことにより、あなたのオブジェクトを
直接格納することができます。格納されるツリーの元がblessされた
リファレンス（つまりオブジェクト）であれば、特別なケースになります。
そのため取込は、そのオブジェクトへのリファレンスを提供せず、
blessされたオブジェクト・リファレンスを提供します。
（そうでなければ、そのblessされたオブジェクトへのリファレンスを
取得することにでしょう）

=head1 MEMORY STORE

(メモリへの格納)

=begin original

The Storable engine can also store data into a Perl scalar instead, to
later retrieve them. This is mainly used to freeze a complex structure in
some safe compact memory place (where it can possibly be sent to another
process via some IPC, since freezing the structure also serializes it in
effect). Later on, and maybe somewhere else, you can thaw the Perl scalar
out and recreate the original complex structure in memory.

=end original

Storableエンジンは後から取り込むために、Perlスカラーにデータを格納する
こともできます。これは主に複雑な構造体を安全で小さなメモリ空間に
固めるため(freeze)に使われます（構造体を固めると実際にはシリアライズも
されるので、他のプロセスにIPCを通じて送ることも潜在的には可能です）。
後で、そして多分どこか別のところで、Perlスカラを解凍(thaw)し、
元の複雑な構造体をメモリ上に再生成することができます。

=begin original

Surprisingly, the routines to be called are named C<freeze> and C<thaw>.
If you wish to send out the frozen scalar to another machine, use
C<nfreeze> instead to get a portable image.

=end original

驚いたことに、呼ばれるルーチンの名前はC<freeze>とC<thaw>といいます。
もし固めたスカラを他のマシンに送信したければ、代わりにC<nfreeze>を
ポータブルなイメージを取得してください。

=begin original

Note that freezing an object structure and immediately thawing it
actually achieves a deep cloning of that structure:

=end original

オブジェクト構造を固め、すぐに解凍すると、実際には、その構造を深く
複写することを実現していることに注意して下さい：

    dclone(.) = thaw(freeze(.))

=begin original

Storable provides you with a C<dclone> interface which does not create
that intermediary scalar but instead freezes the structure in some
internal memory space and then immediately thaws it out.

=end original

Storableは、中間のスカラを作成することなく、代わりに内部メモリ空間に
構造を固め、すぐに解凍するC<dclone>インターフェイスを提供しています。

=head1 ADVISORY LOCKING

(アドバイザリ・ロック)

=begin original

The C<lock_store> and C<lock_nstore> routine are equivalent to
C<store> and C<nstore>, except that they get an exclusive lock on
the file before writing.  Likewise, C<lock_retrieve> does the same
as C<retrieve>, but also gets a shared lock on the file before reading.

=end original

C<lock_store>とC<lock_nstore>はC<store>とC<nstore>と同じです。ただし、
書き込む前に占有ロックを行います。同様にC<lock_retrieve>はC<retrieve>のように
動きます。しかし読み込む前に共有ロックを行います。

=begin original

As with any advisory locking scheme, the protection only works if you
systematically use C<lock_store> and C<lock_retrieve>.  If one side of
your application uses C<store> whilst the other uses C<lock_retrieve>,
you will get no protection at all.

=end original

全てのアドバイザリ・ロックのスキームと同じように、保護はあなたが
システマティックにC<lock_store>とC<lock_retrieve>を使うときにだけ機能します。
もし他の部分がC<lock_retrieve>を使っているときに、あなたのアプリケーションの
ある部分がC<store>を使うと、何も保護されません。

=begin original

The internal advisory locking is implemented using Perl's flock()
routine.  If your system does not support any form of flock(), or if
you share your files across NFS, you might wish to use other forms
of locking by using modules such as LockFile::Simple which lock a
file using a filesystem entry, instead of locking the file descriptor.

=end original

アドバイザリ・ロックの内部はPerlのflock()ルーチンを使って実装されます。
もしあなたのシステムがflock()のいかなる形式もサポートしていなかったり、
あなたのファイルをNFS越しにファイルを共有しているのであれば、ファイル記述子ではなく
ファイルシステムのエントリを使ってロックするLockFile:Simpleのようなモジュールを
使って他の形式のロックを使いたいことでしょう。

=head1 SPEED

(スピード)

=begin original

The heart of Storable is written in C for decent speed. Extra low-level
optimizations have been made when manipulating perl internals, to
sacrifice encapsulation for the benefit of greater speed.

=end original

スピードを上げるため、Storableの中核部分はCで書かれています。 Perl内部を操作するとき、
よりスピードを上げるためにカプセル化を犠牲にするという、特別な低レベルの最適化がな
されています。 

=head1 CANONICAL REPRESENTATION

(規範形式)

=begin original

Normally, Storable stores elements of hashes in the order they are
stored internally by Perl, i.e. pseudo-randomly.  If you set
C<$Storable::canonical> to some C<TRUE> value, Storable will store
hashes with the elements sorted by their key.  This allows you to
compare data structures by comparing their frozen representations (or
even the compressed frozen representations), which can be useful for
creating lookup tables for complicated queries.

=end original

通常StorableはハッシュをPerlが内部的に格納している順序で要素を格納します。つまり
疑似ランダムになります。もしC<$Storable::canonical>をC<TRUE>値に設定すると、
Storableはハッシュをそのキーの順に要素を格納します。これにより、データ構造体を
固められた形式で(または固められ圧縮され形式でさえ）比較することができるように
なります。これは複雑な問い合わせのための参照テーブルを作るのに便利でしょう。

=begin original

Canonical order does not imply network order; those are two orthogonal
settings.

=end original

規範様式(=Canonical)はネットワーク様式を意味していません。それらはまったく違う設定です。

=head1 CODE REFERENCES

(コード・リファレンス)

=begin original

Since Storable version 2.05, CODE references may be serialized with
the help of L<B::Deparse>. To enable this feature, set
C<$Storable::Deparse> to a true value. To enable deserializazion,
C<$Storable::Eval> should be set to a true value. Be aware that
deserialization is done through C<eval>, which is dangerous if the
Storable file contains malicious data. You can set C<$Storable::Eval>
to a subroutine reference which would be used instead of C<eval>. See
below for an example using a L<Safe> compartment for deserialization
of CODE references.

=end original

Storable バージョン 2.05から、コード(CODE)リファレンスがL<B::Deparse>の
助けを借りてシリアライズできます。この機能を有効にするためには、
C<$Storable::Deparse>をtrue値に設定してください。
デシリアライゼーションを有効にするためには、C<$Storable::Eval>がtrue値に
設定されていなければなりません。デシリアライゼーションがC<eval>を通して
行われることに注意してください。もしStorableファイルに悪意のあるデータが
入っていると危険です。C<$Storable::Eval>にC<eval>の代わりに使われる
サブルーチン・リファレンスを設定することができます。
コード(CODE)リファレンスのデシリアライゼーションについては、L<Safe>
コンポーネントを使っている下記の例をご覧ください。

=head1 FORWARD COMPATIBILITY

(将来への互換性)

=begin original

This release of Storable can be used on a newer version of Perl to
serialize data which is not supported by earlier Perls.  By default,
Storable will attempt to do the right thing, by C<croak()>ing if it
encounters data that it cannot deserialize.  However, the defaults
can be changed as follows:

=end original

今回のStorableのリリースでは、Perlのより新しいバージョンで以前のPerlでは
サポートされていなかったデータをシリアライズするために使うことができます。
デフォルトではStorableは適切なことをしようとし、デシリアライズできない
データにぶつかったらC<croak()>します。しかしデフォルトは以下のように
変更することができます:

=over 4

=item utf8 data

(utf8データ)

=begin original

Perl 5.6 added support for Unicode characters with code points > 255,
and Perl 5.8 has full support for Unicode characters in hash keys.
Perl internally encodes strings with these characters using utf8, and
Storable serializes them as utf8.  By default, if an older version of
Perl encounters a utf8 value it cannot represent, it will C<croak()>.
To change this behaviour so that Storable deserializes utf8 encoded
values as the string of bytes (effectively dropping the I<is_utf8> flag)
set C<$Storable::drop_utf8> to some C<TRUE> value.  This is a form of
data loss, because with C<$drop_utf8> true, it becomes impossible to tell
whether the original data was the Unicode string, or a series of bytes
that happen to be valid utf8.

=end original

Perl 5.6 は255よりも大きなコード値を持つUnicode文字のサポートが加わりました。
そしてPerl5.8では、ハッシュキーでのフルサポートを持ちます。Perlは内部的に、
これらの文字を持つ文字列をutf8を使ってエンコードします。Storableはutf8として、
それらをシリアライズします。デフォルトでは、より古いバージョンがそれが
表すことが出来ないutf8の値にぶつかると、それはC<croak()>します。Storableが
utf8をバイトの文字列としてエンコードされたものとしてデシリアライズするよう、
この動きを変更するためには、$C<Storable::drop_utf8>を何らかのC<TRUE>の値に
設定してください。これはデータが失われることになります。
というのもC<$drop_utf8>がtrueであると、もとのデータがUnicode文字列だったのか、
たまたまutf8として正しいバイトの並びだったのかが分からなくなってしまいます。

=item restricted hashes

(限定ハッシュ)

=begin original

Perl 5.8 adds support for restricted hashes, which have keys
restricted to a given set, and can have values locked to be read only.
By default, when Storable encounters a restricted hash on a perl
that doesn't support them, it will deserialize it as a normal hash,
silently discarding any placeholder keys and leaving the keys and
all values unlocked.  To make Storable C<croak()> instead, set
C<$Storable::downgrade_restricted> to a C<FALSE> value.  To restore
the default set it back to some C<TRUE> value.

=end original

Perl 5.8は限定ハッシュ(restricted hash) のサポートを追加します。
それは与えられた集合にのみキーが制限され、値を読込のみにロックすることが
出来ます。デフォルトではそれらをサポートしていないperlではStorableが
限定ハッシュにぶつかると、それを通常のハッシュとしてデシリアライズします。
場所を保持するためのキーを全て黙って処分し、キーと値のロックを全て外します。
代わりにStorableにC<croak()>させるためには、C<$Storable::downgrade_restricted>を
C<FALSE>の値に設定してください。デフォルトの設定に戻すためには何らかのC<TRUE>値に
戻してください。

=item files from future versions of Storable

(将来のバージョンのStorableからのファイル)

=begin original

Earlier versions of Storable would immediately croak if they encountered
a file with a higher internal version number than the reading Storable
knew about.  Internal version numbers are increased each time new data
types (such as restricted hashes) are added to the vocabulary of the file
format.  This meant that a newer Storable module had no way of writing a
file readable by an older Storable, even if the writer didn't store newer
data types.

=end original

以前のStorableは、読んでいるStorableが知っているものより高い内部バージョンを
持ったファイルにぶつかるとすぐにcroakしました。内部バージョン番号は新しいデータ型
（限定ハッシュのような）がファイル形式の用語に加えられるたびに上がります。これは
より新しいStorableモジュールには、たとえ新しいデータ型を格納しなかったとしても、
古いStorableで読めるようなファイルを書く方法がないことを意味します。 

=begin original

This version of Storable will defer croaking until it encounters a data
type in the file that it does not recognize.  This means that it will
continue to read files generated by newer Storable modules which are careful
in what they write out, making it easier to upgrade Storable modules in a
mixed environment.

=end original

Storableのこのバージョンは、ファイルの中で、それが理解しないデータ型にぶつかるまで
croakしないという点で異なります。つまりこれは出力するものに注意を払えば、
新しいStorableモジュールで作られたファイルでも読むことが出来るということです。
これにより混在する環境でStorableをアップグレードすることが簡単になります。

=begin original

The old behaviour of immediate croaking can be re-instated by setting
C<$Storable::accept_future_minor> to some C<FALSE> value.

=end original

C<$Storable::accept_future_minor>をC<FALSE>値にすることにより、即座にcroakする
というStorableの古い動きに戻すことが出来ます。

=back

=begin original

All these variables have no effect on a newer Perl which supports the
relevant feature.

=end original

これらの変数は関連する機能をサポートしている新しいPerlでは何の効果もありません。

=head1 ERROR REPORTING

(エラー・レポート)

=begin original

Storable uses the "exception" paradigm, in that it does not try to workaround
failures: if something bad happens, an exception is generated from the
caller's perspective (see L<Carp> and C<croak()>).  Use eval {} to trap
those exceptions.

=end original

Storableは"例外"パラダイムを使っています。それでは障害を回避しようとはしません:
何かよくないことが発生したら、呼び出した側の視点で例外が発生します
（L<Carp>とC<croak()>をご覧ください）。それらの例外を捕らえるためにはeval{}を
使ってください。

=begin original

When Storable croaks, it tries to report the error via the C<logcroak()>
routine from the C<Log::Agent> package, if it is available.

=end original

Storableがcroakするとき、C<Log::Agent>パッケージが利用できるのであれば、
そのC<logcroak()>ルーチンを経由してエラーを報告しようとします。

=begin original

Normal errors are reported by having store() or retrieve() return C<undef>.
Such errors are usually I/O errors (or truncated stream errors at retrieval).

=end original

通常のエラーはstorable()やretrieve()にC<undef>を返すことにより報告されます。
そのようなエラーは通常I/Oのエラー（あるいはretrieveのさいにストリームが
切り捨てられたか）です。

=head1 WIZARDS ONLY

(上級者のみ)

=head2 Hooks

(フック)

=begin original

Any class may define hooks that will be called during the serialization
and deserialization process on objects that are instances of that class.
Those hooks can redefine the way serialization is performed (and therefore,
how the symmetrical deserialization should be conducted).

=end original

全てのクラスで、そのクラスのインスタンスをシリアライズやデシリアライズの
処理の途中で呼ばれるフックを定義することもできます。それらのフックは
実行されるシリアライゼーションを実行する方法を再定義することが出来ます。
（そのため、対になるデシリアライゼーションも、そのように振舞わなければ
なりません）

=begin original

Since we said earlier:

=end original

前述の通り:

    dclone(.) = thaw(freeze(.))

=begin original

everything we say about hooks should also hold for deep cloning. However,
hooks get to know whether the operation is a mere serialization, or a cloning.

=end original

フックについて述べたことはすべて、深いクローン作成にも当てはまります。
しかしフックには、その処理が単なるシリライゼーションなのかクローンなのかが
わかります。

=begin original

Therefore, when serializing hooks are involved,

=end original

このため、シリアライズ化のフックが呼び出されるとになります。

    dclone(.) <> thaw(freeze(.))

=begin original

Well, you could keep them in sync, but there's no guarantee it will always
hold on classes somebody else wrote.  Besides, there is little to gain in
doing so: a serializing hook could keep only one attribute of an object,
which is probably not what should happen during a deep cloning of that
same object.

=end original

同期を取ることもできます。しかし誰か他の人が書いたクラスについて常に
当てはまるような保証はありません。さらに、そうすることによって得られるものは
あまりありません:シリアライズのフックは、あるオブジェクトの１つの属性を
保持することだけができます。それは、その同じオブジェクトの深い複写の間に起きる
こととは多分、違います。

=begin original

Here is the hooking interface:

=end original

以下にフックのインターフェイスを示します：

=over 4

=item C<STORABLE_freeze> I<obj>, I<cloning>

=begin original

The serializing hook, called on the object during serialization.  It can be
inherited, or defined in the class itself, like any other method.

=end original

シリアライズ化フック。オブジェクトがシリアライズされるときに呼ばれます。
これは他のメソッドと同様に継承したり、クラスの中で再定義することができます。 

=begin original

Arguments: I<obj> is the object to serialize, I<cloning> is a flag indicating
whether we're in a dclone() or a regular serialization via store() or freeze().

=end original

引数:I<obj>はシリアラズするオブジェクト、I<cloning>はdclone()の中であるか、
store()やfreeze()を経由した通常のシリアライゼーションかを示します。

=begin original

Returned value: A LIST C<($serialized, $ref1, $ref2, ...)> where $serialized
is the serialized form to be used, and the optional $ref1, $ref2, etc... are
extra references that you wish to let the Storable engine serialize.

=end original

戻り値:リスト C<($serialized, $ref1, $ref2, ...) >。 $serialized は、
使われるシリアライズされた形式、オプションの$ref1、$ref2などは、
Storableエンジンにシリアラズさせたい特別なリファレンスです。

=begin original

At deserialization time, you will be given back the same LIST, but all the
extra references will be pointing into the deserialized structure.

=end original

デシリアライゼーションのときには、あなたは同じリスト(LIST)が与えられます。
しかし特別なリファレンスは全てデシリアライズされた構造体を示します。

=begin original

The B<first time> the hook is hit in a serialization flow, you may have it
return an empty list.  That will signal the Storable engine to further
discard that hook for this class and to therefore revert to the default
serialization of the underlying Perl data.  The hook will again be normally
processed in the next serialization.

=end original

B<最初に>フックがシリアライゼーションの流れの中でヒットしたとき、
あなたは空のリストを返すことができます。それはこのクラスのためのフックを、
それから先、捨てらるようStorableエンジンに合図し、このため元になっている
Perlデータのデフォルトのシリアライゼーションに戻ります。そのフックは次の
シリアライゼーションでは再び通常通り処理されます。

=begin original

Unless you know better, serializing hook should always say:

=end original

よく分からなければ、シリアライズの
フックは以下のようにするべきです：

=begin original

    sub STORABLE_freeze {
        my ($self, $cloning) = @_;
        return if $cloning;         # Regular default serialization
        ....
    }

=end original

    sub STORABLE_freeze {
        my ($self, $cloning) = @_;
        return if $cloning;         # 通常のデフォルトのシリアライゼーション
        ....
    }

=begin original

in order to keep reasonable dclone() semantics.

=end original

dclone()セマンティクスでも合理的になるようにします。

=item C<STORABLE_thaw> I<obj>, I<cloning>, I<serialized>, ...

=begin original

The deserializing hook called on the object during deserialization.
But wait: if we're deserializing, there's no object yet... right?

=end original

オブジェクトがデシリアライズされるときに呼ばれるデシリアライズ化フック。
しかし待ってください: もしデシリアライズしているのであれば、
オブジェクトはまだないのでは...？ 

=begin original

Wrong: the Storable engine creates an empty one for you.  If you know Eiffel,
you can view C<STORABLE_thaw> as an alternate creation routine.

=end original

違います：Storableエンジンはあなたのために空のものを生成します。
Eiffelをご存知であれば、C<STORABLE_thaw>は代替生成ルーチンとして
みることが出来ます。

=begin original

This means the hook can be inherited like any other method, and that
I<obj> is your blessed reference for this particular instance.

=end original

つまり、フックは他のメソッドと同じように継承することができ、
C<obj>はこの特定のインスタンスのためのblessされたリファレンスになります。

=begin original

The other arguments should look familiar if you know C<STORABLE_freeze>:
I<cloning> is true when we're part of a deep clone operation, I<serialized>
is the serialized string you returned to the engine in C<STORABLE_freeze>,
and there may be an optional list of references, in the same order you gave
them at serialization time, pointing to the deserialized objects (which
have been processed courtesy of the Storable engine).

=end original

その他の引数はC<STORABLE_freeze>を知っていれば慣れているでしょう:深い
クローン処理の一部であればI<cloning>はtrueになります。I<serialized>は
I<STORABLE_freeze>でエンジンに返したシリアライズされた文字列です。
そしてオプションのリファレンスのリストもあるかもしれません。
それはシリアル化のときにあなたが与えた順番で、デシリアライズされた
オブジェクトを指します（それらはStorableエンジンによって特別に扱われます）

=begin original

When the Storable engine does not find any C<STORABLE_thaw> hook routine,
it tries to load the class by requiring the package dynamically (using
the blessed package name), and then re-attempts the lookup.  If at that
time the hook cannot be located, the engine croaks.  Note that this mechanism
will fail if you define several classes in the same file, but L<perlmod>
warned you.

=end original

Storableエンジンが何もSTORABLE_thawフック・ルーチンを見つけられなければ、
それは動的にパッケージを（blessされたパッケージ名を使って）requireすることにより
ロードしようとします。そして再び参照しようとします。もしこの時点で
フックが見つからなければ、エンジンはcroakします。この仕組は同じファイルで
いくつものクラスを定義しているとうまくいきません。しかしL<perlmod>が警告
するでしょう。

=begin original

It is up to you to use this information to populate I<obj> the way you want.

=end original

これらの情報を使って、どのようにI<obj>を作成するかは、あなた次第です。

=begin original

Returned value: none.

=end original

戻り値:ありません。

=back

=head2 Predicates

(述語)

=begin original

Predicates are not exportable.  They must be called by explicitly prefixing
them with the Storable package name.

=end original

述語（Predicates)はエクスポート可能ではありません。それらはStorableパッケージ名を
明示的に前につけて呼び出されなければなりません。

=over 4

=item C<Storable::last_op_in_netorder>

=begin original

The C<Storable::last_op_in_netorder()> predicate will tell you whether
network order was used in the last store or retrieve operation.  If you
don't know how to use this, just forget about it.

=end original

述語C<Storable::last_op_in_netorder()>は、最後のstoreあるいはretrieve操作のさい
ネットワーク・オーダーであったかを示します。もしこの使い方がわからなければ、
忘れてください。 

=item C<Storable::is_storing>

=begin original

Returns true if within a store operation (via STORABLE_freeze hook).

=end original

(STORABLE_freezeフックを経由して)store操作の中であればtrueを返します。 

=item C<Storable::is_retrieving>

=begin original

Returns true if within a retrieve operation (via STORABLE_thaw hook).

=end original

(STORABLE_thawフックを経由して)retrieve操作の中であればtrueを返します。

=back

=head2 Recursion

(再帰)

=begin original

With hooks comes the ability to recurse back to the Storable engine.
Indeed, hooks are regular Perl code, and Storable is convenient when
it comes to serializing and deserializing things, so why not use it
to handle the serialization string?

=end original

フックによってStorableエンジンに再帰的に戻ってくることが可能になります。
実際、フックは通常のPerlコードです。そしてStorableは、あるものをシリアライズ
したりデシリアライズするときに便利です。それならば、シリアライズされた
文字列を扱うために、それを使っていけないなんてことあるんでしょうか？

=begin original

There are a few things you need to know, however:

=end original

しかしいくつか覚えておかなければならないことがあります:

=over 4

=item *

=begin original

You can create endless loops if the things you serialize via freeze()
(for instance) point back to the object we're trying to serialize in
the hook.

=end original

もしfreeze()でシリアライズしようとしているものが、（例えば）フックの中で
シリアライズしようとしているオブジェクトを指しているとすると無限ループを
作ってしまうかもしれません。

=item *

=begin original

Shared references among objects will not stay shared: if we're serializing
the list of object [A, C] where both object A and C refer to the SAME object
B, and if there is a serializing hook in A that says freeze(B), then when
deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D,
a deep clone of B'.  The topology was not preserved.

=end original

オブジェクト間で共有される参照は共有されなくなります:オブジェクトAとCの両方が
同じオブジェクトBを参照しているとき、オブジェクトのリスト[A, C]をシリアライズし、
そしてAにfreeze(B)と書いてあるシリアライズのためのフックがあるなば、、
デシリアライズすると、[A', C']を取得し、A'はB'を参照します。しかしC'はB'の
深いクローンであるDを参照します。位相は保持されません。

=back

=begin original

That's why C<STORABLE_freeze> lets you provide a list of references
to serialize.  The engine guarantees that those will be serialized in the
same context as the other objects, and therefore that shared objects will
stay shared.

=end original

このためにC<STORABLE_freeze>はシリアライズするリファレンスのリストを提供させて
いるのです。エンジンは他のオブジェクトと同じコンテキストの中で、それらが
シリアライズされることを、そのため共有されたオブジェクトは共有されたままに
なることを保証します。

=begin original

In the above [A, C] example, the C<STORABLE_freeze> hook could return:

=end original

上記の[A, C]の例では、C<STORABLE_freeze>フックは以下のように返すことができます:

	("something", $self->{B})

=begin original

and the B part would be serialized by the engine.  In C<STORABLE_thaw>, you
would get back the reference to the B' object, deserialized for you.

=end original

そしてB部分はエンジンによってシリアライズされます。C<STORABLE_thaw>では、
デシリアライズされたB'オブジェクトへのリファレンスを取得するでしょう。

=begin original

Therefore, recursion should normally be avoided, but is nonetheless supported.

=end original

このため再帰は通常は避けられるはずです。しかしそれでもサポートされています。

=head2 Deep Cloning

(深いクローン作成)

=begin original

There is a Clone module available on CPAN which implements deep cloning
natively, i.e. without freezing to memory and thawing the result.  It is
aimed to replace Storable's dclone() some day.  However, it does not currently
support Storable hooks to redefine the way deep cloning is performed.

=end original

CPANから、深いクローン作成をネイティブに、つまりメモリ上に固め、
その結果を解凍することがなしに実装する新しいCloneモジュールが利用できます。
それは将来、Storableのdclone()を置き換えることを目標にしています。
しかし、実行される深いクローン作成の方法を再定義するためのStorableフックは、
まだサポートしていません。

=head1 Storable magic

(Storableのmagic)

=begin original

Yes, there's a lot of that :-) But more precisely, in UNIX systems
there's a utility called C<file>, which recognizes data files based on
their contents (usually their first few bytes).  For this to work,
a certain file called F<magic> needs to taught about the I<signature>
of the data.  Where that configuration file lives depends on the UNIX
flavour; often it's something like F</usr/share/misc/magic> or
F</etc/magic>.  Your system administrator needs to do the updating of
the F<magic> file.  The necessary signature information is output to
STDOUT by invoking Storable::show_file_magic().  Note that the GNU
implementation of the C<file> utility, version 3.38 or later,
is expected to contain support for recognising Storable files
out-of-the-box, in addition to other kinds of Perl files.

=end original

そう、それはたくさん:-)。しかしより正確には、UNIXシステムではC<file>と
呼ばれるユーティリティがあります。それはその内容（通常はその先頭の数バイト）を
ベースにデータファイルを評価します。これが機能するためには、F<magic>と呼ばれる、
あるファイルがそのデータのI<特徴>（signature）について教える必要があります。
その構成設定ファイルがある場所はUNIXの好みに依存し、F</usr/share/misc/magic>や
F</etc/magic>のようなところによくあります。あなたのシステム管理者はF<magic>
ファイルを更新する必要があります。必要な特徴情報はStorable::show_file_magic()を
呼び出すことによりSTDOUTへ出力されます。C<file>ユーティリティ3.38以降の
GNUの実装には、他の種類のPerlファイルに加えて、Stoableファイルを評価するための
サポートが入っていると期待することができます。

=head1 EXAMPLES

=begin original

Here are some code samples showing a possible usage of Storable:

=end original

Storableの使用法を示すコード・サンプルを以下に示します:

	use Storable qw(store retrieve freeze thaw dclone);

	%color = ('Blue' => 0.1, 'Red' => 0.8, 'Black' => 0, 'White' => 1);

	store(\%color, '/tmp/colors') or die "Can't store %a in /tmp/colors!\n";

	$colref = retrieve('/tmp/colors');
	die "Unable to retrieve from /tmp/colors!\n" unless defined $colref;
	printf "Blue is still %lf\n", $colref->{'Blue'};

	$colref2 = dclone(\%color);

	$str = freeze(\%color);
	printf "Serialization of %%color is %d bytes long.\n", length($str);
	$colref3 = thaw($str);

=begin original

which prints (on my machine):

=end original

（私のマシンでの）出力結果：

	Blue is still 0.100000
	Serialization of %color is 102 bytes long.

=begin original

Serialization of CODE references and deserialization in a safe
compartment:

=end original

Safeコンポーネント内でのコード(CODE)リファレンスのシリアライゼーションと
デシリアライゼーション:

=begin original

	use Storable qw(freeze thaw);
	use Safe;
	use strict;
	my $safe = new Safe;
	# permitting the "require" opcode is necessary when using "use strict"
	$safe->permit(qw(:default require));
	local $Storable::Deparse = 1;
	local $Storable::Eval = sub { $safe->reval($_[0]) };
	my $serialized = freeze(sub { print "42\n" });
	my $code = thaw($serialized);
	$code->(); # prints 42

=end original

	use Storable qw(freeze thaw);
	use Safe;
	use strict;
	my $safe = new Safe;
	# opcodeを"require"することを許すことは"use strict"を使う時には必須です
	$safe->permit(qw(:default require));
	local $Storable::Deparse = 1;
	local $Storable::Eval = sub { $safe->reval($_[0]) };
	my $serialized = freeze(sub { print "42\n" });
	my $code = thaw($serialized);
	$code->(); # prints 42


=head1 WARNING

=begin original

If you're using references as keys within your hash tables, you're bound
to be disappointed when retrieving your data. Indeed, Perl stringifies
references used as hash table keys. If you later wish to access the
items via another reference stringification (i.e. using the same
reference that was used for the key originally to record the value into
the hash table), it will work because both references stringify to the
same string.

=end original

ハッシュテーブルのキーとしてリファレンスを使っているならば、データを
取り出したときにガッカリするかもしれません。実際のところPerlは
ハッシュのキーとして使われているリファレンスを文字列化します。
もし後で他のリファレンスの文字列化を通じて（つまり元々、
ハッシュテーブルのなかに値を記録するためにキーとして使われたものと
同じリファレンスを使って）要素にアクセスしたければ、両方のリファレンスが
文字列化されたものが同じ文字列なので機能します。

=begin original

It won't work across a sequence of C<store> and C<retrieve> operations,
however, because the addresses in the retrieved objects, which are
part of the stringified references, will probably differ from the
original addresses. The topology of your structure is preserved,
but not hidden semantics like those.

=end original

しかし、C<store>とC<retieve>操作をまたぐと動きません。なぜなら取り込まれた
オブジェクトでのアドレス（文字列化されたリファレンスの一部です）が、
おそらく元のアドレスとは違っているからです。構造体の形は保持されますが、
このような隠された意味は保存されません。

=begin original

On platforms where it matters, be sure to call C<binmode()> on the
descriptors that you pass to Storable functions.

=end original

問題となるプラットホームでは、Storable関数に渡す記述子にC<binmode>を
呼ぶようにして下さい。

=begin original

Storing data canonically that contains large hashes can be
significantly slower than storing the same data normally, as
temporary arrays to hold the keys for each hash have to be allocated,
populated, sorted and freed.  Some tests have shown a halving of the
speed of storing -- the exact penalty will depend on the complexity of
your data.  There is no slowdown on retrieval.

=end original

データを規範形式で格納すると、大きなハッシュでは通常にデータを格納するのに
比べて非常に遅くなるかもしれません。というのも各ハッシュのためのキーを
保持するための一時的な配列を占有し、生き延びさせ、ソートし、解放しなければ
ならないためです。いくつかのテストでは格納のスピードが半減しました-- 
どれくらい遅くなるかはデータの複雑さに依存します。取込では遅くなることは
ありません。

=head1 BUGS

=begin original

You can't store GLOB, CODE, FORMLINE, etc.... If you can define
semantics for those operations, feel free to enhance Storable so that
it can deal with them.

=end original

GLOB, CODE, FORMLINE等は格納することが出来ません。これらの操作のための
意味をはっきり決めたら、それらを扱えるよう自由にStorableを拡張して下さい。

=begin original

The store functions will C<croak> if they run into such references
unless you set C<$Storable::forgive_me> to some C<TRUE> value. In that
case, the fatal message is turned in a warning and some
meaningless string is stored instead.

=end original

store関数は、C<$Strable::forgive_me>をなんらかのC<TRUE>値に設定しておかなければ、
それらのリファレンスに踏み込むとC<croak>します。その場合、警告で致命的な
メッセージが返され、代わりに意味のない文字列が格納されます。

=begin original

Setting C<$Storable::canonical> may not yield frozen strings that
compare equal due to possible stringification of numbers. When the
string version of a scalar exists, it is the form stored; therefore,
if you happen to use your numbers as strings between two freezing
operations on the same data structures, you will get different
results.

=end original

C<$Storable::canonical>を設定すると、数値が文字列化される可能性から
同じものであると比較される固められた文字列を作り出さないかもしれません。
スカラーの文字列バージョンが存在するときには、それが格納される形式に
なります。このため、もし同じデータ構造の2回固める操作をする間に、
たまたま数値を文字列として使ってしまうと、違う結果になります。

=begin original

When storing doubles in network order, their value is stored as text.
However, you should also not expect non-numeric floating-point values
such as infinity and "not a number" to pass successfully through a
nstore()/retrieve() pair.

=end original

double(倍精度浮動小数点）をネットワーク様式で格納するとき、その値は
テキストとして格納されます。しかし、nstore()/retrieve()の組み合わせに
正常に渡すことにより、無限や"数値ではない"ようなのような数値でない
浮動小数点を予想する必要はありません。

=begin original

As Storable neither knows nor cares about character sets (although it
does know that characters may be more than eight bits wide), any difference
in the interpretation of character codes between a host and a target
system is your problem.  In particular, if host and target use different
code points to represent the characters used in the text representation
of floating-point numbers, you will not be able be able to exchange
floating-point data, even with nstore().

=end original

Storableは文字集合について知りませんし、気にもしません
（それは文字が8ビットよりも大きいかもしれないということは知っています）。
ホストとターゲット・システムでの文字コードの解釈における違いは、
すべてあなたの問題です。特にもしホストとターゲットが浮動小数点数の
テキスト形式で異なるコードポイントを使うのであれば、nstore()を使った
としても浮動小数点のデータをやりとりできないかもしれません。

=begin original

C<Storable::drop_utf8> is a blunt tool.  There is no facility either to
return B<all> strings as utf8 sequences, or to attempt to convert utf8
data back to 8 bit and C<croak()> if the conversion fails.

=end original

C<Storable::drop_utf8>は鈍器のようなものです。それにはB<全ての>文字列を
utf8の並びとして返すか、utf8データを8ビットに変換しようとし、
変換に失敗したらC<croak()>する以外に機能はありません。

=begin original

Prior to Storable 2.01, no distinction was made between signed and
unsigned integers on storing.  By default Storable prefers to store a
scalars string representation (if it has one) so this would only cause
problems when storing large unsigned integers that had never been coverted
to string or floating point.  In other words values that had been generated
by integer operations such as logic ops and then not used in any string or
arithmetic context before storing.

=end original

Storable 2.01より以前、格納時に符号付と符号なし整数での区別はつけられませんでした。
デフォルトではStorableは（もし持っていれば）スカラーを文字列表現を選びます。
そのため文字列や不動賞寸点数に変換されたことがない大きな符号なし整数を格納するとき
にだけ問題になります。言い換えれば、論理演算のような整数処理により作成され、
格納の前に何も文字列操作や算術コンテキストで使われなかった値です。

=head2 64 bit data in perl 5.6.0 and 5.6.1

(perl 5.6.0 と 5.6.1での64ビット・データ)

=begin original

This section only applies to you if you have existing data written out
by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which
has been configured with 64 bit integer support (not the default)
If you got a precompiled perl, rather than running Configure to build
your own perl from source, then it almost certainly does not affect you,
and you can stop reading now (unless you're curious). If you're using perl
on Windows it does not affect you.

=end original

このセクションは、64ビットinteger(デフォルトではありません）を
サポートするように構成設定されているUnixあるいはLinux上のperl5.6.0や5.6.1で
Storable2.20あるいはそれ以前によって出力された既存のデータを持っている場合に
のみ当てはまります。ソースから独自のperlを構築するためにConfigureを実行する
のではなく、既にコンパイルされているperlを取得したのであれば、
それはおそらく何も影響はないでしょう。そして、（あなたが疑問を持っていなければ）
ここで読むのを止めることが出来ます。Windowsでperlを使っていれば、何も影響は
ありません。

=begin original

Storable writes a file header which contains the sizes of various C
language types for the C compiler that built Storable (when not writing in
network order), and will refuse to load files written by a Storable not
on the same (or compatible) architecture.  This check and a check on
machine byteorder is needed because the size of various fields in the file
are given by the sizes of the C language types, and so files written on
different architectures are incompatible.  This is done for increased speed.
(When writing in network order, all fields are written out as standard
lengths, which allows full interworking, but takes longer to read and write)

=end original

Storableは、Storableを構築したCコンパイラのさまざまなC言語の型の大きさが入った
ファイルヘッダを出力します。そして同じ（あるいは互換性のある）アーキテクチャでは
ないStorableによって書かれたファイルをロードすることを拒絶します。
ファイルの中のさまざまなフィールドはC言語の型の大きさによって与えられ、
そのため異なるアーキテクチャで書かれたファイルは互換性がないので、
このチェックとマシンのバイトオーダーについてのチェックは必要です。
これはスピードを向上させるために行われます（ネットワーク順で出力するとき、
全てのフィールドは標準の長さでかかれます。これは完全にネットワーク越える
ことを可能にしますが、読み込みと書込みはより時間がかかります）

=begin original

Perl 5.6.x introduced the ability to optional configure the perl interpreter
to use C's C<long long> type to allow scalars to store 64 bit integers on 32
bit systems.  However, due to the way the Perl configuration system
generated the C configuration files on non-Windows platforms, and the way
Storable generates its header, nothing in the Storable file header reflected
whether the perl writing was using 32 or 64 bit integers, despite the fact
that Storable was storing some data differently in the file.  Hence Storable
running on perl with 64 bit integers will read the header from a file
written by a 32 bit perl, not realise that the data is actually in a subtly
incompatible format, and then go horribly wrong (possibly crashing) if it
encountered a stored integer.  This is a design failure.

=end original

Perl 5.6.x は、perlインタープリタが32ビット・システムで64ビットintegerを
格納できるスカラを可能にするCのC<long long>型を使う、オプションの構成設定の
機能を導入しました。しかしWindowsプラットホーム以外で
Perl構成設定システムがC構成設定ファイルを生成した方法や、
Storableがそのハンドラを生成する方法のために、
Storableは別にいくつかのデータをファイルに格納しているにも関わらず
perlが32あるいは64ビットintegerを使って出力したかは、
Storableファイル・ヘッダの内容に反映されません。
このため64ビットintegerでperlを実行しているStorableは32ビットperlによって
出力されたファイルからのヘッダを読み、データが実際には微妙に互換性のない
ものであると理解せず、格納されたintegerにぶつかると恐ろしい間違いを起こすでしょう
（おそらくはクラッシュしてしまいます）。これは設計上の失敗です。

=begin original

Storable has now been changed to write out and read in a file header with
information about the size of integers.  It's impossible to detect whether
an old file being read in was written with 32 or 64 bit integers (they have
the same header) so it's impossible to automatically switch to a correct
backwards compatibility mode.  Hence this Storable defaults to the new,
correct behaviour.

=end original

Storableは現在はintegerの大きさについての情報を持ったファイル・ヘッダを
出力し、読み込むように変更されています。読み込まれた古いファイルが、32ビット
integerなのか64ビットなのかを判定することはできません（同じヘッダを持っています）。
そのため自動的に正しい後方互換性モードに自動的に移ることはできません。
そのためStorableはデフォルトでは、新しい正しい動きをになっています。

=begin original

What this means is that if you have data written by Storable 1.x running
on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux
then by default this Storable will refuse to read it, giving the error
I<Byte order is not compatible>.  If you have such data then you you
should set C<$Storable::interwork_56_64bit> to a true value to make this
Storable read and write files with the old header.  You should also
migrate your data, or any older perl you are communicating with, to this
current version of Storable.

=end original

これが意味することは、UnixあるいはLinux上で64ビットintegerで構成設定された
perl 5.6.0や5.6.1で実行した Storable 1.xによって書かれたデータを持っている
のであれば、デフォルトではこのStorableはそれを読み込むことを拒絶し、
I<Byte order is not compatible>（バイト順に互換性がありません）というエラーに
なります。もしそのようなデータを持っているのであれば、
このStorableが古いヘッダを持っているファイルを読み書きできるよう、
C<$Storable::interwork_56_64bit>をtrue値に設定しなければなりません。
あなたデータやあなたが通信する古いperlを、Storableこの現行バージョンに
移すこともしなければなりません。

=begin original

If you don't have data written with specific configuration of perl described
above, then you do not and should not do anything.  Don't set the flag -
not only will Storable on an identically configured perl refuse to load them,
but Storable a differently configured perl will load them believing them
to be correct for it, and then may well fail or crash part way through
reading them.

=end original

上記で記述された特定のperlの構成設定で書かれたデータを持っていなければ、
何もしなくてもいいですし、するべきでもありません。フラグを設定しないでください- 
同じように構成設定されたperlでのStorableが、それらをロードすることを拒絶する
だけでなく、違うように構成設定されたperlでのStorableが、それらをそれにとって
正しいものと信じてロードし、読み込んでいる途中で失敗したり、クラッシュしてしまいます。

=head1 CREDITS

=begin original

Thank you to (in chronological order):

=end original

以下の方に感謝いたします。 (時間順）：

	Jarkko Hietaniemi <jhi@iki.fi>
	Ulrich Pfeifer <pfeifer@charly.informatik.uni-dortmund.de>
	Benjamin A. Holzman <bah@ecnvantage.com>
	Andrew Ford <A.Ford@ford-mason.co.uk>
	Gisle Aas <gisle@aas.no>
	Jeff Gresham <gresham_jeffrey@jpmorgan.com>
	Murray Nesbitt <murray@activestate.com>
	Marc Lehmann <pcg@opengroup.org>
	Justin Banks <justinb@wamnet.com>
	Jarkko Hietaniemi <jhi@iki.fi> (AGAIN, as perl 5.7.0 Pumpkin!)
	Salvador Ortiz Garcia <sog@msg.com.mx>
	Dominic Dunlop <domo@computer.org>
	Erik Haugan <erik@solbors.no>

=begin original

for their bug reports, suggestions and contributions.

=end original

バグ報告、提案、貢献がありました。

=begin original

Benjamin Holzman contributed the tied variable support, Andrew Ford
contributed the canonical order for hashes, and Gisle Aas fixed
a few misunderstandings of mine regarding the perl internals,
and optimized the emission of "tags" in the output streams by
simply counting the objects instead of tagging them (leading to
a binary incompatibility for the Storable image starting at version
0.6--older images are, of course, still properly understood).
Murray Nesbitt made Storable thread-safe.  Marc Lehmann added overloading
and references to tied items support.

=end original

Benjamin Holzman はtieされた変数のサポートに貢献してくれました。
Andrew Ford はハッシュための標準様式に貢献してくれました。
そしてGisle Aas はPerlの内部についての私の誤解を修正し、タグを
つける代わりに単純にオブジェクトの数を数えることによって、
出力ストリームでの「タグ」の吐き出しを最適化してくれました。
（これによりバージョン0.6以降でバイナリでのStorableイメージの
互換性をなくすことになりました。しかし古いイメージもまだきちんと
理解されます。）Murray Nesbitt はStorableをスレッド・セーフにしてくれました。
Marc Lehmannはtieされている要素へのオーバーロードと参照のサポートを
追加してくれました。

=head1 AUTHOR

=begin original

Storable was written by Raphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
Maintenance is now done by the perl5-porters F<E<lt>perl5-porters@perl.orgE<gt>>

=end original

StorableはRaphael Manfredi <Raphael_Manfredi@pobox.com> によって作成されました。
現在、perl5-porters <perl5-porters@perl.org>　によってメンテナンスされています。

=begin original

Please e-mail us with problems, bug fixes, comments and complaints,
although if you have complements you should send them to Raphael.
Please don't e-mail Raphael with problems, as he no longer works on
Storable, and your message will be delayed while he forwards it to us.

=end original

たとえRaphaelに送信するべき補足するものを持っていたとしても、障害、バグ修正、
コメント、苦情については私たちにメールしてください。どうか障害についてRaphaeに
メールしないでください。彼はもうStorableについて取り組んでいません。
そしてあなたのメッセージは彼が私たちに転送するまで遅れてしまいます。

=head1 SEE ALSO

L<Clone>.

=cut

