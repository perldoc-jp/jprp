
=encoding euc-jp

=head1 NAME

=begin original

perlxstypemap - Perl XS C/Perl type mapping

=end original

perlxstypemap - Perl XS C/Perl 型マッピング

=head1 DESCRIPTION

=begin original

The more you think about interfacing between two languages, the more
you'll realize that the majority of programmer effort has to go into
converting between the data structures that are native to either of
the languages involved.  This trumps other matter such as differing
calling conventions because the problem space is so much greater.
There are simply more ways to shove data into memory than there are
ways to implement a function call.

=end original

二つの言語の間のインターフェースについて考えれば考えるほど、プログラマの
努力の大半はどちらかの言語にネイティブなデータ構造の変換に費やされることに
気付くことになります。
これは呼び出し規則の違いといったものより重要です; 問題空間が遥かに
大きいからです。
単純に、関数呼び出しを実装する方法よりデータをメモリに納める方法の方が遥かに
多いです。

=begin original

Perl XS' attempt at a solution to this is the concept of typemaps.
At an abstract level, a Perl XS typemap is nothing but a recipe for
converting from a certain Perl data structure to a certain C
data structure and vice versa.  Since there can be C types that
are sufficiently similar to warrant converting with the same logic,
XS typemaps are represented by a unique identifier, henceforth
called an   <XS type> in this document.  You can then tell the XS
compiler that multiple C types are to be mapped with the same
XS typemap.

=end original

これに対する Perl XS での解決の試みは、typemap という概念です。
抽象レベルでは、Perl の XS typemap はある種の Perl データ構造からある種の
C データ構造、およびその逆への変換のためのレシピ以外の何者でもありません。
同じロジックでの変換を保証することと十分に似ている C 型もあるので、
XS typemap はユニークな識別子として表現され、以降この文書では「XS 型」
<XS type> と呼ばれます。
それから複数の C 型が同じ XS typemap にマッピングされるように XS コンパイラに
伝えることができます。

=begin original

In your XS code, when you define an argument with a C type or when
you are using a C<CODE:> and an C<OUTPUT:> section together with a
C return type of your XSUB, it'll be the typemapping mechanism that
makes this easy.

=end original

XS コード中で、C 型の引数を定義したり、XSUB の C 返り型と
C<CODE:> と C<OUTPUT:> の節を共に使ったりする場合、
これらを簡単にするために typemap 機構があります。

=head2 Anatomy of a typemap

(typemap の構造)

=begin original

In more practical terms, the typemap is a collection of code
fragments which are used by the B<xsubpp> compiler to map C function
parameters and values to Perl values.  The typemap file may consist
of three sections labelled C<TYPEMAP>, C<INPUT>, and C<OUTPUT>.
An unlabelled initial section is assumed to be a C<TYPEMAP> section.
The INPUT section tells the compiler how to translate Perl values
into variables of certain C types.  The OUTPUT section tells the
compiler how to translate the values from certain C types into values
Perl can understand.  The TYPEMAP section tells the compiler which
of the INPUT and OUTPUT code fragments should be used to map a given
C type to a Perl value.  The section labels C<TYPEMAP>, C<INPUT>, or
C<OUTPUT> must begin in the first column on a line by themselves,
and must be in uppercase.

=end original

より実際的な用語としては、typemap は C 関数の引数と値を Perl の値に
マッピングするために B<xsubpp> コンパイラによって使われるコード片の集合
(collection)です。
typemap ファイルは C<TYPEMAP>, C<INPUT>, C<OUTPUT> というラベルの付いた
三つのセクションから構成されます。
ラベルのついていない初期化セクションは、C<TYPEMAP> であるかのように
仮定されます。
INPUT セクションは、コンパイラに対して Perl の値をどのように
(幾つかある) C の型に変換するかを指示します。
OUTPUT セクションは、コンパイラに対してどのようにして C の型を Perl が
認識できる値に変換するのかを指示します。
TYPEMAP セクションは、コンパイラに対して指示された C の型を Perl の値に
マッピングするのに使うべき INPUT セクションもしくは OUTPUT セクションに
あるコード片を指示します。
セクションラベル C<TYPEMAP>, C<INPUT>, C<OUTPUT> は行の先頭におかれ、
大文字でなければなりません。

=begin original

Each type of section can appear an arbitrary number of times
and does not have to appear at all.  For example, a typemap may
commonly lack C<INPUT> and C<OUTPUT> sections if all it needs to
do is associate additional C types with core XS types like T_PTROBJ.
Lines that start with a hash C<#> are considered comments and ignored
in the C<TYPEMAP> section, but are considered significant in C<INPUT>
and C<OUTPUT>. Blank lines are generally ignored.

=end original

Each type of section can appear an arbitrary number of times
and does not have to appear at all.  For example, a typemap may
commonly lack C<INPUT> and C<OUTPUT> sections if all it needs to
do is associate additional C types with core XS types like T_PTROBJ.
Lines that start with a hash C<#> are considered comments and ignored
in the C<TYPEMAP> section, but are considered significant in C<INPUT>
and C<OUTPUT>. Blank lines are generally ignored.
(TBT)

=begin original

Traditionally, typemaps needed to be written to a separate file,
conventionally called C<typemap> in a CPAN distribution.  With
ExtUtils::ParseXS (the XS compiler) version 3.12 or better which
comes with perl 5.16, typemaps can also be embedded directly into
XS code using a HERE-doc like syntax:

=end original

Traditionally, typemaps needed to be written to a separate file,
conventionally called C<typemap> in a CPAN distribution.  With
ExtUtils::ParseXS (the XS compiler) version 3.12 or better which
comes with perl 5.16, typemaps can also be embedded directly into
XS code using a HERE-doc like syntax:
(TBT)

  TYPEMAP: <<HERE
  ...
  HERE

=begin original

where C<HERE> can be replaced by other identifiers like with normal
Perl HERE-docs.  All details below about the typemap textual format
remain valid.

=end original

where C<HERE> can be replaced by other identifiers like with normal
Perl HERE-docs.  All details below about the typemap textual format
remain valid.
(TBT)

=begin original

The C<TYPEMAP> section should contain one pair of C type and
XS type per line as follows.  An example from the core typemap file:

=end original

The C<TYPEMAP> section should contain one pair of C type and
XS type per line as follows.  An example from the core typemap file:
(TBT)

  TYPEMAP
  # all variants of char* is handled by the T_PV typemap
  char *          T_PV
  const char *    T_PV
  unsigned char * T_PV
  ...

=begin original

The C<INPUT> and C<OUTPUT> sections have identical formats, that is,
each unindented line starts a new in- or output map respectively.
A new in- or output map must start with the name of the XS type to
map on a line by itself, followed by the code that implements it
indented on the following lines. Example:

=end original

The C<INPUT> and C<OUTPUT> sections have identical formats, that is,
each unindented line starts a new in- or output map respectively.
A new in- or output map must start with the name of the XS type to
map on a line by itself, followed by the code that implements it
indented on the following lines. Example:
(TBT)

  INPUT
  T_PV
    $var = ($type)SvPV_nolen($arg)
  T_PTR
    $var = INT2PTR($type,SvIV($arg))

=begin original

We'll get to the meaning of those Perlish-looking variables in a
little bit.

=end original

We'll get to the meaning of those Perlish-looking variables in a
little bit.
(TBT)

=begin original

Finally, here's an example of the full typemap file for mapping C
strings of the C<char *> type to Perl scalars/strings:

=end original

Finally, here's an example of the full typemap file for mapping C
strings of the C<char *> type to Perl scalars/strings:
(TBT)

  TYPEMAP
  char *  T_PV
  
  INPUT
  T_PV
    $var = ($type)SvPV_nolen($arg)
  
  OUTPUT
  T_PV
    sv_setpv((SV*)$arg, $var);

=begin original

Here's a more complicated example: suppose that you wanted
C<struct netconfig> to be blessed into the class C<Net::Config>.
One way to do this is to use underscores (_) to separate package
names, as follows:

=end original

もっと複雑な例を挙げましょう。
C<struct netconfig> を C<Net::Config> というクラスに bless したいと
考えていると仮定しましょう。
これを行うやり方の一つは、アンダースコア(_)を以下の様にパッケージ名を
区切るために使うというものです。

  typedef struct netconfig * Net_Config;

=begin original

And then provide a typemap entry C<T_PTROBJ_SPECIAL> that maps
underscores to double-colons (::), and declare C<Net_Config> to be of
that type:

=end original

それからアンダースコアをダブルコロン(::)にマップする typemap
エントリー C<T_PTROBJ_SPECIAL> を用意して、C<Net_Config> をその型と
して宣言します。

  TYPEMAP
  Net_Config      T_PTROBJ_SPECIAL
  
  INPUT
  T_PTROBJ_SPECIAL
    if (sv_derived_from($arg, \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\")){
      IV tmp = SvIV((SV*)SvRV($arg));
      $var = INT2PTR($type, tmp);
    }
    else
      croak(\"$var is not of type ${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\")
  
  OUTPUT
  T_PTROBJ_SPECIAL
    sv_setref_pv($arg, \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\",
                 (void*)$var);

=begin original

The INPUT and OUTPUT sections substitute underscores for double-colons
on the fly, giving the desired effect.  This example demonstrates some
of the power and versatility of the typemap facility.

=end original

INPUT セクションと OUTPUT セクションはアンダースコアをダブルコロンへ
その場で置換して、期待される効果をもたらします。
この例では typemap 機構の威力と適用範囲の広さを例示します。

=begin original

The C<INT2PTR> macro (defined in perl.h) casts an integer to a pointer
of a given type, taking care of the possible different size of integers
and pointers.  There are also C<PTR2IV>, C<PTR2UV>, C<PTR2NV> macros,
to map the other way, which may be useful in OUTPUT sections.

=end original

(perl.h に定義されている) C<INT2PTR> マクロは、整数から与えられた型の
ポインタへのキャストを、整数とポインタとのサイズが異なる可能性を
考慮しつつ行います。
また、OUTPUT セクションで有用かもしれない、他の方法でマッピングする、
C<PTR2IV>, C<PTR2UV>, C<PTR2NV> マクロもあります。

=head2 The Role of the typemap File in Your Distribution

(配布の中の typemap ファイルの役割)

=begin original

The default typemap in the F<lib/ExtUtils> directory of the Perl source
contains many useful types which can be used by Perl extensions.  Some
extensions define additional typemaps which they keep in their own directory.
These additional typemaps may reference INPUT and OUTPUT maps in the main
typemap.  The B<xsubpp> compiler will allow the extension's own typemap to
override any mappings which are in the default typemap.  Instead of using
an additional F<typemap> file, typemaps may be embedded verbatim in XS
with a heredoc-like syntax.  See the documentation on the C<TYPEMAP:> XS
keyword.

=end original

Perl のソースの F<lib/ExtUtils> ディレクトリにあるデフォルトの typemap は
Perl のエクステンションから使うことのできるたくさんの便利な型があります。
一部のエクステンションではそれに固有のディレクトリに、typemap に対する
追加の定義を置いています。
これらの追加された typemap はメインの typemap にある INPUT や OUTPUT の
マッピングを参照することができます。
B<xsubpp> コンパイラは、エクステンションに固有の typemap が
デフォルトの typemap にあるマッピングをオーバーライドすることを許しています。
追加の F<typemap> ファイルを使う代わりに、typemap はヒヤドキュメント風の
文法を使って XS にそのまま組み込むことができます。
C<TYPEMAP:> XS キーワードの文書を参照してください。

=begin original

For CPAN distributions, you can assume that the XS types defined by
the perl core are already available. Additionally, the core typemap
has default XS types for a large number of C types.  For example, if
you simply return a C<char *> from your XSUB, the core typemap will
have this C type associated with the T_PV XS type.  That means your
C string will be copied into the PV (pointer value) slot of a new scalar
that will be returned from your XSUB to to Perl.

=end original

For CPAN distributions, you can assume that the XS types defined by
the perl core are already available. Additionally, the core typemap
has default XS types for a large number of C types.  For example, if
you simply return a C<char *> from your XSUB, the core typemap will
have this C type associated with the T_PV XS type.  That means your
C string will be copied into the PV (pointer value) slot of a new scalar
that will be returned from your XSUB to to Perl.
(TBT)

=begin original

If you're developing a CPAN distribution using XS, you may add your own
file called F<typemap> to the distribution.  That file may contain
typemaps that either map types that are specific to your code or that
override the core typemap file's mappings for common C types.

=end original

If you're developing a CPAN distribution using XS, you may add your own
file called F<typemap> to the distribution.  That file may contain
typemaps that either map types that are specific to your code or that
override the core typemap file's mappings for common C types.
(TBT)

=head2 Sharing typemaps Between CPAN Distributions

(CPAN 配布間で typemap を共有する)

=begin original

Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16
and better), it is rather easy to share typemap code between multiple
CPAN distributions. The general idea is to share it as a module that
offers a certain API and have the dependent modules declare that as a
built-time requirement and import the typemap into the XS. An example
of such a typemap-sharing module on CPAN is
C<ExtUtils::Typemaps::Basic>. Two steps to getting that module's
typemaps available in your code:

=end original

(perl 5.16 以降に同梱されている) ExtUtils::ParseXS バージョン 3.13_01 から、
it is rather easy to share typemap code between multiple
CPAN distributions. The general idea is to share it as a module that
offers a certain API and have the dependent modules declare that as a
built-time requirement and import the typemap into the XS. An example
of such a typemap-sharing module on CPAN is
C<ExtUtils::Typemaps::Basic>. Two steps to getting that module's
typemaps available in your code:
(TBT)

=over 4

=item *

=begin original

Declare C<ExtUtils::Typemaps::Basic> as a build-time dependency
in C<Makefile.PL> (use C<BUILD_REQUIRES>), or in your C<Build.PL>
(use C<build_requires>).

=end original


C<Makefile.PL> (C<BUILD_REQUIRES> を使う) または C<Build.PL>
(C<build_requires> を使う) で、ビルド時依存として
C<ExtUtils::Typemaps::Basic> を宣言する。

=item *

=begin original

Include the following line in the XS section of your XS file:
(don't break the line)

=end original

XS ファイルの XS 節に以下の行を含めてください:
(行は分割しないでください)

  INCLUDE_COMMAND: $^X -MExtUtils::Typemaps::Cmd
                   -e "print embeddable_typemap(q{Basic})"

=back

=head2 Writing typemap Entries

(typemap エントリを書く)

=begin original

Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that
will be evaluated in the presence of certain variables to get the
final C code for mapping a certain C type.

=end original

それぞれの INPUT または OUTPUT typemap エントリは、特定の C 型に
マッピングするための最終的な C コードを得るために、特定の変数の存在が
評価される、ダブルクォートで囲まれた Perl 文字列です。

=begin original

This means that you can embed Perl code in your typemap (C) code using
constructs such as
C<${ perl code that evaluates to scalar reference here }>. A common
use case is to generate error messages that refer to the true function
name even when using the ALIAS XS feature:

=end original

つまり、C<${ ここにスカラリファレンスに評価される perl コード }> のような
構文を使って、typemap (C) コードの中に Perl コードを
組み込めるということです。
一般的な使用法は、ALIAS XS 機能を使っているときでも、真の関数名を参照する
エラーメッセージを生成することです:

  ${ $ALIAS ? \q[GvNAME(CvGV(cv))] : \qq[\"$pname\"] }

=begin original

For many typemap examples, refer to the core typemap file that can be
found in the perl source tree at F<lib/ExtUtils/typemap>.

=end original

多くの typemap の例で、perl ソースツリーの F<lib/ExtUtils/typemap> にある
コア typemap ファイルを参照しています。

=begin original

The Perl variables that are available for interpolation into typemaps
are the following:

=end original

typemap へ展開可能な Perl 変数は以下のものです:

=over 4

=item *

=begin original

I<$var> - the name of the input or output variable, eg. RETVAL for
return values.

=end original

I<$var> - 入力または出力の変数名; 例えば返り値の RETVAL。

=item *

=begin original

I<$type> - the raw C type of the parameter, any C<:> replaced with
C<_>.

=end original

I<$type> - 引数の生の C 型; C<:> は C<_> に置換されます。

=item *

=begin original

I<$ntype> - the supplied type with C<*> replaced with C<Ptr>.
e.g. for a type of C<Foo::Bar>, I<$ntype> is C<Foo::Bar>

=end original

I<$ntype> - 提供された型 ; C<*> は C<Ptr> に置換されます。
例えば C<Foo::Bar> の型では、I<$ntype> は C<Foo::Bar> です。

=item *

=begin original

I<$arg> - the stack entry, that the parameter is input from or output
to, e.g. C<ST(0)>

=end original

I<$arg> - スタックエントリ; 引数は入力または出力; 例えば C<ST(0)>

=item *

=begin original

I<$argoff> - the argument stack offset of the argument.  ie. 0 for the
first argument, etc.

=end original

I<$argoff> - 引数の引数スタックオフセット。
つまり、最初の引数は 0、など。

=item *

=begin original

I<$pname> - the full name of the XSUB, with including the C<PACKAGE>
name, with any C<PREFIX> stripped.  This is the non-ALIAS name.

=end original

I<$pname> - XSUB 完全名; C<PACKAGE> 名を含み、C<PREFIX> は除去されます。
これは非-ALIAS 名です。

=item *

=begin original

I<$Package> - the package specified by the most recent C<PACKAGE>
keyword.

=end original

I<$Package> - もっとも最近の C<PACKAGE> キーワードで指定されたパッケージ。

=item *

=begin original

I<$ALIAS> - non-zero if the current XSUB has any aliases declared with
C<ALIAS>.

=end original

I<$ALIAS> - 現在の XSUB が C<ALIAS> で宣言された別名を持っていれば非 0。

=back

=head2 Full Listing of Core Typemaps

(コア typemap の完全な一覧)

=begin original

Each C type is represented by an entry in the typemap file that
is responsible for converting perl variables (SV, AV, HV, CV, etc.)
to and from that type. The following sections list all XS types
that come with perl by default.

=end original

Each C type is represented by an entry in the typemap file that
is responsible for converting perl variables (SV, AV, HV, CV, etc.)
to and from that type. The following sections list all XS types
that come with perl by default.
(TBT)

=over 4

=item T_SV

=begin original

This simply passes the C representation of the Perl variable (an SV*)
in and out of the XS layer. This can be used if the C code wants
to deal directly with the Perl variable.

=end original

This simply passes the C representation of the Perl variable (an SV*)
in and out of the XS layer. This can be used if the C code wants
to deal directly with the Perl variable.
(TBT)

=item T_SVREF

=begin original

Used to pass in and return a reference to an SV.

=end original

SV へのリファレンスを渡したり返したりするために使われます。

=begin original

Note that this typemap does not decrement the reference count
when returning the reference to an SV*.
See also: T_SVREF_REFCOUNT_FIXED

=end original

Note that this typemap does not decrement the reference count
when returning the reference to an SV*.
See also: T_SVREF_REFCOUNT_FIXED
(TBT)

=item T_SVREF_FIXED

=begin original

Used to pass in and return a reference to an SV.
This is a fixed
variant of T_SVREF that decrements the refcount appropriately
when returning a reference to an SV*. Introduced in perl 5.15.4.

=end original

Used to pass in and return a reference to an SV.
This is a fixed
variant of T_SVREF that decrements the refcount appropriately
when returning a reference to an SV*. Introduced in perl 5.15.4.
(TBT)

=item T_AVREF

=begin original

From the perl level this is a reference to a perl array.
From the C level this is a pointer to an AV.

=end original

perl レベルでは perl 配列へのリファレンスです。
C レベルでは AV へのポインタです。

=begin original

Note that this typemap does not decrement the reference count
when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED

=end original

この typemap は AV* を返すときに参照カウントをデクリメントしないことに
注意してください。
T_AVREF_REFCOUNT_FIXED も参照してください。

=item T_AVREF_REFCOUNT_FIXED

=begin original

From the perl level this is a reference to a perl array.
From the C level this is a pointer to an AV. This is a fixed
variant of T_AVREF that decrements the refcount appropriately
when returning an AV*. Introduced in perl 5.15.4.

=end original

From the perl level this is a reference to a perl array.
From the C level this is a pointer to an AV. This is a fixed
variant of T_AVREF that decrements the refcount appropriately
when returning an AV*. Introduced in perl 5.15.4.
(TBT)

=item T_HVREF

=begin original

From the perl level this is a reference to a perl hash.
From the C level this is a pointer to an HV.

=end original

From the perl level this is a reference to a perl hash.
From the C level this is a pointer to an HV.
(TBT)

=begin original

Note that this typemap does not decrement the reference count
when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED

=end original

Note that this typemap does not decrement the reference count
when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED
(TBT)

=item T_HVREF_REFCOUNT_FIXED

=begin original

From the perl level this is a reference to a perl hash.
From the C level this is a pointer to an HV. This is a fixed
variant of T_HVREF that decrements the refcount appropriately
when returning an HV*. Introduced in perl 5.15.4.

=end original

From the perl level this is a reference to a perl hash.
From the C level this is a pointer to an HV. This is a fixed
variant of T_HVREF that decrements the refcount appropriately
when returning an HV*. Introduced in perl 5.15.4.
(TBT)

=item T_CVREF

=begin original

From the perl level this is a reference to a perl subroutine
(e.g. $sub = sub { 1 };). From the C level this is a pointer
to a CV.

=end original

From the perl level this is a reference to a perl subroutine
(e.g. $sub = sub { 1 };). From the C level this is a pointer
to a CV.
(TBT)

=begin original

Note that this typemap does not decrement the reference count
when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED

=end original

Note that this typemap does not decrement the reference count
when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED
(TBT)

=item T_CVREF_REFCOUNT_FIXED

=begin original

From the perl level this is a reference to a perl subroutine
(e.g. $sub = sub { 1 };). From the C level this is a pointer
to a CV.

=end original

From the perl level this is a reference to a perl subroutine
(e.g. $sub = sub { 1 };). From the C level this is a pointer
to a CV.
(TBT)

=begin original

This is a fixed
variant of T_HVREF that decrements the refcount appropriately
when returning an HV*. Introduced in perl 5.15.4.

=end original

This is a fixed
variant of T_HVREF that decrements the refcount appropriately
when returning an HV*. Introduced in perl 5.15.4.
(TBT)

=item T_SYSRET

=begin original

The T_SYSRET typemap is used to process return values from system calls.
It is only meaningful when passing values from C to perl (there is
no concept of passing a system return value from Perl to C).

=end original

The T_SYSRET typemap is used to process return values from system calls.
It is only meaningful when passing values from C to perl (there is
no concept of passing a system return value from Perl to C).
(TBT)

=begin original

System calls return -1 on error (setting ERRNO with the reason)
and (usually) 0 on success. If the return value is -1 this typemap
returns C<undef>. If the return value is not -1, this typemap
translates a 0 (perl false) to "0 but true" (which
is perl true) or returns the value itself, to indicate that the
command succeeded.

=end original

System calls return -1 on error (setting ERRNO with the reason)
and (usually) 0 on success. If the return value is -1 this typemap
returns C<undef>. If the return value is not -1, this typemap
translates a 0 (perl false) to "0 but true" (which
is perl true) or returns the value itself, to indicate that the
command succeeded.
(TBT)

=begin original

The L<POSIX|POSIX> module makes extensive use of this type.

=end original

L<POSIX|POSIX> モジュールはこの型を広範囲に使います。

=item T_UV

=begin original

An unsigned integer.

=end original

符号なし整数。

=item T_IV

=begin original

A signed integer. This is cast to the required integer type when
passed to C and converted to an IV when passed back to Perl.

=end original

符号付き整数。
This is cast to the required integer type when
passed to C and converted to an IV when passed back to Perl.
(TBT)

=item T_INT

=begin original

A signed integer. This typemap converts the Perl value to a native
integer type (the C<int> type on the current platform). When returning
the value to perl it is processed in the same way as for T_IV.

=end original

符号付き整数。
This typemap converts the Perl value to a native
integer type (the C<int> type on the current platform). When returning
the value to perl it is processed in the same way as for T_IV.
(TBT)

=begin original

Its behaviour is identical to using an C<int> type in XS with T_IV.

=end original

この振る舞いは XS で T_IV 付きで C<int> を使うのと同じです。

=item T_ENUM

=begin original

An enum value. Used to transfer an enum component
from C. There is no reason to pass an enum value to C since
it is stored as an IV inside perl.

=end original

列挙値。
C から列挙要素を転送するために使われます。
C に列挙値を渡す理由はありません; perl の内部では IV として
保管されているからです。

=item T_BOOL

=begin original

A boolean type. This can be used to pass true and false values to and
from C.

=end original

真偽値型。
これは C との間で真と偽の値を渡すために使えます。

=item T_U_INT

=begin original

This is for unsigned integers. It is equivalent to using T_UV
but explicitly casts the variable to type C<unsigned int>.
The default type for C<unsigned int> is T_UV.

=end original

これは符号なし整数のためのものです。
It is equivalent to using T_UV
but explicitly casts the variable to type C<unsigned int>.
The default type for C<unsigned int> is T_UV.
(TBT)

=item T_SHORT

=begin original

Short integers. This is equivalent to T_IV but explicitly casts
the return to type C<short>. The default typemap for C<short>
is T_IV.

=end original

short 整数。
This is equivalent to T_IV but explicitly casts
the return to type C<short>. The default typemap for C<short>
is T_IV.
(TBT)

=item T_U_SHORT

=begin original

Unsigned short integers. This is equivalent to T_UV but explicitly
casts the return to type C<unsigned short>. The default typemap for
C<unsigned short> is T_UV.

=end original

符号なし short 整数。
This is equivalent to T_UV but explicitly
casts the return to type C<unsigned short>. The default typemap for
C<unsigned short> is T_UV.
(TBT)

=begin original

T_U_SHORT is used for type C<U16> in the standard typemap.

=end original

T_U_SHORT は標準 typemap での C<U16> 型で使われます。

=item T_LONG

=begin original

Long integers. This is equivalent to T_IV but explicitly casts
the return to type C<long>. The default typemap for C<long>
is T_IV.

=end original

long 整数。
This is equivalent to T_IV but explicitly casts
the return to type C<long>. The default typemap for C<long>
is T_IV.
(TBT)

=item T_U_LONG

=begin original

Unsigned long integers. This is equivalent to T_UV but explicitly
casts the return to type C<unsigned long>. The default typemap for
C<unsigned long> is T_UV.

=end original

符号なし long 整数。
This is equivalent to T_UV but explicitly
casts the return to type C<unsigned long>. The default typemap for
C<unsigned long> is T_UV.
(TBT)

=begin original

T_U_LONG is used for type C<U32> in the standard typemap.

=end original

T_U_LONG は標準 typemap での C<U32> 型で使われます。

=item T_CHAR

=begin original

Single 8-bit characters.

=end original

単一の 8 ビット文字。

=item T_U_CHAR

=begin original

An unsigned byte.

=end original

符号なしバイト。

=item T_FLOAT

=begin original

A floating point number. This typemap guarantees to return a variable
cast to a C<float>.

=end original

浮動小数点数。
この typemap は C<float> にキャストした変数を返すことを保証します。

=item T_NV

=begin original

A Perl floating point number. Similar to T_IV and T_UV in that the
return type is cast to the requested numeric type rather than
to a specific type.

=end original

Perl の浮動小数点数。
Similar to T_IV and T_UV in that the
return type is cast to the requested numeric type rather than
to a specific type.
(TBT)

=item T_DOUBLE

=begin original

A double precision floating point number. This typemap guarantees to
return a variable cast to a C<double>.

=end original

倍精度浮動小数点数。
This typemap guarantees to
return a variable cast to a C<double>.
(TBT)

=item T_PV

=begin original

A string (char *).

=end original

文字列 (char *)。

=item T_PTR

=begin original

A memory address (pointer). Typically associated with a C<void *>
type.

=end original

メモリアドレス(ポインタ)。
典型的には C<void *> 型に結びつけられます。

=item T_PTRREF

=begin original

Similar to T_PTR except that the pointer is stored in a scalar and the
reference to that scalar is returned to the caller. This can be used
to hide the actual pointer value from the programmer since it is usually
not required directly from within perl.

=end original

Similar to T_PTR except that the pointer is stored in a scalar and the
reference to that scalar is returned to the caller. This can be used
to hide the actual pointer value from the programmer since it is usually
not required directly from within perl.
(TBT)

=begin original

The typemap checks that a scalar reference is passed from perl to XS.

=end original

typemap はスカラリファレンスが perl から XS に渡されたことをチェックします。

=item T_PTROBJ

=begin original

Similar to T_PTRREF except that the reference is blessed into a class.
This allows the pointer to be used as an object. Most commonly used to
deal with C structs. The typemap checks that the perl object passed
into the XS routine is of the correct class (or part of a subclass).

=end original

Similar to T_PTRREF except that the reference is blessed into a class.
This allows the pointer to be used as an object. Most commonly used to
deal with C structs. The typemap checks that the perl object passed
into the XS routine is of the correct class (or part of a subclass).
(TBT)

=begin original

The pointer is blessed into a class that is derived from the name
of type of the pointer but with all '*' in the name replaced with
'Ptr'.

=end original

The pointer is blessed into a class that is derived from the name
of type of the pointer but with all '*' in the name replaced with
'Ptr'.
(TBT)

=item T_REF_IV_REF

=begin original

NOT YET

=end original

未記述

=item T_REF_IV_PTR

=begin original

Similar to T_PTROBJ in that the pointer is blessed into a scalar object.
The difference is that when the object is passed back into XS it must be
of the correct type (inheritance is not supported).

=end original

Similar to T_PTROBJ in that the pointer is blessed into a scalar object.
The difference is that when the object is passed back into XS it must be
of the correct type (inheritance is not supported).
(TBT)

=begin original

The pointer is blessed into a class that is derived from the name
of type of the pointer but with all '*' in the name replaced with
'Ptr'.

=end original

The pointer is blessed into a class that is derived from the name
of type of the pointer but with all '*' in the name replaced with
'Ptr'.
(TBT)

=item T_PTRDESC

=begin original

NOT YET

=end original

未記述

=item T_REFREF

=begin original

Similar to T_PTRREF, except the pointer stored in the referenced scalar
is dereferenced and copied to the output variable. This means that
T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?

=end original

Similar to T_PTRREF, except the pointer stored in the referenced scalar
is dereferenced and copied to the output variable. This means that
T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?
(TBT)

=begin original

Only the INPUT part of this is implemented (Perl to XSUB) and there
are no known users in core or on CPAN.

=end original

これは INPUT 部 (Perl から XSUB) のみが実装されていて、コアや CPAN で
使っているコードは知られていません。

=item T_REFOBJ

=begin original

NOT YET

=end original

未記述

=item T_OPAQUEPTR

=begin original

This can be used to store bytes in the string component of the
SV. Here the representation of the data is irrelevant to perl and the
bytes themselves are just stored in the SV. It is assumed that the C
variable is a pointer (the bytes are copied from that memory
location).  If the pointer is pointing to something that is
represented by 8 bytes then those 8 bytes are stored in the SV (and
length() will report a value of 8). This entry is similar to T_OPAQUE.

=end original

This can be used to store bytes in the string component of the
SV. Here the representation of the data is irrelevant to perl and the
bytes themselves are just stored in the SV. It is assumed that the C
variable is a pointer (the bytes are copied from that memory
location).  If the pointer is pointing to something that is
represented by 8 bytes then those 8 bytes are stored in the SV (and
length() will report a value of 8). This entry is similar to T_OPAQUE.
(TBT)

=begin original

In principle the unpack() command can be used to convert the bytes
back to a number (if the underlying type is known to be a number).

=end original

In principle the unpack() command can be used to convert the bytes
back to a number (if the underlying type is known to be a number).
(TBT)

=begin original

This entry can be used to store a C structure (the number
of bytes to be copied is calculated using the C C<sizeof> function)
and can be used as an alternative to T_PTRREF without having to worry
about a memory leak (since Perl will clean up the SV).

=end original

This entry can be used to store a C structure (the number
of bytes to be copied is calculated using the C C<sizeof> function)
and can be used as an alternative to T_PTRREF without having to worry
about a memory leak (since Perl will clean up the SV).
(TBT)

=item T_OPAQUE

=begin original

This can be used to store data from non-pointer types in the string
part of an SV. It is similar to T_OPAQUEPTR except that the
typemap retrieves the pointer directly rather than assuming it
is being supplied. For example, if an integer is imported into
Perl using T_OPAQUE rather than T_IV the underlying bytes representing
the integer will be stored in the SV but the actual integer value will
not be available. i.e. The data is opaque to perl.

=end original

This can be used to store data from non-pointer types in the string
part of an SV. It is similar to T_OPAQUEPTR except that the
typemap retrieves the pointer directly rather than assuming it
is being supplied. For example, if an integer is imported into
Perl using T_OPAQUE rather than T_IV the underlying bytes representing
the integer will be stored in the SV but the actual integer value will
not be available. i.e. The data is opaque to perl.
(TBT)

=begin original

The data may be retrieved using the C<unpack> function if the
underlying type of the byte stream is known.

=end original

The data may be retrieved using the C<unpack> function if the
underlying type of the byte stream is known.
(TBT)

=begin original

T_OPAQUE supports input and output of simple types.
T_OPAQUEPTR can be used to pass these bytes back into C if a pointer
is acceptable.

=end original

T_OPAQUE supports input and output of simple types.
T_OPAQUEPTR can be used to pass these bytes back into C if a pointer
is acceptable.
(TBT)

=item Implicit array

=begin original

xsubpp supports a special syntax for returning
packed C arrays to perl. If the XS return type is given as

=end original

xsubpp supports a special syntax for returning
packed C arrays to perl. If the XS return type is given as
(TBT)

  array(type, nelem)

=begin original

xsubpp will copy the contents of C<nelem * sizeof(type)> bytes from
RETVAL to an SV and push it onto the stack. This is only really useful
if the number of items to be returned is known at compile time and you
don't mind having a string of bytes in your SV.  Use T_ARRAY to push a
variable number of arguments onto the return stack (they won't be
packed as a single string though).

=end original

xsubpp will copy the contents of C<nelem * sizeof(type)> bytes from
RETVAL to an SV and push it onto the stack. This is only really useful
if the number of items to be returned is known at compile time and you
don't mind having a string of bytes in your SV.  Use T_ARRAY to push a
variable number of arguments onto the return stack (they won't be
packed as a single string though).
(TBT)

=begin original

This is similar to using T_OPAQUEPTR but can be used to process more
than one element.

=end original

This is similar to using T_OPAQUEPTR but can be used to process more
than one element.
(TBT)

=item T_PACKED

=begin original

Calls user-supplied functions for conversion. For C<OUTPUT>
(XSUB to Perl), a function named C<XS_pack_$ntype> is called
with the output Perl scalar and the C variable to convert from.
C<$ntype> is the normalized C type that is to be mapped to
Perl. Normalized means that all C<*> are replaced by the
string C<Ptr>. The return value of the function is ignored.

=end original

Calls user-supplied functions for conversion. For C<OUTPUT>
(XSUB to Perl), a function named C<XS_pack_$ntype> is called
with the output Perl scalar and the C variable to convert from.
C<$ntype> is the normalized C type that is to be mapped to
Perl. Normalized means that all C<*> are replaced by the
string C<Ptr>. The return value of the function is ignored.
(TBT)

=begin original

Conversely for C<INPUT> (Perl to XSUB) mapping, the
function named C<XS_unpack_$ntype> is called with the input Perl
scalar as argument and the return value is cast to the mapped
C type and assigned to the output C variable.

=end original

Conversely for C<INPUT> (Perl to XSUB) mapping, the
function named C<XS_unpack_$ntype> is called with the input Perl
scalar as argument and the return value is cast to the mapped
C type and assigned to the output C variable.
(TBT)

=begin original

An example conversion function for a typemapped struct
C<foo_t *> might be:

=end original

typemap された構造体 C<foo_t *> のための変換関数の例は次のようなものです:

  static void
  XS_pack_foo_tPtr(SV *out, foo_t *in)
  {
    dTHX; /* alas, signature does not include pTHX_ */
    HV* hash = newHV();
    hv_stores(hash, "int_member", newSViv(in->int_member));
    hv_stores(hash, "float_member", newSVnv(in->float_member));
    /* ... */

    /* mortalize as thy stack is not refcounted */
    sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
  }

=begin original

The conversion from Perl to C is left as an exercise to the reader,
but the prototype would be:

=end original

Perl から C への変換は読者の演習として残されていますが、プロトタイプは
次のようになります:

  static foo_t *
  XS_unpack_foo_tPtr(SV *in);

=begin original

Instead of an actual C function that has to fetch the thread context
using C<dTHX>, you can define macros of the same name and avoid the
overhead. Also, keep in mind to possibly free the memory allocated by
C<XS_unpack_foo_tPtr>.

=end original

Instead of an actual C function that has to fetch the thread context
using C<dTHX>, you can define macros of the same name and avoid the
overhead. Also, keep in mind to possibly free the memory allocated by
C<XS_unpack_foo_tPtr>.
(TBT)

=item T_PACKEDARRAY

=begin original

T_PACKEDARRAY is similar to T_PACKED. In fact, the C<INPUT> (Perl
to XSUB) typemap is indentical, but the C<OUTPUT> typemap passes
an additional argument to the C<XS_pack_$ntype> function. This
third parameter indicates the number of elements in the output
so that the function can handle C arrays sanely. The variable
needs to be declared by the user and must have the name
C<count_$ntype> where C<$ntype> is the normalized C type name
as explained above. The signature of the function would be for
the example above and C<foo_t **>:

=end original

T_PACKEDARRAY は T_PACKED に似ています。
In fact, the C<INPUT> (Perl
to XSUB) typemap is indentical, but the C<OUTPUT> typemap passes
an additional argument to the C<XS_pack_$ntype> function. This
third parameter indicates the number of elements in the output
so that the function can handle C arrays sanely. The variable
needs to be declared by the user and must have the name
C<count_$ntype> where C<$ntype> is the normalized C type name
as explained above. The signature of the function would be for
the example above and C<foo_t **>:
(TBT)

  static void
  XS_pack_foo_tPtrPtr(SV *out, foo_t *in, UV count_foo_tPtrPtr);

=begin original

The type of the third parameter is arbitrary as far as the typemap
is concerned. It just has to be in line with the declared variable.

=end original

The type of the third parameter is arbitrary as far as the typemap
is concerned. It just has to be in line with the declared variable.
(TBT)

=begin original

Of course, unless you know the number of elements in the
C<sometype **> C array, within your XSUB, the return value from
C<foo_t ** XS_unpack_foo_tPtrPtr(...)> will be hard to decypher.
Since the details are all up to the XS author (the typemap user),
there are several solutions, none of which particularly elegant.
The most commonly seen solution has been to allocate memory for
N+1 pointers and assign C<NULL> to the (N+1)th to facilitate
iteration.

=end original

Of course, unless you know the number of elements in the
C<sometype **> C array, within your XSUB, the return value from
C<foo_t ** XS_unpack_foo_tPtrPtr(...)> will be hard to decypher.
Since the details are all up to the XS author (the typemap user),
there are several solutions, none of which particularly elegant.
The most commonly seen solution has been to allocate memory for
N+1 pointers and assign C<NULL> to the (N+1)th to facilitate
iteration.
(TBT)

=begin original

Alternatively, using a customized typemap for your purposes in
the first place is probably preferrable.

=end original

あるいは、最初の場所であなたの目的のためのカスタマイズされた typemap を
使う方がおそらく好ましいです。

=item T_DATAUNIT

=begin original

NOT YET

=end original

未記述

=item T_CALLBACK

=begin original

NOT YET

=end original

未記述

=item T_ARRAY

=begin original

This is used to convert the perl argument list to a C array
and for pushing the contents of a C array onto the perl
argument stack.

=end original

This is used to convert the perl argument list to a C array
and for pushing the contents of a C array onto the perl
argument stack.
(TBT)

=begin original

The usual calling signature is

=end original

この通常の呼び出しシグネチャは

  @out = array_func( @in );

=begin original

Any number of arguments can occur in the list before the array but
the input and output arrays must be the last elements in the list.

=end original

Any number of arguments can occur in the list before the array but
the input and output arrays must be the last elements in the list.
(TBT)

=begin original

When used to pass a perl list to C the XS writer must provide a
function (named after the array type but with 'Ptr' substituted for
'*') to allocate the memory required to hold the list. A pointer
should be returned. It is up to the XS writer to free the memory on
exit from the function. The variable C<ix_$var> is set to the number
of elements in the new array.

=end original

When used to pass a perl list to C the XS writer must provide a
function (named after the array type but with 'Ptr' substituted for
'*') to allocate the memory required to hold the list. A pointer
should be returned. It is up to the XS writer to free the memory on
exit from the function. The variable C<ix_$var> is set to the number
of elements in the new array.
(TBT)

=begin original

When returning a C array to Perl the XS writer must provide an integer
variable called C<size_$var> containing the number of elements in the
array. This is used to determine how many elements should be pushed
onto the return argument stack. This is not required on input since
Perl knows how many arguments are on the stack when the routine is
called. Ordinarily this variable would be called C<size_RETVAL>.

=end original

When returning a C array to Perl the XS writer must provide an integer
variable called C<size_$var> containing the number of elements in the
array. This is used to determine how many elements should be pushed
onto the return argument stack. This is not required on input since
Perl knows how many arguments are on the stack when the routine is
called. Ordinarily this variable would be called C<size_RETVAL>.
(TBT)

=begin original

Additionally, the type of each element is determined from the type of
the array. If the array uses type C<intArray *> xsubpp will
automatically work out that it contains variables of type C<int> and
use that typemap entry to perform the copy of each element. All
pointer '*' and 'Array' tags are removed from the name to determine
the subtype.

=end original

Additionally, the type of each element is determined from the type of
the array. If the array uses type C<intArray *> xsubpp will
automatically work out that it contains variables of type C<int> and
use that typemap entry to perform the copy of each element. All
pointer '*' and 'Array' tags are removed from the name to determine
the subtype.
(TBT)

=item T_STDIO

=begin original

This is used for passing perl filehandles to and from C using
C<FILE *> structures.

=end original

This is used for passing perl filehandles to and from C using
C<FILE *> structures.
(TBT)

=item T_INOUT

=begin original

This is used for passing perl filehandles to and from C using
C<PerlIO *> structures. The file handle can used for reading and
writing. This corresponds to the C<+E<lt>> mode, see also T_IN
and T_OUT.

=end original

This is used for passing perl filehandles to and from C using
C<PerlIO *> structures. The file handle can used for reading and
writing. This corresponds to the C<+E<lt>> mode, see also T_IN
and T_OUT.
(TBT)

=begin original

See L<perliol> for more information on the Perl IO abstraction
layer. Perl must have been built with C<-Duseperlio>.

=end original

See L<perliol> for more information on the Perl IO abstraction
layer. Perl must have been built with C<-Duseperlio>.
(TBT)

=begin original

There is no check to assert that the filehandle passed from Perl
to C was created with the right C<open()> mode.

=end original

There is no check to assert that the filehandle passed from Perl
to C was created with the right C<open()> mode.
(TBT)

=begin original

Hint: The L<perlxstut> tutorial covers the T_INOUT, T_IN, and T_OUT
XS types nicely.

=end original

Hint: The L<perlxstut> tutorial covers the T_INOUT, T_IN, and T_OUT
XS types nicely.
(TBT)

=item T_IN

=begin original

Same as T_INOUT, but the filehandle that is returned from C to Perl
can only be used for reading (mode C<E<lt>>).

=end original

Same as T_INOUT, but the filehandle that is returned from C to Perl
can only be used for reading (mode C<E<lt>>).
(TBT)

=item T_OUT

=begin original

Same as T_INOUT, but the filehandle that is returned from C to Perl
is set to use the open mode C<+E<gt>>.

=end original

Same as T_INOUT, but the filehandle that is returned from C to Perl
is set to use the open mode C<+E<gt>>.
(TBT)

=back

=begin meta

Translate: SHIRAKATA Kentaro <argrath@ub32.org>
Status: in progress

=end meta

