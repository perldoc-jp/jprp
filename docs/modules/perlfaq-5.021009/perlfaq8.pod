
=encoding utf8

=head1 NAME

=begin original

perlfaq8 - System Interaction

=end original

perlfaq8 - システムとの相互作用

=head1 VERSION

version 5.021009

=head1 DESCRIPTION

=begin original

This section of the Perl FAQ covers questions involving operating
system interaction. Topics include interprocess communication (IPC),
control over the user-interface (keyboard, screen and pointing
devices), and most anything else not related to data manipulation.

=end original

FAQ のこのセクションでは、オペレーティングシステムとの対話に関する質問を
扱っています。
これにはプロセス間(IPC)、ユーザーインターフェース
(キーボード、スクリーン、ポインティングデバイス)の制御、
その他データ操作に関連しないほとんどの事柄を含みます。

=begin original

Read the FAQs and documentation specific to the port of perl to your
operating system (eg, L<perlvms>, L<perlplan9>, ...). These should
contain more detailed information on the vagaries of your perl.

=end original

あなたの使っているオペレーティングシステム向けの移植について特有のことは、
それに関する FAQ とドキュメント(L<perlvms>, L<perlplan9> など)を
読んでください。
そこには、あなたの使う perl についてのより詳しい情報があります。

=head2 How do I find out which operating system I'm running under?

(実行しているオペレーティングシステムを見分けるには?)

=begin original

The C<$^O> variable (C<$OSNAME> if you use C<English>) contains an
indication of the name of the operating system (not its release
number) that your perl binary was built for.

=end original

C<$^O> という変数(use C<Engish> をしていれば C<$OSNAME>)は、あなたの使っている
perl の実行ファイルがビルドされたオペレーションシステムの名前
(リリース番号ではありません)の情報を持っています。

=head2 How come exec() doesn't return?
X<exec> X<system> X<fork> X<open> X<pipe>

(なぜ exec() は戻ってこないのでしょう?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

The C<exec> function's job is to turn your process into another
command and never to return. If that's not what you want to do, don't
use C<exec>. :)

=end original

C<exec> 関数の仕事は、あなたのプロセスを他のコマンドに切り替えて、
決して帰ってこないことです。
もしこれがあなたのしたいことでないなら、C<exec> を使わないでください。 :)

=begin original

If you want to run an external command and still keep your Perl process
going, look at a piped C<open>, C<fork>, or C<system>.

=end original

もし外部コマンドを実行して、かつ Perl プロセスを実行したままにしたい場合は、
パイプ付きの C<open>, C<fork>, C<system> のいずれかを見てください。

=head2 How do I do fancy stuff with the keyboard/screen/mouse?

(キーボード/画面/マウスの凝った機能を使うには?)

=begin original

How you access/control keyboards, screens, and pointing devices
("mice") is system-dependent. Try the following modules:

=end original

キーボード、画面、ポインティングデバイス(“マウス”)にアクセスしたり
それを制御することはシステム依存です。
以下のモジュールを試してみてください:

=over 4

=item Keyboard

    Term::Cap               Standard perl distribution
    Term::ReadKey           CPAN
    Term::ReadLine::Gnu     CPAN
    Term::ReadLine::Perl    CPAN
    Term::Screen            CPAN

=item Screen

    Term::Cap               Standard perl distribution
    Curses                  CPAN
    Term::ANSIColor         CPAN

=item Mouse

    Tk                      CPAN
    Wx                      CPAN
    Gtk2                    CPAN
    Qt4                     kdebindings4 package

=back

=begin original

Some of these specific cases are shown as examples in other answers
in this section of the perlfaq.

=end original

これらの一部の特殊なケースは、このセクションの他の回答の例として
示されています。

=head2 How do I print something out in color?

(色付きで何かを出力するには?)

=begin original

In general, you don't, because you don't know whether
the recipient has a color-aware display device. If you
know that they have an ANSI terminal that understands
color, you can use the L<Term::ANSIColor> module from CPAN:

=end original

一般的にはできません; なぜなら、あなたはディスプレイデバイスに関する
レシピについて何も知らないからです。
もしあなたがカラーの扱える ANSI ターミナルについて知っているのなら、
CPAN にある L<Term::ANSIColor> モジュールを使うことができます。

    use Term::ANSIColor;
    print color("red"), "Stop!\n", color("reset");
    print color("green"), "Go!\n", color("reset");

=begin original

Or like this:

=end original

あるいは次のようにも書けます:

    use Term::ANSIColor qw(:constants);
    print RED, "Stop!\n", RESET;
    print GREEN, "Go!\n", RESET;

=head2 How do I read just one key without waiting for a return key?

(リターンキーを待たずにキーのデータを一つ読み取るには?)

=begin original

Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the B<stty> command as shown in
L<perlfunc/getc>, but as you see, that's already getting you into
portability snags.

=end original

入力バッファを制御するのは非常にシステムに依存したやりかたです。
多くのシステムでは、L<perlfunc/getc> にあるように
B<stty> コマンドを使うことができますが、今書いた通り
移植性の問題があるのです。

    open(TTY, "+</dev/tty") or die "no tty: $!";
    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
    $key = getc(TTY);        # perhaps this works
    # OR ELSE
    sysread(TTY, $key, 1);    # probably this does
    system "stty -cbreak </dev/tty >/dev/tty 2>&1";

=begin original

The L<Term::ReadKey> module from CPAN offers an easy-to-use interface that
should be more efficient than shelling out to B<stty> for each key.
It even includes limited support for Windows.

=end original

CPAN にある L<Term::ReadKey> モジュールは、B<stty> をキー毎にシェルに
送るよりもより効果的に行ってくれて使うのが簡単なインターフェースを
提供します。
このモジュールは限定的ながら Windows にも対応しています。

    use Term::ReadKey;
    ReadMode('cbreak');
    $key = ReadKey(0);
    ReadMode('normal');

=begin original

However, using the code requires that you have a working C compiler
and can use it to build and install a CPAN module. Here's a solution
using the standard L<POSIX> module, which is already on your system
(assuming your system supports POSIX).

=end original

しかし、このコードを使うには C コンパイラを使えることが条件であり、かつ
CPAN モジュールのビルドとインストールができなければなりません。
以下の例は、標準の L<POSIX> モジュールを使った解決策で、
あなたの使っているシステムが POSIX をサポートしていれば
即使えるものです。

    use HotKey;
    $key = readkey();

=begin original

And here's the C<HotKey> module, which hides the somewhat mystifying calls
to manipulate the POSIX termios structures.

=end original

そして以下の例は、C<HotKey> モジュールを使ったものです; これは POSIX の
termio 構造体の操作を包み隠します。

    # HotKey.pm
    package HotKey;

    use strict;
    use warnings;

    use parent 'Exporter';
    our @EXPORT = qw(cbreak cooked readkey);

    use POSIX qw(:termios_h);
    my ($term, $oterm, $echo, $noecho, $fd_stdin);

    $fd_stdin = fileno(STDIN);
    $term     = POSIX::Termios->new();
    $term->getattr($fd_stdin);
    $oterm     = $term->getlflag();

    $echo     = ECHO | ECHOK | ICANON;
    $noecho   = $oterm & ~$echo;

    sub cbreak {
        $term->setlflag($noecho);  # ok, so i don't want echo either
        $term->setcc(VTIME, 1);
        $term->setattr($fd_stdin, TCSANOW);
    }

    sub cooked {
        $term->setlflag($oterm);
        $term->setcc(VTIME, 0);
        $term->setattr($fd_stdin, TCSANOW);
    }

    sub readkey {
        my $key = '';
        cbreak();
        sysread(STDIN, $key, 1);
        cooked();
        return $key;
    }

    END { cooked() }

    1;

=head2 How do I check whether input is ready on the keyboard?

(キーの入力待ちがあるかどうかチェックするには?)

=begin original

The easiest way to do this is to read a key in nonblocking mode with the
L<Term::ReadKey> module from CPAN, passing it an argument of -1 to indicate
not to block:

=end original

最も簡単な方法は、CPAN にある L<Term::ReadKey> に対して
(ブロックを行わないという意味である)-1 を引数に渡して
使用することによって非ブロックモードでキーを読み取るという方法です。

    use Term::ReadKey;

    ReadMode('cbreak');

    if (defined (my $char = ReadKey(-1)) ) {
        # input was waiting and it was $char
    } else {
        # no input was waiting
    }

    ReadMode('normal');                  # restore normal tty settings

=head2 How do I clear the screen?

(画面をクリアするには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

To clear the screen, you just have to print the special sequence
that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.

=end original

画面をクリアするには、端末に画面をクリアするように伝える特殊な
シーケンスを表示するだけです。
このシーケンスが分かれば、画面をクリアしたいときにこれを出力します。

=begin original

You can use the L<Term::ANSIScreen> module to get the special
sequence. Import the C<cls> function (or the C<:screen> tag):

=end original

この特殊なシーケンスを得るためには L<Term::ANSIScreen> モジュールが
使えます。
C<cls> 関数 (あるいは C<:screen> タグ) をインポートします:

    use Term::ANSIScreen qw(cls);
    my $clear_screen = cls();

    print $clear_screen;

=begin original

The L<Term::Cap> module can also get the special sequence if you want
to deal with the low-level details of terminal control. The C<Tputs>
method returns the string for the given capability:

=end original

端末制御のための低レベルな詳細を扱いたいなら、
L<Term::Cap> から特殊シーケンスを得られます。
C<Tputs> メソッドは、与えられた能力のための文字列を返します:

    use Term::Cap;

    my $terminal = Term::Cap->Tgetent( { OSPEED => 9600 } );
    my $clear_string = $terminal->Tputs('cl');

    print $clear_screen;

=begin original

On Windows, you can use the L<Win32::Console> module. After creating
an object for the output filehandle you want to affect, call the
C<Cls> method:

=end original

Windows では、L<Win32::Console> モジュールが使えます。
影響を与えたい出力ファイルハンドルのオブジェクトを作った後、
C<Cls> メソッドを呼び出します:

    Win32::Console;

    my $OUT = Win32::Console->new(STD_OUTPUT_HANDLE);
    my $clear_string = $OUT->Cls;

    print $clear_screen;

=begin original

If you have a command-line program that does the job, you can call
it in backticks to capture whatever it outputs so you can use it
later:

=end original

もしこの処理を行うコマンドラインプログラムがあるなら、そのプログラムが
出力するものを得るために逆クォートで呼び出して、後でそれを使うことも
できます:

    my $clear_string = `clear`;

    print $clear_string;

=head2 How do I get the screen size?

(画面サイズを得るには?)

=begin original

If you have L<Term::ReadKey> module installed from CPAN,
you can use it to fetch the width and height in characters
and in pixels:

=end original

CPAN にある L<Term::ReadKey> モジュールをインストールしているのなら、
文字やピクセルでの幅と高さを得ることができます:

    use Term::ReadKey;
    my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

=begin original

This is more portable than the raw C<ioctl>, but not as
illustrative:

=end original

以下の例は生の C<ioctl> よりも移植性がありますが、
あまりわかりやすい例ではありません:

    require 'sys/ioctl.ph';
    die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
    open(my $tty_fh, "+</dev/tty")                     or die "No tty: $!";
    unless (ioctl($tty_fh, &TIOCGWINSZ, $winsize='')) {
        die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
    }
    my ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
    print "(row,col) = ($row,$col)";
    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
    print "\n";

=head2 How do I ask the user for a password?

(ユーザーにパスワードを尋ねるには?)

=begin original

(This question has nothing to do with the web. See a different
FAQ for that.)

=end original

(この質問は web とは関係ありません。
それに関しては 別の FAQ を参照してください。)

=begin original

There's an example of this in L<perlfunc/crypt>). First, you put the
terminal into "no echo" mode, then just read the password normally.
You may do this with an old-style C<ioctl()> function, POSIX terminal
control (see L<POSIX> or its documentation the Camel Book), or a call
to the B<stty> program, with varying degrees of portability.

=end original

この例が L<perlfunc/crypt> にあります。
第一に、端末を“no echo”モードにし、それから通常通りにパスワードを
読み込みます。
これを、古いスタイルの C<ioctl()> 関数を使ってできますし、あるいは
POSIX の端末制御(L<POSIX> と、らくだ本を参照してください)を使うことも、
B<stty> プログラムを呼び出すことも可能です(ただしこれは移植性は劣ります)。

=begin original

You can also do this for most systems using the L<Term::ReadKey> module
from CPAN, which is easier to use and in theory more portable.

=end original

あるいはほとんどのシステムで、CPAN にある L<Term::ReadKey> を使って
行うこともできます; これは使うのが簡単で、理論的にはより移植性があります。

    use Term::ReadKey;

    ReadMode('noecho');
    my $password = ReadLine(0);

=head2 How do I read and write the serial port?

(シリアルポートの読み書きを行うには?)

=begin original

This depends on which operating system your program is running on. In
the case of Unix, the serial ports will be accessible through files in
C</dev>; on other systems, device names will doubtless differ.
Several problem areas common to all device interaction are the
following:

=end original

これはプログラムを実行するオペレーティングシステムに依存します。
UNIX の場合、シリアルポートは C</dev> にあるファイルを通じてアクセスが
可能です; 他のシステムでは、デバイス名は異なったものであることでしょう。
全てのデバイス操作に共通の問題点として以下のものが挙げられます:

=over 4

=item lockfiles

(ロックファイル)

=begin original

Your system may use lockfiles to control multiple access. Make sure
you follow the correct protocol. Unpredictable behavior can result
from multiple processes reading from one device.

=end original

あなたの使っているシステムは、多重アクセスを制御するためにロック
ファイルを使用しているかもしれません。
正しい手順に従うようにしてください。
予測のつかない振る舞いは一つのデバイスに対する複数のプロセスの読み出しが
原因かもしれません。

=item open mode

(オープンモード)

=begin original

If you expect to use both read and write operations on the device,
you'll have to open it for update (see L<perlfunc/"open"> for
details). You may wish to open it without running the risk of
blocking by using C<sysopen()> and C<O_RDWR|O_NDELAY|O_NOCTTY> from the
L<Fcntl> module (part of the standard perl distribution). See
L<perlfunc/"sysopen"> for more on this approach.

=end original

一つのデバイスに対して、読み込みと書き出しの両方の操作ができることを
期待しているのなら、それを更新モード(詳しくは  L<perlfunc/"open"> を
参照)でオープンする必要があるでしょう。
C<sysopen()> と L<Fcntl> モジュールにある C<O_RDWR|O_NDELAY|O_NOCTTY> とを使って
ブロッキングする危険性なしにオープンを実行したいと考えるかもしれません。
このアプローチに関する詳細は L<perlfunc/"sysopen"> を参照してください。

=item end of line

(行の末尾)

=begin original

Some devices will be expecting a "\r" at the end of each line rather
than a "\n". In some ports of perl, "\r" and "\n" are different from
their usual (Unix) ASCII values of "\015" and "\012". You may have to
give the numeric values you want directly, using octal ("\015"), hex
("0x0D"), or as a control-character specification ("\cM").

=end original

幾つかのデバイスでは、行の終端に "\n" ではなく "\r" を期待しています。
perl の移植の一部では、"\r" と "\n" は通常の(UNIX の) ASCII 値である
"\015" と "\012" とは異なったものになっています。
八進表記 ("\015") や十六進表記("0x0D")、
あるいは制御文字指定 ("\cM") を使って
直接数値を与える必要があるかもしれません。

=begin original

    print DEV "atv1\012";    # wrong, for some devices
    print DEV "atv1\015";    # right, for some devices

=end original

    print DEV "atv1\012";    # 一部のデバイスにとっては間違い
    print DEV "atv1\015";    # 一部のデバイスにとっては正しい

=begin original

Even though with normal text files a "\n" will do the trick, there is
still no unified scheme for terminating a line that is portable
between Unix, DOS/Win, and Macintosh, except to terminate I<ALL> line
ends with "\015\012", and strip what you don't need from the output.
This applies especially to socket I/O and autoflushing, discussed
next.

=end original

通常のテキストファイルでさえも、"\n" はいたずらを行う可能性があります;
B<全ての行> を "\015\012" で終わらせ、出力から必要のないものを
取り除くということを除いては、UNIX、DOS/Win、Macintosh との間で
互換性のある行の終端方法は未だに統一されていません。
これは特にソケットの入出力や自動フラッシュで適用されます; これについては
次に述べます。

=item flushing output

=begin original

If you expect characters to get to your device when you C<print()> them,
you'll want to autoflush that filehandle. You can use C<select()>
and the C<$|> variable to control autoflushing (see L<perlvar/$E<verbar>>
and L<perlfunc/select>, or L<perlfaq5>, "How do I flush/unbuffer an
output filehandle? Why must I do this?"):

=end original

デバイスに C<print()> した時にそのキャラクタが反映されるようにしたいのなら、
そのハンドルを自動フラッシュするようにしたいでしょう。
自動フラッシュを制御するのに、C<$|> という変数と、C<select()> を
使うことができます(L<perlvar/$E<verbar>>とL<perlfunc/select> または
L<perlfaq5> の "How do I flush/unbuffer an output filehandle?  Why must
I do this?" を参照してください)。

    my $old_handle = select($dev_fh);
    $| = 1;
    select($old_handle);

=begin original

You'll also see code that does this without a temporary variable, as in

=end original

以下のように、これを一時変数を使わないで行うコードを見るかもしれません:

    select((select($deb_handle), $| = 1)[0]);

=begin original

Or if you don't mind pulling in a few thousand lines
of code just because you're afraid of a little C<$|> variable:

=end original

C<$|> というような変数に戸惑いを感じていて、数千行のプログラムを
引っ張りこむことを気にしないのなら以下のようにできます:

    use IO::Handle;
    $dev_fh->autoflush(1);

=begin original

As mentioned in the previous item, this still doesn't work when using
socket I/O between Unix and Macintosh. You'll need to hard code your
line terminators, in that case.

=end original

先のアイテムで述べたように、これでもまだ UNIX と Macintosh の間で
ソケット I/O を使った場合にはうまく動作しません。
その場合には、行の終端をハードコーディングする必要があるでしょう。

=item non-blocking input

=begin original

If you are doing a blocking C<read()> or C<sysread()>, you'll have to
arrange for an alarm handler to provide a timeout (see
L<perlfunc/alarm>). If you have a non-blocking open, you'll likely
have a non-blocking read, which means you may have to use a 4-arg
C<select()> to determine whether I/O is ready on that device (see
L<perlfunc/"select">.

=end original

ブロッキング C<read()> やブロッキング C<sysread()> を行うのであれば、
タイムアウトを実現するためにalarmハンドラーをアレンジする必要があるでしょう
(L<perlfunc/alarm> を参照)。
もしノンブロッキング open を持っているのであれば、デバイスが入出力完了の
状態であるかどうかを決定するために四つの引数を取る C<select()> を使う必要が
あるであろうノンブロッキング read も同様に持っていることでしょう
(L<perlfunc/"select">を参照)。

=back

=begin original

While trying to read from his caller-id box, the notorious Jamie
Zawinski C<< <jwz@netscape.com> >>, after much gnashing of teeth and
fighting with C<sysread>, C<sysopen>, POSIX's C<tcgetattr> business,
and various other functions that go bump in the night, finally came up
with this:

=end original

caller-id ボックスから読み出すことに挑戦したことで有名な
Jamie Zawinski C<< <jwd@netscape.com> >> は、
C<sysread> や C<sysopen>、POSIX の C<tcgetattr> その他さまざまな関数を扱い
悪戦苦闘しながら、最終的には以下のようものを作りました:

    sub open_modem {
        use IPC::Open2;
        my $stty = `/bin/stty -g`;
        open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
        # starting cu hoses /dev/tty's stty settings, even when it has
        # been opened on a pipe...
        system("/bin/stty $stty");
        $_ = <MODEM_IN>;
        chomp;
        if ( !m/^Connected/ ) {
            print STDERR "$0: cu printed `$_' instead of `Connected'\n";
        }
    }

=head2 How do I decode encrypted password files?

(暗号化されたパスワードファイルを復号化するには?)

=begin original

You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.

=end original

特別なハードウェアに非常に多額のお金を掛けてください;
しかしこれはあなたが何について話しているかによります。

=begin original

Seriously, you can't if they are Unix password files--the Unix
password system employs one-way encryption. It's more like hashing
than encryption. The best you can do is check whether something else
hashes to the same string. You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.

=end original

まじめな話をすると、UNIX のパスワードに対してのものならできません --
UNIX のパスワードシステムは一方向の暗号化を採用しています。
それは暗号化というよりはむしろハッシュ化といえるものです。
あなたがチェックできる最善の方法は、同じ文字列に対するハッシュかどうかを
調べることです。
ハッシュを元の文字列に戻すことはできません。
Crack のようなプログラムは考えられるパスワードを力づくで(そして知的に)
試しますが、即座に成功するものを生成することはしません(できません)。

=begin original

If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
L<passwd(1)>, for example).

=end original

もしあなたが、ユーザーが悪いパスワードを選択してしまうことを
心配しているのであれば、ユーザーが(たとえば L<passwd(1)> を使って)自分の
パスワードを変更しようとしたときに積極的にチェックをすべきでしょう。

=head2 How do I start a process in the background?

(バックグラウンドでプロセスを起動するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

There's not a single way to run code in the background so you don't
have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are covered in L<perlipc>.

=end original

バックグラウンドでコードを実行するための単一の方法というのはないので、
あなたのプログラムが他のアスクに移動する前に終わるのを待つ必要は
ありません。
プロセス管理は使用するオペレーティングシステムに依存していて、
多くのテクニックは L<perlipc> にあります。

=begin original

Several CPAN modules may be able to help, including L<IPC::Open2> or
L<IPC::Open3>, L<IPC::Run>, L<Parallel::Jobs>,
L<Parallel::ForkManager>, L<POE>, L<Proc::Background>, and
L<Win32::Process>. There are many other modules you might use, so
check those namespaces for other options too.

=end original

L<IPC::Open2>, L<IPC::Open3>, L<IPC::Run>, L<Parallel::Jobs>,
L<Parallel::ForkManager>, L<POE>, L<Proc::Background>, L<Win32::Process>
といった CPAN モジュールが助けになるでしょう。
その他にも使えるかもしれない多くのモジュールがありますので、
これらの名前空間をチェックしてみてください。

=begin original

If you are on a Unix-like system, you might be able to get away with a
system call where you put an C<&> on the end of the command:

=end original

Unix 風のシステムを使っているなら、コマンドの最後に C<&> を置くことで
システムコールから切り離すことができるかもしれません:

    system("cmd &")

=begin original

You can also try using C<fork>, as described in L<perlfunc> (although
this is the same thing that many of the modules will do for you).

=end original

L<perlfunc> に記述されているように、C<fork> を使うこともできます
(しかしこれは多くのモジュールがやってくれるのと同じことです)。

=over 4

=item STDIN, STDOUT, and STDERR are shared

(STDIN, STDOUT, STDERR は共有されます)

=begin original

Both the main process and the backgrounded one (the "child" process)
share the same STDIN, STDOUT and STDERR filehandles. If both try to
access them at once, strange things can happen. You may want to close
or reopen these for the child. You can get around this with
C<open>ing a pipe (see L<perlfunc/"open">) but on some systems this
means that the child process cannot outlive the parent.

=end original

主プロセスとバックグラウンドプロセス(子プロセス)で同じ STDIN, 
STDOUT, STDERR のファイルハンドルが共有されます。
両方のプロセスが同時にアクセスしようとすると、
おかしな事が発生するかもしれません。
子プロセス用のこれらのハンドルを、クローズしたり再オープンしたり
したくなるかもしれません。
これは、パイプを C<open> することで行えますが、
一部のシステムにおいてはこれは子プロセスが親プロセスよりも
長生きすることはできないということになります。

=item Signals

(シグナル)

=begin original

You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too.
SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is
sent when you write to a filehandle whose child process has closed (an
untrapped SIGPIPE can cause your program to silently die). This is
not an issue with C<system("cmd&")>.

=end original

SIGCHLD シグナルを捕捉する必要があり、可能なら SIGPIPE も
捕捉する必要があるでしょう。
SIGCHLD はバックグラウンドプロセスが終了したときに送られます。
SIGPIPE は既にクローズされている子プロセスを所有するファイルハンドルに
書き込みを行ったときに送られます(トラップされていない SIGPIPE は、
あなたのプログラムを黙って終わらせてしまうかもしれません)。
これは C<system("cmd&")> を使ったときには起こりません。

=item Zombies

(ゾンビ)

=begin original

You have to be prepared to "reap" the child process when it finishes.

=end original

子プロセスが終了したときにそれを“刈り取る”(reap) 準備をする必要があります。

    $SIG{CHLD} = sub { wait };

    $SIG{CHLD} = 'IGNORE';

=begin original

You can also use a double fork. You immediately C<wait()> for your
first child, and the init daemon will C<wait()> for your grandchild once
it exits.

=end original

2 重 fork も使えます。
あなたは直ちに最初の子に対して C<wait()> し、init デーモンは孫が終了するのを
C<wait()> します。

    unless ($pid = fork) {
        unless (fork) {
            exec "what you really wanna do";
            die "exec failed!";
        }
        exit 0;
    }
    waitpid($pid, 0);

=begin original

See L<perlipc/"Signals"> for other examples of code to do this.
Zombies are not an issue with C<system("prog &")>.

=end original

これを行うサンプルは L<perlipc/"Signals"> を参照してください。
ゾンビは C<system("prog &")> を使ったときには発生しません。

=back

=head2 How do I trap control characters/signals?

(制御文字やシグナルをトラップするには?)

=begin original

You don't actually "trap" a control character. Instead, that character
generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in L<perlipc/"Signals"> and the
section on "Signals" in the Camel.

=end original

実際には制御文字を“トラップ”できません。
その代わりに、その文字が生成して
端末のフォアグラウンドプロセスに送られることになる
シグナルがトラップできます。
シグナルは L<perlipc/"Signals"> とらくだ本の "Signal" の章に
説明があります。

=begin original

You can set the values of the C<%SIG> hash to be the functions you want
to handle the signal. After perl catches the signal, it looks in C<%SIG>
for a key with the same name as the signal, then calls the subroutine
value for that key.

=end original

C<%SIG> ハッシュにシグナルを扱いたい関数をセットできます。
perl がシグナルを捕捉した後、perl はシグナルと同じ名前をキーとして C<%SIG> を
見て、そのキーの値であるサブルーチンを呼び出します。

    # as an anonymous subroutine

    $SIG{INT} = sub { syswrite(STDERR, "ouch\n", 5 ) };

    # or a reference to a function

    $SIG{INT} = \&ouch;

    # or the name of the function as a string

    $SIG{INT} = "ouch";

=begin original

Perl versions before 5.8 had in its C source code signal handlers which
would catch the signal and possibly run a Perl function that you had set
in C<%SIG>. This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at C<%SIG>
B<after> the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.

=end original

バージョン 5.8 より前の Perl には、シグナルを受け取って、可能なら C<%SIG>
にセットされている Perl の関数を実行する C ソースコードのシグナルハンドラが
ありました。
これはこのレベルでのシグナルハンドリングのルールに違反していて、perl の
コアダンプを引き起こしていました。
バージョン 5.8.0 から、perl はシグナルを捕捉している間ではなく、シグナルを
捕捉した B<後に> C<%SIG> を見ます。
この答えの以前のバージョンは間違っていました。

=head2 How do I modify the shadow password file on a Unix system?

(UNIX システムのシャドウパスワードファイルを変更するには?)

=begin original

If perl was installed correctly and your shadow library was written
properly, the C<getpw*()> functions described in L<perlfunc> should in
theory provide (read-only) access to entries in the shadow password
file. To change the file, make a new shadow password file (the format
varies from system to system--see L<passwd(1)> for specifics) and use
C<pwd_mkdb(8)> to install it (see L<pwd_mkdb(8)> for more details).

=end original

perl が正しくインストールされていて、かつ、シャドウライブラリが
きちんとインストールされていれば、L<perlfunc> で説明されている
C<getpw*()> 関数がシャドウパスワードファイルに対する(リードオンリーの)
アクセスを提供しています。
ファイルを変更するには、新たなシャドウパスワードファイルを作成して
(フォーマットはシステム毎に異なります--詳しくは L<passwd(1)> 
を参照してください)、C<pwd_mkdb(8)> を使ってそれをインストールします
(詳細は L<pwd_mkdb(8)> を参照のこと)。

=head2 How do I set the time and date?

(日付や時刻を設定するには?)

=begin original

Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the C<date(1)>
program. (There is no way to set the time and date on a per-process
basis.)  This mechanism will work for Unix, MS-DOS, Windows, and NT;
the VMS equivalent is C<set time>.

=end original

あなたが十分な権限を持っているとすれば、C<date(1)> プログラムを実行すれば
システム全体の日付や時刻を設定できるはずです
(プロセス毎に日付や時刻を設定する方法はありません)。
この機構は、UNIX、MS-DOS、Windows、NT でうまくいくでしょう。
VMS には等価な C<set time> があります。

=begin original

However, if all you want to do is change your time zone, you can
probably get away with setting an environment variable:

=end original

あなたのやりたいことがタイムゾーンの変更であるのなら、
環境変数を変更することでそれができるでしょう。

    $ENV{TZ} = "MST7MDT";           # Unixish
    $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
    system('trn', 'comp.lang.perl.misc');

=head2 How can I sleep() or alarm() for under a second?
X<Time::HiRes> X<BSD::Itimer> X<sleep> X<select>

(一秒未満の時間に対する sleep() や alarm() をするには?)

=begin original

If you want finer granularity than the 1 second that the C<sleep()>
function provides, the easiest way is to use the C<select()> function as
documented in L<perlfunc/"select">. Try the L<Time::HiRes> and
the L<BSD::Itimer> modules (available from CPAN, and starting from
Perl 5.8 L<Time::HiRes> is part of the standard distribution).

=end original

C<sleep()> 関数が一秒未満の単位での動作をサポートすることを求めているのなら、
L<perlfunc/"select"> にあるように、C<select()> を使うのが最も単純な方法です。
L<Time::Hires> と L<BSD::Itimer> モジュール(CPAN から利用可能ですし、
Perl 5.8 からは L<Time::HiRes> は標準配布の一部です)も
試してみてください。

=head2 How can I measure time under a second?
X<Time::HiRes> X<BSD::Itimer> X<sleep> X<select>

(1 秒未満の時間を計るには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

The L<Time::HiRes> module (part of the standard distribution as of
Perl 5.8) measures time with the C<gettimeofday()> system call, which
returns the time in microseconds since the epoch. If you can't install
L<Time::HiRes> for older Perls and you are on a Unixish system, you
may be able to call C<gettimeofday(2)> directly. See
L<perlfunc/syscall>.

=end original

(Perl 5.8 から標準配布の一部である) L<Time::HiRes> モジュールは、
紀元からのマイクロ秒を返す C<gettimeofday()> システムコールを使って時間を
計測します。
もし古い Perl を使っていて L<Time::HiRes> をインストールできず、
Unixish を使っているなら、C<gettimeofday(2)> を直接使えます。
L<perlfunc/syscall> を参照してください。

=head2 How can I do an atexit() or setjmp()/longjmp()? (Exception handling)

(atexit() や setjmp()/longjmp() をするには? (例外処理))

=begin original

You can use the C<END> block to simulate C<atexit()>. Each package's
C<END> block is called when the program or thread ends. See the L<perlmod>
manpage for more details about C<END> blocks.

=end original

C<atexit()> をシミュレートするのに C<END> ブロックが使えます。
それぞれのパッケージの C<END> ブロックは、プログラムやスレッドの終了時に
呼び出されます。
C<END> ブロックに関するさらなる詳細については L<perlmod> を
参照してください。

=begin original

For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:

=end original

例を挙げると、あなたのフィルタープログラムが出力を確実に
ディスクに送るようにするためには以下のようにできます:

    END {
        close(STDOUT) || die "stdout close failed: $!";
    }

=begin original

The C<END> block isn't called when untrapped signals kill the program,
though, so if you use C<END> blocks you should also use

=end original

C<END> ブロックは、トラップされないシグナルがプログラムを強制終了させた
場合には呼び出されません; したがって、C<END> ブロックを使う場合には同時に
以下のようにするべきです:

    use sigtrap qw(die normal-signals);

=begin original

Perl's exception-handling mechanism is its C<eval()> operator. You
can use C<eval()> as C<setjmp> and C<die()> as C<longjmp>. For
details of this, see the section on signals, especially the time-out
handler for a blocking C<flock()> in L<perlipc/"Signals"> or the
section on "Signals" in I<Programming Perl>.

=end original

Perl の例外処理機構は C<eval()> 演算子です。
C<setjmp> として C<eval()> を、C<longjmp> として C<die()> を使うことができます。
これに関する詳細は、シグナルに関するセクション、
特に L<perlipc/"Signals"> にあるブロッキング C<flock()> のための
タイムアウトハンドラーと、 I<Programming Perl> の "Signal" の章を参照してください。

=begin original

If exception handling is all you're interested in, use one of the
many CPAN modules that handle exceptions, such as L<Try::Tiny>.

=end original

例外処理そのものに興味があるのなら、L<Try::Tiny> のような、例外を
扱うための多くの CPAN モジュールの一つを使ってください。

=begin original

If you want the C<atexit()> syntax (and an C<rmexit()> as well), try the
C<AtExit> module available from CPAN.

=end original

C<atexit()> 構文(と、C<rmexit()>) が欲しいのなら、CPAN にある
C<AtExit> モジュールを試してみてください。

=head2 Why doesn't my sockets program work under System V (Solaris)? What does the error message "Protocol not supported" mean?

(なぜ私のソケットプログラムはSystem V (Solaris) ではうまく動かないの? "Protocol not supported"というエラーメッセージの意味するところは?)

=begin original

Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants. Since these were constant across all
architectures, they were often hardwired into perl code. The proper
way to deal with this is to "use Socket" to get the correct values.

=end original

一部の System 5 ベースのシステム、特に Solaris 2.x では標準のソケット定数の
幾つかが再定義されています。
これらの定数は全てのアーキテクチャに渡るものであったので、
しばしば perl コードにハードコーディングされています。
これに対処する適切な方法は正しい値を得るために "use Socket" とすることです。

=begin original

Note that even though SunOS and Solaris are binary compatible, these
values are different. Go figure.

=end original

SunOS と Solaris とではバイナリ互換性があるにも関らず、
これらの値が異なるということに注意してください。
不思議なことです。

=head2 How can I call my system's unique C functions from Perl?

(Perl から私のシステムに固有の C 関数を呼び出すには?)

=begin original

In most cases, you write an external module to do it--see the answer
to "Where can I learn about linking C with Perl? [h2xs, xsubpp]".
However, if the function is a system call, and your system supports
C<syscall()>, you can use the C<syscall> function (documented in
L<perlfunc>).

=end original

ほとんどの場合、その方法は外部モジュールを作るというものです --
"Where can I learn about linking C with Perl? [h2xs, xsubpp]"
の回答を参照してください。
ただし、その関数がシステムコールでありあなたの使っているシステムが
C<syscall()> をサポートしているのであれば、
C<syscall> 関数(L<perlfunc> に説明があります)を使うことができます。

=begin original

Remember to check the modules that came with your distribution, and
CPAN as well--someone may already have written a module to do it. On
Windows, try L<Win32::API>. On Macs, try L<Mac::Carbon>. If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with L<Inline::C>.

=end original

一緒に配布されたモジュールや CPAN にあるモジュールをチェックすることを
忘れないでください--誰かが求めるモジュールを既に作っているかもしれません。
Windows では、L<Win32::API> を試してください。
Mac では、L<Mac::Carbon> を試してください。
C 関数へのインターフェースを持つモジュールがなければ、
L<Inline::C> を使って Perl のソースコードにちょっとした C のコードを
インライン化できます。

=head2 Where do I get the include files to do ioctl() or syscall()?

(ioctl() や syscall() で使うための include ファイルはどこで入手できますか?)

=begin original

Historically, these would be generated by the L<h2ph> tool, part of the
standard perl distribution. This program converts C<cpp(1)> directives
in C header files to files containing subroutine definitions, like
C<SYS_getitimer()>, which you can use as arguments to your functions.
It doesn't work perfectly, but it usually gets most of the job done.
Simple files like F<errno.h>, F<syscall.h>, and F<socket.h> were fine,
but the hard ones like F<ioctl.h> nearly always need to be hand-edited.
Here's how to install the *.ph files:

=end original

伝統的に、これらのファイルは標準配布に含まれる L<h2ph> というツールによって
生成されるものです。
このプログラムは C のヘッダーファイルにある C<cpp(1)> 指示子を
C<SYS_getitimer()> のような、関数に対する引数として使うことのできる
サブルーチン定義を含むファイルに変換するものです。
これは完璧なものではありませんが、ほとんどの場合には十分な仕事を行います。
F<errno.h>, F<syscall.h>,  F<socket.h> のような単純なファイルはよいのですが、
F<ioctl.h> のように難しいものはほとんど常に手で編集する必要があります。
以下の手順は、*.ph ファイルをインストールするためのものです。

    1. Become the super-user
    2. cd /usr/include
    3. h2ph *.h */*.h

=begin original

If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use L<h2xs> (also part of the standard perl
distribution). This tool converts C header files to Perl extensions.
See L<perlxstut> for how to get started with L<h2xs>.

=end original

あなたの使っているシステムが動的ローディングをサポートしているのであれば、
移植性と健全性(sanity)のために、L<h2xs> を使うべきでしょう
(これも標準の perl 配布キットに含まれています)。
このツールは、C のヘッダーファイルを Perl のエクステンションに変換します。
L<h2xs> の使い方は L<perlxstut> を参照してください。

=begin original

If your system doesn't support dynamic loading, you still probably
ought to use L<h2xs>. See L<perlxstut> and L<ExtUtils::MakeMaker> for
more information (in brief, just use B<make perl> instead of a plain
B<make> to rebuild perl with a new static extension).

=end original

あなたの使っているシステムが動的ローディングをサポートしていない
場合であっても、やはり L<h2xs> を使うべきでしょう。
より詳しい情報は L<perlxstut> と L<ExtUtils::MakeMaker> を参照してください
(簡単に言うと、新しい静的エクステションを伴った perl を再ビルドするのに
通常の B<make> を使うのではなく、B<make perl> を使うだけです)。

=head2 Why do setuid perl scripts complain about kernel problems?

(なぜ setuid された perl スクリプトはカーネルの問題について文句を言うのでしょうか?)

=begin original

Some operating systems have bugs in the kernel that make setuid
scripts inherently insecure. Perl gives you a number of options
(described in L<perlsec>) to work around such systems.

=end original

幾つかのオペレーティングシステムは、setuid スクリプトを本質的に
安全でなくするようなカーネルのバグを抱えています。
Perl は、そういったシステムに対処して動作させるための幾つかのオプションを
持っています(L<perlsec> に説明があります)。

=head2 How can I open a pipe both to and from a command?

(あるコマンドに対する双方向のパイプをオープンするには?)

=begin original

The L<IPC::Open2> module (part of the standard perl distribution) is
an easy-to-use approach that internally uses C<pipe()>, C<fork()>, and
C<exec()> to do the job. Make sure you read the deadlock warnings in
its documentation, though (see L<IPC::Open2>). See
L<perlipc/"Bidirectional Communication with Another Process"> and
L<perlipc/"Bidirectional Communication with Yourself">

=end original

L<IPC::Open2> モジュール(標準の perl の配布に含まれています)は内部的に
C<pipe()>, C<fork()>, C<exec()> を使った使いやすい手法です。
ただし、ドキュメントにあるデッドロックの警告をよく読んでください
(L<IPC::Open2>を参照)。
L<perlipc/"Bidirectional Communication with Another Process"> と
L<perlipc/"Bidirectional Communication with Yourself"> も参照してください。

=begin original

You may also use the L<IPC::Open3> module (part of the standard perl
distribution), but be warned that it has a different order of
arguments from L<IPC::Open2> (see L<IPC::Open3>).

=end original

L<IPC::Open3> モジュール(標準配布パッケージに含まれています)も使えますが、
これは L<IPC::Open2> とは引数の順序が違うということに注意してください
(L<IPC::Open3> を参照してください)。

=head2 Why can't I get the output of a command with system()?

(なぜ system() を使ったコマンドの出力を得ることができないのでしょうか?)

=begin original

You're confusing the purpose of C<system()> and backticks (``). C<system()>
runs a command and returns exit status information (as a 16 bit value:
the low 7 bits are the signal the process died from, if any, and
the high 8 bits are the actual exit value). Backticks (``) run a
command and return what it sent to STDOUT.

=end original

C<system()> の目的と逆クォートの目的を混同しているのでしょう。
C<system()> はコマンドを実行して、終了ステータス情報(16bit 値として:
下位 7bit は(もしあれば)終了したプロセスからのシグナルで、上位 8bit は
実際の終了ステータス)を返します。
逆クォートはコマンドを実行し、そのコマンドが STDOUT に送ったものを返します。

    my $exit_status   = system("mail-users");
    my $output_string = `ls`;

=head2 How can I capture STDERR from an external command?

(外部コマンドの STDERR を捕捉するには?)

=begin original

There are three basic ways of running external commands:

=end original

外部コマンドを実行する基本的なやり方が三つあります:

    system $cmd;        # using system()
    my $output = `$cmd`;        # using backticks (``)
    open (my $pipe_fh, "$cmd |");    # using open()

=begin original

With C<system()>, both STDOUT and STDERR will go the same place as the
script's STDOUT and STDERR, unless the C<system()> command redirects them.
Backticks and C<open()> read B<only> the STDOUT of your command.

=end original

C<system()> を使った場合の STDOUT と STDERR は、C<system()> コマンドが
リダイレクトを行っていない限りはそれぞれスクリプトが使っていた
STDOUT と STDERR へ出力されます。
逆クォートと C<open()> はコマンドの STDOUT B<だけを> 読み込みます。

=begin original

You can also use the C<open3()> function from L<IPC::Open3>. Benjamin
Goldberg provides some sample code:

=end original

L<IPC::Open3> の C<open3()> 関数も使えます。
Benjamin Goldberg がいくつかのサンプルコードを提供しています:

=begin original

To capture a program's STDOUT, but discard its STDERR:

=end original

あるプログラムの STDOUT は捕捉したいが、STDERR は捨てたい場合:

    use IPC::Open3;
    use File::Spec;
    my $in = '';
    open(NULL, ">", File::Spec->devnull);
    my $pid = open3($in, \*PH, ">&NULL", "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);

=begin original

To capture a program's STDERR, but discard its STDOUT:

=end original

あるプログラムの STDERR は捕捉したいが、STDOUT は捨てたい場合:

    use IPC::Open3;
    use File::Spec;
    my $in = '';
    open(NULL, ">", File::Spec->devnull);
    my $pid = open3($in, ">&NULL", \*PH, "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);

=begin original

To capture a program's STDERR, and let its STDOUT go to our own STDERR:

=end original

プログラムの STDERR を捕捉してその STDOUT を自身の STDERR に送るには:

    use IPC::Open3;
    my $in = '';
    my $pid = open3($in, ">&STDERR", \*PH, "cmd");
    while( <PH> ) { }
    waitpid($pid, 0);

=begin original

To read both a command's STDOUT and its STDERR separately, you can
redirect them to temp files, let the command run, then read the temp
files:

=end original

あるコマンドの STDOUT と STDERR を別々に読み込みたい場合、それをテンポラリ
ファイルにリダイレクトして、コマンドを実行して、テンポラリファイルから
読み込みます:

    use IPC::Open3;
    use IO::File;
    my $in = '';
    local *CATCHOUT = IO::File->new_tmpfile;
    local *CATCHERR = IO::File->new_tmpfile;
    my $pid = open3($in, ">&CATCHOUT", ">&CATCHERR", "cmd");
    waitpid($pid, 0);
    seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
    while( <CATCHOUT> ) {}
    while( <CATCHERR> ) {}

=begin original

But there's no real need for B<both> to be tempfiles... the following
should work just as well, without deadlocking:

=end original

しかし、実際には B<両方を> テンポラリファイルにするする必要はありません…。
以下のものもデッドロックなしにうまく動きます:

    use IPC::Open3;
    my $in = '';
    use IO::File;
    local *CATCHERR = IO::File->new_tmpfile;
    my $pid = open3($in, \*CATCHOUT, ">&CATCHERR", "cmd");
    while( <CATCHOUT> ) {}
    waitpid($pid, 0);
    seek CATCHERR, 0, 0;
    while( <CATCHERR> ) {}

=begin original

And it'll be faster, too, since we can begin processing the program's
stdout immediately, rather than waiting for the program to finish.

=end original

そして、これはプログラムの終了を待つのではなく、プログラムの標準出力を直ちに
処理するので、より速いはずです。

=begin original

With any of these, you can change file descriptors before the call:

=end original

これらのどれでも、呼び出しの前にファイル記述子を変更できます:

    open(STDOUT, ">logfile");
    system("ls");

=begin original

or you can use Bourne shell file-descriptor redirection:

=end original

Bourne シェルのファイル記述子リダイレクションを使うこともできます:

    $output = `$cmd 2>some_file`;
    open (PIPE, "cmd 2>some_file |");

=begin original

You can also use file-descriptor redirection to make STDERR a
duplicate of STDOUT:

=end original

同様に、STDERR を STDOUT の複製にするためにファイル記述子
リダイレクションを使うこともできます。

    $output = `$cmd 2>&1`;
    open (PIPE, "cmd 2>&1 |");

=begin original

Note that you I<cannot> simply open STDERR to be a dup of STDOUT
in your Perl program and avoid calling the shell to do the redirection.
This doesn't work:

=end original

STDOUT の複製のために、Perl プログラムの中で単純に STDERR を
オープンすることは B<できない> ということと、リダイレクトのための
シェルの呼び出しを避けることはできないということに注意してください。
以下の例はうまくいきません:

    open(STDERR, ">&STDOUT");
    $alloutput = `cmd args`;  # stderr still escapes

=begin original

This fails because the C<open()> makes STDERR go to where STDOUT was
going at the time of the C<open()>. The backticks then make STDOUT go to
a string, but don't change STDERR (which still goes to the old
STDOUT).

=end original

これは C<open()> が、STDERR を(C<open()> が呼び出された時点で)STDOUT が
使っていた場所に対応するようにするので失敗します。
その後で逆クォートは STDOUT(に出力された内容)を文字列にしますが、
STDERR を変更することはしません(これは以前の STDOUT が指していたところです)。

=begin original

Note that you I<must> use Bourne shell (C<sh(1)>) redirection syntax in
backticks, not C<csh(1)>!  Details on why Perl's C<system()> and backtick
and pipe opens all use the Bourne shell are in the
F<versus/csh.whynot> article in the "Far More Than You Ever Wanted To
Know" collection in L<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> . To
capture a command's STDERR and STDOUT together:

=end original

backticlsの中では、C<csh(1)> のリダイレクト構文ではなく、Bourne shell
(C<sh(1)>) のリダイレクト構文を B<使わなければならない> ということに
注意してください!
なぜ Perl の C<system()>、逆クォート、パイプオープンの全てで Bourne シェルの
ものを使うかは L<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> にある
"Far More Than You Ever Wanted To Know" の F<versus/csh.whynot> という記事で
説明されています。
あるコマンドの標準出力と標準エラー出力を両方とも捉えるには:

    $output = `cmd 2>&1`;                       # either with backticks
    $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
    while (<PH>) { }                            #    plus a read

=begin original

To capture a command's STDOUT but discard its STDERR:

=end original

あるコマンドの標準出力を捉え、標準エラー出力を捨てるには:

    $output = `cmd 2>/dev/null`;                # either with backticks
    $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
    while (<PH>) { }                            #    plus a read

=begin original

To capture a command's STDERR but discard its STDOUT:

=end original

あるコマンドの標準エラー出力を捉え、標準出力を捨てるには:

    $output = `cmd 2>&1 1>/dev/null`;           # either with backticks
    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
    while (<PH>) { }                            #    plus a read

=begin original

To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out our old STDERR:

=end original

あるコマンドの標準エラー出力を捉えるために
標準出力と標準エラー出力を入れ替えるが、標準出力に
古い標準エラー出力に出るようにするには:

    $output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
    while (<PH>) { }                            #    plus a read

=begin original

To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:

=end original

標準出力と標準エラー出力の両方を分けて読み出すには、
別々のファイルにリダイレクトしてしまって、
その後でそのファイルをプログラムから読むというのが最も簡単な方法です:

    system("program args 1>program.stdout 2>program.stderr");

=begin original

Ordering is important in all these examples. That's because the shell
processes file descriptor redirections in strictly left to right order.

=end original

これらの例では順序が重要です。
なぜなら、シェルがリダイレクトのためのファイル記述子を処理する順序は
正確に左から右へという順になっているからです。

    system("prog args 1>tmpfile 2>&1");
    system("prog args 2>&1 1>tmpfile");

=begin original

The first command sends both standard out and standard error to the
temporary file. The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.

=end original

最初のコマンドは標準出力と標準エラー出力の両方を一時ファイルに送ります。
二番目のコマンドは古い標準出力だけをファイルへと送り、古い標準エラー出力は
古い標準出力へと送り出します。

=head2 Why doesn't open() return an error when a pipe open fails?

(なぜ open() は パイプのオープンに失敗したときにエラーを返さないのでしょうか?)

=begin original

If the second argument to a piped C<open()> contains shell
metacharacters, perl C<fork()>s, then C<exec()>s a shell to decode the
metacharacters and eventually run the desired program. If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started. You can still capture the shell's STDERR and
check it for error messages. See L<"How can I capture STDERR from an
external command?"> elsewhere in this document, or use the
L<IPC::Open3> module.

=end original

パイプされた C<open()> の第二引数にシェルのメタ文字が含まれている場合、
perl は C<fork()> し、メタ文字をデコードするためにシェルを C<exec()> し、
最終的に必要なプログラムを実行します。
このプログラムが実行できない場合、メッセージを得るのはシェルであって、
Perl ではありません。
あなたの Perl プログラムがわかることはシェル自身が正しく開始されたかどうか
だけです。
エラーメッセージのためにシェルの STDERR を捕捉してチェックするという方法は
あります。
この文書の別の場所にある L<"How can I capture STDERR from an external
command?"> を参照するか、L<IPC::Open3> モジュールを使ってください。

=begin original

If there are no shell metacharacters in the argument of C<open()>, Perl
runs the command directly, without using the shell, and can correctly
report whether the command started.

=end original

C<open()> の引数にシェルのメタ文字がないなら、Perl はコマンドをシェルを使わずに
直接実行し、コマンドが開始したかどうかを正しく報告できます。

=head2 What's wrong with using backticks in a void context?

(無効コンテキストで逆クォートを使うことのなにが悪いのでしょうか?)

=begin original

Strictly speaking, nothing. Stylistically speaking, it's not a good
way to write maintainable code. Perl has several operators for
running external commands. Backticks are one; they collect the output
from the command for use in your program. The C<system> function is
another; it doesn't do this.

=end original

厳密に言えばありません。
形式的に言えば、保守しやすいコードを書くための良い方法ではありません。
Perl は外部コマンドを実行するためのいくつかの演算子があります。
逆クォートはその一つです; これはコマンドからの出力を、自身のプログラムで
使うために収集します。
C<system> 関数はもう一つのものです; これはコマンドからの出力を収集しません。

=begin original

Writing backticks in your program sends a clear message to the readers
of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?

=end original

プログラム中に逆クォートを書くことで、そのコマンドの出力を使いたいという
はっきりしたメッセージをあなたのコードの読者に送ります。
なぜ正しくないはっきりしたメッセージを送るのですか?

=begin original

Consider this line:

=end original

以下のような行を考えてみましょう:

    `cat /etc/termcap`;

=begin original

You forgot to check C<$?> to see whether the program even ran
correctly. Even if you wrote

=end original

プログラムが正しく実行されたかどうかを確認するために
C<$?> を見るのを忘れています。
以下のように書いたとしても

    print `cat /etc/termcap`;

=begin original

this code could and probably should be written as

=end original

このコードは、以下のように書くべきでしょう

    system("cat /etc/termcap") == 0
    or die "cat program failed!";

=begin original

which will echo the cat command's output as it is generated, instead
of waiting until the program has completed to print it out. It also
checks the return value.

=end original

これは、プログラムが出力を終えるのを待つのではなく、cat コマンドの出力が
生成される毎にエコーします。
これはまたその戻り値のチェックも行います。

=begin original

C<system> also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.

=end original

system() はまた、シェルのワイルドカード処理を行えるかどうかを直接
制御しますが、逆クォートはそういった制御は行いません。

=head2 How can I call backticks without shell processing?

(シェルの処理をせずに逆クォートを呼び出すには?)

=begin original

This is a bit tricky. You can't simply write the command
like this:

=end original

ちょっとトリッキーになります。
単純に以下のようにはコマンドを書けません:

    @ok = `grep @opts '$search_string' @filenames`;

=begin original

As of Perl 5.8.0, you can use C<open()> with multiple arguments.
Just like the list forms of C<system()> and C<exec()>, no shell
escapes happen.

=end original

Perl 5.8.0 から、複数の引数の C<open()> を使えます。
リスト形式の C<system()> や C<exec()> と同様に、シェルエスケープは
起きません。

    open( GREP, "-|", 'grep', @opts, $search_string, @filenames );
    chomp(@ok = <GREP>);
    close GREP;

=begin original

You can also:

=end original

以下のようにもできます:

    my @ok = ();
    if (open(GREP, "-|")) {
        while (<GREP>) {
            chomp;
            push(@ok, $_);
        }
        close GREP;
    } else {
        exec 'grep', @opts, $search_string, @filenames;
    }

=begin original

Just as with C<system()>, no shell escapes happen when you C<exec()> a
list. Further examples of this can be found in L<perlipc/"Safe Pipe
Opens">.

=end original

C<system()> を使ったときと同じく、シェルエスケープは C<exec()> のリストに
対して行われません。
さらなる例が L<perlipc/"Safe Pipe Opens"> にあります。

=begin original

Note that if you're using Windows, no solution to this vexing issue is
even possible. Even though Perl emulates C<fork()>, you'll still be
stuck, because Windows does not have an argc/argv-style API.

=end original

もしあなたが Windows を使っているのなら、この悩ましい問題を
解決する方法は全くありません。
たとえ Perl が C<fork()> をエミュレートしたとしても、まだうまくいきません;
なぜならマイクロソフトは argc/argv 形式の API を提供していないからです。

=head2 Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?

(なぜ EOF(UNIX での^D、MS-DOS での^Z)を受け取った後で STDIN から読み込むことができないの?)

=begin original

This happens only if your perl is compiled to use stdio instead of
perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The L<POSIX> module defines
C<clearerr()> that you can use. That is the technically correct way to
do it. Here are some less reliable workarounds:

=end original

これは、デフォルトである perlio ではなく、stdio を使ってコンパイルされた
perl でのみ起こります。
一部の(おそらく全ての?) stdio ではエラーフラグと eof フラグがセットされ、
それをクリアする必要があるからです。
L<POSIX> モジュールはこのために使える C<clearerr()> を定義しています。
これは、フラグをクリアするための技術的に正しい方法です。
以下の方法はこれよりは信頼性にかけるやり方です:

=over 4

=item 1

=begin original

Try keeping around the seekpointer and go there, like this:

=end original

以下の例のように、シークポインタを保存しておいてそこへ移動します:

    my $where = tell($log_fh);
    seek($log_fh, $where, 0);

=item 2

=begin original

If that doesn't work, try seeking to a different part of the file and
then back.

=end original

上のやりかたがだめなら、一度ファイルの別の部分にシークして、それから
元の場所にシークするようにします。

=item 3

=begin original

If that doesn't work, try seeking to a different part of
the file, reading something, and then seeking back.

=end original

これでもだめなら、ファイルの別の部分にシークして何かを読み出し、それから
元の場所にシークするようにします。

=item 4

=begin original

If that doesn't work, give up on your stdio package and use sysread.

=end original

これでだめなら stdio パッケージで行うことはあきらめて、sysread を使います。

=back

=head2 How can I convert my shell script to perl?

(私のシェルスクリプトを perl に変換するには?)

=begin original

Learn Perl and rewrite it. Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell->perl converter
nigh-on impossible to write. By rewriting it, you'll think about what
you're really trying to do, and hopefully will escape the shell's
pipeline datastream paradigm, which while convenient for some matters,
causes many inefficiencies.

=end original

Perl を学び、自分で書き直しましょう。
まじめな話、単純なコンバータというものはありません。
シェルで行うには不格好になるようなことも Perl では簡単に行うことができ、
そして、このとても不格好なことがシェル→ perl コンバーターを作製することを
ほとんど不可能なことにしているのです。
自分で書き換えをすることで、あなたは自分が本当に試すべきことについて
考えるようになり、シェルの(便利なときもあるものの多くの非効率を持ち込む)
パイプラインデータストリームパラダイムから逃れることができるでしょう。

=head2 Can I use perl to run a telnet or ftp session?

(telnet や ftp のセッションを実行するために perl を使うことができますか?)

=begin original

Try the L<Net::FTP>, L<TCP::Client>, and L<Net::Telnet> modules
(available from CPAN).
L<http://www.cpan.org/scripts/netstuff/telnet.emul.shar> will also help
for emulating the telnet protocol, but L<Net::Telnet> is quite
probably easier to use.

=end original

L<Net::FTP>, L<TCP::Client>, L<Net::Telnet> といったモジュール(CPAN で
入手可能です)を試してみてください。
L<http://www.cpan.org/scripts/netstuff/telnet.emul.shar> も
telnet プロトコルをエミュレートする助けになるでしょうが、L<Net::Telnet> は
使うのがとても簡単です。

=begin original

If all you want to do is pretend to be telnet but don't need
the initial telnet handshaking, then the standard dual-process
approach will suffice:

=end original

あなたのやりたいことが telnet のふりをすることであっても初期化時の
telnet のハンドシェイクを必要としないのであれば、
標準的な dual-process アプローチで十分でしょう。

    use IO::Socket;             # new in 5.004
    my $handle = IO::Socket::INET->new('www.perl.com:80')
        or die "can't connect to port 80 on www.perl.com $!";
    $handle->autoflush(1);
    if (fork()) {               # XXX: undef means failure
        select($handle);
        print while <STDIN>;    # everything from stdin to socket
    } else {
        print while <$handle>;  # everything from socket to stdout
    }
    close $handle;
    exit;

=head2 How can I write expect in Perl?

( Perl で expect を書くには?)

=begin original

Once upon a time, there was a library called F<chat2.pl> (part of the
standard perl distribution), which never really got finished. If you
find it somewhere, I<don't use it>. These days, your best bet is to
look at the L<Expect> module available from CPAN, which also requires two
other modules from CPAN, L<IO::Pty> and L<IO::Stty>.

=end original

昔々、F<chat2.pl> と呼ばれたライブラリがありました(これは標準の perl
配布キットに含まれます); 実際には完成していませんでした。
もしこれをどこかで見つけても I<使ってはいけません>。
今日では、CPAN にある L<IO::Pty> や L<IO::Stty> といった
ライブラリを使う L<Expect> を探すのが最善でしょう。

=head2 Is there a way to hide perl's command line from programs such as "ps"?

(“ps”のようなプログラムから、perl のコマンドラインを隠す方法はありますか?)

=begin original

First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite
your program so that critical information is never given as an
argument. Hiding the arguments won't make your program completely
secure.

=end original

まず初めに、あなたが(たとえば他人がパスワードを除くのを避けるためなどの)
セキュリティ上の理由でそれを行おうとしてるのであれば、
重要な情報が引数として与えられることがないようにプログラムを
書き直すべきだということに注意してください。
引数を隠すことは、あなたのプログラムを完全に安全なものにすることは
ありません。

=begin original

To actually alter the visible command line, you can assign to the
variable $0 as documented in L<perlvar>. This won't work on all
operating systems, though. Daemon programs like sendmail place their
state there, as in:

=end original

外部から見えるコマンドラインを実際に書き換えるために、L<perlvar> で
説明されているように $0 という変数に代入することができます。
ただし、これはすべてのオペレーティングシステムで実行できるというものでは
ありません。
sendmail のようなデーモンプログラムは以下の例のように状態を設定します:

    $0 = "orcus [accepting connections]";

=head2 I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?

(perl スクリプトの中で、ディレクトリを変更したり環境変数を変更しました。なぜ、スクリプトを終了したときこれらの変更は無効になってしまうの? 変更が反映されるようにするには?)

=over 4

=item Unix

=begin original

In the strictest sense, it can't be done--the script executes as a
different process from the shell it was started from. Changes to a
process are not reflected in its parent--only in any children
created after the change. There is shell magic that may allow you to
fake it by C<eval()>ing the script's output in your shell; check out the
comp.unix.questions FAQ for details.

=end original

もっとも厳密な意味で言うと、それはできません--スクリプトはそれを
起動したシェルとは異なるプロセスで実行されるのです。
あるプロセスに対する変更はその親に反映されることはありません
--変更した後で生成された子プロセスに対してのみ反映されます。
あなたの使っているシェルにおいてスクリプトの出力を C<eval()> することによって、
お望みのことをしたように見せかけるシェルマジック (shell magic)があります;
詳しくは comp.unix.questions FAQを調べてください。

=back

=head2 How do I close a process's filehandle without waiting for it to complete?

(プロセスの完了を待つことなしにそのファイルハンドルをクローズするには?)

=begin original

Assuming your system supports such things, just send an appropriate signal
to the process (see L<perlfunc/"kill">). It's common to first send a TERM
signal, wait a little bit, and then send a KILL signal to finish it off.

=end original

あなたの使っているシステムがそういった機能をサポートしていると仮定すると、
そのプロセスに対して適切なシグナルを送るだけです
(L<perlfunc/"kill"> を参照してください)。
最初にTERMシグナルを送り、ちょっとだけ待って、
終了させるために KILL シグナルを送るというのが一般的なものです。

=head2 How do I fork a daemon process?

(デーモンプロセスを fork() するには?)

=begin original

If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most
Unixish systems. Non-Unix users should check their Your_OS::Process
module for other solutions.

=end original

あなたのいうデーモンプロセスが detach されている(tty と
結び付けられていない)ものであれば、以下の手順がほとんどの UNIX 的な
システムで動作するということが報告されています。
非 UNIX ユーザーは Your_OS::Process モジュールで他の解決策を
あたるべきでしょう。

=over 4

=item *

=begin original

Open /dev/tty and use the TIOCNOTTY ioctl on it. See L<tty(1)>
for details. Or better yet, you can just use the C<POSIX::setsid()>
function, so you don't have to worry about process groups.

=end original

/dev/tty をオープンし、それに TIOCNOTTY ioctl を使います。
詳しくは L<tty(1)> を参照してください。
そのほかもっと良いのは、C<POSIX::setsid()> 関数を使うことです; これによって
プロセスグループに関して思い煩う必要がなくなります。

=item *

=begin original

Change directory to /

=end original

/ へディレクトリを変更します。

=item *

=begin original

Reopen STDIN, STDOUT, and STDERR so they're not connected to the old
tty.

=end original

STDIN、STDOUT、STDERR を再オープンします; これでこれらのハンドルは以前の
tty とは結び付けらていない状態になります。

=item *

=begin original

Background yourself like this:

=end original

以下のようにしてバックグラウンドにします:

    fork && exit;

=back

=begin original

The L<Proc::Daemon> module, available from CPAN, provides a function to
perform these actions for you.

=end original

CPAN で入手できる L<Proc::Daemon> モジュールはこれらの操作を
行ってくれる関数を提供しています。

=head2 How do I find out if I'm running interactively or not?

(自分が対話的に実行されているかどうかを知るには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

This is a difficult question to answer, and the best answer is
only a guess.

=end original

これは答えるのが難しい質問で、最良の答えは単なる推測です。

=begin original

What do you really want to know? If you merely want to know if one of
your filehandles is connected to a terminal, you can try the C<-t>
file test:

=end original

本当に知りたいことは何でしょう?
単にファイルハンドルの一つが端末と接続しているかどうかを知りたいなら、
C<-t> ファイルテストを試すことができます:

    if( -t STDOUT ) {
        print "I'm connected to a terminal!\n";
    }

=begin original

However, you might be out of luck if you expect that means there is a
real person on the other side. With the L<Expect> module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.

=end original

しかし、その先に実際の人間がいることを想定するなら、うまく
いかないかもしれません。
L<Expect> では、他のプログラムは人間である振りをします。
プログラムはチューリングテストに通過しそうになるかもしれません。

=begin original

The L<IO::Interactive> module does the best it can to give you an
answer. Its C<is_interactive> function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:

=end original

L<IO::Interactive> モジュールが答えとして最良のものです。
この C<is_interactive> 関数は出力ファイルハンドルを返します;
このファイルハンドルは、モジュールがセッションが対話的であると考えた
場合には、標準出力を示します。
さもなければ、ファイルハンドルは、単に出力が捨てられる空のハンドルです:

    use IO::Interactive;

    print { is_interactive } "I might go to standard output!\n";

=begin original

This still doesn't guarantee that a real person is answering your
prompts or reading your output.

=end original

これままだ実際の人間がプロンプトに答えたり出力を読んだりするのが
実際の人間であることを保証しません。

=begin original

If you want to know how to handle automated testing for your
distribution, you can check the environment. The CPAN
Testers, for instance, set the value of C<AUTOMATED_TESTING>:

=end original

あなたの配布での自動化テストの扱う方法を知りたいなら、環境を
チェックしてください。
例えば、CPAN Testers は C<AUTOMATED_TESTING> の値を設定します:

    unless( $ENV{AUTOMATED_TESTING} ) {
        print "Hello interactive tester!\n";
    }

=head2 How do I timeout a slow event?

(遅いイベントをタイムアウトするには?)

=begin original

Use the C<alarm()> function, probably in conjunction with a signal
handler, as documented in L<perlipc/"Signals"> and the section on
"Signals" in the Camel. You may instead use the more flexible
L<Sys::AlarmCall> module available from CPAN.

=end original

L<perlipc/"Signals"> やらくだ本の "Signal" の章で説明されているように、
C<alarm()> 関数と、おそらくはシグナルハンドラーを組み合わせて使います。
この代わりに、CPAN にあるより柔軟性のある 
L<Sys::AlarmCall> モジュールを使うこともできます。

=begin original

The C<alarm()> function is not implemented on all versions of Windows.
Check the documentation for your specific version of Perl.

=end original

C<alarm()> 関数は Windows の全てのバージョンで実装されているわけではありません。
あなたの特定のバージョンの Perl のドキュメントをチェックしてください。

=head2 How do I set CPU limits?
X<BSD::Resource> X<limit> X<CPU>

(CPU のリミットを設定するには?)

=begin original

(contributed by Xho)

=end original

(Xho によって寄贈されました)

=begin original

Use the L<BSD::Resource> module from CPAN. As an example:

=end original

CPAN にある L<BSD::Resource> モジュールを使います。
例として:

    use BSD::Resource;
    setrlimit(RLIMIT_CPU,10,20) or die $!;

=begin original

This sets the soft and hard limits to 10 and 20 seconds, respectively.
After 10 seconds of time spent running on the CPU (not "wall" time),
the process will be sent a signal (XCPU on some systems) which, if not
trapped, will cause the process to terminate. If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.

=end original

これはソフト制限とハード制限をそれぞれ 10 秒と 20 秒にセットします。
CPU が 10 秒の時間を消費後("wall" 時間ではありません)、プロセスはシグナル
(システムによっては XCPU)を送り、トラップされなければ、これによりプロセスは
終了します。
シグナルがトラップされると、さらに 10 秒(合計 20 秒)経過後、プロセスは
ブロック不可シグナルで kill されます。

=begin original

See the L<BSD::Resource> and your systems documentation for the gory
details.

=end original

詳細については L<BSD::Resource> とあなたのシステムのドキュメントを
参照してください。

=head2 How do I avoid zombies on a Unix system?

(UNIX システムでゾンビを回避するには?)

=begin original

Use the reaper code from L<perlipc/"Signals"> to call C<wait()> when a
SIGCHLD is received, or else use the double-fork technique described
in L<perlfaq8/"How do I start a process in the background?">.

=end original

SIGCHLD を受け取ったときに C<wait()> を呼び出すように L<perlipc/"Signals"> に
ある刈り取り機プログラム (reaper code) を使うか、
L<perlfaq8/"How do I start a process in the background?"> で
説明されている double-fork テクニックを使います。

=head2 How do I use an SQL database?

(SQL データベースを使うには?)

=begin original

The L<DBI> module provides an abstract interface to most database
servers and types, including Oracle, DB2, Sybase, mysql, Postgresql,
ODBC, and flat files. The DBI module accesses each database type
through a database driver, or DBD. You can see a complete list of
available drivers on CPAN: L<http://www.cpan.org/modules/by-module/DBD/> .
You can read more about DBI on L<http://dbi.perl.org/> .

=end original

L<DBI> モジュールはほとんどのデータベースサーバと型に対する抽象
インターフェースを提供します; これには Oracle, DB2, Sybase, mysql,
Postgresql, ODBC, フラットファイルを含みます。
DBI モジュールは、DBD と呼ばれるデータベースドライバを通して各データベース
型にアクセスします。
利用可能なドライバの完全な一覧は CPAN
(L<http://www.cpan.org/modules/by-module/DBD/>) にあります。
DBI に関するさらなる情報は L<http://dbi.perl.org/> にあります。

=begin original

Other modules provide more specific access: L<Win32::ODBC>, L<Alzabo>,
C<iodbc>, and others found on CPAN Search: L<http://search.cpan.org/> .

=end original

その他のモジュールはより具体的なアクセスを提供します: L<Win32::ODBC>,
L<Alzabo>, C<iodbc> などは CPAN Search (L<http://search.cpan.org/>) で
見つけられます。

=head2 How do I make a system() exit on control-C?

(コントロール-C で system() が exit するようにするには?)

=begin original

You can't. You need to imitate the C<system()> call (see L<perlipc> for
sample code) and then have a signal handler for the INT signal that
passes the signal on to the subprocess. Or you can check for it:

=end original

できません。
C<system()> 呼び出しを模倣する必要があり(L<perlipc> のサンプルコードを
参照してください)、サブプロセスでのシグナルを送る
INT シグナルのためのシグナルハンドラーを持つ必要があります。
あるいは、以下のようにしてチェックすることもできます:

    $rc = system($cmd);
    if ($rc & 127) { die "signal death" }

=head2 How do I open a file without blocking?

(ブロックせずにファイルをオープンするには?)

=begin original

If you're lucky enough to be using a system that supports
non-blocking reads (most Unixish systems do), you need only to use the
C<O_NDELAY> or C<O_NONBLOCK> flag from the C<Fcntl> module in conjunction with
C<sysopen()>:

=end original

幸運にもあなたの使っているシステムがノンブロッキング読み出し
(ほとんどの Unix 的システムはサポートしています)をサポートしているのであれば、
C<Fcntl> モジュールの C<O_NDELAY> や C<O_NONBLOCK> というフラグを
C<sysopen()> と一緒に使うだけです。

    use Fcntl;
    sysopen(my $fh, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
        or die "can't open /foo/somefile: $!":

=head2 How do I tell the difference between errors from the shell and perl?

(シェルからと perl からのエラーを見分けるには?)

=begin original

(answer contributed by brian d foy)

=end original

(答えは brian d foy によって寄贈されました)

=begin original

When you run a Perl script, something else is running the script for you,
and that something else may output error messages. The script might
emit its own warnings and error messages. Most of the time you cannot
tell who said what.

=end original

あなたが Perl スクリプトを実行すると、他の誰かがあなたのためにスクリプトを
動かします; そしてその他の誰かがエラーメッセージを出すことがあります。
スクリプトも自身の警告やエラーメッセージを出すかもしれません。
ほとんどの場合、それを言っているのが誰かは教えてもらえません。

=begin original

You probably cannot fix the thing that runs perl, but you can change how
perl outputs its warnings by defining a custom warning and die functions.

=end original

あなたが perl を実行しているものを修正することはおそらくできませんが、
独自の警告と die の関数を定義することで、perl がどのように警告を
出力するかを変えることはできます。

=begin original

Consider this script, which has an error you may not notice immediately.

=end original

すぐには気付かないかもしれない誤りを含むこのスクリプトを考えてみてください。

    #!/usr/locl/bin/perl

    print "Hello World\n";

=begin original

I get an error when I run this from my shell (which happens to be
bash). That may look like perl forgot it has a C<print()> function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.

=end original

これを私のシェル(たまたま bash でした)で実行するとエラーが表示されます。
これは perl が C<print()> 関数を忘れてしまったかのように見えますが、
#! 行の perl へのパスが間違っているので、シェルがこのスクリプトを実行し、
エラーが表示されます。

    $ ./test
    ./test: line 3: print: command not found

=begin original

A quick and dirty fix involves a little bit of code, but this may be all
you need to figure out the problem.

=end original

素早く汚い修正には少しコードが必要ですが、おそらく問題を見つけ出すのに
必要なものが全てあるでしょう。

    #!/usr/bin/perl -w

    BEGIN {
        $SIG{__WARN__} = sub{ print STDERR "Perl: ", @_; };
        $SIG{__DIE__}  = sub{ print STDERR "Perl: ", @_; exit 1};
    }

    $a = 1 + undef;
    $x / 0;
    __END__

=begin original

The perl message comes out with "Perl" in front. The C<BEGIN> block
works at compile time so all of the compilation errors and warnings
get the "Perl:" prefix too.

=end original

perl のメッセージは先頭に "Perl" を付けて出力されます。
C<BEGIN> ブロックはコンパイル時に動作するので、全てのコンパイル時のエラーと
警告にも "Perl:" の接頭辞がつきます。

    Perl: Useless use of division (/) in void context at ./test line 9.
    Perl: Name "main::a" used only once: possible typo at ./test line 8.
    Perl: Name "main::x" used only once: possible typo at ./test line 9.
    Perl: Use of uninitialized value in addition (+) at ./test line 8.
    Perl: Use of uninitialized value in division (/) at ./test line 9.
    Perl: Illegal division by zero at ./test line 9.
    Perl: Illegal division by zero at -e line 3.

=begin original

If I don't see that "Perl:", it's not from perl.

=end original

"Perl:" という文字がなければ、perl が出しているものではありません。

=begin original

You could also just know all the perl errors, and although there are
some people who may know all of them, you probably don't. However, they
all should be in the L<perldiag> manpage. If you don't find the error in
there, it probably isn't a perl error.

=end original

単に全ての perl のエラーを知るという方法もありますが、(全てのエラーを
知っている人もいるかもしれませんが)おそらくあなたは知らないでしょう。
しかし、これら全ては L<perldiag> マニュアルページにあるはずです。
もしエラーがここになければ、それはおそらく perl のエラーではありません。

=begin original

Looking up every message is not the easiest way, so let perl to do it
for you. Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.

=end original

全てのメッセージを探すというのは最も簡単な方法ではないので、その作業は
perl にさせます。
perl の通常のメッセージを、より長い説明に変更する diagnostics プラグマを
使います。

    use diagnostics;

=begin original

If you don't get a paragraph or two of expanded discussion, it
might not be perl's message.

=end original

段落一つか二つの追加の議論が表示されなければ、それは perl のメッセージでは
ないでしょう。

=head2 How do I install a module from CPAN?

(モジュールを CPAN からインストールするには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

The easiest way is to have a module also named CPAN do it for you by using
the C<cpan> command that comes with Perl. You can give it a list of modules
to install:

=end original

最も単純な方法は、Perl と同梱されている C<cpan> コマンドを使って、この仕事を
してくれる CPAN モジュールを入手することです。
インストールするモジュールの一覧を与えます:

    $ cpan IO::Interactive Getopt::Whatever

=begin original

If you prefer C<CPANPLUS>, it's just as easy:

=end original

C<CPANPLUS> が好みなら、やはり簡単です:

    $ cpanp i IO::Interactive Getopt::Whatever

If you want to install a distribution from the current directory, you can
tell C<CPAN.pm> to install C<.> (the full stop):

    $ cpan .

=begin original

See the documentation for either of those commands to see what else
you can do.

=end original

その他に出来ることについてはこれらのコマンドの文書を参照してください。

=begin original

If you want to try to install a distribution by yourself, resolving
all dependencies on your own, you follow one of two possible build
paths.

=end original

全ての依存を自分で解決して、配布を自分自身でインストールしてみたい場合は、
二つのビルド方法のどちらかに従います。

=begin original

For distributions that use I<Makefile.PL>:

=end original

I<Makefile.PL> を使う配布では:

    $ perl Makefile.PL
    $ make test install

=begin original

For distributions that use I<Build.PL>:

=end original

I<Build.PL> を使う配布では:

    $ perl Build.PL
    $ ./Build test
    $ ./Build install

=begin original

Some distributions may need to link to libraries or other third-party
code and their build and installation sequences may be more complicated.
Check any I<README> or I<INSTALL> files that you may find.

=end original

一部の配布ではライブラリはその他のサードパーティのコードへのリンクが
必要であったり、ビルドとインストールの手順がもっと複雑な場合もあります。
見付かった I<README> や I<INSTALL> ファイルをチェックしてください。

=head2 What's the difference between require and use?

(require と use の間の違いとは?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Perl runs C<require> statement at run-time. Once Perl loads, compiles,
and runs the file, it doesn't do anything else. The C<use> statement
is the same as a C<require> run at compile-time, but Perl also calls the
C<import> method for the loaded package. These two are the same:

=end original

Perl は C<require> 文を実行時に実行します。
一旦 Perl がロードされ、コンパイルされ、ファイルが実行されると、
他に何もしません。
C<use> 文は C<require> と同じことをコンパイル時に行いますが、
Perl はまたロードされたパッケージの C<import> メソッドを呼び出します。
以下の二つは同じです:

    use MODULE qw(import list);

    BEGIN {
        require MODULE;
        MODULE->import(import list);
    }

=begin original

However, you can suppress the C<import> by using an explicit, empty
import list. Both of these still happen at compile-time:

=end original

しかし、明示的に空のインポートリストを使うことで、C<import> を
抑制できます。
これらはどちらもやはりコンパイル時に起こります:

    use MODULE ();

    BEGIN {
        require MODULE;
    }

=begin original

Since C<use> will also call the C<import> method, the actual value
for C<MODULE> must be a bareword. That is, C<use> cannot load files
by name, although C<require> can:

=end original

C<use> は C<import> メソッドの呼び出しも行うので、
C<MODULE> の実際の値は裸の単語でなければなりません。
これは、C<use> は名前でファイルをロード出来ませんが、
C<require> ではできます:

    require "$ENV{HOME}/lib/Foo.pm"; # no @INC searching!

=begin original

See the entry for C<use> in L<perlfunc> for more details.

=end original

さらなる詳細については L<perlfunc> の C<use> の項目を参照してください。

=head2 How do I keep my own module/library directory?

(自分自身のモジュール/ライブラリディレクトリを持つには?)

=begin original

When you build modules, tell Perl where to install the modules.

=end original

モジュールを作成するときに、Perl にモジュールをインストールする場所を
指定します。

=begin original

If you want to install modules for your own use, the easiest way might
be L<local::lib>, which you can download from CPAN. It sets various
installation settings for you, and uses those same settings within
your programs.

=end original

自分自身が使うためにモジュールをインストールしたいなら、一番簡単な方法は、
CPAN からダウンロードできる L<local::lib> でしょう。
これは様々なインストール設定を行い、プログラム中で同じ設定を使います。

=begin original

If you want more flexibility, you need to configure your CPAN client
for your particular situation.

=end original

もっと柔軟性がほしいなら、CPAN クライアントを特定の状況に合わせて
設定する必要があります。

=begin original

For C<Makefile.PL>-based distributions, use the INSTALL_BASE option
when generating Makefiles:

=end original

C<Makefile.PL>-ベースの配布では、Makefile の生成時に INSTALL_BASE
オプションを使ってください:

    perl Makefile.PL INSTALL_BASE=/mydir/perl

=begin original

You can set this in your C<CPAN.pm> configuration so modules
automatically install in your private library directory when you use
the CPAN.pm shell:

=end original

CPAN.pm シェルを使ったときに、自動的にモジュールを自分のプライベートな
ディレクトリにインストールさせるように、CPAN.pm の設定を変更できます:

    % cpan
    cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
    cpan> o conf commit

=begin original

For C<Build.PL>-based distributions, use the --install_base option:

=end original

C<Build.PL>-ベースの配布では、--install_base オプションを使ってください:

    perl Build.PL --install_base /mydir/perl

=begin original

You can configure C<CPAN.pm> to automatically use this option too:

=end original

自動的にこのオプションを使うために、CPAN.pm を設定することも出来ます:

    % cpan
    cpan> o conf mbuild_arg "--install_base /mydir/perl"
    cpan> o conf commit

=begin original

INSTALL_BASE tells these tools to put your modules into
F</mydir/perl/lib/perl5>. See L<How do I add a directory to my
include path (@INC) at runtime?> for details on how to run your newly
installed modules.

=end original

INSTALL_BASE はこれらのツールにモジュールを F</mydir/perl/lib/perl5> に
置くように伝えます。
新しくインストールしたモジュールを実行する方法についての詳細は
L<How do I add a directory to my include path (@INC) at runtime?> を
参照してください。

=begin original

There is one caveat with INSTALL_BASE, though, since it acts
differently from the PREFIX and LIB settings that older versions of
L<ExtUtils::MakeMaker> advocated. INSTALL_BASE does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider whether you
really want that and, if you do, use the older PREFIX and LIB
settings. See the L<ExtUtils::Makemaker> documentation for more details.

=end original

しかし、INSTALL_BASE には一つの問題点があります;
なぜなら、より古いバージョンの L<ExtUtils::MakeMaker> が推奨していた
PREFIX および LIB とは異なった動作をするからです。
INSTALL_BASE は、複数のバージョンの Perl や異なったアーキテクチャに
対して同じディレクトリにモジュールをインストールすることには
対応していません。
もし本当にそれが必要でそうするなら、古い PREFIX と LIB の設定を
考慮するべきです。
さらなる詳細については L<ExtUtils::Makemaker> の文書を参照してください。

=head2 How do I add the directory my program lives in to the module/library search path?

(私のプログラムの置いてある場所をモジュール/ライブラリの検索パスに追加するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

If you know the directory already, you can add it to C<@INC> as you would
for any other directory. You might <use lib> if you know the directory
at compile time:

=end original

すでにディレクトリが分かっている場合は、それを C<@INC> に追加できます。
コンパイル時に分かっている場合は、<use lib> が使えます:

    use lib $directory;

=begin original

The trick in this task is to find the directory. Before your script does
anything else (such as a C<chdir>), you can get the current working
directory with the C<Cwd> module, which comes with Perl:

=end original

このタスクの秘訣は、ディレクトリを探すことです。
あなたのスクリプトが(C<chdir> などで)他の場所へ行く前に、Perl に
同梱されている C<Cwd> モジュールを使って、カレントワーキングディレクトリを
取得できます:

    BEGIN {
        use Cwd;
        our $directory = cwd;
    }

    use lib $directory;

=begin original

You can do a similar thing with the value of C<$0>, which holds the
script name. That might hold a relative path, but C<rel2abs> can turn
it into an absolute path. Once you have the

=end original

似たようなことは、スクリプト名を記録している C<$0> でもできます。
これは相対パスかもしれませんが、C<rel2abs> はこれを絶対パスに変更できます。
以下のようにすると

    BEGIN {
        use File::Spec::Functions qw(rel2abs);
        use File::Basename qw(dirname);

        my $path   = rel2abs( $0 );
        our $directory = dirname( $path );
    }

    use lib $directory;

=begin original

The L<FindBin> module, which comes with Perl, might work. It finds the
directory of the currently running script and puts it in C<$Bin>, which
you can then use to construct the right library path:

=end original

Perl に同梱されている L<FindBin> モジュールが働くでしょう。
これは現在実行しているスクリプトのディレクトリを見つけて C<$Bin> に
設定し、正しいライブラリパスを構築するために使えるようにします:

    use FindBin qw($Bin);

=begin original

You can also use L<local::lib> to do much of the same thing. Install
modules using L<local::lib>'s settings then use the module in your
program:

=end original

同じことをするのに L<local::lib> も使えます。
L<local::lib> の設定を使ってモジュールをインストールしてから、プログラムで
そのモジュールを使います:

     use local::lib; # sets up a local lib at ~/perl5

=begin original

See the L<local::lib> documentation for more details.

=end original

さらなる詳細については L<local::lib> の文書を参照してください。

=head2 How do I add a directory to my include path (@INC) at runtime?

(実行時にインクルードパス (@INC) にディレクトリを追加するには?)

=begin original

Here are the suggested ways of modifying your include path, including
environment variables, run-time switches, and in-code statements:

=end original

環境変数、実行時スイッチ、コード内の文などを使って、インクルードパスを
変更するためのお薦めの方法を挙げておきます:

=over 4

=item the C<PERLLIB> environment variable

(C<PERLLIB> 環境変数)

    $ export PERLLIB=/path/to/my/dir
    $ perl program.pl

=item the C<PERL5LIB> environment variable

(C<PERL5LIB> 環境変数)

    $ export PERL5LIB=/path/to/my/dir
    $ perl program.pl

=item the C<perl -Idir> command line flag

(C<perl -Idir> コマンドラインフラグ)

    $ perl -I/path/to/my/dir program.pl

=item the C<lib> pragma:

(C<lib> プラグマ)

    use lib "$ENV{HOME}/myown_perllib";

=item the L<local::lib> module:

    use local::lib;

    use local::lib "~/myown_perllib";

=back

=begin original

The last is particularly useful because it knows about machine-dependent
architectures. The C<lib.pm> pragmatic module was first
included with the 5.002 release of Perl.

=end original

最後のものが特に便利です; なぜなら、これはマシン依存のアーキテクチャを
知っているからです。
プラグマ的モジュール C<lib.pm> は Perl 5.002 で最初に導入されました。

=head2 Where are modules installed?

(モジュールはどこにインストールされますか?)

=begin original

Modules are installed on a case-by-case basis (as provided by the methods
described in the previous section), and in the operating system. All of these
paths are stored in @INC, which you can display with the one-liner

=end original

モジュールは(前の節で記述されている手法によって)ケースバイケースの場所で、
オペレーティングシステムの中にインストールされます。
これらのパスの全ては @INC に保管されていて、これは次の 1 行で
表示できます:

    perl -e 'print join("\n",@INC,"")'

=begin original

The same information is displayed at the end of the output from the command

=end original

同じ情報は次のコマンドの最後にも表示されます:

    perl -V

=begin original

To find out where a module's source code is located, use

=end original

モジュールのソースコードがどこにあるかを探すには、これを使い:

    perldoc -l Encode

=begin original

to display the path to the module. In some cases (for example, the C<AutoLoader>
module), this command will show the path to a separate C<pod> file; the module
itself should be in the same directory, with a 'pm' file extension.

=end original

モジュールのパスを表示します。
(例えば C<AutoLoader> モジュールのように) 一部の場合では、このコマンドは
個別の C<pod> へのパスを表示します; モジュール自身は同じディレクトリに、
'pm' ファイル拡張子であるはずです。

=head2 What is socket.ph and where do I get it?

(socket.ph とは一体何で、それはどこで入手できますか?)

=begin original

It's a Perl 4 style file defining values for system networking
constants. Sometimes it is built using L<h2ph> when Perl is installed,
but other times it is not. Modern programs should use C<use Socket;>
instead.

=end original

それは Perl 4 スタイルのファイルで、ネットワーク使用のための
値を定義しているものです。
これは Perl がインストールされたときに L<h2ph> を使って作成されることも
ありますが、そうでないときもあります。
最近のプログラムでは代わりに C<use Socket> を使うべきです。

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: SHIRAKATA Kentaro <argrath@ub32.org> (5.6.1-5.14.1, 5.00150039)
Status: completed

=end meta

