<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
		<link
			rel="shortcut icon"
			href="../../page/favicon.ico"
		/>
		<title>2時間半で学ぶPerl</title>
		<meta name="description" content="2時間半で学べるPerlのチュートリアル">
		<!-- linkto: http://qntm.org/files/perl/perl_jp.html -->


		<style type="text/css">
			@font-face {
				font-family: 'Ubuntu Mono';
				font-style: normal;
				font-weight: 700;
				src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url('http://themes.googleusercontent.com/static/fonts/ubuntumono/v3/ceqTZGKHipo8pJj4molytjqR_3kx9_hJXbbyU8S6IN0.woff') format('woff');
			}
			body {
				padding: 2em;
				font-family: Tahoma;
			}
			pre {
				margin-left: 2em;
                                padding-left: 1em;
			}
			code {
				color: #348275;
				font-family: "Ubuntu Mono", monospace;
			}
			.original {
				display: none;
			}
		</style>
	</head>

	<!-- http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700|Roboto+Slab:400,700 -->

	<body>
<h1 class="original">Learn Perl in about 2 hours 30 minutes</h1>
<h1>2時間半で学ぶPerl</h1>
<h2><a href="http://qntm.org/perl">By Sam Hughes</a>, translated by <a href="http://d.hatena.ne.jp/ktat/">Kato Atsusi</a></h2>

<p class="original">Perl is a dynamic, dynamically-typed, high-level, scripting (interpreted) language most comparable with PHP and Python. Perl's syntax owes a lot to ancient shell scripting tools, and it is famed for its overuse of confusing symbols, the majority of which are impossible to Google for. Perl's shell scripting heritage makes it great for writing <i>glue code</i>: scripts which link together other scripts and programs. Perl is ideally suited for processing text data and producing more text data. Perl is widespread, popular, highly portable and well-supported. Perl was designed with the philosophy "There's More Than One Way To Do It" (TMTOWTDI) (contrast with Python, where "there should be one - and preferably only one - obvious way to do it").</p>

<p>Perlは動的な、動的型付けの、高級な、スクリプト(インタープリタで解釈される)言語で、PHPやPythonとともによく比較されます。Perlのシンタックスは、昔のshellスクリプトツールから多くの部分を借りており、それにより混乱させるシンボルを使い過ぎていることで有名です。それらの大多数をGoogleで検索することは不可能です。Perlのshellスクリプトから受け継いだ遺産は、<i>glueコード</i>(他のスクリプトやプログラムと一緒にリンクされているスクリプト)を書くのに、大変役に立ちます。Perlは、理想的にテキストデータを処理することや、テキストデータを生成するのに適しています。Perlは広く行き渡り、有名であり、極めてポータブルで、十分にサポートされています。Perlは"There's More Than One Way To Do It(やり方はひとつじゃない)" (TMTOWTDI)の哲学でデザインされました(Pythonと比較すると、"there should be one - and preferably only one - obvious way to do it(明らかなやり方は、ひとつであるべきであり、むしろひとつのみであるべき)")。</p>

<p class="original">Perl has horrors, but it also has some great redeeming features. In this respect it is like every other programming language ever created.</p>
<p>Perlには恐ろしいところがありますが、それを補って余りある良さもあります。その点で、今までに作られた全ての他のプログラミング言語と同じです。</p>
<p class="original">This document is intended to be informative, not evangelical. It is aimed at people who, like me:</p>
<p>このドキュメントは、情報を与えることを意図しており、熱心に普及させるものではありません。以下のような、私のような人向けのものです:</p>
<ul class="original">
	<li>dislike the official Perl documentation at <a href="http://perl.org">http://perl.org/</a> for being intensely technical and giving far too much space to very unusual edge cases</li>
	<li>learn new programming languages most quickly by "axiom and example"</li>
	<li>wish Larry Wall would get to the point</li>
	<li>already know how to program in general terms</li>
	<li>don't care about Perl beyond what's necessary to get the job done.</li>
</ul>

<ul>
	<li>技術的過ぎて、一般的ではないエッジケースに多くの部分を割いている<a href="http://perl.org">http://perl.org/</a>にある、公式のPerlのドキュメントが嫌い</li>
	<li>"原理と例"で新しいプログラミング言語さっさと学びたい</li>
	<li>Larry Wallにはっきり言ってほしいと思っている</li>
	<li>一般的な用語でプログラムすることをすでに知っている</li>
	<li>仕事を終えるために何が必要かということ以上のことをPerlについて気にしない</li>
</ul>

<p class="original">This document is intended to be as short as possible, but no shorter.</p>

<p>このドキュメントは可能な限り短くしていますが、足らないことのないようにしています。</p>

<h2 class="original">Preliminary notes</h2>
<h2>前書き</h2>
<ul>
<li><p class="original">The following can be said of almost every declarative statement in this document: "that's not, strictly speaking, true; the situation is actually a lot more complicated". If you see a serious lie, point it out, but I reserve the right to preserve certain critical lies-to-children.
</p>
<p>以下のことを、このドキュメント内のほとんどすべての宣言文で言うことが出来ます: "これは、厳格な意味での、真実ではありません; 状況は実際にはもっと複雑です"。もし深刻な嘘を見つけたら、指摘してください。ですが、私には子どもにつく重要な嘘をそのままにしておく権利があります。</p></li>
<li><p class="original">Throughout this document I'm using example <code>print</code> statements to output data but not explicitly appending line breaks. This is done to prevent me from going crazy and to give greater attention to the actual string being printed in each case, which is invariably more important. In many examples, this results in alotofwordsallsmusheduptogetherononeline if the code is run in reality. Try to ignore this. 
</p>
<p>このドキュメントを通して、例において<code>print</code>ステートメントをデータを出力するために使っていますが、明示的に改行を追加していません。これは、私を気違いにさせないためであり、それぞれのケースで出力される、より重要な実際の文字列に多くの注意を向けさせるためです。多くの例で、実際にコードを動かすと、alotofwordsallsmusheduptogetherononelineのような結果になります。無視してください。</p></li>
</ul>

<h2 class="original">Hello world</h2>

<h2>Hello world</h2>

<p class="original">A Perl <i>script</i> is a text file with the extension <code>.pl</code>.</p>
<p>Perl<i>スクリプト</i>は<code>.pl</code>という拡張子のテキストファイルです。</p>
<p class="original">Here's the full text of <code>helloworld.pl</code>:</p>
<p><code>helloworld.pl</code>は以下のようになります:</p>
<pre class="prettyprint lang-perl">
use strict;
use warnings;

<a href="http://perldoc.jp/func/print">print</a> "Hello world";
</pre>
<p class="original">Perl scripts are interpreted by the Perl interpreter, <code>perl</code> or <code>perl.exe</code>:</p>
<p>PerlスクリプトはPerlインタープリタ、<code>perl</code>か<code>perl.exe</code>で解釈されます:</p>

<pre class="bash">
perl helloworld.pl [arg0 [arg1 [arg2 ...]]]
</pre>
<p class="original">A few immediate notes. Perl's syntax is highly permissive and it will allow you to do things which result in ambiguous-looking statements with unpredictable behaviour. There's no point in me explaining what these behaviours are, because you want to avoid them. The way to avoid them is to put <code>use strict; use warnings;</code> at the very top of every Perl script or module that you create. Statements of the form <code>use foo;</code> are <i>pragmas</i>. A pragma is a signal to <code>perl.exe</code>, which takes effect when initial syntactic validation is being performed, before the program starts running. These lines have no effect when the interpreter encounters them at run time.</p>

<p>当面のメモとしていくつか。Perlのシンタックスはかなり寛大なので、結果として振る舞いを予測できない曖昧に見えるようなセンテンスを書くことをあなたに許します。私にとっては意味がないので、それらの振る舞いに関して説明しません。なぜなら、あなたはそれらを避けたいでしょうから。それらを避ける方法は、<code>use strict;use warnings;</code>を、あなたの作る全てのperlスクリプトやモジュールの上の方に置くことです。<code>use</code> fooのステートメントは<i>プラグマ</i>です。プラグマは<code>Perl.exe</code>へのシグナルです。プログラムが走り始める前に、最初のシンタックスチェックをする方法を変更します。これらの行はコンパイル時に影響し、実行時にはインタープリタが出くわしても影響を受けません。</p>
<p class="original">The semicolon, <code>;</code>, is the statement terminator. The symbol <code>#</code> begins a comment. A comment lasts until the end of the line. Perl has no block comment syntax.</p>
<p>セミコロン<code>;</code>はステートメントの終わりです。<p>シンボル<code>#</code>はコメントの開始です。コメントは行末で終わります。Perlには、ブロックコメントのシンタックスはありません。</p>

<h2 class="original">Variables</h2>

<h2>変数</h2>

<p class="original">Perl variables come in three types: <i>scalars</i>, <i>arrays</i> and <i>hashes</i>. Each type has its own <i>sigil</i>: <code>$</code>, <code>@</code> and <code>%</code> respectively. Variables are declared using <code>my</code>, and remain in scope until the end of the enclosing block or file.</p>

<p>Perlの変数には次の3タイプあります: <i>スカラ</i>、<i>配列</i>、 <i>ハッシュ</i>です. それぞれのタイプには、自身の<i>シジル(sigil)</i>があります: それぞれ、<code>$</code>, <code>@</code> and <code>%</code>。 変数は<code>my</code>で宣言され、ブロックかファイルの最後までスコープ内に残ります。</p>

<h3 class="original">Scalar variables</h3>

<h3>スカラ変数</h3>

<p class="original">A scalar variable can contain:</p>
<p>スカラ変数は以下のものを格納できます:</p>
<ul class="original">
	<li><code>undef</code> (corresponds to <code>None</code> in Python, <code>null</code> in PHP)</li>
	<li>a number (Perl does not distinguish between an integer and a float)</li>
	<li>a string</li>
	<li>a reference to any other variable.</li>
</ul>
<ul>
	<li><code>undef</code> (Pythonにおける<code>None</code>、PHPの<code>null</code>に対応)</li>
	<li>数字 (Perlはintegerとfloatを区別しません)</li>
	<li>文字</li>
	<li>他の変数へのリファレンス</li>
</ul>

<pre class="prettyprint lang-perl">
my $undef = undef;
print $undef; # prints the empty string "" and raises a warning

# implicit undef:
my $undef2;
print $undef2; # prints "" and raises exactly the same warning
</pre>

<pre class="prettyprint lang-perl">
my $num = 4040.5;
print $num; # "4040.5"
</pre>

<pre class="prettyprint lang-perl">
my $string = "world";
print $string; # "world"
</pre>

<p class="original">(References are coming up shortly.)</p>
<p>(リファレンスは後で説明します)</p>

<p class="original">String concatenation using the <code>.</code> operator (same as PHP):</p>
<p>文字列の連結には<code>.</code>演算子を使います(PHPと同じ):</p>
<pre class="prettyprint lang-perl">
print "Hello ".$string; # "Hello world"
</pre>

<h3 class="original">"Booleans"</h3>
<h3>真偽値</h3>
<p class="original"><strong>Perl has no boolean data type.</strong> A scalar in an <code>if</code> statement evaluates to boolean "false" if and only if it is one of the following:</p>

<p><strong>Perlにはブーリアンのデータ型はありません。</strong> <code>if</code>ステートメントではスカラは、以下のいずれかの場合にのみ"偽"として評価されます:</p>

<ul>
	<li><code>undef</code></li>
	<li>number <code>0</code></li>
	<li>string <code>""</code></li>
	<li>string <code>"0"</code>.</li>
</ul>

<p class="original">The Perl documentation <em>repeatedly</em> claims that functions return "true" or "false" values in certain situations. In practice, when a function is claimed to return "true" it usually returns <code>1</code>, and when it is claimed to return false it usually returns the empty string, <code>""</code>.</p>

<p>Perlのドキュメントでは、<em>繰り返し</em>、特定の状況で"真"か"偽"の値を関数が返すように主張しています。実際には、関数が真を返すように主張しているときは、普通<code>1</code>を返します。また、関数が偽を返すように主張しているなら、普通は空文字<code>""</code>を返します。</p>

<h3 class="original">Weak typing</h3>
<h3>弱い型付け</h3>
<p class="original"><strong>It is impossible to determine whether a scalar contains a "number" or a "string".</strong> More precisely, it should never be necessary to do this. Whether a scalar behaves like a number or a string depends on the operator with which it is used. When used as a string, a scalar will behave like a string. When used as a number, a scalar will behave like a number (raising a warning if this isn't possible):</p>
<p><strong>スカラーに"数字"か"変数"のいずれかが入っているのかを判断することはできません。</strong> より正確には、そんなことは見当違いです。Perlはその点で弱い型付けです。 スカラが数字か文字のどちらかのように振舞うかは、使われる演算子によります。文字列として使えば、スカラは文字列のようにふるまいます。数字として使えば、スカラは数字のようにふるまいます(また、そうすることが出来なければ、警告を発します):</p>

<pre class="prettyprint lang-perl">
my $str1 = "4G";
my $str2 = "4H";

print $str1 .  $str2; # "4G4H"
print $str1 +  $str2; # "8" with two warnings
print $str1 eq $str2; # "" (empty string, i.e. false)
print $str1 == $str2; # "1" with two warnings

# The classic error
print "yes" == "no"; # "1" with two warnings; both values evaluate to 0 when used as numbers
</pre>
<p class="original">The lesson is to always using the correct operator in the correct situation. There are separate operators for comparing scalars as numbers and comparing scalars as strings:</p>
<p>このレッスンでは、正しい状況で正しい演算子を使うようにしています。数字としてスカラを比較するのと、文字列としてスカラを比較するのとでは、演算子を区別します。:</p>

<pre class="perl original">
# Numerical operators:  &lt;,  &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt;, +, *
# String operators:    <a href="http://perldoc.perl.org/perlop.html#Equality-Operators">lt, gt, le, ge, eq, ne, cmp</a>, <a href="http://perldoc.perl.org/perlop.html#Multiplicative-Operators">.</a>, <a href="http://perldoc.perl.org/perlop.html#Multiplicative-Operators">x</a>
</pre>

<pre class="prettyprint lang-perl">
# 数字用の演算子:  &lt;,  &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt;
# 文字用の演算子:     <a href="http://perldoc.jp/docs/perl/perlop.pod#Equality32Operators">lt, gt, le, ge, eq, ne, cmp</a>, <a href="http://perldoc.jp/docs/perl/perlop.pod#Multiplicative32Operators">.</a>, <a href="http://perldoc.jp/docs/perl/perlop.pod#Multiplicative32Operators">x</a>
</pre>

<h3 class="original">Array variables</h3>
<h3>配列変数</h3>

<p class="original">An array variable is a list of scalars indexed by integers beginning at 0. In Python this is known as a <i>list</i>, and in PHP this is known as an <i>array</i>. An array is declared using a parenthesised list of scalars:</p>
<p>配列変数は整数の0で始まるはじまるインデックスされたスカラです。Pythonでは、<i>list</i>で、PHPでは、<i>array</i>です。配列は丸括弧を使って宣言される、配列のリストです。</p>

<pre class="perl original">
my @array = (
	"print",
	"these",
	"strings",
	"out",
	"for",
	"me", # trailing comma is okay
);
</pre>

<pre class="prettyprint lang-perl">
my @array = (
	"print",
	"these",
	"strings",
	"out",
	"for",
	"me", # カンマを最後に続けても問題ありません
);
</pre>

<p class="original">You have to use a dollar sign to access a value from an array, because the value being <em>retrieved</em> is not an array but a scalar:</p>

<p>配列から値にアクセスするときにはドル記号を使わなければいけません。<em>取られる</em>値は配列ではなく、スカラだからです:</p>

<pre class="prettyprint lang-perl">
print $array[0]; # "print"
print $array[1]; # "these"
print $array[2]; # "strings"
print $array[3]; # "out"
print $array[4]; # "for"
print $array[5]; # "me"
print $array[6]; # returns undef, prints "" and raises a warning
</pre>

<p class="original">You can use negative indices to retrieve entries starting from the end and working backwards:</p>
<p>負のインデックスを、後ろから値を取るのに使えます。逆向きになります:</p>

<pre class="prettyprint lang-perl">
print $array[-1]; # "me"
print $array[-2]; # "for"
print $array[-3]; # "out"
print $array[-4]; # "strings"
print $array[-5]; # "these"
print $array[-6]; # "print"
print $array[-7]; # returns undef, prints "" and raises a warning
</pre>

<p class="original">There is no collision between a scalar <code>$var</code> and an array <code>@var</code> containing a scalar entry <code>$var[0]</code>. There may, however, be reader confusion, so avoid this.</p>

<p>スカラ<code>$var</code>とスカラのエントリ<code>$var[0]</code>を持つ配列<code>@var</code>は衝突しません。 とはいえ、コードを読む人が混乱しますので、同じ名前を付けるのは避けましょう。</p>

<p class="original">To get an array's length:</p>
<p>配列の長さを得るには:</p>

<pre class="prettyprint lang-perl">
print "This array has ".(scalar @array)."elements"; # "This array has 6 elements"
print "The last populated index is ".$#array;       # "The last populated index is 5"
</pre>

<p class="original">The arguments with which the original Perl script was invoked are stored in the <a href="http://perldoc.perl.org/perlvar.html">built-in array variable</a> <code>@ARGV</code>.</p>
<p>オリジナルのPerlスクリプトの実行時の引数は、<a href="http://perldoc.jp/docs/perl/perlvar.pod">組込の配列変数</a><code>@ARGV</code>に入ります。</p>

<p class="original">Variables can be interpolated into strings:</p>
<p>変数を文字列の間に入れることができます:</p>
<pre class="prettyprint lang-perl">
print "Hello $string"; # "Hello world"
print "@array";        # "print these strings out for me"
</pre>

<p class="original"><strong>Caution.</strong> One day you will put somebody's email address inside a string, <code>"jeff@gmail.com"</code>. This will cause Perl to look for an array variable called <code>@gmail</code> to interpolate into the string, and not find it, resulting in a runtime error. Interpolation can be prevented in two ways: by backslash-escaping the sigil, or by using single quotes instead of double quotes.</p>
<p><strong>注意。</strong> ある日、誰かのメールアドレス、<code>"jeff@gmail.com"</code>を文字列に入れたとします。 これは、Perlに<code>@gmail</code>という配列変数を探させ、文字列の間に入れようとします。それが見つからなければ、エラーになります。変数の展開を防ぐには2つの方法があります:シジルをエスケープする。または、ダブルクォートの代わりにシングルクォートを使う。</p>

<pre class="prettyprint lang-perl">
print "Hello \$string"; # "Hello $string"
print 'Hello $string';  # "Hello $string"
print "\@array";        # "@array"
print '@array';         # "@array"
</pre>

<h3 class="original">Hash variables</h3>
<h3>ハッシュ変数</h3>

<p class="original">A hash variable is a list of scalars indexed by strings. In Python this is known as a <i>dictionary</i>, and in PHP it is known as an <i>array</i>.</p>
<p>ハッシュ変数は文字でインデックスされた素からのリストです。Pythonでは<i>dictionary</i>、PHPでは<i>array</i>になります。</p>

<pre class="prettyprint lang-perl">
my %scientists = (
	"Newton"   =&gt; "Isaac",
	"Einstein" =&gt; "Albert",
	"Darwin"   =&gt; "Charles",
);
</pre>

<p class="original">Notice how similar this declaration is to an array declaration. In fact, the double arrow symbol <code>=&gt;</code> is called a "fat comma", because it is just a synonym for the comma separator. A hash is declared using a list with an even number of elements, where the even-numbered elements (0, 2, ...) are all taken as strings.</p>
<p>この宣言は配列変数の宣言にとても似ていることに注意してください。実際に、二重矢印記号<code>=&gt;</code>は、"ファットカンマ"と呼ばれます。というのも、これは、カンマセパレータのまさにシノニムだからです。ハッシュは偶数の数のリストを使って宣言されます。偶数の要素(0, 2, ...)は全て文字列として取られます。</p>

<p class="original">Once again, you have to use a dollar sign to access a value from a hash, because the value being <em>retrieved</em> is not a hash but a scalar:</p>
<p>またまた、ハッシュから値にアクセスするには、ドル記号を使わなければいけません。<em>取られる</em>値はハッシュではなく、スカラだからです:</p>

<pre class="perl original">
print $scientists{"Newton"};   # "Isaac"
print $scientists{"Einstein"}; # "Albert"
print $scientists{"Darwin"};   # "Charles"
print $scientists{"Dyson"};    # returns undef, prints "" and raises a warning
</pre>

<pre class="prettyprint lang-perl">
print $scientists{"Newton"};   # "Isaac"
print $scientists{"Einstein"}; # "Albert"
print $scientists{"Darwin"};   # "Charles"
print $scientists{"Dyson"};    # undefを返すので、""が出力され、警告が起きます。
</pre>

<p class="original">Note the braces used here. Again, there is no collision between a scalar <code>$var</code> and a hash <code>%var</code> containing a scalar entry <code>$var{"foo"}</code>.</p>

<p>ブレースが使われていることに注意してください。配列のときと同じですが、スカラの<code>$var</code>とスカラのエントリ<code>$var{"foo"}</code>が入っているハッシュの<code>%var</code>は衝突しません。</p>

<p class="original">You can convert a hash straight to an array with twice as many entries, alternating between key and value (and the reverse is equally easy):</p>
<p>エントリを2倍にしてハッシュを配列に直接変換することや、キーと値を変更することができます(その逆もまた簡単です):</p>

<pre class="prettyprint lang-perl">
my @scientists = %scientists;
</pre>

<p class="original">However, unlike an array, the keys of a hash have <em>no underlying order</em>. They will be returned in whatever order is more efficient. So, notice the rearranged <em>order</em> but preserved <em>pairs</em> in the resulting array:</p>

<p>ですが、配列とは違い、ハッシュのキーは<em>順番がありません</em>。より効率的な順番で返ってきます。そのため、整列され直された<em>順番</em>に気をつけてください。しかし、結果の配列の<em>ペア</em>は保持されます:</p>

<pre class="prettyprint lang-perl">
print "@scientists"; # something like "Einstein Albert Darwin Charles Newton Isaac"
</pre>

<p class="original">To recap, you have to use <strong>square brackets</strong> to retrieve a value from an array, but you have to use <strong>braces</strong> to retrieve a value from a hash. The square brackets are effectively a numerical operator and the braces are effectively a string operator. The fact that the <em>index</em> supplied is a number or a string is of absolutely no significance:</p>
<p>要点をまとめると、配列から値を取り出すのには<strong>四角いブラケット</strong>を使わなければいけませんが、ハッシュから値を取り出すのは<strong>ブレース</strong>を使わなければいけません。提供される<em>インデックス</em>が数字であるか文字列であるということには、重要性はありません:</p>

<pre class="prettyprint lang-perl">
my $data = "orange";
my @data = ("purple");
my %data = ( "0" =&gt; "blue");

print $data;      # "orange"
print $data[0];   # "purple"
print $data["0"]; # "purple"
print $data{0};   # "blue"
print $data{"0"}; # "blue"
</pre>

<h3 class="original">Lists</h3>
<h3>リスト</h3>

<p class="original">A <i>list</i> in Perl is a different thing again from either an array or a hash. You've just seen several lists:</p>
<p>Perlにおける<i>リスト</i>は配列やハッシュとは違うものです。既にいくつかのリストがありました:</p>

<pre class="prettyprint lang-perl">
(
	"print",
	"these",
	"strings",
	"out",
	"for",
	"me",
)

(
	"Newton"   =&gt; "Isaac",
	"Einstein" =&gt; "Albert",
	"Darwin"   =&gt; "Charles",
)
</pre>

<p class="original"><strong>A list is not a variable.</strong> A list is an ephemeral <em>value</em> which can be <em>assigned</em> to an array or a hash variable. This is why the syntax for declaring array and hash variables is identical. There are many situations where the terms "list" and "array" can be used interchangeably, but there are equally many where lists and arrays display subtly different and extremely confusing behaviour.</p>
<p><strong>リストは変数ではありません。</strong>リストはその場限りの<em>値</em>で、配列やハッシュ変数に<em>割り当て</em>られます。このことは、配列とハッシュの変数の宣言のシンタックスがが一致していることの理由です。"リスト"と"配列"の用語が交換可能な状況は多くありますが、同様に、リストと配列がいくぶん違って見えるところもあり、その振る舞いに非常に混乱します。</p>
<p class="original">Okay. Remember that <code>=&gt;</code> is just <code>,</code> in disguise and then look at this example:</p>
<p>いいでしょう。 <code>=&gt;</code>は、ただの<code>,</code>であることを思い出し、返送させて、次の例を見てください:</p>

<pre class="prettyprint lang-perl">
("one", 1, "three", 3, "five", 5)
("one" =&gt; 1, "three" =&gt; 3, "five" =&gt; 5)
</pre>

<p class="original">The use of <code>=&gt;</code> hints that one of these lists is an array declaration and the other is a hash declaration. But on their own, neither of them are declarations of anything. They are just lists. <em>Identical</em> lists. Also:</p>
<p><code>=&gt;</code>の使い方が一方のリストが配列の宣言であることを示し、他方はハッシュの宣言であることを示しています。ですが、2つとも、それ自身、何の宣言でもありません。ただのリストです。<em>同一の</em>リストです。また:</p>

<pre class="prettyprint lang-perl">
()
</pre>

<p class="original">There aren't even hints here. This list could be used to declare an empty array or an empty hash and the <code>perl</code> interpreter clearly has no way of telling either way. Once you understand this odd aspect of Perl, you will also understand why the following fact must be true: <strong>List values cannot be nested.</strong> Try it:</p>

<p>なんのヒントも存在しません。このリストは空の配列として宣言されているのでしょうか、それとも、カラのハッシュとしてでしょうか。<code>perl</code>インタープリタには、明らかにどちらとも判断することができません。Perlの変わった一面であると理解したなら、次の事実が真であることもまた理解するでしょう: <strong>リストの値はネストできません。</strong> 試してみてください:</p>

<pre class="prettyprint lang-perl">
my @array = (
	"apples",
	"bananas",
	(
		"inner",
		"list",
		"several",
		"entries",
	),
	"cherries",
);
</pre>

<p class="original">Perl has no way of knowing whether <code>("inner", "list", "several", "entries")</code> is supposed to be an inner array or an inner hash. Therefore, Perl assumes that it is neither and <strong>flattens the list out into a single long list</strong>:</p>

<p>Perlには、<code>("inner"(訳註:内側の), "list"(訳註:リストが), "several"(訳註:複数の), "entries"(訳註:値))</code>が内包された配列なのか、ハッシュなのかどうかがわかりません。そのため、Perlはいずれでもないと想定し、<strong>ひとつの長いリストに平板化します</strong>:</p>

<pre class="perl original">
print $array[0]; # "apples"
print $array[1]; # "bananas"
print $array[2]; # "inner"
print $array[3]; # "list"
print $array[4]; # "several"
print $array[5]; # "entries"
print $array[6]; # "cherries"
</pre>

<p class="original">The same is true whether the fat comma is used or not:</p>
<p>ファットカンマを使っていてもいなくても同じく真です:</p>

<pre class="perl original">
my %hash = (
	"beer" =&gt; "good",
	"bananas" =&gt; (
		"green"  =&gt; "wait",
		"yellow" =&gt; "eat",
	),
);

# The above raises a warning because the hash was declared using a 7-element list

print $hash{"beer"};    # "good"
print $hash{"bananas"}; # "green"
print $hash{"wait"};    # "yellow";
print $hash{"eat"};     # undef, so prints "" and raises a warning
</pre>

<pre class="prettyprint lang-perl">
my %hash = (
	"beer" =&gt; "good",
	"bananas" =&gt; (
		"green"  =&gt; "wait",
		"yellow" =&gt; "eat",
	),
);

# 上のコードはwarningが出ます。ハッシュが7つの要素のリストで宣言されているからです。

print $hash{"beer"};    # "good"
print $hash{"bananas"}; # "green"
print $hash{"wait"};    # "yellow";
print $hash{"eat"};     # undef, そのため、警告が出て、""を出力します
</pre>

<p class="original">Of course, this does make it easy to concatenate multiple arrays together:</p>
<p>もちろん、このことは複数の配列を一緒にしやすくしています:</p>

<pre class="prettyprint lang-perl">
my @bones   = ("humerus", ("jaw", "skull"), "tibia");
my @fingers = ("thumb", "index", "middle", "ring", "little");
my @parts   = (@bones, @fingers, ("foot", "toes"), "eyeball", "knuckle");
print @parts;
</pre>

<p class="original">More on this shortly.</p>
<p>詳細は後ほど。</p>

<h2 class="original">Context</h2>
<h2>コンテキスト</h2>

<p class="original">Perl's most distinctive feature is that its code is <i>context-sensitive</i>. <strong>Every expression in Perl is evaluated either in scalar context or list context</strong>, depending on whether it is expected to produce a scalar or a list. Many Perl expressions and <a href="http://perldoc.perl.org/perlfunc.html">built-in functions</a> display radically different behaviour depending on the context in which they are evaluated.</p>

<p>Perlの最も特徴のあるところは、コードが<i>コンテクストセンシティブ</i>なところです。<strong>Perlの全ての式はスカラコンテキストかリストコンテキストで評価されます</strong>。スカラかリストをのいずれかを作るかを期待されているかに依存します。多くのPerlの式と<a href="http://perldoc.jp/docs/perl/perlfunc.pod">組込の関数</a>は、それが評価されるコンテキストによって、振る舞いに根本的に違いを見せます。</p>

<p class="original">A scalar assignment such as <code>$scalar =</code> evaluates its expression in scalar context. In this case, the expression is <code>"Mendeleev"</code> and the returned value is the same scalar value <code>"Mendeleev"</code>:</p>

<p><code>$scalar =</code>のようなスカラの割り当てはスカラコンテキストとして評価されます。このケースでは、この式は<code>"Mendeleev"</code>と、返される値は<code>"Mendeleev"</code>と同じスカラになります:</p>

<pre class="prettyprint lang-perl">
my $scalar = "Mendeleev";
</pre>
<p class="original">An array or hash assignment such as <code>@array =</code> or <code>%hash =</code> evaluates its expression in list context. A list value evaluated in list context returns the list, which then gets fed in to populate the array or hash:</p>
<p><code>@array =</code> や <code>%hash =</code> のような配列やハッシュの割り当ては、リストコンテキストで評価されます。リストの値はリストコンテキストで評価され、リストを返します。配列やハッシュに代入するようなときです:</p>

<pre class="prettyprint lang-perl">
my @array = ("Alpha", "Beta", "Gamma", "Pie");
my %hash = ("Alpha" =&gt; "Beta", "Gamma" =&gt; "Pie");
</pre>

<p class="original">No surprises so far.</p>
<p>驚くようなことはありません。</p>

<p class="original">A scalar expression evaluated in list context turns into a single-element list:</p>
<p>スカラの式はリストコンテキストで評価されると、ひとつの値のリストとなります:</p>

<pre class="prettyprint lang-perl">
my @array = "Mendeleev"; # same as 'my @array = ("Mendeleev");'
</pre>

<p class="original">A list expression evaluated in scalar context returns <em>the final scalar in the list</em>:</p>
<p>リストの式がスカラコンテキストで評価されると、<em>リストの最後のスカラ</em>を返します:</p>
<pre class="prettyprint lang-perl">
my $scalar = ("Alpha", "Beta", "Gamma", "Pie"); # Value of $scalar is now "Pie"
</pre>
<p class="original">An array expression (an array is different from a list, remember?) evaluated in scalar context returns <em>the length of the array</em>:</p>
<p>配列の式(配列はリストと違います。覚えてる？)は、スカラコンテキストでは<em>配列の長さ</em>を返します:</p>

<pre class="prettyprint lang-perl">
my @array = ("Alpha", "Beta", "Gamma", "Pie");
my $scalar = @array; # Value of $scalar is now 4
</pre>
<p class="original">The <code><a href="http://perldoc.perl.org/functions/print.html">print</a></code> built-in function evaluates all of its arguments in list context. In fact, <code>print</code> accepts an unlimited list of arguments and prints each one after the other, which means it can be used to print arrays directly:</p>
<p><code><a href="http://perldoc.jp/func/print">print</a></code> 組込関数は全ての引数をリストコンテキストで評価します。<code>print</code>は無制限のリストの引数を受取り、一つ一つ出力します。つまり、配列を直接与えることが出来ます。</p>
<pre class="prettyprint lang-perl">
my @array = ("Alpha", "Beta", "Goo");
my $scalar = "-X-";
print @array;              # "AlphaBetaGoo";
print $scalar, @array, 98; # "-X-AlphaBetaGoo98";
</pre>
<p class="original">You can force any expression to be evaluated in scalar context using the <code><a href="http://perldoc.perl.org/functions/scalar.html">scalar</a></code> built-in function. In fact, this is why we use <code>scalar</code> to retrieve the length of an array.</p>
<p>どのような式も<code>scalar</code>組込関数を使えばスカラコンテキストで強制的に評価することが出来ます。このことが、なぜ<code><a href="http://perldoc.jp/func/scalar">scalar</a></code>を配列の長さを取るのに使うのかの理由です。</p>

<p class="original">You are not bound by law or syntax to return a scalar value when a subroutine is evaluated in scalar context, nor to return a list value in list context. As seen above, Perl is perfectly capable of fudging the result for you.</p>
<p>サブルーチンがスカラコンテキストで評価されるときにスカラを返すような法律やシンタックスにはあなたは縛られていませんし、また、リストコンテキストでリストを返すこともまた同じです。上で見たように、Perlは完全にあなたのために結果を作ることができます。</p>

<h2 class="original">References and nested data structures</h2>
<h2>リファレンスとネストされたデータ構造</h2>

<p class="original">In the same way that lists cannot contain lists as elements, <strong>arrays and hashes cannot contain other arrays and hashes as elements.</strong> They can only contain scalars. Watch what happens when we try:</p>
<p>リストが要素としてリストを含めないのと同様、<strong>配列とハッシュは他の配列やハッシュを要素として持てません</strong>。 両方ともスカラしか持てません。 今から試すことをよく見てください:</p>

<pre class="prettyprint lang-perl">
my @outer = ("Sun", "Mercury", "Venus", undef, "Mars");
my @inner = ("Earth", "Moon");

$outer[3] = @inner;

print $outer[3]; # "2"
</pre>

<p class="original"><code>$outer[3]</code> is a scalar, so it demands a scalar value. When you try to assign an array value like <code>@inner</code> to it, <code>@inner</code> is evaluated in scalar context. This is the same as assigning <code>scalar @inner</code>, which is the length of array <code>@inner</code>, which is 2.</p>
<p><code>$outer[3]</code>はスカラです。そのため、スカラの値を要求します。<code>@inner</code>のような配列を割り当てようとすると、<code>@inner</code>はスカラコンテキストで評価されます。つまり、<code>scalar @inner</code>と同じです。配列<code>@inner</code>の長さ、2になります。</p>

<p class="original">However, a scalar variable may contain a <i>reference</i> to any variable, including an array variable or a hash variable. This is how more complicated data structures are created in Perl.</p>
<p>ですが, スカラ変数は、配列変数やハッシュ変数を含む、他の変数への<i>リファレンス</i>を持てます。これが、Perlでより複雑なデータ構造を作る方法です。</p>

<p class="original">A reference is created using a backslash.</p>
<p>リファレンスはバックスラッシュを使って作られます。</p>
<pre class="prettyprint lang-perl">
my $colour    = "Indigo";
my $scalarRef = \$colour;
</pre>

<p class="original">Any time you would use the name of a variable, you can instead just put some braces in, and, within the braces, put a <em>reference</em> to a variable instead.</p>
<p>いつでも、変数の名前を使えます。代わりにブレースを置いて、ブレース内に変数への<em>リファレンス</em>を置きます。</p>
<pre class="prettyprint lang-perl">
print $colour;         # "Indigo"
print $scalarRef;      # e.g. "SCALAR(0x182c180)"
print ${ $scalarRef }; # "Indigo"
</pre>

<p class="original">As long as the result is not ambiguous, you can omit the braces too:</p>
<p>結果が曖昧でない限り、ブレースを省略することもできます:</p>

<pre class="prettyprint lang-perl">
print $$scalarRef; # "Indigo"
</pre>

<p class="original">If your reference is a reference to an array or hash variable, you can get data out of it using braces or using the more popular arrow operator, <code>-&gt;</code>:</p>
<p>リファレンスが配列かハッシュ変数のリファレンスの場合、ブレースかより一般的なアロー演算子、<code>-&gt;</code>を使ってデータを取り出せます:</p>

<pre class="prettyprint lang-perl">
my @colours = ("Red", "Orange", "Yellow", "Green", "Blue");
my $arrayRef = \@colours;

print $colours[0];       # direct array access
print ${ $arrayRef }[0]; # use the reference to get to the array
print $arrayRef-&gt;[0];    # exactly the same thing

my %atomicWeights = ("Hydrogen" =&gt; 1.008, "Helium" =&gt; 4.003, "Manganese" =&gt; 54.94);
my $hashRef = \%atomicWeights;

print $atomicWeights{"Helium"}; # direct hash access
print ${ $hashRef }{"Helium"};  # use a reference to get to the hash
print $hashRef-&gt;{"Helium"};     # exactly the same thing - this is very common
</pre>

<h3 class="original">Declaring a data structure</h3>
<h3>データ構造を宣言する</h3>

<p class="original">Here are four examples, but in practice the last one is the most useful.</p>
<p>4つの例があります。ですが、実践的には、最後のものがもっとも有用です。</p>

<pre class="prettyprint lang-perl">
my %owner1 = (
	"name" =&gt; "Santa Claus",
	"DOB"  =&gt; "1882-12-25",
);

my $owner1Ref = \%owner1;

my %owner2 = (
	"name" =&gt; "Mickey Mouse",
	"DOB"  =&gt; "1928-11-18",
);

my $owner2Ref = \%owner2;

my @owners = ( $owner1Ref, $owner2Ref );

my $ownersRef = \@owners;

my %account = (
	"number" =&gt; "12345678",
	"opened" =&gt; "2000-01-01",
	"owners" =&gt; $ownersRef,
);
</pre>

<p class="original">That's obviously unnecessarily laborious, because you can shorten it to:</p>
<p>これは、明らかに不必要で骨の折れます。なぜなら、次のように省略できます:</p>

<pre class="prettyprint lang-perl">
my %owner1 = (
	"name" =&gt; "Santa Claus",
	"DOB"  =&gt; "1882-12-25",
);

my %owner2 = (
	"name" =&gt; "Mickey Mouse",
	"DOB"  =&gt; "1928-11-18",
);

my @owners = ( \%owner1, \%owner2 );

my %account = (
	"number" =&gt; "12345678",
	"opened" =&gt; "2000-01-01",
	"owners" =&gt; \@owners,
);
</pre>

<p class="original">It is also possible to declare <i>anonymous</i> arrays and hashes using different symbols. Use square brackets for an anonymous array and braces for an anonymous hash. The value returned in each case is a <em>reference</em> to the anonymous data structure in question. Watch carefully, this results in exactly the same <code>%account</code> as above:</p>
<p>別の記号を使って<i>無名</i>配列やハッシュを宣言することも出来ます。四角いブラケットを無名配列に、ブレースを無名ハッシュに使います。それぞれ、返される値は、無名のデータ構造の<em>リファレンス</em>になります。注意して見てください。次の結果は、上の<code>%account</code>と全く同じです:</p>

<pre class="prettyprint lang-perl">
# Braces denote an anonymous hash
my $owner1Ref = {
	"name" =&gt; "Santa Claus",
	"DOB"  =&gt; "1882-12-25",
};

my $owner2Ref = {
	"name" =&gt; "Mickey Mouse",
	"DOB"  =&gt; "1928-11-18",
};

# Square brackets denote an anonymous array
my $ownersRef = [ $owner1Ref, $owner2Ref ];

my %account = (
	"number" =&gt; "12345678",
	"opened" =&gt; "2000-01-01",
	"owners" =&gt; $ownersRef,
);
</pre>

<p class="original">Or, for short (and this is the form you should <em>actually</em> use when declaring complex data structures in-line):</p>
<p>または、省略するすると(そして、行でデータ複雑な構造を宣言する時に、<em>実際に</em>使うべき形です):</p>

<pre class="prettyprint lang-perl">
my %account = (
	"number" =&gt; "31415926",
	"opened" =&gt; "3000-01-01",
	"owners" =&gt; [
		{
			"name" =&gt; "Philip Fry",
			"DOB"  =&gt; "1974-08-06",
		},
		{
			"name" =&gt; "Hubert Farnsworth",
			"DOB"  =&gt; "2841-04-09",
		},
	],
);
</pre>

<h3 class="original">Getting information out of a data structure</h3>
<h3>データ構造から情報を取り出す</h3>

<p class="original">Now, let's assume that you still have <code>%account</code> kicking around but everything else (if there was anything else) has fallen out of scope. You can print the information out by reversing the same procedure in each case. Again, here are four examples, of which the last is the most useful:</p>

<p>さて、いじくりまわすために<code>%account</code>がまだあるとしましょう。ですが、全ての他のもの(他のものがあったなら)は、スコープの外に落ちます。それぞれのケースで同じ手順を逆向きにすることで、情報を表示できます。もう一度、4つの例がありますが、最後のものが一番有用です。</p>

<pre class="prettyprint lang-perl">
my $ownersRef = $account{"owners"};
my @owners    = @{ $ownersRef };
my $owner1Ref = $owners[0];
my %owner1    = %{ $owner1Ref };
my $owner2Ref = $owners[1];
my %owner2    = %{ $owner2Ref };
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
</pre>

<p class="original">Or, for short:</p>
<p>または, 省略して:</p>

<pre class="prettyprint lang-perl">
my @owners = @{ $account{"owners"} };
my %owner1 = %{ $owners[0] };
my %owner2 = %{ $owners[1] };
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
</pre>

<p class="original">Or using references and the <code>-&gt;</code> operator:</p>
<p>または、リファレンスと<code>-&gt;</code> を使って:</p>

<pre class="prettyprint lang-perl">
my $ownersRef = $account{"owners"};
my $owner1Ref = $ownersRef-&gt;[0];
my $owner2Ref = $ownersRef-&gt;[1];
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $owner1Ref-&gt;{"name"}, " (born ", $owner1Ref-&gt;{"DOB"}, ")\n";
print "\t", $owner2Ref-&gt;{"name"}, " (born ", $owner2Ref-&gt;{"DOB"}, ")\n";
</pre>

<p class="original">And if we completely skip all the intermediate values:</p>
<p>そして、全ての中間の値をスキップするなら:</p>

<pre class="prettyprint lang-perl">
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $account{"owners"}-&gt;[0]-&gt;{"name"}, " (born ", $account{"owners"}-&gt;[0]-&gt;{"DOB"}, ")\n";
print "\t", $account{"owners"}-&gt;[1]-&gt;{"name"}, " (born ", $account{"owners"}-&gt;[1]-&gt;{"DOB"}, ")\n";
</pre>

<h3 class="original">How to shoot yourself in the foot with array references</h3>
<h3>配列のリファレンスで自分で自分の足を撃つ方法</h3>

<p class="original">This array has five elements:</p>
<p>次の配列には5つの要素があります:</p>
<pre class="prettyprint lang-perl">
my @array1 = (1, 2, 3, 4, 5);
print @array1; # "12345"
</pre>

<p class="original">This array, however, has ONE element (which happens to be a reference to an anonymous, five-element array):</p>
<p>しかし、次の配列には*ひとつ*の要素(無名の5つの要素の配列のリファレンス)があります:</p>
<pre class="prettyprint lang-perl">
my @array2 = [1, 2, 3, 4, 5];
print @array2; # e.g. "ARRAY(0x182c180)"
</pre>

<p class="original">This <em>scalar</em> is a reference to an anonymous, five-element array:</p>
<p>次の <em>スカラ</em> は、無名の5つの要素の配列のリファレンスになります:</p>
<pre class="prettyprint lang-perl">
my $array3Ref = [1, 2, 3, 4, 5];
print $array3Ref;      # e.g. "ARRAY(0x22710c0)"
print @{ $array3Ref }; # "12345"
print @$array3Ref;     # "12345"
</pre>

<h2 class="original">Conditionals</h2>
<h2>条件</h2>

<h3><code>if</code> ... <code>elsif</code> ... <code>else</code> ...</h3>

<p class="original">No surprises here, other than the spelling of <code>elsif</code>:</p>
<p><code>elsif</code>のスペル以外には驚くものはありません:</p>

<pre class="prettyprint lang-perl">
my $word = "antidisestablishmentarianism";
my $strlen = <a href="http://perldoc.jp/func/length">length</a> $word;

if($strlen &gt;= 15) {
	print "'", $word, "' is a very long word";
} elsif(10 &lt;= $strlen &amp;&amp; $strlen &lt; 15) {
	print "'", $word, "' is a medium-length word";
} else {
	print "'", $word, "' is a short word";
}
</pre>

<p class="original">Perl provides a shorter "<i>statement</i> <code>if</code> <i>condition</i>" syntax which is highly recommended for <strong>short</strong> statements:</p>
<p>Perlにはより短い "<i>ステートメント</i> <code>if</code> <i>条件</i>"のシンタックスがあります。<strong>短い</strong>ステートメント用に、強く推奨されます:</p>

<pre class="prettyprint lang-perl">
print "'", $word, "' is actually enormous" if $strlen >= 20;
</pre>

<h3><code>unless</code> ... <code>else</code> ...</h3>

<pre class="prettyprint lang-perl">
my $temperature = 20;

unless($temperature > 30) {
	print $temperature, " degrees Celsius is not very hot";
} else {
	print $temperature, " degrees Celsius is actually pretty hot";
}
</pre>

<p class="original"><code>unless</code> blocks are generally best avoided like the plague because they are very confusing. An "<code>unless</code> [... <code>else</code>]" block can be trivially refactored into an "<code>if</code> [... <code>else</code>]" block by negating the condition [or by keeping the condition and swapping the blocks]. Mercifully, there is no <code>elsunless</code> keyword.</p>

<p><code>unless</code>ブロックは災いのように避けるのが一番です。それらは混乱のもととなります。"<code>unless</code> [... <code>else</code>]"ブロックは簡単に、"<code>if</code> [... <code>else</code>]" ブロックに、条件を否定する[または、条件をそのままにブロックを交換する]ことでリファクタできます。幸い、 <code>elsunless</code>のキーワードはありません。</p>

<p class="original">This, by comparison, is highly recommended because it is so easy to read:</p>
<p>一方で、以下は読みやすさのために、強く推奨されます</p>
<pre class="prettyprint lang-perl">
print "Oh no it's too cold" unless $temperature > 15;
</pre>

<h3 class="original">Ternary operator</h3>
<h3>三項演算子</h3>

<p class="original">The ternary operator <code>?:</code> allows simple <code>if</code> statements to be embedded in a statement. The canonical use for this is singular/plural forms:</p>
<p>三項演算子 <code>?:</code> は、単純な <code>if</code> ステートメントをひとつのステートメントに埋め込めます。三項演算子の標準的な使い方として、単数/複数の形があります:</p>

<pre class="prettyprint lang-perl">
my $gain = 48;
print "You gained ", $gain, " ", ($gain == 1 ? "experience point" : "experience points"), "!";
</pre>

<p class="original">Aside: singulars and plurals are best spelled out in full in both cases. Don't do something clever like the following, because anybody searching the codebase to replace the words "tooth" or "teeth" will never find this line:</p>
<p>余談: 両方のケースの単数と複数を完全に書き出されています。決して以下のような巧妙なことをしないでください。コードを検索して、"tooth"か"teeth"の単語を置き換えようとしても、この行から見つけることができません。</p>

<pre class="prettyprint lang-perl">
my $lost = 1;
print "You lost ", $lost, " t", ($lost == 1 ? "oo" : "ee"), "th!";
</pre>

<p class="original">Ternary operators may be nested:</p>
<p>三項演算子はネストできます:</p>

<pre class="prettyprint lang-perl">
my $eggs = 5;
print "You have ", $eggs == 0 ? "no eggs" :
                   $eggs == 1 ? "an egg"  :
                   "some eggs";
</pre>

<p class="original"><code>if</code> statements evaluate their conditions in scalar context. For example, <code>if(@array)</code> returns true if and only if <code>@array</code> has 1 or more elements. It doesn't matter what those elements are - they may contain <code>undef</code> or other false values for all we care.</p>
<p><code>if</code>文では、これらの条件がはスカラコンテキストで価されます。<code>if(@array)</code>は、<code>@array</code>にひとつ以上のエレメントがある場合のみ、真となります。配列の中の値が何かは問題にしません - 全てが<code>undef</code>や他の偽の値でも</p>

<h2 class="original">Loops</h2>
<h2>ループ</h2>

<p class="original">There's More Than One Way To Do It.</p>
<p>やりかたはひとつではありません。</p>

<p class="original">Perl has a conventional <code>while</code> loop:</p>
<p>Perlの慣例的な<code>while</code> ループ:</p>

<pre class="prettyprint lang-perl">
my $i = 0;
while($i &lt; scalar @array) {
	print $i, ": ", $array[$i];
	$i++;
}
</pre>

<p class="original">Perl also offers the <code>until</code> keyword:</p>
<p>Perlには<code>until</code>キーワードもあります:</p>
<pre class="prettyprint lang-perl">
my $i = 0;
until($i &gt;= scalar @array) {
	print $i, ": ", $array[$i];
	$i++;
}
</pre>

<p class="original">These <code>do</code> loops are <em>almost</em> equivalent to the above (a warning would be raised if <code>@array</code> were empty):</p>
<p>これらの<code>do</code>ループは、<em>ほとんど</em>上と同じです(<code>@array</code>が空の場合警告が起きます):</p>

<pre class="prettyprint lang-perl">
my $i = 0;
do {
	print $i, ": ", $array[$i];
	$i++;
} while ($i &lt; scalar @array);
</pre>

<p class="original">and</p>
<p>そして</p>

<pre class="prettyprint lang-perl">
my $i = 0;
do {
	print $i, ": ", $array[$i];
	$i++;
} until ($i &gt;= scalar @array);
</pre>

<p class="original">Basic C-style <code>for</code> loops are available too. Notice how we put a <code>my</code> inside the <code>for</code> statement, declaring <code>$i</code> only for the scope of the loop:</p>
<p>基本的なC-styleの<code>for</code>ループも利用できます。<code>my</code>を<code>for</code>文の内側に置く方法に注意してください。宣言された<code>$i</code>はループのスコープでのみ有効です:</p>

<pre class="prettyprint lang-perl">
for(my $i = 0; $i &lt; scalar @array; $i++) {
	print $i, ": ", $array[$i];
}
# $i has ceased to exist here, which is much tidier.
</pre>

<p class="original">This kind of <code>for</code> loop is considered old-fashioned and should be avoided where possible. Native iteration over a list is much nicer. Note: unlike PHP, the <code>for</code> and <code>foreach</code> keywords are synonyms. Just use whatever looks most readable:</p>
<p>この種の<code>for</code>ループは古臭いやり方なので、可能であれば避けるべきです。リストのネイティブのイテレーションはより簡単です。注意: PHPと違い、 <code>for</code> と <code>foreach</code> キーワードはシノニムです。もっとも読みやすいもののいずれかを使ってください:</p>
<pre class="prettyprint lang-perl">
foreach my $string ( @array ) {
	print $string;
}
</pre>

<p class="original">If you do need the indices, the <a href="http://perldoc.perl.org/perlop.html#Range-Operators">range operator</a> <code>..</code> creates an anonymous list of integers:</p>
<p>複数のインデックスが必要なら、<a href="http://perldoc.jp/docs/perl/perlop.pod#Range32Operators">範囲演算子</a><code>..</code>で整数の無名リストを作れます:</p>

<pre class="prettyprint lang-perl">
foreach my $i ( 0 .. $#array ) {
	print $i, ": ", $array[$i];
}
</pre>

<p class="original">You can't iterate over a hash. However, you can iterate over its keys. Use the <code>keys</code> built-in function to retrieve an array containing all the keys of a hash. Then use the <code>foreach</code> approach that we used for arrays:</p>
<p>ハッシュはイテレートできません。そのキーをイテレートできます。組込関数の<code>keys</code>を使って、ハッシュの全てのキーを含む配列を取り出してください。それから、配列で使った<code>foreach</code>のアプローチを使います:</p>

<pre class="prettyprint lang-perl">
foreach my $key (keys %scientists) {
	print $key, ": ", $scientists{$key};
}
</pre>

<p class="original">Since a hash has no underlying order, the keys may be returned in any order. Use the <code>sort</code> built-in function to sort the array of keys alphabetically beforehand:</p>
<p>ハッシュには順番がありませんので、keysはどのような順番でも戻ります。組込の<code>sort</code>関数を使って、アルファベット順でキーの配列をソートできます:</p>
<pre class="prettyprint lang-perl">
foreach my $key (sort keys %scientists) {
	print $key, ": ", $scientists{$key};
}
</pre>

<p class="original">If you don't provide an explicit iterator, Perl uses a default iterator, <code>$_</code>. <code>$_</code> is the first and friendliest of the <a href="http://perldoc.perl.org/perlvar.html">built-in variables</a>:</p>
<p>明示的なイテレータを使わなければ、Perlはデフォルトのイテレータとして<code>$_</code>を使います。<code>$_</code>は最初の最もフレンドリーな<a href="http://perldoc.jp/docs/perl/perlvar.pod">組込の変数</a>です:</p>

<pre class="prettyprint lang-perl">
foreach ( @array ) {
	print $_;
}
</pre>

<p class="original">If using the default iterator, and you only wish to put a single statement inside your loop, you can use the super-short loop syntax:</p>
<p>デフォルトのイテレータを使うなら、ループに一つのステートメントしか置かないのなら、とても短いループのシンタックスを使えます:</p>
<pre class="prettyprint lang-perl">
print $_ foreach @array;
</pre>

<h3 class="original">Loop control</h3>
<h3>ループ制御</h3>

<p class="original"><code>next</code> and <code>last</code> can be used to control the progress of a loop. In most programming languages these are known as <code>continue</code> and <code>break</code> respectively. We can also optionally provide a label for any loop. By convention, labels are written in <code>ALLCAPITALS</code>. Having labelled the loop, <code>next</code> and <code>last</code> may target that label. This example finds primes below 100:</p>

<p><code>next</code> と <code>last</code>はループ進みを制御するのに使われます。多くのプログラミング言語では、それぞれ、<code>continue</code> と <code>break</code>となっています。オプションで、どのループにもラベルをつけることができます。慣例により、ラベルは<code>全て大文字で</code>書くことになっています。ループにラベルをつけることで、<code>next</code> と <code>last</code> にラベルを対象にできます。100以下の素数を見つける例です:</p>

<pre class="prettyprint lang-perl">
CANDIDATE: for my $candidate ( 2 .. 100 ) {
	for my $divisor ( 2 .. <a href="http://perldoc.jp/func/sqrt">sqrt</a> $candidate ) {
		next CANDIDATE if $candidate % $divisor == 0;
	}
	print $candidate." is prime\n";
}
</pre>

<h2 class="original">Array functions</h2>
<h2>配列関数</h2>

<h3 class="original">In-place array modification</h3>
<h3>その場で配列を変更する</h3>

<p class="original">We'll use <code>@stack</code> to demonstrate these:</p>

<p><code>@stack</code>を使ってデモします:</p>

<pre class="prettyprint lang-perl">
my @stack = ("Fred", "Eileen", "Denise", "Charlie");
print @stack; # "FredEileenDeniseCharlie"
</pre>

<p class="original"><code><a href="http://perldoc.perl.org/functions/pop.html">pop</a></code> extracts and returns the final element of the array. This can be thought of as the top of the stack:</p>
<p><code><a href="http://perldoc.jp/func/pop">pop</a></code> は配列の最後の要素を引き出して返します。スタックの上として考えられます:</p>
<pre class="prettyprint lang-perl">
print pop @stack; # "Charlie"
print @stack;     # "FredEileenDenise"
</pre>

<p class="original"><code><a href="http://perldoc.perl.org/functions/push.html">push</a></code> appends extra elements to the end of the array:</p>
<p><code><a href="http://perldocjp/func/push">push</a></code> は追加の要素を配列の最後に付加します:</p>
<pre class="prettyprint lang-perl">
push @stack, "Bob", "Alice";
print @stack; # "FredEileenDeniseBobAlice"
</pre>

<p class="original"><code><a href="http://perldoc.perl.org/functions/shift.html">shift</a></code> extracts and returns the first element of the array:</p>
<p><code><a href="http://perldoc.perl.org/func/shift">shift</a></code> は配列の最初の要素を引き出して返します:</p>
<pre class="prettyprint lang-perl">
print shift @stack; # "Fred"
print @stack;       # "EileenDeniseBobAlice"
</pre>

<p class="original"><code><a href="http://perldoc.perl.org/functions/unshift.html">unshift</a></code> inserts new elements at the beginning of the array:</p>
<p><code><a href="http://perldoc.jp/func/unshift">unshift</a></code> 配列の最初に新しい要素を挿入します:</p>
<pre class="prettyprint lang-perl">
unshift @stack, "Hank", "Grace";
print @stack; # "HankGraceEileenDeniseBobAlice"
</pre>

<p class="original"><code>pop</code>, <code>push</code>, <code>shift</code> and <code>unshift</code> are all special cases of <code><a href="http://perldoc.perl.org/functions/splice.html">splice</a></code>. <code>splice</code> removes and returns an array slice, replacing it with a different array slice:</p>
<p><code>pop</code>、<code>push</code>、 <code>shift</code>、<code>unshift</code> は、全て、<code><a href="http://perldoc.jp/func/splice">splice</a></code>の特別なケースです。<code>splice</code> は、配列のスライスを削除して、返します。別の配列スライスでそれを置き換えます:</p>
<pre class="prettyprint lang-perl">
print splice(@stack, 1, 4, "&lt;&lt;&lt;", "&gt;&gt;&gt;"); # "GraceEileenDeniseBob"
print @stack;                             # "Hank&lt;&lt;&lt;&gt;&gt;&gt;Alice"
</pre>

<h3 class="original">Creating new arrays from old</h3>
<h3>古い配列から新しい配列を作る</h3>

<p class="original">Perl provides the following functions which act on arrays to create other arrays.</p>
<p>Perlには以下の関数があり、配列に対して、新しい配列を作ります</p>

<p class="original">The <code><a href="http://perldoc.perl.org/functions/join.html">join</a></code> function concatenates many strings into one:</p>
<p><code><a href="http://perldoc.jp/func/join">join</a></code> 関数は多くの文字列を一つに結合します:</p>

<pre class="prettyprint lang-perl">
my @elements = ("Antimony", "Arsenic", "Aluminum", "Selenium");
print @elements;             # "AntimonyArsenicAluminumSelenium"
print "@elements";           # "Antimony Arsenic Aluminum Selenium"
print join(", ", @elements); # "Antimony, Arsenic, Aluminum, Selenium"
</pre>

<p class="original">In list context, the <code><a href="http://perldoc.perl.org/functions/reverse.html">reverse</a></code> function returns a list in reverse order. In scalar context, <code>reverse</code> concatenates the whole list together and then reverses it as a single word.</p>
<p>リストコンテキストでは、<code><a href="http://perldoc.jp/func/reverse">reverse</a></code>関数は逆順のリストを返します。スカラーコンテキストでは<code>reverse</code>リストの全てをつなげて一つの文字列として、それを逆順にします。</p>
<pre class="prettyprint lang-perl">
print reverse("Hello", "World");        # "WorldHello"
print reverse("HelloWorld");            # "HelloWorld"
print scalar reverse("HelloWorld");     # "dlroWolleH"
print scalar reverse("Hello", "World"); # "dlroWolleH"
</pre>

<p class="original">The <code><a href="http://perldoc.perl.org/functions/map.html">map</a></code> function takes an array as input and applies an operation to every scalar <code>$_</code> in this array. It then constructs a new array out of the results. The operation to perform is provided in the form of a single expression inside braces:</p>
<p><code><a href="http://perldoc.jp/func/map">map</a></code>関数は入力として配列をとり、配列内の全てのスカラ <code>$_</code>を操作します。結果として新しい配列を作ります。操作はひとつのブレースで渡します:</p>

<pre class="prettyprint lang-perl">
my @capitals = ("Baton Rouge", "Indianapolis", "Columbus", "Montgomery", "Helena", "Denver", "Boise");

print join ", ", map { uc $_ } @capitals;
# "BATON ROUGE, INDIANAPOLIS, COLUMBUS, MONTGOMERY, HELENA, DENVER, BOISE"
</pre>

<p class="original">The <code><a href="http://perldoc.perl.org/functions/grep.html">grep</a></code> function takes an array as input and returns a filtered array as output. The syntax is similar to <code>map</code>. This time, the second argument is evaluated for each scalar <code>$_</code> in the input array. If a boolean true value is returned, the scalar is put into the output array, otherwise not.</p>
<p><code><a href="http://perldoc.jp/func/grep">grep</a></code>関数は入力として配列をとり、フィルターされた配列を出力します。シンタックスは<code>map</code>と似ています。今度は、第二引数は入力された配列の各スカラ<code>$_</code>を評価されます。ブーリアンで真の値が戻れば、スカラは配列として出力されますが、そうでなければ、出力されません。</p>

<pre class="prettyprint lang-perl">
print join ", ", grep { length $_ == 6 } @capitals;
# "Helena, Denver"
</pre>

<p class="original">Obviously, the length of the resulting array is the <em>number of successful matches</em>, which means you can use <code>grep</code> to quickly check whether an array contains an element:</p>
<p>当然、結果の配列の長さは、<em>マッチに成功した数</em>になります、このとことは、<code>grep</code>を配列に要素があるかどうかを素早くチェックするのに使えることを意味します。:</p>

<pre class="prettyprint lang-perl">
print scalar grep { $_ eq "Columbus" } @capitals; # "1"
</pre>

<p class="original"><code>grep</code> and <code>map</code> may be combined to form <i><a href="https://en.wikipedia.org/wiki/List_comprehension">list comprehensions</a></i>, an exceptionally powerful feature conspicuously absent from many other programming languages.</p>
<p><code>grep</code> と <code>map</code> は、<i><a href="https://en.wikipedia.org/wiki/List_comprehension">リスト包含</a></i>の形に含まれます。他の多くのプログラミング言語に目立って欠けている、例外的に強力な機能です。</p>

<p class="original">By default, the <code><a href="http://perldoc.perl.org/functions/sort.html">sort</a></code> function returns the input array, sorted into lexical (alphabetical) order:</p>
<p>デフォルトでは、<code><a href="http://perldoc.jp/func/sort">sort</a></code>関数は入力された配列を文字順(アルファベット順)に並びかえます:</p>

<pre class="prettyprint lang-perl">
my @elevations = (19, 1, 2, 100, 3, 98, 100, 1056);

print join ", ", sort @elevations;
# "1, 100, 100, 1056, 19, 2, 3, 98"
</pre>

<p class="original">However, similar to <code>grep</code> and <code>map</code>, you may supply some code of your own. Sorting is always performed using a series of comparisons between two elements. Your block receives <code>$a</code> and <code>$b</code> as inputs and should return -1 if <code>$a</code> is "less than" <code>$b</code>, 0 if they are "equal" or 1 if <code>$a</code> is "greater than" <code>$b</code>.</p>
<p>しかし、<code>grep</code> と <code>map</code>と似て、自分のコードを渡すことも出来ます。ソートは常に2要素間の一連の比較を使ってされます。コードブロックは、<code>$a</code>と<code>$b</code>を受け、<code>$a</code>が<code>$b</code>"より小さ"ければ -1、"同じ"であれば 0、<code>$a</code>が<code>$b</code>"より大き"ければ 1 を返します。</p>

<p class="original">The <code>cmp</code> operator does exactly this for strings:</p>
<p><code>cmp</code> 演算子は文字列に対して、まさにこれをします:</p>

<pre class="prettyprint lang-perl">
print join ", ", sort { $a cmp $b } @elevations;
# "1, 100, 100, 1056, 19, 2, 3, 98"
</pre>

<p class="original">The "spaceship operator", <code>&lt;=&gt;</code>, does the same for numbers:</p>
<p>"スペースシップ演算子", <code>&lt;=&gt;</code>は、数字に対して同じことをします:</p>

<pre class="prettyprint lang-perl">
print join ", ", sort { $a &lt;=&gt; $b } @elevations;
# "1, 2, 3, 19, 98, 100, 100, 1056"
</pre>

<p class="original"><code>$a</code> and <code>$b</code> are always scalars, but they can be references to quite complex objects which are difficult to compare. If you need more space for the comparison, you can create a separate subroutine and provide its name instead:</p>
<p><code>$a</code> と <code>$b</code> は常にスカラーですが、比較が難しい非常に複雑なオブジェクトのリファレンスもありえます。比較によりスペースが必要なら、別のサブルーチンを作り、代わりにその名前を渡せます:</p>

<pre class="prettyprint lang-perl">
sub comparator {
	# lots of code...
	# return -1, 0 or 1
}

print join ", ", sort comparator @elevations;
</pre>

<p class="original">You can't do this for <code>grep</code> or <code>map</code> operations.</p>
<p>同じことは、<code>grep</code> や <code>map</code> ではできません。</p>

<p class="original">Notice how the subroutine and block are never explicitly provided with <code>$a</code> and <code>$b</code>. Like <code>$_</code>, <code>$a</code> and <code>$b</code> are, in fact, global variables which are <em>populated</em> with a pair of values to be compared each time.</p>
<p>サブルーチンとブロックは <code>$a</code> と <code>$b</code>と一緒には渡されません。<code>$_</code>のように、 <code>$a</code>と<code>$b</code>は、実際、グローバル変数で、その時々に、比較される値のペアで<em>埋められ</em>ます</p>

<h2 class="original">Built-in functions</h2>
<h2>組込関数</h2>
<p class="original">By now you have seen at least a dozen built-in functions: <code>print</code>, <code>sort</code>, <code>map</code>, <code>grep</code>, <code>keys</code>, <code>scalar</code> and so on. Built-in functions are one of Perl's greatest strengths. They</p>
<p>今までで、少なくともよくある組込関数が出てきました: <code>print</code>, <code>sort</code>, <code>map</code>, <code>grep</code>, <code>keys</code>, <code>scalar</code> など。 組込関数はPerlの最も偉大な強みのひとつです。それらは、</p>

<ul class="original">
	<li>are numerous</li>
	<li>are very useful</li>
	<li>are <a href="http://perldoc.perl.org/perlfunc.html">extensively documented</a></li>
	<li>vary greatly in syntax, so check the documentation</li>
	<li>sometimes accept regular expressions as arguments</li>
	<li>sometimes accept entire blocks of code as arguments</li>
	<li>sometimes don't require commas between arguments</li>
	<li>sometimes will consume an arbitrary number of comma-separated arguments and sometimes will not</li>
	<li>sometimes will fill in their own arguments if too few are supplied</li>
	<li>generally don't require brackets around their arguments except in ambiguous circumstances</li>
</ul>
<ul>
	<li>たくさんある</li>
	<li>とても便利</li>
	<li><a href="http://perldoc.jp/docs/perl/perlfunc.pod">広くドキュント化</a>されている</li>
	<li>シンタックスで大きく異なるので、ドキュメントを見ること</li>
	<li>引数として正規表現を受け付けるものもある</li>
	<li>引数として完全なコードブロックを受け付けるものもある</li>
	<li>引数の間にコンマが不要なものもある</li>
	<li>コンマで区切られた任意の数を取るものもあれば、そうでないものもある</li>
	<li>引数が少なすぎる場合に、自分自身で引数を埋めるものもある</li>
	<li>曖昧な状況でなければ、一般的に引数のまわりに括弧は不要</li>
</ul>
<p class="original">The best advice regarding built-in functions is to <strong>know that they exist</strong>. Skim the documentation for future reference. If you are carrying out a task which feels like it's low-level and common enough that it's been done many times before, the chances are that it has.</p>
<p>組込関数が存在していることを知ることに館する最も良いアドバイスは、<strong>それらが存在することを知る</strong>ことです。未来のリファレンスにざっと目を通してください。低レベルで以前に何度も行っている十分に共通だと感じるタスクを実行しているなら、そのチャンスです。</p>

<h2 class="original">User-defined subroutines</h2>
<h2>ユーザー定義のサブルーチン</h2>

<p class="original">Subroutines are declared using the <code><a href="http://perldoc.perl.org/functions/sub.html">sub</a></code> keyword. In contrast with built-in functions, user-defined subroutines always accept the same input: a list of scalars. That list may of course have a single element, or be empty. A single scalar is taken as a list with a single element. A hash with <var>N</var> elements is taken as a list with 2<var>N</var> elements.</p>
<p>サブルーチンは<code>sub</code> キーワードを使って宣言されます。組込関数と対照的に、ユーザー定義のサブルーチンは常に同じ入力を受け付けます: スカラのリストです。そのリストは、もちろん、ひとつの要素か、空の場合もあります。ひとつのスカラは一つの要素のリストです。<var>N</var>要素のハッシュは2<var>N</var>要素のリストです。</p>

<p class="original">Although the brackets are optional, subroutines should always be invoked using brackets, even when called with no arguments. This makes it clear that a subroutine call is happening.</p>
<p>括弧はオプションですが、サブルーチンは、引数がひとつも無くても、常に括弧付きで使うべきです。こうしておけば、サブルーチンが呼ばれたことが、明確になります。</p>

<p class="original">Once you're inside a subroutine, the arguments are available using the <a href="http://perldoc.perl.org/perlvar.html">built-in array variable</a> <code>@_</code>. Example:</p>
<p>サブルーチンの中に入ってしまうと、<a href="http://perldoc.jp/docs/perl/perlvar.pod">組込の配列変数</a><code>@_</code>が使えます。例:</p>

<pre class="prettyprint lang-perl">
sub hyphenate {

  # Extract the first argument from the array, ignore everything else
  my $word = shift @_;

  # An overly clever list comprehension
  $word = join "-", map { <a href="http://perldoc.jp/func/substr">substr</a> $word, $_, 1 } (0 .. (<a href="http://perldoc.jp/func/length">length</a> $word) - 1);
  return $word;
}

print hyphenate("exterminate"); # "e-x-t-e-r-m-i-n-a-t-e"
</pre>

<h3 class="original">Perl calls by reference</h3>

<h3>Perlがリファレンスとよぶもの</h3>

<p class="original">Unlike almost every other major programming language, Perl calls by reference. This means that the variables or values available inside the body of a subroutine are not copies of the originals. They <em>are</em> the originals.</p>

<p>全ての他の主要なプログラミング言語とは違い、Perlはリファレンスと呼びます。これは、サブルーチンの内側で利用可能な変数か値がオリジナルのコピーではないことを意味します。</p>

<pre class="prettyprint lang-perl">
my $x = 7;

sub reassign {
  $_[0] = 42;
}

reassign($x);
print $x; # "42"
</pre>

<p class="original">If you try something like</p>

<p>次のようなものを試すと</p>

<pre class="prettyprint lang-perl">
reassign(8);
</pre>

<p>then an error occurs and execution halts, because the first line of <code>reassign()</code> is equivalent to</p>

<pre class="prettyprint lang-perl">
8 = 7;
</pre>

<p class="original">which is obviously nonsense.</p>

<p>これは明らかにナンセンスです。</p>

<p class="original">The lesson to learn is that in the body of a subroutine, you should always unpack your arguments before working with them.</p>

<p>このレッスンで学ぶことは、サブルーチンの中で、それらで何かする前に、いつも引数をアンパックすべきです。</p>

<h3 class="original">Unpacking arguments</h3>
<h3>引数を取り出す</h3>
<p class="original">There's More Than One Way To unpack <code>@_</code>, but some are superior to others.</p>
<p><code>@_</code>を取り出すのにいくつかやり方があります。 ですが、いくつかは、他のものより、より良いです。</p>

<p class="original">The example subroutine <code>left_pad</code> below pads a string out to the required length using the supplied pad character. (The <code>x</code> function concatenates multiple copies of the same string in a row.) (Note: for brevity, these subroutines all lack some elementary error checking, i.e. ensuring the pad character is only 1 character, checking that the width is greater than or equal to the length of existing string, checking that all needed arguments were passed at all.)</p>
<p>例のサブルーチン<code>left_pad</code>は、以下の例は、渡された詰め込み文字を使って、必要な長さになるまで文字列に付加します。(<code>x</code>関数は行に同じ文字列の複数のコピーをつなげます)。(注意: 簡潔さのために、これらのサブルーチンは全て基本的なエラーチェックを行っていません。例えば、詰め込み文字が1文字のみであることを保証するとか、長さが既存の文字列の長さ以上であるか、必要な引数が全て渡されているかどうか、など)。</p>
<p class="original"><code>left_pad</code> is typically invoked as follows:</p>
<p><code>left_pad</code> は典型的に、次のように呼ばれます:</p>
<pre class="prettyprint lang-perl">
print left_pad("hello", 10, "+"); # "+++++hello"
</pre>

<ol>
	<li>
		<p class="original">Unpacking <code>@_</code> entry by entry is effective but not terribly pretty:</p>
  		<p>エントリによって、<code>@_</code>エントリを取り出すのは、効率的ですが、あまりよくありません:</p>
<pre class="prettyprint lang-perl">
sub left_pad {
	my $oldString = $_[0];
	my $width     = $_[1];
	my $padChar   = $_[2];
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
	</li>
	<li>
		<p class="original">Unpacking <code>@_</code> by removing data from it using <code>shift</code> is recommended for up to 4 arguments:</p>
		<p><code>@_</code>を取り出すのに、<code>shift</code>を使って、@_からデータを削除するのは、引数が4つまでなら推奨されます:</p>
<pre class="prettyprint lang-perl">
sub left_pad {
	my $oldString = shift @_;
	my $width     = shift @_;
	my $padChar   = shift @_;
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
		<p class="original">If no array is provided to the <code>shift</code> function, then it operates on <code>@_</code> implicitly. This approach is seen very commonly:</p>
		<p><code>shift</code>に配列を渡さなければ、暗黙に、<code>@_</code>に対して操作します。このアプローチはとてもよく見られます:</p>
<pre class="prettyprint lang-perl">
sub left_pad {
	my $oldString = shift;
	my $width     = shift;
	my $padChar   = shift;
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
		<p class="original">Beyond 4 arguments it becomes hard to keep track of what is being assigned where.</p>
		<p>引数が5つ以上になるなら、どこで割り当てたかを追い続けるのが難しくなるでしょう。</p>
	</li>
	<li>
		<p class="original">You can unpack <code>@_</code> all in one go using multiple simultaneous scalar assignment. Again, this is okay for up to 4 arguments:</p>
		<p><code>@_</code>の取り出しを、同時に全て一度にスカラに割り当てることが出来ます。 この方法も、引数が4つまでなら問題ありません:</p>
<pre class="prettyprint lang-perl">
sub left_pad {
	my ($oldString, $width, $padChar) = @_;
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
	</li>
	<li>
		<p class="original">For subroutines with large numbers of arguments or where some arguments are optional or cannot be used in combination with others, best practice is to require the user to provide a hash of arguments when calling the subroutine, and then unpack <code>@_</code> back into that hash of arguments. For this approach, our subroutine call would look a little different:</p>
		<p>引数が多いサブルーチンや、いくつかの引数がオプションであるとか、他との組み合わせで使えないなら、最も良い方法は、サブルーチンの呼び出し時に、ユーザにハッシュの引数を渡させることです。そして、<code>@_</code>をハッシュに取り出します。このアプローチのために、サブルーチンの呼び出しはちょっと違ったものになります:</p>
<pre class="prettyprint lang-perl">
print left_pad("oldString" =&gt; "pod", "width" =&gt; 10, "padChar" =&gt; "+");
</pre>
		<p class="original">And the subroutine itself looks like this:</p>
		<p>そして、サブルーチン自身は次のようになります:</p>
<pre class="prettyprint lang-perl">
sub left_pad {
	my %args = @_;
	my $newString = ($args{"padChar"} x ($args{"width"} - length $args{"oldString"})) . $args{"oldString"};
	return $newString;
}
</pre>
	</li>
</ol>
<h3 class="original">Returning values</h3>
<h3>戻り値</h3>
<p class="original">Like other Perl expressions, subroutine calls may display contextual behaviour. You can use the <code><a href="http://perldoc.perl.org/functions/wantarray.html">wantarray</a></code> function (which should be called <code>wantlist</code> but never mind) to detect what context the subroutine is being evaluated in, and return a result appropriate to that context:</p>

<p>他のPerlの式と同様、サブルーチン呼び出しは、コンテキスト依存の振る舞いをします。<code><a href="http://perldoc.jp/func/wantarray">wantarray</a></code>を使うことができます(<code>wantlist</code>と呼ばれるべきですが、気にしないでください)を使って、どのコンテキストでサブルーチンが評価されているかをチェックでき、コンテキストに適した結果を返すことが出来ます:</p>

<pre class="prettyprint lang-perl">
sub contextualSubroutine {
	# Caller wants a list. Return a list
	return ("Everest", "K2", "Etna") if wantarray;

	# Caller wants a scalar. Return a scalar
	return 3;
}

my @array = contextualSubroutine();
print @array; # "EverestK2Etna"

my $scalar = contextualSubroutine();
print $scalar; # "3"
</pre>
<h2 class="original">System calls</h2>
<h2>システムコール</h2>
<p class="original">Apologies if you already know the following non-Perl-related facts. Every time a process finishes on a Windows or Linux system (and, I assume, on most other systems), it concludes with a 16-bit <i>status word</i>. The highest 8 bits constitute a <i>return code</i> between 0 and 255 inclusive, with 0 conventionally representing unqualified success, and other values representing various degrees of failure. The other 8 bits are less frequently examined - they "reflect mode of failure, like signal death and core dump information".</p>
<p>既に以下のPerlと関係ない事実をご存知でしたら申し訳有りません。WindowやLinux(また、多くの他のシステムでも同様と想定されますが)のシステムではプロセスが終わるたびに、16ビットの<i>状態ワード</i>で終了します。上位の8ビットは0〜255の間を含む<i>リターンコード</i>を構成します。0は慣例的に、無条件で成功したことを示します。他の値は様々な度合いの失敗を示します。他の8ビットはあまりよく調べられませんが、それらは"シグナルの死亡やコアダンプの情報のような失敗のモードを反映します"。</p>
<p class="original">You can exit from a Perl script with the return code of your choice (from 0 to 255) using <code><a href="http://perldoc.perl.org/functions/exit.html">exit</a></code>.</p>
<p>Perlから終了する際に、<code><a href="http://perldoc.jp/func/exit">exit</a></code>を使って(0から255までの)好きなリターンコードを返せます。</p>
<p class="original">Perl provides More Than One Way To - in a single call - spawn a child process, pause the current script until the child process has finished, and then resume interpretation of the current script. Whichever method is used, you will find that immediately afterwards, the <a href="http://perldoc.perl.org/perlvar.html">built-in scalar variable</a> <code>$?</code> has been populated with the status word that was returned from that child process's termination. You can get the return code by taking just the highest 8 of those 16 bits: <code>$? >> 8</code>.</p>
<p>Perlには一つ以上の - 子プロセスを産む - 方法があります。現在のスクリプトを止め、子プロセスが終わったら、現在のスクリプトの解釈を続けます。どの方法を使っても、その直後で、子プロセスの終了時に返された状態ワードが<a href="http://perldoc.jp/docs/perl/perlvar.pod">組込のスカラ変数</a>の<code>$?</code>に入ります。返された値の16ビットの上位8を取ることで、リターンコードを得ることができます: <code>$? >> 8</code>。</p>
<p class="original">The <code><a href="http://perldoc.perl.org/functions/system.html">system</a></code> function can be used to invoke another program with the arguments listed. The value returned by <code>system</code> is the same value with which <code>$?</code> is populated:</p>
<p><code>system</code>関数は他のプログラムを引数のリストと一緒に呼び出せます。<code>system</code>によって返される値は、<code>$?</code>に入るのと同じ値です:</p>
<pre class="prettyprint lang-perl">
my $rc = system "perl", "anotherscript.pl", "foo", "bar", "baz";
$rc >>= 8;
print $rc; # "37"
</pre>
<p class="original">Alternatively, you can use backticks <code>``</code> to run an actual command at the command line and capture the standard output from that command. In scalar context the entire output is returned as a single string. In list context, the entire output is returned as an array of strings, each one representing a line of output.</p>
<p>代わりに、バッククォート<code>``</code>を使って、コマンドラインで実際のコマンドを走らせて、コマンドからの標準出力をキャプチャできます。スカラコンテキストでは、全ての出力は単一の文字列として帰ります。リストコンテキストでは、全ての出力は一行ずつの文字列の配列として返されます。</p>
<pre class="prettyprint lang-perl">
my $text = `perl anotherscript.pl foo bar baz`;
print $text; # "foobarbaz"
</pre>
<p class="original">This is the behaviour which would be seen if <code>anotherscript.pl</code> contained, for example:</p>
<p>これは、<code>anotherscript.pl</code>が含んでいたら、見られる振る舞いです。例:</p>
<pre class="prettyprint lang-perl">
use strict;
use warnings;

print @ARGV;
exit 37;
</pre>

<h2 class="original">Files and file handles</h2>
<h2>ファイルとファイルハンドル</h2>

<p class="original">A scalar variable may contain a <i>file handle</i> instead of a number/string/reference or <code>undef</code>. A file handle is essentially a reference to a specific location inside a specific file.</p>
<p>スカラ変数は、数字/文字列/リファレンスや<code>undef</code>の代わりに<i>ファイルハンドル</i>も持てます。ファイルハンドルは基本的に特定のファイルの特定の場所を示すリファレンスです。</p>

<p class="original">Use <code><a href="http://perldoc.perl.org/functions/open.html">open</a></code> to turn a scalar variable into a file handle. <code>open</code> must be supplied with a <i>mode</i>. The mode <code>&lt;</code> indicates that we wish to open the file to read from it:</p>
<p><code><a href="http://perldoc.jp/func/open">open</a></code>を使って、スカラ変数をファイルハンドルにします。<code>open</code>は<i>モード</i>とともに使われなければいけません。モード <code>&lt;</code> は、ファイルから読み出したいことを意図します:</p>

<pre class="prettyprint lang-perl">
my $f = "text.txt";
my $result = open my $fh, "&lt;", $f;

if(!$result) {
	<a href="http://perldoc.jp/func/die">die</a>  "Couldn't open '".$f."' for reading because: ".$!;
}
</pre>

<p class="original">As seen above, you should always check that the <code>open</code> operation completed successfully. If successful, <code>open</code> returns a true value. Otherwise, it returns false and an error message is stuffed into the built-in variable <code>$!</code>. This checking being rather tedious, a common idiom is:</p>
<p class="original">If successful, <code>open</code> returns a true value. Otherwise, it returns false and an error message is stuffed into the built-in variable <code>$!</code>. As seen above, you should always check that the <code>open</code> operation completed successfully. This checking being rather tedious, a common idiom is:</p>
<p>成功すれば、<code>open</code>は真を返します。そうでなければ、偽を返し、エラーメッセージが組み込みの変数<code>$!</code>に入ります。上で見たように、<code>open</code> 演算子が完全に成功したかを常にチェックすべきです。このチェックの手続きは退屈ですが、よくみかけるイディオムは次のものです:</p>

<pre class="prettyprint lang-perl">
open(my $fh, "&lt;", $f) || die "Couldn't open '".$f."' for reading because: ".$!;
</pre>
<p class="original">Note the need for parentheses around the <code>open</code> call's arguments.</p>
<p><code>open</code>呼び出しの引数に括弧が必要なことに注意してください。</p>

<p class="original">To read a line of text from a filehandle, use the <code><a href="http://perldoc.perl.org/functions/readline.html">readline</a></code> built-in function. <code>readline</code> returns a full line of text, with a line break intact at the end of it (except possibly for the final line of the file), or <code>undef</code> if you've reached the end of the file.</p>
<p>ファイルハンドルからテキストの行を読むために、組込関数の<code><a href="http://perldoc.jp/func/readline">readline</a></code>を使えます。<code>readline</code>は、テキストの一行全体を、その終わりに改行をそのまま含んで返す(たぶんファイルの最終行を除いて)か、ファイルの最後に達すると<code>undef</code>を返します。</p>

<pre class="prettyprint lang-perl">
while(1) {
	my $line = readline $fh;
	last unless defined $line;
	# process the line...
}
</pre>
<p class="original">To truncate that possible trailing line break, use <code><a href="http://perldoc.perl.org/functions/chomp.html">chomp</a></code>:</p>
<p><code><a href="http://perldoc.jp/func/chomp">chomp</a></code>を使うと改行を取り除けます:</p>
<pre class="prettyprint lang-perl">
chomp $line;
</pre>
<p class="original">Note that <code>chomp</code> acts on <code>$line</code> in place. <code>$line = chomp $line</code> is probably not what you want.</p>
<p><code>chomp</code>は <code>$line</code>に対してその場で働きます。<code>$line = chomp $line</code>は多分お望みのものではないでしょう。</p>

<p class="original">You can also use <code><a href="http://perldoc.perl.org/functions/eof.html">eof</a></code> to detect that the end of the file has been reached:</p>
<p><code><a href="http://perldoc.jp/func/eof">eof</a></code>を使ってファイルの終端を判断することもできます:</p>
<pre class="prettyprint lang-perl">
while(!eof $fh) {
	my $line = readline $fh;
	# process $line...
}
</pre>
<p class="original">But beware of just using <code>while(my $line = readline $fh)</code>, because if <code>$line</code> turns out to be <code>"0"</code>, the loop will terminate early. If you want to write something like that, Perl provides the <code>&lt;&gt;</code> operator which wraps up <code>readline</code> in a fractionally safer way. This is very commonly-seen and perfectly safe:</p>
<p>ですが、<code>while(my $line = readline $fh)</code>を使うのは注意してください。<code>$line</code>が<code>"0"</code>で合った場合、ループは早くに終わってしまいます。そのように書きたいのならば、Perlには<code>&lt;&gt;</code>演算子があり、少し安全な方法で<code>readline</code>をラップしています。次のものは、とてもよくある完全に安全なものです:</p>

<pre class="prettyprint lang-perl">
while(my $line = &lt;$fh&gt;) {
	# process $line...
}
</pre>
<p class="original">And even:</p>
<p>次のようにさえ:</p>
<pre class="prettyprint lang-perl">
while(&lt;$fh&gt;) {
	# process $_...
}
</pre>
<p class="original">Writing to a file involves first opening it in a different mode. The mode <code>&gt;</code> indicates that we wish to open the file to write to it. (<code>&gt;</code> will clobber the content of the target file if it already exists and has content. To merely append to an existing file, use mode <code>&gt;&gt;</code>.) Then, simply provide the filehandle as a zeroth argument for the <code>print</code> function.</p>
<p>ファイルに書き込む場合は、違ったモードで最初に開きます。モード <code>&gt;</code> は、書き込み用にファイルを開くことを指示します。(<code>&gt;</code>は、目的のファイルの中身を壊します。単純に、追加したい場合は、<code>&gt;&gt;</code> のモードを使います)。それから、<code>print</code>関数の0番目の引数として、ファイルハンドルを単に渡します。</p>
<pre class="prettyprint lang-perl">
open(my $fh2, "&gt;", $f) || die "Couldn't open '".$f."' for writing because: ".$!;
print $fh2 "The eagles have left the nest";
</pre>
<p class="original">Notice the absence of a comma between <code>$fh2</code> and the next argument.</p>
<p><code>print</code>で<code>$fh2</code>と次の引数の間にカンマがないことに気をつけてください。</p>

<p class="original">File handles are actually closed automatically when they drop out of scope, but otherwise:</p>
<p>ファイルハンドルはスコープを抜けると自動的に閉じられます。もしくは、次のようにします:</p>

<pre class="prettyprint lang-perl">
<a href="http://perldoc.jp/func/close">close</a> $fh2;
close $fh;
</pre>

<p class="original">Three filehandles exist as global constants: <code>STDIN</code>, <code>STDOUT</code> and <code>STDERR</code>. These are open automatically when the script starts. To read a single line of user input:</p>
<p>3つのファイルハンドルがグローバルな定数としてあります: <code>STDIN</code>と<code>STDOUT</code>と<code>STDERR</code>があります。これらはスクリプトが開始されたときに自動的に開かれます。ユーザーの入力を一行読むには:</p>
<pre class="prettyprint lang-perl">
my $line = &lt;STDIN&gt;;
</pre>
<p class="original">To just wait for the user to hit Enter:</p>
<p>ユーザーがエンターを押すまで待つだけです:</p>
<pre class="prettyprint lang-perl">
&lt;STDIN&gt;;
</pre>
<p class="original">Calling <code>&lt;&gt;</code> with no filehandle reads data from <code>STDIN</code>, or from any files named in arguments when the Perl script was called.</p>
<p><code>&lt;&gt;</code>をファイルハンドルなしで呼ぶと、<code>STDIN</code>からデータを読むか、Perlスクリプトが呼ばれた時の引数に渡された名前のファイルから読みます。</p>
<p class="original">As you may have gathered, <code>print</code> prints to <code>STDOUT</code> by default if no filehandle is named.</p>
<p>分かるかと思いますが、<code>print</code>は、ファイルハンドルが省略された場合は、デフォルトで<code>STDOUT</code>に出力しますす。</p>

<h3 class="original">File tests</h3>
<h3>ファイルテスト</h3>

<p class="original">The function <code>-e</code> is a built-in function which tests whether the named file exists.</p>
<p>関数<code>-e</code> は組込の関数で与えられた名前のファイルが存在するかどうかをテストします。</p>
<pre class="prettyprint lang-perl">
print "what" unless -e "/usr/bin/perl";
</pre>
<p class="original">The function <code>-d</code> is a built-in function which tests whether the named file is a directory.</p>
<p>関数<code>-d</code> は組込の関数で与えられた名前のファイルがディレクトリかどうかをテストします。</p>
<p class="original">The function <code>-f</code> is a built-in function which tests whether the named file is a plain file.</p>
<p>関数<code>-f</code> は組込の関数で与えられた名前のファイルが普通のファイルかどうかをテストします。</p>
<p class="original">These are just three of <a href="http://perldoc.perl.org/functions/-X.html">a large class of functions</a> of the form <code>-X</code> where <code>X</code> is some lower- or upper-case letter. These functions are called <i>file tests</i>. Note the leading minus sign. In a Google query, the minus sign indicates to exclude results containing this search term. This makes file tests hard to Google for! Just search for "perl file test" instead.</p>
<p><code>-X</code>形式の<a href="http://perldoc.jp/func/-X">大きなクラスの関数</a>の3つの関数です。<code>X</code>は小文字か大文字です。これらの関数は<i>ファイルテスト</i>と呼ばれます。マイナス記号が先に来ることに気をつけてください。Googleクエリでは、マイナス記号は、その言葉を結果に含めないことを指示します。そのため、ファイルテストをGoogleで検索しづらくしています! 代わりに、 "perl file test"(訳註: "perl ファイルテスト")で検索して下さい。</p>

<h2 class="original">Regular expressions</h2>
<h2>正規表現</h2>
<p class="original">Regular expressions appear in many languages and tools other than Perl. Perl's core regular expression syntax is basically the same as everywhere else, but Perl's <em>full</em> regular expression capabilities are terrifyingly complex and difficult to understand. The best advice I can give you is to avoid this complexity wherever possible.</p>


<p>正規表現はPerl以外の多くの言語やツールにみられます。Perlのコアの正規表現シンタックスは他のものと基本的に同じです。Perlの<em>完全な</em>正規表現の性能は恐ろしく複雑で理解するのが難しいです; 一番良いアドバイスをするとしたら、可能な限りこういた複雑なものを避けるということです。</p>
<p class="original">Match operations are performed using <code>=~ m//</code>. In scalar context, <code>=~ m//</code> returns true on success, false on failure.</p>
<p>マッチは、マッチ演算子<code>=~ m//</code>を使ってされます。スカラコンテキストでは、<code>=~ m//</code>は、成功なら真を返し、失敗なら偽を返します。</p>

<pre class="prettyprint lang-perl">
my $string = "Hello world";
if($string =~ m/(\w+)\s+(\w+)/) {
	print "success";
}
</pre>
<p class="original">Parentheses perform sub-matches. After a successful match operation is performed, the sub-matches get stuffed into the built-in variables <code>$1</code>, <code>$2</code>, <code>$3</code>, ...:</p>
<p>括弧はサブマッチになります。マッチが成功したら、サブマッチは組込変数の<code>$1</code>, <code>$2</code>, <code>$3</code>, ...にマッチしたものが入ります:</p>
<pre class="prettyprint lang-perl">
print $1; # "Hello"
print $2; # "world"
</pre>
<p class="original">In list context, <code>=~ m//</code> returns <code>$1</code>, <code>$2</code>, ... as a list.</p>
<p>リストコンテキストでは、<code>=~ m//</code> は<code>$1</code>, <code>$2</code>, ... をリストとして返します:</p>

<pre class="prettyprint lang-perl">
my $string = "colourless green ideas sleep furiously";
my @matches = $string =~ m/(\w+)\s+((\w+)\s+(\w+))\s+(\w+)\s+(\w+)/;

print join ", ", map { "'".$_."'" } @matches;
# prints "'colourless', 'green ideas', 'green', 'ideas', 'sleep', 'furiously'"
</pre>

<p class="original">Substitution operations are performed using <code>=~ s///</code>.</p>
<p>置換操作は<code>=~ s///</code>で行います。</p>
<pre class="prettyprint lang-perl">
my $string = "Good morning world";
$string =~ s/world/Vietnam/;
print $string; # "Good morning Vietnam"
</pre>
<p class="original">Notice how the contents of <code>$string</code> have changed. You have to pass a scalar variable on the left-hand side of an <code>=~ s///</code> operation. If you pass a literal string, you'll get an error.</p>
<p><code>$string</code>の中身を変更する方法に注意してください。<code>=~ s///</code> 操作の左側にスカラ変数を渡さなければなりません。リテラルの文字列を渡した場合、エラーになります。</p>

<p class="original">The <code>/g</code> flag indicates "group match".</p>
<p><code>/g</code>フラグは"グループマッチ"を指示します。</p>

<p class="original">In scalar context, each <code>=~ m//g</code> call finds another match after the previous one, returning true on success, false on failure. You can access <code>$1</code> and so on afterwards in the usual way. For example:</p>
<p>スカラコンテキストでは、それぞれの<code>=~ m//g</code> 呼び出しは前のものの後の他のマッチを探し、成功すると真を返し、失敗すると値を返します。よくある方法で<code>$1</code>などにアクセス出来ます。 例:</p>

<pre class="prettyprint lang-perl">
my $string = "a tonne of feathers or a tonne of bricks";
while($string =~ m/(\w+)/g) {
  print "'".$1."'\n";
}
</pre>

<p class="original">In list context, an <code>=~ m//g</code> call returns all of the matches at once.</p>
<p>リストコンテキストでは、<code>=~ m//g</code>呼び出しは、マッチしたものを一度に全部返します。</p>
<pre class="prettyprint lang-perl">
my @matches = $string =~ m/(\w+)/g;
print join ", ", map { "'".$_."'" } @matches;
</pre>

<p class="original">An <code>=~ s///g</code> call performs a global search/replace and returns the number of matches. Here, we replace all vowels with the letter "r".</p>
<p><code>=~ s///g</code>呼び出しはグローバルな検索/置換でマッチした数を返します。ここでは、すべての母音を文字"r"に置換しています。</p>

<pre class="prettyprint lang-perl">
# Try once without /g.
$string =~ s/[aeiou]/r/;
print $string; # "r tonne of feathers or a tonne of bricks"

# Once more.
$string =~ s/[aeiou]/r/;
print $string; # "r trnne of feathers or a tonne of bricks"

# And do all the rest using /g
$string =~ s/[aeiou]/r/g;
print $string, "\n"; # "r trnnr rf frrthrrs rr r trnnr rf brrcks"
</pre>

<p class="original">The <code>/i</code> flag makes matches and substitutions case-insensitive.</p>
<p><code>/i</code> フラグはマッチと置換をケースインセンシティブにします。</p>
<p class="original">The <code>/x</code> flag allows your regular expression to contain whitespace (e.g., line breaks) and comments.</p>
<p class="original"><code>/x</code>フラグは正規表現の中に空白(e.g. 改行)やコメントを含めることができるようにします。</p>
<pre class="prettyprint lang-perl">
"Hello world" =~ m/
  (\w+) # one or more word characters
  [ ]   # single literal space, stored inside a character class
  world # literal "world"
/x;

# returns true
</pre>

<h2 class="original">Modules and packages</h2>
<h2>モジュールとパッケージ</h2>

<p class="original">In Perl, modules and packages are different things.</p>
<p>Perlにおいて、モジュールとパッケージは別物です。</p>


<h3 class="original">Modules</h3>
<h3>モジュール</h3>

<p class="original">A <i>module</i> is a <code>.pm</code> file that you can <i>include</i> in another Perl file (script or module). A module is a text file with exactly the same syntax as a <code>.pl</code> Perl script. An example module might be located at <code>C:\foo\bar\baz\Demo\StringUtils.pm</code> or <code>/foo/bar/baz/Demo/StringUtils.pm</code>, and read as follows:</p>
<p>A <i>モジュール</i>は、他のPerlファイル(スクリプトかモジュール)に<i>含める</i>ことが出来る<code>.pm</code>ファイルです。モジュールは <code>.pl</code> Perlスクリプトとまったく同じシンタックのステキストファイルです。例のモジュールは、<code>C:\foo\bar\baz\Demo\StringUtils.pm</code> か <code>/foo/bar/baz/Demo/StringUtils.pm</code>にあります。続きを読んでください:</p>
<pre class="prettyprint lang-perl">
use strict;
use warnings;

sub zombify {
	my $word = shift @_;
	$word =~ s/[aeiou]/r/g;
	return $word;
}

return 1;
</pre>

<p class="original">Because a module is executed from top to bottom when it is loaded, you need to return a true value at the end to show that it was loaded successfully.</p>
<p>モジュールはロードされると、最初から最後まで実行されるので、ロードが成功したことを示すために、最後に真の値を返す必要があります。</p>
<p class="original">So that the Perl interpreter can find them, directories containing Perl modules should be listed in your environment variable <code>PERL5LIB</code> before calling <code>perl</code>. List the root directory containing the modules, don't list the module directories or the modules themselves:</p>
<p>Perlインタープリタはそれらを見つけることができるためには、<code>perl</code>を呼ぶ前に、Perlモジュールが入っているディレクトリが環境変数<code>PERL5LIB</code>にリストされているべきです。モジュールが入っているルートディレクトリをリストしてください。モジュールのディレクトリやモジュール自身をリストしてはいけません。</p>

<pre class="bash">
set PERL5LIB=C:\foo\bar\baz;%PERL5LIB%
</pre>
<p class="original">or</p>
<p>または</p>
<pre class="bash">
export PERL5LIB=/foo/bar/baz:$PERL5LIB
</pre>

<p class="original">Once the Perl module is created and <code>perl</code> knows where to look for it, you can use the <code><a href="http://perldoc.perl.org/functions/require.html">require</a></code> built-in function to search for and execute it during a Perl script. For example, calling <code>require Demo::StringUtils</code> causes the Perl interpreter to search each directory listed in <code>PERL5LIB</code> in turn, looking for a file called <code>Demo/StringUtils.pm</code>. After the module has been executed, the subroutines that were defined there suddenly become available to the main script. Our example script might be called <code>main.pl</code> and read as follows:</p>
<p>Perlモジュールが作られて、<code>perl</code>がそれがどこにあるかを知っていれば、組込の<code>require</code>関数を使って探し、Perlのスクリプト中で実行することができます。例えば、<code>require Demo::StringUtils</code>を呼ぶと、Perlインタープリタは<code>PERL5LIB</code>にリストされているディレクトリを順番に、 <code>Demo/StringUtils.pm</code>というファイルを探します。モジュールがロードされたら、そこで定義されたサブルーチンは、突然にメインスクリプトから利用できるようになります。この例のスクリプトを<code>main.pl</code>と呼びましょう。続けて読んでくさい:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

require Demo::StringUtils;

print zombify("i want brains"); # "r wrnt brrrns"
</pre>

<p class="original"><i>Note the use of the double colon <code>::</code> as a directory separator.</i></p>
<p><i>名前空間の区切りに<code>::</code>を使っているのに注意してください</i></p>

<p class="original">Now a problem surfaces: if <code>main.pl</code> contains many <code>require</code> calls, and each of the modules so loaded contains more <code>require</code> calls, then it can become difficult to track down the original declaration of the <code>zombify()</code> subroutine. The solution to this problem is to use packages.</p>
<p>ここで問題が表面化します: <code>main.pl</code>が、多くの<code>require</code> を呼んでいて、それぞれのモジュールがさらに<code>require</code>を呼んでいる場合、<code>zombify()</code>サブルーチンの元の宣言がどこにあるのか、追いにくくなります。その解決策としては、パッケージを使うことです。</p>

<h3 class="original">Packages</h3>
<h3>パッケージ</h3>

<p class="original">A <i>package</i> is a namespace in which subroutines can be declared. Any subroutine you declare is implicitly declared within the current package. At the beginning of execution, you are in the <code>main</code> package, but you can switch package using the <code><a href="http://perldoc.perl.org/functions/package.html">package</a></code> built-in function:</p>
<p><i>package</i>は名前空間で、その中で、サブルーチンを宣言できます。宣言したサブルーチンは、暗黙的に、現在のパッケージ内に宣言されます。実行の最初は、<code>main</code>パッケージになりますが、組込関数の<code>package</code>を使って、パッケージを切り替えられます:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

sub subroutine {
	print "universe";
}

package Food::Potatoes;

# no collision:
sub subroutine {
	print "kingedward";
}
</pre>

<p class="original"><i>Note the use of the double colon <code>::</code> as a namespace separator.</i></p>
<p><i>名前空間の区切りに<code>::</code>を使っているのに注意してください</i></p>

<p class="original">Any time you call a subroutine, you implicitly call a subroutine which is inside the current package. Alternatively, you can explicitly provide a package. See what happens if we continue the above script:</p>
<p>サブルーチンを呼んだときはいつでも、暗黙に現在のパッケージ内のサブルーチンを呼んでいます。代わりに、パッケージを明示的に書くこともできます。下のスクリプトを実行したら、何が起きるでしょうか:</p>

<pre class="prettyprint lang-perl">
subroutine();                 # "kingedward"
main::subroutine();           # "universe"
Food::Potatoes::subroutine(); # "kingedward"
</pre>

<p class="original">So the logical solution to the problem described above is to modify <code>C:\foo\bar\baz\Demo\StringUtils.pm</code> or <code>/foo/bar/baz/Demo/StringUtils.pm</code> to read:</p>
<p>ですので、上で述べた問題の論理的な解決策は<code>C:\foo\bar\baz\Demo\StringUtils.pm</code>か<code>/foo/bar/baz/Demo/StringUtils.pm</code>を変更することです:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

<ins>package Demo::StringUtils;</ins>

sub zombify {
	my $word = shift @_;
	$word =~ s/[aeiou]/r/g;
	return $word;
}

return 1;
</pre>

<p class="original">And modify <code>main.pl</code> to read:</p>
<p>そして、<code>main.pl</code>を変更します</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

require Demo::StringUtils;

print <ins>Demo::StringUtils::</ins>zombify("i want brains"); # "r wrnt brrrns"
</pre>

<p class="original">Now read this next bit carefully.</p>
<p>では、次はちょっと注意して読んでください。</p>
<p class="original">Packages and modules are two completely separate and distinct features of the Perl programming language. The fact that they both use the same double colon delimiter is a huge red herring. It is possible to switch packages multiple times over the course of a script or module, and it is possible to use the same package declaration in multiple locations in multiple files. Calling <code>require Foo::Bar</code> <em>does not</em> look for and load a file with a <code>package Foo::Bar</code> declaration somewhere inside it, nor does it necessarily load subroutines in the <code>Foo::Bar</code> namespace. Calling <code>require Foo::Bar</code> merely loads a file called <code>Foo/Bar.pm</code>, which need not have <em>any</em> kind of package declaration inside it at all, and in fact might declare <code>package Baz::Qux</code> and other nonsense inside it for all you know.</p>

<p>パッケージとモジュールの2つは、プログラミング言語Perlにおいて完全に分かれており、区別された機能です。この2つが同じダブルコロンのデリミタを使っていることは、大きなひっかけです。これは、スクリプトまたはモジュールのコース経由でパッケージを複数回切り替えることができ、また、複数のファイル内の複数の場所で同一のパッケージ宣言を使うこともできます。<code>require Foo::Bar</code>を呼ぶことは<code>Foo::Bar</code>名前空間にあるサブルーチンやパッケージ変数を必ずしもロード<em>しません</em>し、<code>Foo::Bar</code>名前空間のサブルーチンを必ずしもロードするわけではありません。<code>require Foo::Bar</code>を呼ぶことは、単に<code>Foo/Bar.pm</code>というファイルをロードするだけであり、そのファイルに、<em>どのような</em>種類のパッケージ宣言も必要有りません。実際には、<code>package Baz::Qux</code>のようなナンセンスな宣言もできます。</p>

<p class="original">Likewise, a subroutine call <code>Baz::Qux::processThis()</code> need not necessarily have been declared inside a file named <code>Baz/Qux.pm</code>. It could have been declared <em>literally anywhere</em>.</p>
<p>その上、<code>Baz::Qux::processThis()</code>のサブルーチン呼び出しは、<code>Baz/Qux.pm</code>という名前のファイル内に宣言されている必要すらありません。<em>文字通り、どこにでも</em>定義することができます。</p>
<p class="original">Separating these two concepts is one of the stupidest features of Perl, and treating them as separate concepts invariably results in chaotic, maddening code. Fortunately for us, the majority of Perl programmers obey the following two laws:</p>
<p>この2つのコンセプトを分けてしまったことは、Perlの最も愚かな特徴の1つであり、これら2つのコンセプトを分けて取り扱ってしまうと常に、カオスで気の狂ったようなコードとなります。幸運なことに、Perlプログラマの多くは、次の2つの規則に従っています:</p>
<ol class="original">
	<li><strong>A Perl script (<code>.pl</code> file) must always contain exactly zero <code>package</code> declarations.</strong></li>
	<li><strong>A Perl module (<code>.pm</code> file) must always contain exactly one <code>package</code> declaration, corresponding exactly to its name and location.</strong> E.g. module <code>Demo/StringUtils.pm</code> must begin with <code>package Demo::StringUtils</code>.</li>
</ol>
<ol>
	<li><strong>Perlスクリプト(<code>.pl</code>ファイル)は、1つの<code>package</code>宣言も含まない。</strong></li>
	<li><strong>Perlモジュール(<code>.pm</code>ファイル)は、1つの<code>package</code>宣言を含み、名前と場所が一致している。</strong> 例: モジュール<code>Demo/StringUtils.pm</code>は、<code>package Demo::StringUtils</code>で始まっている。</li>
</ol>

<p class="original">Because of this, in practice you will find that most "packages" and "modules" produced by reliable third parties <em>can</em> be regarded and referred to interchangeably. However, it is important that you do not take this for granted, because one day you <em>will</em> meet code produced by a madman.</p>
<p>これにより, 信頼できるサードパーティに作られた、ほとんどの"パッケージ"と"モジュール"を見つけることができ、相互に関係し参照することが<em>できます</em>。しかし、これが当たり前と思わないことは重要です。いつか、常軌を逸した人が作ったコードに出会う<em>でしょう</em>。</p>

<h2 class="original">Object-oriented Perl</h2>
<h2>オブジェクト指向Perl</h2>
<p class="orignal">Perl is not a great language for OO programming. Perl's OO capabilities were grafted on after the fact, and this shows.</p>
<p>PerlはOOプログラミングに、あまり適した言語ではありません。 PerlのOO能力は後付のものです。それは、</p>

<ul>
	<li>
        <p class="original">An <i>object</i> is simply a reference (i.e. a scalar variable) which happens to know which class its referent belongs to. To tell a reference that its referent belongs to a class, use <code><a href="http://perldoc.perl.org/functions/bless.html">bless</a></code>. To find out what class a reference's referent belongs to (if any), use <code><a href="http://perldoc.perl.org/functions/ref.html">ref</a></code>.</p>
        <p><i>オブジェクト</i>は単純に、どのクラスに属しているかを示しているリファレンスです(i.e. スカラ変数)。そのリファレントがクラスに属していることをリファレンスに教えるために、<code>bless</code>を使います。blessにより、どのクラスがどのリファレントに属するのかを分かるようになります。リファレンスのリファレントがどのクラスに属しているかをみつけるためには、<code>ref</code>を使います</p>
        </li>
	<li>
        <p class="original">A <i>method</i> is simply a subroutine that expects an object (or, in the case of class methods, a package name) as its first argument. Object methods are invoked using <code>$obj-&gt;method()</code>; class methods are invoked using <code>Package::Name-&gt;method()</code>.</p>
        <p><i>メソッド</i>は単純に第一引数オブジェクト(または、クラスメソッドであれば、パッケージ名)であるサブルーチンです。オブジェクトメソッドは、<code>$obj-&gt;method()</code>を使って呼び出されます; クラスメソッドは<code>Package::Name-&gt;method()</code>です。</p>
        </li>
	<li>
        <p class="original">A <i>class</i> is simply a package that happens to contain methods.</p>
        <p><i>クラス</i>は単純にメソッドを含むパッケージです。</p>
        </li>
</ul>

<p class="original">A quick example makes this clearer. An example module <code>Animal.pm</code> containing a class <code>Animal</code> reads like this:</p>
<p>以下、簡単な例でそれをはっきりさせます。 例のモジュールとして<code>Animal.pm</code>のクラス<code>Animal</code>は、次のようになります:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

package Animal;

sub eat {
	# First argument is always the object to act upon.
	my $self = shift @_;

	foreach my $food ( @_ ) {
		if($self-&gt;can_eat($food)) {
			print "Eating ", $food;
		} else {
			print "Can't eat ", $food;
		}
	}
}

# For the sake of argument, assume an Animal can eat anything.
sub can_eat {
	return 1;
}

return 1;
</pre>

<p class="original">And we might make use of this class like so:</p>
<p>このクラスを使う次のように使うでしょう:</p>

<pre class="prettyprint lang-perl">
require Animal;

my $animal = {
	"legs"   =&gt; 4,
	"colour" =&gt; "brown",
};                       # $animal is an ordinary hash reference
print ref $animal;       # "HASH"
bless $animal, "Animal"; # now it is an object of class "Animal"
print ref $animal;       # "Animal"
</pre>

<p class="original">Note: literally any reference can be blessed into any class. It's up to you to ensure that (1) the referent can actually be used as an instance of this class and (2) that the class in question exists and has been loaded.</p>
<p>注意: 文字通り、どのようなリファレンスも、どのようなクラスにでもblessすることができます。(1)リファレンスが実際にそのクラスのインスタンスとして使われているかと、(2)問題のクラスが存在し、ロードされているかを保証するのはあなた次第です。</p>

<p class="original">You can still work with the original hash in the usual way:</p>
<p>まだ、通常のやり方でオリジナルのハッシュを操作できます</p>
<pre class="prettyprint lang-perl">
print "Animal has ", $animal->{"legs"}, " leg(s)";
</pre>

<p class="original">But you can now also call methods on the object using the same <code>-&gt;</code> operator, like so:</p>
<p>ですが、同じ<code>-&gt;</code>オペレータでオブジェクトからメソッドを呼ぶこともできます。次のようにします:</p>
<pre class="prettyprint lang-perl">
$animal-&gt;eat("insects", "curry", "eucalyptus");
</pre>
<p class="original">This final call is equivalent to <code>Animal::eat($animal, "insects", "curry", "eucalyptus")</code>.</p>
<p>最後の呼び出しは、<code>Animal::eat($animal, "insects", "curry", "eucalyptus")</code>と同じです。</p>

<h3 class="original">Constructors</h3>
<h3>コンストラクタ</h3>

<p class="original">A constructor is a class method which returns a new object. If you want one, just declare one. You can use any name you like. For class methods, the first argument passed is not an object but a class name. In this case, <code>"Animal"</code>:</p>
<p>コンストラクタはクラスメソッドで、新しいオブジェクトを返します。コンストラクタが欲しければ、それを宣言するだけです。好きな名前を使えます。クラスメソッドには、最初の引数として、オブジェクトではなくクラス名が渡ります。このケースでは、<code>"Animal"</code>です:</p>
<pre class="prettyprint lang-perl">
use strict;
use warnings;

package Animal;

sub new {
	my $class = shift @_;
	return bless { "legs" =&gt; 4, "colour" =&gt; "brown" }, $class;
}

# ...etc.
</pre>

<p class="original">And then use it like so:</p>
<p>次のように使います:</p>
<pre class="prettyprint lang-perl">
my $animal = Animal-&gt;new();
</pre>

<h3 class="original">Inheritance</h3>
<h3>継承</h3>

<p class="original">To create a class inheriting from a parent class, use <code>use parent</code>. Let's suppose we subclassed <code>Animal</code> with <code>Koala</code>, located at <code>Koala.pm</code>:</p>
<p>ベースクラスから継承しているクラスを作るには、<code>use parent</code>を使います。<code>Animal</code>をサブクラス化して<code>Koala</code>でサブクラスを作るとします。場所は<code>Koala.pm</code>になります:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

package Koala;

# Inherit from Animal
use parent ("Animal");

# Override one method
sub can_eat {
	my $self = shift @_; # Not used. You could just put "shift @_;" here
	my $food = shift @_;
	return $food eq "eucalyptus";
}

return 1;
</pre>

<p class="original">And some sample code:</p>
<p>サンプルコード:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

require Koala;

my $koala = Koala-&gt;new();

$koala-&gt;eat("insects", "curry", "eucalyptus"); # eat only the eucalyptus
</pre>
<p class="original">This final method call tries to invoke <code>Koala::eat($koala, "insects", "curry", "eucalyptus")</code>, but a subroutine <code>eat()</code> isn't defined in the <code>Koala</code> package. However, because <code>Koala</code> has a parent class <code>Animal</code>, the Perl interpreter tries calling <code>Animal::eat($koala, "insects", "curry", "eucalyptus")</code> instead, which works. Note how the class <code>Animal</code> was loaded automatically by <code>Koala.pm</code>.</p>
<p>最後のメソッド呼び出しは、<code>Koala::eat($koala, "insects", "curry", "eucalyptus")</code>を呼ぼうとしますが、サブルーチン<code>eat()</code>は、<code>Koala</code> パッケージには定義されていません。ですが、<code>Koala</code>は親クラス<code>Animal</code>があるので、Perlインタプリタは <code>Animal::eat($koala, "insects", "curry", "eucalyptus")</code>を代わりに呼ぼうとして、代わりにそれは動きます。次のことに注意してください。クラス<code>Animal</code>は<code>Koala.pm</code>で自動的ににロードされました。</p>
<p class="original">Since <code>use parent</code> accepts a list of parent class names, Perl supports multiple inheritance, with all the benefits and horrors this entails.</p>
<p><code>use parent</code> は親クラス名のリストを受け取れます。Perl は多重継承をサポートします。全ての利益と恐怖を伴いますが。</p>

<h2 class="original"><code>BEGIN</code> blocks</h2>
<h2><code>BEGIN</code>ブロック</h2>
<p class="original">A <code><a href="http://perldoc.perl.org/functions/BEGIN.html">BEGIN</a></code> block is executed as soon as <code>perl</code> has finished parsing that block, even before it parses the rest of the file. It is ignored at execution time:</p>
<p><code><a href="http://perldoc.jp/func/BEGIN">BEGIN</a></code>ブロックは<code>perl</code>がそのブロックをパースし終えるとすぐに実行されます。コンパイラがまだ全てをパースしていなくてもです。BEGINブロックは実行時には無視されます。</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

print "This gets printed second";

BEGIN {
       print "This gets printed first";
}

print "This gets printed third";
</pre>
<p class="original">A <code>BEGIN</code> block is always executed first. If you create multiple <code>BEGIN</code> blocks (don't), they are executed in order from top to bottom as the compiler encounters them. A <code>BEGIN</code> block always executes first even if it is placed halfway through a script (don't do this) or at the end (or this). <strong>Do not mess with the natural order of code. Put <code>BEGIN</code> blocks at the beginning!</strong></p>
<p><code>BEGIN</code>ブロックは常に最初に実行されます。複数の<code>BEGIN</code>ブロックを書くと(don't)、 上から順番にコンパイラがそれらに出会う順番に実行されます。<code>BEGIN</code>ブロックは常に最初に実行されます。もし、BEGINブロックがスクリプトの途中(そんなことはしないでください)や、最後(or this)に書かれていたりしても。<strong>コードの自然な順番をめちゃくちゃにしないでください。<code>BEGIN</code>ブロックは最初に書くこと!</strong></p>
<p class="original">A <code>BEGIN</code> block is executed as soon as the block has been parsed. Once this is done, <em>parsing</em> resumes at the end of the <code>BEGIN</code> block. Only once the whole script or module has been parsed is any of the code outside of <code>BEGIN</code> blocks executed.</p>
<p><code>BEGIN</code>ブロックはそのブロックが解釈されたと同時に実行されます。一度実行されると、<em>コードのパース</em>は<code>BEGIN</code>ブロックの終わりで再開されます。一度スクリプト全体かモジュールがパースされていれば、<code>BEGIN</code>ブロックの外側のいずれかが実行されます。
</p>
<pre class="prettyprint lang-perl">
use strict;
use warnings;

print "This 'print' statement gets parsed successfully but never executed";

BEGIN {
       print "This gets printed first";
}

print "This, also, is parsed successfully but never executed";

...because e4h8v3oitv8h4o8gch3o84c3 there is a huge parsing error down here.
</pre>
<p class="original">Because they are executed at compilation time, a <code>BEGIN</code> block placed inside a conditional block will <em>still</em> be executed first, even if the conditional evaluates to false and despite the fact that the conditional <em>has not been evaluated at all yet</em> and in fact <em>may never be evaluated</em>.</p>
<p>コンパイル時に実行されるので、<code>BEGIN</code>ブロックが条件ブロックの中にあっても、<em>まだ</em>最初に実行されます。たとえ、条件の評価が偽であり、条件が<em>まだまったく評価されていない</em>にもかかわらず、実際には、<em>評価されることがない</em>としてもです。</p>
<pre class="prettyprint lang-perl">
if(0) {
       BEGIN {
               print "This will definitely get printed";
       }
       print "Even though this won't";
}
</pre>
<p class="original"><strong>Do not put <code>BEGIN</code> blocks in conditionals!</strong> If you want to do something conditionally at compile time, you need to put the conditional <em>inside</em> the <code>BEGIN</code> block:</p>
<p>
<strong><code>BEGIN</code>ブロックを条件の中に置いては行けません!</strong> コンパイル時に何かしらの条件付きのことがしたければ、<code>BEGIN</code>ブロックの<em>中に</em>条件文を置かなければなりません:</p>
<pre class="prettyprint lang-perl">
BEGIN {
	if($condition) {
		# etc.
	}
}
</pre>

<h2><code>use</code></h2>
<p class="original">Okay. Now that you understand the obtuse behaviour and semantics of packages, modules, class methods and <code>BEGIN</code> blocks, I can explain the exceedingly commonly-seen <code><a href="http://perldoc.perl.org/functions/use.html">use</a></code> function.</p>
<p>いいでしょう。もうわかりにくい、パッケージ、モジュールクラスメソッドと<code>BEGIN</code>ブロックの意味を理解したので、よく見かける<code><a href="http://perldoc.jp/func/use">use</a></code>関数について説明できます。</p>
<p class="original">The following three statements:</p>
<p>以下の3つのステートメントは:</p>
<pre class="prettyprint lang-perl">
use Caterpillar ("crawl", "pupate");
use Caterpillar ();
use Caterpillar;
</pre>
<p class="original">are respectively equivalent to:</p>
<p>以下とそれぞれ等価です:</p>
<pre class="prettyprint lang-perl">
BEGIN {
	require Caterpillar;
	Caterpillar-&gt;import("crawl", "pupate");
}
BEGIN {
	require Caterpillar;
}
BEGIN {
	require Caterpillar;
	Caterpillar-&gt;import();
}
</pre>
<ul class="original">
	<li>No, the three examples are not in the wrong order. It is just that Perl is dumb.</li>
	<li>A <code>use</code> call is a disguised <code>BEGIN</code> block. The same warnings apply. <code>use</code> statements must always be placed at the top of the file, and <strong>never inside conditionals</strong>.</li>
	<li><code>import()</code> is not a built-in Perl function. It is a <strong>user-defined class method</strong>. The burden is on the programmer of the <code>Caterpillar</code> package to define or inherit <code>import()</code>, and the method could theoretically accept anything as arguments and do anything with those arguments. <code>use Caterpillar;</code> could do anything. Consult the documentation of <code>Caterpillar.pm</code> to find out exactly what will happen.</li>
	<li>Notice how <code>require Caterpillar</code> loads a <strong>module</strong> named <code>Caterpillar.pm</code>, whereas <code>Caterpillar-&gt;import()</code> calls the <code>import()</code> subroutine that was defined inside the <code>Caterpillar</code> <strong>package</strong>. Let's hope the module and the package coincide!</li>
</ul>

<ul>
	<li>いいえ、３つの例は間違った順番ではありません。Perlが馬鹿なだけです。</li>
	<li><code>use</code>の呼び出しは<code>BEGIN</code>ブロックに変換されます。同じ警告が適用されます。<code>use</code>ステートメントはファイルの最初に置かれなければいけません。<strong>条件の中に置いてはいけません</strong>。</li>
	<li><code>import()</code> はPerlの組込の関数ではありません。<strong>ユーザー定義のクラスメソッドです</strong>。<code>import()</code>を定義するか、継承するかの義務は<code>Caterpillar</code>パッケージのプログラマにあり、メソッドは理論上、どのような引数でも受け入れ、どのようなことでもできます。<code>use Caterpillar;</code> は何でもできます。<code>Captepillar.pm</code>のドキュメントを読んで、何が起きるか正確に調査してください。</li>
	<li><code>require Caterpillar</code>が<code>Caterpillar.pm</code>という名前の<strong>module</strong>をロードすることに注意してください。<code>Caterpillar-&gt;import()</code>は、<code>Caterpillar</code> <strong>package</strong>内に定義された<code>import()</code>サブルーチンを呼びます。モジュールとパッケージが一致していることを期待しましょう!</li>
</ul>

<h2>Exporter</h2>

<p class="original">The most common way to define an <code>import()</code> method is to inherit it from the <a href="http://perldoc.perl.org/Exporter.html">Exporter</a> module. Exporter is a core module, and a <i>de facto</i> core feature of the Perl programming language. In Exporter's implementation of <code>import()</code>, the list of arguments that you pass in is interpreted as a list of subroutine names. When a subroutine is <code>import()</code>ed, it becomes available in the current package as well as in its own original package.</p>

<p><code>import()</code>メソッドを定義する常識的な方法は <a href="http://perldoc.perl.org/Exporter.html">Exporter</a> モジュールから継承することです。Exporter はコアモジュールで、プログラミング言語Perlの<i>デファクト</i>のコアの機能です。Exporterの<code>import</code>の実装で、渡した引数のリストは、サブルーチンの名前として解釈されます。サブルーチンが<code>import()</code>されると、現在の名前空間で、そのオリジナルの名前空間にあるかのと同じように、利用可能になります。</p>
<p class="original">This concept is easiest to grasp using an example. Here's what <code>Caterpillar.pm</code> looks like:</p>
<p>このコンセプトは例を使うと把握しやすいでしょう。<code>Caterpillar.pm</code>は次のようなものです:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

package Caterpillar;

# Inherit from Exporter
use parent ("Exporter");

sub crawl  { print "inch inch";   }
sub eat    { print "chomp chomp"; }
sub pupate { print "bloop bloop"; }

our @EXPORT_OK = ("crawl", "eat");

return 1;
</pre>

<p class="original">The package variable <code>@EXPORT_OK</code> should contain a list of subroutine names.</p>
<p>パッケージ変数<code>@EXPORT_OK</code>にサブルーチン名のリストを含むべきです。</p>
<p class="original">Another piece of code may then <code>import()</code> these subroutines by name, typically using a <code>use</code> statement:</p>
<p>コードの別の部分が、名前でこれらのサブルーチンを<code>import()</code>するでしょう。典型的に、<code>use</code>ステートメントを使います:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

use Caterpillar ("crawl");

crawl(); # "inch inch"
</pre>

<p class="original">In this case, the current package is <code>main</code>, so the <code>crawl()</code> call is actually a call to <code>main::crawl()</code>, which (because it was imported) maps to <code>Caterpillar::crawl()</code>.</p>
<p>このケースでは、現在のパッケージは<code>main</code>です。そのため、<code>crawl()</code>の呼び出しは、実際には、<coe>main::crawl()</code>を呼びます。これは、<code>Caterpillar::crawl()</code>にマップされています(インポートされたので)。</p>

<p class="original">Note: regardless of the content of <code>@EXPORT_OK</code>, every method can always be called "longhand":</p>
<p>注意: <code>@EXPORT_OK</code>の内容は無視して、すべてのメソッドは、常に"longhand"で呼ぶこともできます:</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;
use Caterpillar (); # no subroutines named, no import() call made

# and yet...
Caterpillar::crawl();  # "inch inch"
Caterpillar::eat();    # "chomp chomp"
Caterpillar::pupate(); # "bloop bloop"
</pre>

<p class="original">Perl has no private methods. Customarily, a method intended for private use is named with a leading underscore or two.</p>
<p>Perlにはプライベートメソッドはありません。慣例的に、プライベート用のメソッドは1つか2つのアンダースコアを頭につけた名前をつけます。</p>

<h3><code>@EXPORT</code></h3>

<p class="original">The Exporter module also defines a package variable called <code>@EXPORT</code>, which can also be populated with a list of subroutine names.</p>
<p>Exporter モジュールは <code>@EXPORT</code>と呼ばれるパッケージ変数も定義します。ここにもサブルーチン名のリストを入れます。</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;

package Caterpillar;

# Inherit from Exporter
use parent ("Exporter");

sub crawl  { print "inch inch";   }
sub eat    { print "chomp chomp"; }
sub pupate { print "bloop bloop"; }

our @EXPORT = ("crawl", "eat", "pupate");

return 1;
</pre>

<p class="original">The subroutines named in <code>@EXPORT</code> are exported if <code>import()</code> is called with no arguments at all, which is what happens here:</p>
<p><code>@EXPORT</code>に書かれたサブルーチンは <code>import()</code>が引数なしで呼ばれた場合にエクスポートされます。この例で起きることが起きます。</p>

<pre class="prettyprint lang-perl">
use strict;
use warnings;
use Caterpillar; # calls import() with no arguments

crawl();  # "inch inch"
eat();    # "chomp chomp"
pupate(); # "bloop bloop"
</pre>

<p class="original">But notice how we are back in a situation where, without other clues, it might not be easy to tell where <code>crawl()</code> was originally defined. The moral of this story is twofold:</p>
<p>ですが、ここでシチュエーションにどのように戻るか注意してください。他のものなしに、<code>crawl()</code>がもともとどこで定義されているかを知るのは簡単ではありません。</p>
<ol>
<li>
    <p class="original">When creating a module which makes use of Exporter, never use <code>@EXPORT</code> to export subroutines by default. Always make the user call subroutines "longhand" or <code>import()</code> them explicitly (using e.g. <code>use Caterpillar ("crawl")</code>, which is a strong clue to look in <code>Caterpillar.pm</code> for the definition of <code>crawl()</code>).</p>
    <p>Exporterを使うモジュールを作る際には、デフォルトでサブルーチンをエクスポートする<code>@EXPORT</code>を使わないこと。常に、ユーザーに、"longhand"でサブルーチンを呼ばせるか、明示的に<code>import()</code>させること(e.g. <code>use Caterpillar ("crawl")</code>を使って。<code>Caterpillar.pm</code>に<code>crawl()</code>)の定義があるという強いヒントになります。</p>
</li>
<li>
    <p class="original">When <code>use</code>ing a module which makes use of Exporter, always explicitly name the subroutines you want to <code>import()</code>. If you don't want to <code>import()</code> any subroutines and wish to refer to them longhand, you must supply an explicit empty list: <code>use Caterpillar ()</code>.</p>
    <p>モジュールを<code>use</code>すると、常に明示的に<code>import()</code>したいサブルーチンの名前書きます。何のサブルーチンも<code>import()</code>したくなく、longhandで参照したいのなら、空のリストを提供しなければいけません: <code>use Caterpillar ()</code>.</p></li>
</ol>

<h2 class="original">Miscellaneous notes</h2>
<h2>その他の注意</h2>
<ul>
	<li>
		<p class="original">The core module <a href="http://perldoc.perl.org/Data/Dumper.html">Data::Dumper</a> can be used to output an arbitrary scalar to the screen. This is an essential debug tool.</p>
		<p>コアモジュール<a href="http://perldoc.perl.org/Data/Dumper.html">Data::Dumper</a>は任意のスカラをスクリーンに出力するのに使えます。これは基本的なデバッグツールです。</p>
	</li>
	<li>
		<p class="original">There's an alternate syntax, <code>qw{ }</code>, for declaring arrays. This is often seen in <code>use</code> statements:</p>
		<p>配列を宣言するための代わりのシンタックス、<code>qw{ }</code>があります。<code>use</code>ステートメントでよく見られます:</p>
<pre class="prettyprint lang-perl">
use Account qw{create open close suspend delete};
</pre>
		<p class="original">There are <a href="http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators">many other quote-like operators</a>.</p>
		<p><a href="http://perldoc.jp/docs/perl/perlop.pod#Quote32and32Quote-like32Operators">多くの他のクォートライクなオペレータ</a>があります。</p>
	</li>
	<li>
		<p class="original">In <code>=~ m//</code> and <code>=~ s///</code> operations, you can use braces instead of slashes as the regex delimiters. This is quite useful if your regex contains a lot of slashes, which would otherwise need escaping with backslashes. For example, <code>=~ m{///}</code> matches three literal forward slashes, and <code>=~ s{^https?://}{}</code> removes the protocol part of a URL.</p>
		<p><code>=~ m//</code> と <code>=~ s///</code> 演算子で、正規表現の区切り文字にスラッシュの代わりにブレースを使えます。これは、正規表現が多くのスラッシュやバックスラッシュを含む場合に、非常に有用です。例えば、<code>m{///}</code>は、前方の3文字のスラッシュにマッチします。また、<code>=~ s{^https?://}{}</code> は、URLからプロトコル部分を削除します。</p>
	</li>
	<li>
		<p class="original">Perl does have <code>CONSTANTS</code>. These are discouraged now, but weren't always. Constants are actually just subroutine calls with omitted brackets.</p>
                <p>Perlには<code>定数</code>があります。 気落ちするようなものですが、常にではありません。定数は実際には、ブラケットを省略したただのサブルーチン呼び出しです。</p>
	</li>
	<li>
		<p class="original">Sometimes people omit quotes around hash keys, writing <code>$hash{key}</code> instead of <code>$hash{"key"}</code>. They can get away with it because in this situation the bareword <code>key</code> occurs as the string <code>"key"</code>, as opposed to a subroutine call <code>key()</code>.</p>
                <p>時々、ハッシュのキーでクォートを省略して、<code>$hash{key}</code>を<code>$hash{"key"}</code>の代わりに使います。この状況では、裸の<code>key</code>は、<code>"key"</code>になるからです。<code>key()</code>のようにすると、サブルーチン呼び出しになります。</p>
	</li>
	<li>
		<p class="original">If you see a block of unformatted code wrapped in a delimiter with double chevrons, like <code><a href="http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators">&lt;&lt;EOF</a></code>, the magic word to Google for is "here-doc".</p>
                <p>like <code><a href="http://perldoc.jp/docs/perl/perlop.pod#Quote32and32Quote-like32Operators">&lt;&lt;EOF</a></code>のように、2つの山括弧で区切られてラップされた整理されていないコードのブロックを見たら、Google検索のためのマジックワードは"ヒアドキュメント(here-doc)"です。</p>
	</li>
	<li>
		<p class="original">Warning! Many built-in functions can be called with no arguments, <strong>causing them to operate on <code>$_</code> instead</strong>. Hopefully this will help you understand formations like:</p>
                <p>注意! 多くの組込関数では、引数なしで呼ぶと<strong><code>$_</code>が代わりに渡されます</strong>。願わくば、次のような形を理解する助けになれば良いのですが:</p>
<pre class="prettyprint lang-perl">
print foreach @array;
</pre>
<p class="original">and</p>
<p>そして</p>
<pre class="prettyprint lang-perl">
foreach ( @array ) {
	next unless defined;
}
</pre>
		<p class="original">I dislike this formation because it can lead to problems when refactoring.</p>
                <p>私は、この形は嫌いです。リファクタリングの際に、問題を起こすことがあるからです。</p>
	</li>
</ul>

<p class="original">And that's two and a half hours.</p>
<p>これで、2.5時間です。</p>

<script type="text/javascript"><!--
	var sc_project=667681; 
	var sc_invisible=1; 
	var sc_partition=5; 
	var sc_security="f56850e2"; 
	var sc_remove_link=1; 
// --></script>
<script type="text/javascript" src="http://www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript>
	<p><img
		class="statcounter"
		src="http://c6.statcounter.com/counter.php?sc_project=667681&amp;java=0&amp;security=f56850e2&amp;invisible=1"
		alt="website statistics"
	/></p>
</noscript>
<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?autoload=true&skin=sunburst"></script>
</body>
</html> 
